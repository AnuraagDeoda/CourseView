/* eslint-disable object-shorthand */
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
      || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function () { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }
  if(!Array.prototype.findIndex) {
    'use strict';

    Array.prototype.findIndex = Array.prototype.findIndex || function(callback) {
      if (this === null) {
        throw new TypeError('Array.prototype.findIndex called on null or undefined');
      } else if (typeof callback !== 'function') {
        throw new TypeError('callback must be a function');
      }
      var list = Object(this);
      // Makes sures is always has an positive integer as length.
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      for (var i = 0; i < length; i++) {
        if ( callback.call(thisArg, list[i], i, list) ) {
          return i;
        }
      }
      return -1;
    };
  }
  if(!Array.prototype.findLastIndex) {
    'use strict';

    Array.prototype.findLastIndex = Array.prototype.findLastIndex || function(callback) {
      if (this === null) {
        throw new TypeError('Array.prototype.findIndex called on null or undefined');
      } else if (typeof callback !== 'function') {
        throw new TypeError('callback must be a function');
      }
      var list = Object(this);
      // Makes sures is always has an positive integer as length.
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      for (var i = length - 1; i > 0; i--) {
        if ( callback.call(thisArg, list[i], i, list) ) {
          return i;
        }
      }
      return -1;
    };
  }
  if (!Math.trunc) {
    Math.trunc = function (v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
  }
  if (!Array.prototype.keys) {
    Array.prototype.keys = function() {
        var k, a = [], nextIndex = 0, ary = this;
        k = ary.length;
        while (k > 0) a[--k] = k;
        a.next = function(){
            return nextIndex < ary.length ?
                {value: nextIndex++, done: false} :
                {done: true};
        };
    return a;
    };
  }
 
  if (!Array.prototype.values) {
    Array.prototype.values = function() {
      var k, a = [], nextIndex = 0, ary = this;
      k = ary.length;
      while (k > 0) a[--k] = ary[k];
      a.next = function(){
          return nextIndex < ary.length ?
              {value: ary[nextIndex++], done: false} :
              {done: true};
      };
    return a;
    };
  }
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    };
  }
  if (!Object.keys) {
    Object.keys = function(obj) {
      var keys = [];
  
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          keys.push(i);
        }
      }
  
      return keys;
    };
  }
  if (!Object.values) {
    Object.prototype.values = function(object) {
      var values = [];
      var keys = Object.keys(object);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        values.push(object[k]);
      }
      return values;
    }
  }
  if (!String.prototype.replaceAll) {
    String.prototype.replaceAll = function(str, newStr){
  
      // If a regex pattern
      if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {
        return this.replace(str, newStr);
      }
  
      // If a string
      return this.replace(new RegExp(str, 'g'), newStr);
  
    };
  }
  if (!Math.hypot) 
  {
    Math.hypot = function () {
    var max = 0;
    var s = 0;
    var containsInfinity = false;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = Math.abs(Number(arguments[i]));
      if (arg === Infinity)
        containsInfinity = true
      if (arg > max) {
        s *= (max / arg) * (max / arg);
        max = arg;
      }
      s += arg === 0 && max === 0 ? 0 : (arg / max) * (arg / max);
    }
    return containsInfinity ? Infinity : (max === 1 / 0 ? 1 / 0 : max * Math.sqrt(s));
    };
  }


  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      value: function(predicate) {
        // 1. Let O be ? ToObject(this value).
        if (this == null) {
          throw TypeError('"this" is null or not defined');
        }

        var o = Object(this);

        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = o.length >>> 0;

        // 3. If IsCallable(predicate) is false, throw a TypeError exception.
        if (typeof predicate !== 'function') {
          throw TypeError('predicate must be a function');
        }

        // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
        var thisArg = arguments[1];

        // 5. Let k be 0.
        var k = 0;

        // 6. Repeat, while k < len
        while (k < len) {
          // a. Let Pk be ! ToString(k).
          // b. Let kValue be ? Get(O, Pk).
          // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
          // d. If testResult is true, return kValue.
          var kValue = o[k];
          if (predicate.call(thisArg, kValue, k, o)) {
            return kValue;
          }
          // e. Increase k by 1.
          k++;
        }

        // 7. Return undefined.
        return undefined;
      },
      configurable: true,
      writable: true
    });
  }
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (search instanceof RegExp) {
        throw TypeError('first argument must not be a RegExp');
      }
      if (start === undefined) { start = 0; }
      return this.indexOf(search, start) !== -1;
    };
  }
  if (!Array.prototype.includes) {
    Object.defineProperty(Array.prototype, 'includes', {
      enumerable: false,
      value: function (obj) {
        var newArr = this.filter(function (el) {
          return el === obj;
        });
        return newArr.length > 0;
      }
    });
  }
}());

/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function A(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||"-"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+" "+(a.f+"00")+" 300px "+I(a.c)}function I(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function J(a){return a.a+a.f}function H(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);K(a,"loading")}function L(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}K(a,"inactive")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function N(a){u(a.c,"body",a.a)}function O(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+I(a.c)+";"+("font-style:"+H(a)+";font-weight:"+(a.f+"00")+";")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+",serif",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+",sans-serif",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G("serif",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G("sans-serif",J(this.a));a=
O(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:"serif",C:"sans-serif"},S=null;function T(){if(null===S){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.m.a.offsetWidth;this.A=q();U(this)};
function la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,J(a).toString(),"active")],[b.a.c("wf",a.c,J(a).toString(),"loading"),b.a.c("wf",a.c,J(a).toString(),"inactive")]);K(b,"fontactive",a);this.m=!0;na(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,J(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,J(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,J(a).toString(),"inactive"));w(b.f,d,e)}K(b,"fontinactive",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),K(a,"active")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};
function qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c("wf",x.c,J(x).toString(),"loading")]);K(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);
X=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}
ra.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||"https://fast.fonts.net/jsapi")+"/"+d+".js"+(e?"?v="+e:""),function(e){e?a([]):(f["__MonotypeConfiguration__"+
d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||""}var ua="https://fonts.googleapis.com/css";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function wa(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}
var za={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Aa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ba={i:"i",italic:"i",n:"n",normal:"n"},
Ca=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(","),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k="";else{k=n[2];k=null==k||""==k?"n":Ba[k];n=n[1];if(null==n||""==n)n="4";else var r=Aa[n],n=r?r:isNaN(n)?"4":n.substr(0,1);k=[k,n].join("")}}else k="";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},A(this.c,(this.f.api||"https://f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());

"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// ////////////////////////////////////////////////////////////////////////////////////
// Developed By: Mitr Learning & Media
// Name: DemoActClass
// Description: The View Class Controls the Lab by interacting with BrainClass and updates the lab accordingly
// Date Created: 08/04/2019
// Date Modified: 03/06/2019
// Version: 1.0
// canvas arrow : http://www.dbp-consulting.com/tutorials/canvas/CanvasArrow.html
// ////////////////////////////////////////////////////////////////////////////////////
// Please read below info for more info about variables.
//= ================================

/*
--------- Quadrant Info ---------------
    Quadrant 4 |  Quadrant 1
      --------------------------
      Quadrant 3 |  Quadrant 2
      ---------------------------------------

    While defining qudrants. Pass array. For ex. If you want to show only quadrant 1 then pass string as.
    quadrant:'1'
    quadrant:'2'
    quadrant:'3'
    quadrant:'4'
    If you want to display qudrants 1 and 2 then pass below code.
    for qudrants 1 and 2 => '12' or '21'
    for qudrants 2 and 3 => '23' or '32'
    for qudrants 3 and 4 => '34' or '43'
    for qudrants 1 and 4 => '14' or '41'

    for all pass => '1234';

    ----------------------------------------------------

    How to define Graph Center --------

    // ====== possible values ===============
    graphCenter = 'center';
    graphCenter = 'center-left';
    graphCenter = 'center-right';
    graphCenter = 'left-top';
    graphCenter = 'left-bottom';
    graphCenter = 'right-top';
    graphCenter = 'right-bottom';
    //=======================================

*/
// ////////////////////////////////////////////////////////////////////////////////////
function graphPluginAdvClass(_obj) {
  var modelObj = {
    x: 0,
    y: 0,
    width: 1280,
    height: 720,
    imageList: [],
    fontsize: 16,
    lineWidth: 1,
    minX: -10,
    minY: -10,
    maxX: 10,
    maxY: 10,
    unitsPerTick: 5,
    XunitsPerTick: 5,
    XunitsPerTickToFixed: 0,
    YunitsPerTick: 5,
    YunitsPerTickToFixed: 0,
    unitsPerGrid: 5,
    XunitsPerGrid: 5,
    YunitsPerGrid: 5,
    panX: true,
    panY: true,
    gridLightColor: "#cde6f1",
    gridDarkColor: "#98c8db",
    // gridLightColor: '#0000ff',
    // gridDarkColor: '#ff0000',
    axisColor: "#000",
    numberFontSize: 16,
    labelFontSize: 18,
    tickSize: 10,
    showQuadrants: "1234",
    graphCenter: "center",
    margin: 0,
    topMargin: 1,
    rightMargin: 1,
    bottomMargin: 1,
    leftMargin: 1,
    gridMargin: [0, 0, 0, 0],
    // L R T B
    numbersMinX: null,
    numbersMaxX: null,
    numbersMinY: null,
    numbersMaxY: null,
    numTextFontSize: 12,
    xLabelText: "X",
    xLabelTextOffsetX: 15,
    xLabelTextOffsetY: 11,
    yLabelText: "Y",
    yLabelTextOffsetX: 15,
    yLabelTextOffsetY: 18,
    lineThickness: 1,
    lineColor: "#ff0000",
    pointColor: "#ff0000",
    borderColor: "rgba(73,124,190,1)",
    bgColor: "rgba(255,255,255,1)",
    borderThickness: 1,
    majorThickness: 1,
    cacheGraph: true,
    showPointText: true,
    showAxisLabels: true,
    limitNumberDisplay: "true",
    visible: true,
    pointRadius: 5,
    pixelValuePerX: 35,
    pixelValuePerY: 35,
    alignXLine: "center",
    // left center right
    alignYLine: "center",
    // top center bottom,
    regX: null,
    regY: null,
    clickable: false,
    showGrid: true,
    sections: {
      graph: {
        index: 0,
        visible: true,
        // required for cache graph drawing
        horizontalGrid: true,
        verticalGrid: true
      },
      axis: {
        index: 1,
        visible: true,
        origin: {
          visible: true
        },
        xAxis: {
          visible: true,
          ticks: true,
          arrowHead: true,
          numbers: true,
          minPanInPixel: null,
          maxPanInPixel: null,
          restrictPadding: 35,
          restrictToBoundry: true,
          values: [] // provide an array of text id from labText.json. default is number

        },
        yAxis: {
          visible: true,
          ticks: true,
          arrowHead: true,
          numbers: true,
          minPanInPixel: null,
          maxPanInPixel: null,
          restrictPadding: 35,
          restrictToBoundry: true,
          values: [] // provide an array of text id from labText.json default is number

        }
      },
      shape: {
        index: 2,
        visible: true
      },
      line: {
        index: 3,
        visible: true
      },
      point: {
        index: 4,
        visible: true
      }
    },
    minPanX: -10000000,
    // top left    this values only to restrict dragging area
    maxPanX: 10000000,
    // bottom right
    minPanY: -10000000,
    // top left
    maxPanY: 10000000,
    // bottom right,
    decimalPoint: 2,
    centerPoint: null,
    arrowOnly: false
  }; // context.lineWidth = modelObj.borderThickness;
  // context.strokeStyle = modelObj.borderColor;
  // ====================== Local Variables =====================================

  var brainObj = {};
  var imgObj;
  var resetObj;
  var events = {};
  var localObj = {};
  var context;
  var rangeX;
  var rangeY;
  var unitX;
  var unitY;
  var centerX;
  var centerY;
  var iteration;
  var scaleX;
  var scaleY;
  var vertex_X;
  var vertex_Y;
  var xShift = 0;
  var yShift = 0;
  var trangleWidth = 5;
  var trangleHeight = 10;
  var graphCanvas = document.createElement("canvas");
  var graphContext = graphCanvas.getContext("2d");
  graphCanvas.style.position = "absolute";
  var axisCanvas = document.createElement("canvas");
  var axisContext = axisCanvas.getContext("2d");
  axisCanvas.style.position = "absolute"; // document.body.appendChild(graphCanvas);

  var lineCanvas = document.createElement("canvas");
  var lineContext = lineCanvas.getContext("2d");
  lineCanvas.style.position = "absolute"; // document.body.appendChild(lineCanvas);

  var pointCanvas = document.createElement("canvas");
  var pointContext = pointCanvas.getContext("2d");
  pointCanvas.style.position = "absolute"; // document.body.appendChild(pointCanvas);

  var shapeCanvas = document.createElement("canvas");
  var shapeContext = shapeCanvas.getContext("2d");
  shapeCanvas.style.position = "absolute"; // document.body.appendChild(shapeCanvas);

  var pointsArr = [];
  var coeffObj;
  var _counter = 0;
  var mouseDown = false;

  var _mouseDownPageX;

  var _mouseDownPageY;

  var renderGraph = false;
  var arrow1 = true;
  var arrow2 = true;
  var arrow3 = true;
  var arrow4 = true;
  var graphLineArr = [];
  var graphPointArr = [];
  var shapePointArr = [];

  var _this = this;

  var originalX;
  var originalY;
  var canvasImages; //= ==================================================================
  // --------------------

  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === "object" && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === "object" && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  }

  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass(); // --------------------

  if (modelObj.imageList.length > 0) {
    modelObj.LabComClass.requestLocalImage(modelObj.imageList, onImageLoaded);
  } else {
    onImageLoaded({});
  } // =================================================
  // PUBLIC SECTION
  // =================================================

  /*
   * This function is a initialization function and used to initialize the values.
   * @param _obj is of type object. It has all the data from the brainObj.
   */


  this.init = function () {
    correctModelObj(); //= =======================================
    // modelObj.height = modelObj.height

    /*
    resetObj = JSON.parse(JSON.stringify(brainObj));
    onActValueUpdate();
    addEvents();
    */

    originalX = modelObj.x;
    originalY = modelObj.y;

    if (modelObj.cacheGraph) {
      modelObj.x = 0;
      modelObj.y = 0;
    }

    context = modelObj.context;
    graphCanvas.width = modelObj.width;
    graphCanvas.height = modelObj.height;
    axisCanvas.width = modelObj.width;
    axisCanvas.height = modelObj.height;
    lineCanvas.width = modelObj.width;
    lineCanvas.height = modelObj.height;
    pointCanvas.width = modelObj.width;
    pointCanvas.height = modelObj.height;
    shapeCanvas.width = modelObj.width;
    shapeCanvas.height = modelObj.height;
    canvasImages = [{
      img: graphCanvas,
      sectionId: "graph",
      changeImageSmoothing: false
    }, {
      img: axisCanvas,
      sectionId: "axis",
      changeImageSmoothing: false
    }, {
      img: lineCanvas,
      sectionId: "line",
      changeImageSmoothing: false
    }, {
      img: pointCanvas,
      sectionId: "point",
      changeImageSmoothing: false
    }, {
      img: shapeCanvas,
      sectionId: "shape",
      changeImageSmoothing: false
    }];
    updateZoomValues();
    addEvents();
  }; // =================================================


  function correctModelObj() {
    // =========== Convert +ve & -ve Range to numbers ==================
    modelObj.minX = Number(modelObj.minX);
    modelObj.minY = Number(modelObj.minY);
    modelObj.maxX = Number(modelObj.maxX);
    modelObj.maxY = Number(modelObj.maxY); //= ==================================================

    modelObj.numbersMinX = Number(modelObj.numbersMinX);
    modelObj.numbersMaxX = Number(modelObj.numbersMaxX);
    modelObj.numbersMinY = Number(modelObj.numbersMinY);
    modelObj.numbersMaxY = Number(modelObj.numbersMaxY); //= ==================================================

    modelObj.xLabelTextOffsetX = Number(modelObj.xLabelTextOffsetX);
    modelObj.xLabelTextOffsetY = Number(modelObj.xLabelTextOffsetY);
    modelObj.yLabelTextOffsetX = Number(modelObj.yLabelTextOffsetX);
    modelObj.yLabelTextOffsetY = Number(modelObj.yLabelTextOffsetY); //= ==================================================
  }

  this.getGraphMinMax = function () {
    var _screenMin = _this.getPointByPixel(originalX, originalY);

    var _screenMax = _this.getPointByPixel(originalX + modelObj.width, originalY + modelObj.height);

    var _screenCenter = _this.getPointByPixel(originalX + modelObj.width / 2, originalY + modelObj.height / 2);

    return {
      min: {
        x: _screenMin.x,
        y: _screenMin.y
      },
      max: {
        x: _screenMax.x,
        y: _screenMax.y
      },
      center: {
        x: _screenCenter.x,
        y: _screenCenter.y
      },
      unit: {
        x: modelObj.unitsPerTick,
        pxValX: modelObj.pixelValuePerX,
        pxValY: modelObj.pixelValuePerX
      }
    };
  };

  this.getScreenData = function () {
    var data = {
      x: originalX,
      y: originalY,
      width: modelObj.width,
      height: modelObj.height,
      screen: {
        x: originalX,
        y: originalY,
        w: modelObj.width,
        h: modelObj.height
      },
      originX: _this.getPixelByPoint(0, 0).x,
      originY: _this.getPixelByPoint(0, 0).y,
      centerX: centerX,
      centerY: centerY,
      unitX: unitX,
      unitY: unitY,
      XunitsPerGrid: modelObj.XunitsPerGrid,
      YunitsPerGrid: modelObj.YunitsPerGrid,
      showQuadrants: modelObj.showQuadrants
    };

    if (modelObj.showQuadrants === "1") {
      data.x = originalX + restrictAxisX(axisContext);
      data.width = modelObj.width - (data.x - originalX);
      data.height = restrictAxisY();
    }

    return data;
  };

  this.getPointByPixel = function (_x, _y) {
    var pointX;
    var pointY;
    pointX = (_x - originalX - centerX) / unitX;
    pointY = -1 * (_y - originalY - centerY) / unitY;
    return {
      x: pointX,
      y: pointY
    };
  };

  this.getPixelByPoint = function (valueX, valueY) {
    var pointX;
    var pointY;
    pointX = valueX * unitX + centerX + originalX;
    pointY = valueY * unitY / -1 + centerY + originalY;
    return {
      x: pointX,
      y: pointY
    };
  };

  this.setPointToScreenCenter = function (valueX, valueY) {
    var pixelX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1280 / 2;
    var pixelY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 720 / 2;
    updateGraphPos(valueX, valueY, pixelX, pixelY);
    validateValues();
  };

  function updateGraphPos(valueX, valueY, pixelX, pixelY) {
    var point = _this.getPixelByPoint(valueX, valueY);

    var screenCenter = {
      x: pixelX,
      y: pixelY
    };

    var origin = _this.getPixelByPoint(0, 0);

    var diff = {
      x: point.x - screenCenter.x,
      y: point.y - screenCenter.y
    };
    modelObj.regX = origin.x - diff.x - originalX;
    modelObj.regY = origin.y - diff.y - originalY;
    centerX = modelObj.regX;
    centerY = modelObj.regY;
  }

  this.getPointUnitByPixelUnit = function (_pixelUnit) {
    return _pixelUnit / unitX;
  };

  this.getPixelUnitByPointUnit = function (_pointUnit) {
    return _pointUnit * unitX;
  };

  this.graphLines = function (_obj) {
    if (_obj.axis !== undefined) {
      modelObj.sections.axis.visible = _obj.axis;
    }

    if (_obj.grid !== undefined) {
      modelObj.sections.graph.visible = _obj.grid;
    }
  };

  this.setZoom = function (_obj) {
    // modelObj.centerPoint = _this.getPointByPixel(originalX + modelObj.width / 2, originalY + modelObj.height / 2);
    if (_obj.value === "zoomReset") {
      _this.setParams({
        regX: "",
        regY: ""
      });
    }

    var currentZoomData = _obj.data;
    modelObj.pixelValuePerX = currentZoomData.pixelQube;
    modelObj.pixelValuePerY = currentZoomData.pixelQube; // eslint-disable-next-line no-multi-assign

    modelObj.unitsPerTick = modelObj.XunitsPerTick = modelObj.YunitsPerTick = currentZoomData.tick;
    modelObj.XunitsPerTickToFixed = currentZoomData.toFixed;
    modelObj.YunitsPerTickToFixed = currentZoomData.toFixed;
    modelObj.unitsPerGrid = modelObj.unitsPerTick / 5;
    modelObj.XunitsPerGrid = modelObj.XunitsPerTick / 5;
    modelObj.YunitsPerGrid = modelObj.YunitsPerTick / 5;
    validateValues(true);
  };

  this.setParams = function (_obj) {
    var keys = ["x", "y", "width", "height", "unitsPerTick", "XunitsPerTick", "YunitsPerTick", "unitsPerGrid", "XunitsPerGrid", "YunitsPerGrid", "panX", "panY", "pixelValuePerX", "pixelValuePerY", "regX", "regY", "clickable", "sections", "minPanX", "maxPanX", "minPanY", "maxPanY", "decimalPoint"];
    updateValues.apply(void 0, [_obj].concat(keys));
    validateValues(false);
  };

  function updateValues(_data) {
    var temp = {};
    var needToInitialize = false;

    for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      keys[_key - 1] = arguments[_key];
    }

    keys.forEach(function (i) {
      if (_data.hasOwnProperty(i)) {
        temp[i] = _data[i];

        if (i === "x" || i === "y" || i === "width" || i === "height") {
          needToInitialize = true;
        }
      }
    });
    setData(modelObj, temp);

    if (needToInitialize) {
      _this.init();
    }

    drawGraph();
  }

  function validateValues(_flag) {
    checkPanRestrictions();
    var dataSetters = {
      restrictions: {
        tickRange: {
          min: 0.000000001,
          max: 1000000,
          toFixed: 10
        },
        gridRange: {
          min: 0.000000001,
          max: 1000000,
          toFixed: 10
        }
      },
      property: {
        unitsPerTick: "tickRange",
        XunitsPerTick: "tickRange",
        YunitsPerTick: "tickRange",
        unitsPerGrid: "gridRange",
        XunitsPerGrid: "gridRange",
        YunitsPerGrid: "gridRange"
      }
    };
    Object.keys(dataSetters.property).forEach(function (i) {
      if (modelObj[i] < dataSetters.restrictions[dataSetters.property[i]].min) {
        modelObj[i] = dataSetters.restrictions[dataSetters.property[i]].min;
      }

      if (modelObj[i] > dataSetters.restrictions[dataSetters.property[i]].max) {
        modelObj[i] = dataSetters.restrictions[dataSetters.property[i]].max;
      }

      if (dataSetters.restrictions[dataSetters.property[i]].toFixed >= 0 && modelObj[dataSetters.property[i]] !== "") {
        modelObj[i] = Number(Number(modelObj[i]).toFixed(dataSetters.restrictions[dataSetters.property[i]].toFixed));
      }
    });
    updateZoomValues(_flag);
  }

  this.updateBarChart = function (_obj) {
    for (var i = 0; i < _obj.length; i++) {
      modelObj.bardata[i].value = _obj[i].value;
    }

    drawGraph();
  };

  function updateZoomValues(_flag) {
    rangeX = modelObj.maxX - modelObj.minX;
    rangeY = modelObj.maxY - modelObj.minY;
    unitX = modelObj.pixelValuePerX;
    unitY = modelObj.pixelValuePerY;

    if (modelObj.regX === "") {
      switch (modelObj.alignXLine) {
        case "left":
          modelObj.regX = modelObj.x + modelObj.leftMargin + unitX;
          break;

        case "right":
          modelObj.regX = modelObj.x + modelObj.width - modelObj.rightMargin - unitX;
          break;

        case "center":
          modelObj.regX = modelObj.x + modelObj.width / 2;
          break;

        default:
          modelObj.regX = modelObj.x + modelObj.leftMargin + unitX;
      }

      switch (modelObj.alignYLine) {
        case "top":
          modelObj.regY = modelObj.y + modelObj.topMargin + unitY;
          break;

        case "bottom":
          modelObj.regY = modelObj.y + modelObj.height - modelObj.bottomMargin - unitY;

          if (modelObj.showQuadrants === "1") {
            if (modelObj.sections.axis.yAxis.maxPanInPixel !== null) {
              modelObj.regY = modelObj.height - modelObj.sections.axis.yAxis.maxPanInPixel;
            }
          }

          break;

        case "center":
          modelObj.regY = modelObj.y + modelObj.height / 2;
          break;

        default:
          modelObj.regY = modelObj.y + modelObj.topMargin + unitY;
      }
    }

    centerX = modelObj.regX;
    centerY = modelObj.regY;
    restrictAxisX(axisContext); // if (_flag && modelObj.showQuadrants !== '1') {
    // updateGraphPos(modelObj.centerPoint.x, modelObj.centerPoint.y, originalX + modelObj.width / 2, originalY + modelObj.height / 2);
    // }

    if (typeof events.scaleUpdate !== "undefined") {
      events.scaleUpdate({
        type: "scaleUpdate"
      }, true);
    }

    drawGraph();
  }

  this.enablePan = function (bool) {
    if (bool) {
      modelObj.panX = true;
      modelObj.panY = true;
    } else {
      modelObj.panX = false;
      modelObj.panY = false;
    }

    addEvents();
  }; // =================================================
  // var graphImage;


  function drawGraph() {
    // DRAWING BUG FIXED: 1-6-2020 WHILE DOING POC
    graphContext.clearRect(0, 0, modelObj.width, modelObj.height);
    axisContext.clearRect(0, 0, modelObj.width, modelObj.height);
    lineContext.clearRect(0, 0, modelObj.width, modelObj.height);
    pointContext.clearRect(0, 0, modelObj.width, modelObj.height);
    shapeContext.clearRect(0, 0, modelObj.width, modelObj.height);

    if (modelObj.maxY < 0) {
      centerY = -centerY;
    }

    if (modelObj.minX > 0) {
      centerX = -centerX;
    }

    iteration = (modelObj.maxX - modelObj.minX) / 1000;
    scaleX = (modelObj.width - 2 * modelObj.margin) / rangeX;
    scaleY = (modelObj.height - 2 * modelObj.margin) / rangeY; // ===== Sample Rect =================

    if (modelObj.showQuadrants === "2") {
      centerY += modelObj.margin;
    }

    if (modelObj.showQuadrants === "3") {
      centerX -= modelObj.margin;
      centerY += modelObj.margin;
    }

    if (modelObj.showQuadrants === "4") {
      centerX -= modelObj.margin;
    }

    if (modelObj.graphCenter === "center-left") {
      centerX = modelObj.x + modelObj.leftMargin;
    }

    if (modelObj.graphCenter === "center-right") {
      centerX = modelObj.x + modelObj.width - modelObj.rightMargin;
    }

    if (modelObj.graphCenter === "left-bottom") {
      centerX = modelObj.x + modelObj.leftMargin;
      centerY = modelObj.height + modelObj.y - modelObj.bottomMargin;
    }

    if (modelObj.cacheGraph) {
      drawAllParts({
        graphContext: graphContext,
        axisContext: axisContext,
        lineContext: lineContext,
        pointContext: pointContext,
        shapeContext: shapeContext
      });
    } else {
      drawAllParts({
        graphContext: context,
        axisContext: context,
        lineContext: context,
        pointContext: context,
        shapeContext: context
      });
    } //= ================================

  }

  function drawAllParts(_obj) {
    _obj.graphContext.save();

    clipGraphRegion(_obj.graphContext);
    drawGridLines(_obj.graphContext);

    _obj.graphContext.restore();

    axisContext.save();
    clipGraphRegion(_obj.axisContext); // barchart-pyramid

    if (modelObj.graphType === "barchart") {
      drawBarChart(_obj.axisContext);
    }

    if (modelObj.graphType === "barchart-pyramid") {
      drawBarChartPyramid(_obj.axisContext);
    }

    if (modelObj.sections.axis.yAxis.visible) {
      drawYAxis(_obj.axisContext);
    }

    if (modelObj.sections.axis.xAxis.visible) {
      drawXAxis(_obj.axisContext);
    }

    axisContext.restore();

    _this.plotLineArr(_obj.lineContext);

    _this.plotPointArr(_obj.pointContext);

    _this.plotShapeArr(_obj.shapeContext);
  }

  function clipGraphRegion(ctx) {
    ctx.beginPath();
    ctx.rect(modelObj.x, modelObj.y, modelObj.width - 1, modelObj.height);
    ctx.strokeStyle = "transparent";
    ctx.lineWidth = "1";
    ctx.stroke();
    ctx.closePath();
    ctx.clip();
  } // =================================================

  /*
   * This function is used to Add custom events.
   * @param _evt is of type string. It is the name of the events to be saved.
   * @param _func is of type function. It is the code which is to be exectued on the event fire
   */


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================

  /*
   * This function is used to Update the Lab.
   * @param _obj is of type object. It has all the data from the brainObj.
   */


  this.updateRender = function (_obj) {
    if (_obj) {
      Object.keys(_obj).forEach(function (i) {
        brainObj[i] = _obj[i];
      });
    }

    onActValueUpdate();
  };

  this.updateGraph = function () {
    drawGraph();
  }; // =================================================

  /*
   * This function is used to reset the lab.
   */


  this.resetLab = function () {}; // =================================================
  // =================================================

  /*
   * This function is used to draw the Lab.
   */
  //= =========================


  this.draw = function () {
    if (modelObj.visible) {
      context.save();

      if (modelObj.cacheGraph) {
        drawGraphBorder(originalX, originalY, modelObj.width, modelObj.height);

        for (var i = 0; i < canvasImages.length; i++) {
          for (var j = 0; j < canvasImages.length; j++) {
            if (modelObj.sections[canvasImages[j].sectionId].index === i && modelObj.sections[canvasImages[j].sectionId].visible) {
              context.save();
              context.beginPath();

              if (canvasImages[j].changeImageSmoothing) {
                context.imageSmoothingEnabled = false;
                context.mozImageSmoothingEnabled = false;
                context.webkitImageSmoothingEnabled = false;
                context.msImageSmoothingEnabled = false;
              }

              context.drawImage(canvasImages[j].img, originalX, originalY);
              context.closePath();
              context.restore();
            }
          }
        }
      } else {
        drawGraphBorder(modelObj.x, modelObj.y, modelObj.width, modelObj.height);
        drawGraph();
      }

      context.restore();
    }
  };

  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  };

  this.getVisible = function () {
    return modelObj.visible;
  }; //= =========================


  function drawGraphBorder(x, y, w, h) {
    context.save();
    context.fillStyle = modelObj.bgColor;
    context.fillRect(x, y, w, h);
    context.beginPath();
    context.lineWidth = modelObj.borderThickness;
    context.strokeStyle = modelObj.borderColor;
    context.rect(x, y, w - 1, h);
    context.stroke();
    context.closePath();
    context.restore();
  } //= =========================


  this.getTotalPoints = function () {
    return pointsArr.length;
  };

  this.updateGraphRange = function () {
    xShift += 0.1;
    yShift += 0.1;
    modelObj.minX += xShift;
    modelObj.maxX += xShift;
  };

  this.drawCustomGraph = function () {
    centerY = Math.round(Math.abs(modelObj.maxY / rangeY) * modelObj.height);
    centerX = Math.round(Math.abs(modelObj.minX / rangeX) * modelObj.width);

    if (modelObj.maxY < 0) {
      centerY = -centerY;
    }

    if (modelObj.minX > 0) {
      centerX = -centerX;
    }

    centerX += modelObj.x;
    centerY += modelObj.y;
    iteration = (modelObj.maxX - modelObj.minX) / 1000;
    scaleX = modelObj.width / rangeX;
    scaleY = modelObj.height / rangeY;
    drawGridLines();

    if (modelObj.minX <= 0 && modelObj.maxX >= 0) {
      drawYAxis();
    }

    if (modelObj.maxY >= 0 && modelObj.minY <= 0) {
      drawXAxis();
    }

    context.save();
    context.rect(modelObj.x + 5, modelObj.y + 3, modelObj.width - 8, modelObj.height - 10);
    context.strokeStyle = "transparent";
    context.stroke();
    context.clip();

    for (var i = 0; i < pointsArr.length; i++) {
      this.plotPoint(pointsArr[i].x, pointsArr[i].y, pointsArr[i].color, pointsArr[i].type, true);
    }

    context.restore(); //= ============================= DRAW EQUATIONS ==================
  };

  function drawEqTriangle(ctx, side, cx, cy, type) {
    // type
    // type 0 ( Y-Upside):
    // type 1 ( X-Rightside) :
    // type 2  ( Y-Downside):
    // type 3 ( X-Leftside) :
    var h = side * (Math.sqrt(3) / 2);
    ctx.strokeStyle = "#000";
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();

    if (type === 0) {
      ctx.moveTo(0, -h / 2);
      ctx.lineTo(-side / 2, h / 2);
      ctx.lineTo(side / 2, h / 2);
      ctx.lineTo(0, -h / 2);
    }

    if (type === 1) {
      ctx.moveTo(0, h / 2);
      ctx.lineTo(-side / 2, -h / 2);
      ctx.lineTo(side / 2, -h / 2);
      ctx.lineTo(0, h / 2);
    }

    if (type === 2) {
      ctx.moveTo(h / 2, 0);
      ctx.lineTo(-h / 2, -side / 2);
      ctx.lineTo(-h / 2, side / 2);
      ctx.lineTo(h / 2, 0);
    }

    if (type === 3) {
      ctx.moveTo(-h / 2, 0);
      ctx.lineTo(side / 2, h / 2);
      ctx.lineTo(side / 2, -h / 2);
      ctx.lineTo(-h / 2, 0);
    }

    ctx.stroke();
    ctx.fill();
    ctx.closePath();
    ctx.restore();
  } //= ==================================================


  function canvas_arrow(context, fromx, fromy, tox, toy) {
    var headlen = 0.3; // length of head in pixels

    var dx = tox - fromx;
    var dy = toy - fromy;
    var angle = Math.atan2(dy, dx);
    context.moveTo(tox, toy);
    context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
    context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
    context.lineTo(tox, toy);
    context.fill();
  } //= ==================================================


  function drawGridLines(ctx) {
    var lineCounter;

    var _drawGridBool; // return;
    // draw tick marks


    var minorLineWidth = 1;
    var xPosIncrement = modelObj.XunitsPerGrid * unitX;
    var xPosIncrementMajor = modelObj.XunitsPerTick * unitX;
    var xPos, unit;
    ctx.font = modelObj.numberFontSize + "px " + modelObj.LabComClass.klettFontRegular;
    ctx.textAlign = "center";
    ctx.textBaseline = "top"; // ctx.strokeStyle = '#b5f3d0';

    ctx.strokeStyle = modelObj.gridLightColor; //= =================================
    // draw left tick marks

    xPos = centerX - xPosIncrement;
    unit = -1 * modelObj.XunitsPerGrid; //= =================================

    var leftVerticalLines = true;

    if (modelObj.showQuadrants === "1") {
      leftVerticalLines = false;
    }

    if (modelObj.sections.graph.verticalGrid) {
      if (leftVerticalLines) {
        lineCounter = 0;

        while (xPos > modelObj.x + modelObj.gridMargin[0]) {
          if (xPos < modelObj.x + modelObj.width - modelObj.gridMargin[1]) {
            lineCounter++;
            _drawGridBool = lineCounter % (modelObj.XunitsPerTick / modelObj.XunitsPerGrid);
            ctx.beginPath();
            ctx.moveTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.gridMargin[2]) + 0.5);
            ctx.lineTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.gridMargin[3]) + 0.5);

            if (_drawGridBool === 0) {
              ctx.lineWidth = modelObj.majorThickness;
              ctx.strokeStyle = modelObj.gridDarkColor;
            } else {
              ctx.lineWidth = minorLineWidth;
              ctx.strokeStyle = modelObj.gridLightColor;
            }

            ctx.stroke();
            ctx.closePath();
          }

          unit -= modelObj.XunitsPerGrid;
          xPos -= xPosIncrement;
        }
      } //= =================================
      // draw right tick marks


      xPos = centerX;
      unit = modelObj.XunitsPerGrid; //= ====================================

      var rightVerticalLines = true;
      var axisX = restrictAxisX(ctx);

      if (rightVerticalLines) {
        lineCounter = 0;

        while (xPos < modelObj.x + modelObj.width) {
          var drawLines = true;

          if (modelObj.showQuadrants === "1" && xPos < axisX) {
            drawLines = false;
          }

          if (drawLines) {
            _drawGridBool = lineCounter % (modelObj.XunitsPerTick / modelObj.XunitsPerGrid);
            ctx.beginPath();
            ctx.moveTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.gridMargin[2]) + 0.5);

            if (modelObj.showQuadrants === "1") {
              var end = restrictAxisY();

              if (modelObj.gridMargin[3] && end > modelObj.y + modelObj.height - modelObj.gridMargin[3]) {
                end = modelObj.y + modelObj.height - modelObj.gridMargin[3];
              }

              ctx.lineTo(Math.round(xPos) + 0.5, Math.round(end) + 0.5);
            } else {
              ctx.lineTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.gridMargin[3]) + 0.5);
            }

            if (_drawGridBool === 0) {
              ctx.lineWidth = modelObj.majorThickness;
              ctx.strokeStyle = modelObj.gridDarkColor;
            } else {
              ctx.lineWidth = minorLineWidth;
              ctx.strokeStyle = modelObj.gridLightColor;
            }

            ctx.stroke();
            ctx.closePath();
          }

          lineCounter++;
          unit += modelObj.XunitsPerGrid;
          xPos += xPosIncrement;
        }
      }
    } //= ====================================
    //= =================================
    // draw tick marks


    var yPosIncrement = modelObj.YunitsPerGrid * unitY;
    var yPos;
    ctx.font = modelObj.numberFontSize + "px " + modelObj.LabComClass.klettFontRegular;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.strokeStyle = modelObj.gridLightColor; //= =================================
    // draw top tick marks

    yPos = centerY;
    unit = modelObj.YunitsPerGrid;
    var _counter = 0; // while(yPos > modelObj.y)
    // modelObj.y

    var startX = modelObj.x + modelObj.gridMargin[0];
    var endX = modelObj.x + modelObj.width - modelObj.gridMargin[1];

    if (modelObj.showQuadrants === "1") {
      startX = restrictAxisX(ctx);
    }

    var axisY = restrictAxisY();

    if (modelObj.sections.graph.horizontalGrid) {
      lineCounter = 0;

      while (yPos > modelObj.y + modelObj.gridMargin[2]) {
        _counter++;
        _drawGridBool = lineCounter % (modelObj.YunitsPerTick / modelObj.YunitsPerGrid);
        lineCounter++;
        var _drawLines = true;

        if (modelObj.showQuadrants === "1") {
          if (yPos > axisY) {
            _drawLines = false;
          }
        }

        if (_drawLines && yPos < modelObj.height + modelObj.y - modelObj.gridMargin[3]) {
          ctx.beginPath();
          ctx.moveTo(Math.round(startX) + 0.5, Math.round(yPos) + 0.5);
          ctx.lineTo(Math.round(endX) + 0.5, Math.round(yPos) + 0.5);

          if (_drawGridBool === 0) {
            ctx.lineWidth = modelObj.majorThickness;
            ctx.strokeStyle = modelObj.gridDarkColor;
          } else {
            ctx.lineWidth = minorLineWidth;
            ctx.strokeStyle = modelObj.gridLightColor;
          }

          ctx.stroke();
          ctx.closePath();
        }

        unit += modelObj.YunitsPerGrid; // yPos = Math.round(yPos - yPosIncrement);

        yPos -= yPosIncrement;
      } //= =================================
      // draw bottom tick marks


      yPos = centerY + yPosIncrement;
      unit = -1 * modelObj.YunitsPerGrid;
      var bottomHorizontalLines = true;

      if (modelObj.showQuadrants === "1") {
        bottomHorizontalLines = false;
      }

      if (bottomHorizontalLines) {
        lineCounter = 0;

        while (yPos < modelObj.height + modelObj.y - modelObj.gridMargin[3]) {
          if (yPos > modelObj.y + modelObj.gridMargin[2]) {
            lineCounter++;
            _drawGridBool = lineCounter % (modelObj.YunitsPerTick / modelObj.YunitsPerGrid);
            ctx.beginPath();
            ctx.moveTo(Math.round(modelObj.x + modelObj.gridMargin[0]) + 0.5, Math.round(yPos) + 0.5);
            ctx.lineTo(Math.round(modelObj.x + modelObj.width - modelObj.gridMargin[1]) + 0.5, Math.round(yPos) + 0.5);

            if (_drawGridBool === 0) {
              ctx.lineWidth = modelObj.majorThickness;
              ctx.strokeStyle = modelObj.gridDarkColor;
            } else {
              ctx.lineWidth = minorLineWidth;
              ctx.strokeStyle = modelObj.gridLightColor;
            }

            ctx.stroke();
            ctx.closePath();
          }

          unit -= modelObj.YunitsPerGrid;
          yPos += yPosIncrement;
        }
      }
    }
  }

  function drawBar(ctx, upperLeftCornerX, upperLeftCornerY, width, height, color) {
    if (color === "") {
      color = "#000000";
    }

    ctx.save();
    ctx.fillStyle = color;
    ctx.fillRect(upperLeftCornerX, upperLeftCornerY, width, height);
    ctx.restore();
  }

  function drawBarChart(ctx) {
    var barIndex = 0;

    for (var i = 0; i < modelObj.bardata.length; i++) {
      var _barWidth = modelObj.barSize;
      var _barValArr = modelObj.bardata[i].value;
      var _barColorArr = modelObj.bardata[i].color;
      var _barGroupStartX = 0;
      var _barGroupWidth = 0;

      for (var j = 0; j < _barValArr.length; j++) {
        var _barHeight = Number(_barValArr[j]) * unitY;

        var _barColor = _barColorArr[j];

        var _barX = centerX + modelObj.barChartPadding + modelObj.barChartLeftMargin + barIndex * (modelObj.barSize + modelObj.barsGapWidth) + j * modelObj.barSize;

        var _barY = centerY - _barHeight - modelObj.barChartPadding;

        if (j === 0) {
          _barGroupStartX = _barX;
        }

        _barGroupWidth += modelObj.barSize;
        drawBar(ctx, _barX, _barY, _barWidth, _barHeight, _barColor);
      }

      ctx.fillStyle = "#000000";
      ctx.textAlign = "center";
      ctx.font = modelObj.barLabelFontSize + "px " + modelObj.LabComClass.klettFontRegular; // start text from the center of the graph

      var _textX = _barGroupStartX + _barGroupWidth / 2;

      ctx.fillText(modelObj.LabComClass.globalLangText[modelObj.bardata[i].name], _textX, centerY + 15);
      barIndex++;
    }
  }

  function drawBarChartPyramid(ctx) {
    var barIndex = 0;

    for (var i = 0; i < modelObj.bardata.length; i++) {
      //= ========================================
      var _xPtVal = centerX + modelObj.shiftCenterX * unitX;

      var _yPtVal = centerY - barIndex * 5 * unitY;

      var _barX = _xPtVal;
      var _barY = _yPtVal; //= ========= DRAW LEFT BAR CHART ====================

      var _barWidth = modelObj.bardata[i].value[0] * unitX;

      var _barHeight = 4 * unitY;

      var _barColor = "#00aeef";
      _barY -= 4 * unitY;
      drawBar(ctx, _barX, _barY, _barWidth, _barHeight, _barColor); //= ========= DRAW RIGHT BAR CHART ====================

      _barWidth = modelObj.bardata[i].value[1] * unitX;
      _barHeight = 4 * unitY;
      _barColor = "#fb7e83";
      drawBar(ctx, _barX, _barY, _barWidth, _barHeight, _barColor); //= =======================================

      barIndex++;
    }
  }

  function drawAxisLabels(ctx) {
    if (modelObj.showAxisLabels) {
      ctx.textAlign = "left";
      var textXpos = centerX;
      var textYpos = modelObj.y;

      if (modelObj.LabComClass.globalLangText[modelObj.yLabelText] !== undefined) {
        var _textX = textXpos + modelObj.yLabelTextOffsetX;

        var _textY = modelObj.y + modelObj.height / 2 + modelObj.yLabelTextOffsetY;

        ctx.save();
        ctx.translate(_textX, _textY);
        ctx.rotate(0 * Math.PI / 180);
        ctx.drawStyledText(modelObj.LabComClass.globalLangText[modelObj.yLabelText], 0, 0, modelObj.font, modelObj.labelFontSize);
        ctx.restore();
      }
    }
  } //= ==================================================


  function restrictAxisY() {
    var diff = modelObj.sections.axis.yAxis.restrictPadding;
    var arrowY = centerY;

    if (modelObj.sections.axis.yAxis.restrictToBoundry) {
      if (centerY < diff) {
        arrowY = diff;
      } else if (centerY >= modelObj.height - diff) {
        arrowY = modelObj.height - diff;
      }
    }

    return arrowY;
  }

  function restrictAxisX(ctx) {
    var diff = modelObj.sections.axis.xAxis.restrictPadding;
    var arrowX = centerX;

    if (modelObj.sections.axis.xAxis.restrictToBoundry) {
      if (centerX < diff) {
        arrowX = diff;
      } else if (centerX > modelObj.width - diff) {
        arrowX = modelObj.width - diff;
      }
    }

    var topLeft = _this.getPointByPixel(originalX, originalY).y.toFixed(modelObj.YunitsPerTickToFixed);

    var bottomLeft = _this.getPointByPixel(originalX, originalY + modelObj.height).y.toFixed(modelObj.YunitsPerTickToFixed);

    ctx.save();
    ctx.font = modelObj.numberFontSize + "px " + modelObj.LabComClass.klettFontRegular;
    var topLeftSize = ctx.measureText(topLeft).width;
    var bottomLeftSize = ctx.measureText(bottomLeft).width;
    var maxWidth = topLeftSize > bottomLeftSize ? topLeftSize : bottomLeftSize;
    maxWidth += 14;

    if (arrowX < maxWidth) {
      arrowX = maxWidth;
    } else if (modelObj.showQuadrants === "1" && modelObj.regX > maxWidth) {
      arrowX = maxWidth;
      modelObj.regX = arrowX;
      centerX = arrowX;
    }

    ctx.restore();
    return arrowX;
  }

  function drawXAxis(ctx) {
    arrow1 = false;
    arrow3 = false;
    var arrowY = restrictAxisY();
    var arrowX = restrictAxisX(ctx);

    if (modelObj.showQuadrants === "1" || modelObj.showQuadrants === "2" || modelObj.showQuadrants === "12" || modelObj.showQuadrants === "23" || modelObj.showQuadrants === "41" || modelObj.showQuadrants === "1234") {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.lineTo(Math.round(modelObj.x + modelObj.width - modelObj.rightMargin - trangleWidth / 2) + 0.5, Math.round(arrowY) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow1 = true;
    }

    if (modelObj.showQuadrants === "3" || modelObj.showQuadrants === "4" || modelObj.showQuadrants === "23" || modelObj.showQuadrants === "34" || modelObj.showQuadrants === "41" || modelObj.showQuadrants === "1234") {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.lineTo(Math.round(modelObj.x + modelObj.leftMargin) + 0.5, Math.round(arrowY) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow3 = true;
    } // draw tick marks


    if (modelObj.sections.axis.xAxis.ticks || modelObj.sections.axis.xAxis.numbers) {
      var xPosIncrement = modelObj.XunitsPerTick * unitX;
      var xPos;
      ctx.font = modelObj.numberFontSize + "px " + modelObj.LabComClass.klettFontRegular;
      ctx.textAlign = "center";
      ctx.textBaseline = "top"; // draw left tick marks

      xPos = centerX;

      if (arrow3) {
        var _obj2 = {
          ctx: ctx,
          type: 1,
          min: modelObj.x + modelObj.leftMargin + trangleHeight,
          start: xPos,
          max: modelObj.x + modelObj.width - trangleHeight,
          incrDecrFactor: -xPosIncrement,
          y: arrowY
        };
        drawTicksX(_obj2);
      } // draw right tick marks


      xPos = centerX;
      var lecftMostPos = modelObj.x + modelObj.leftMargin + trangleHeight;

      if (modelObj.showQuadrants === "1") {
        lecftMostPos = modelObj.x + modelObj.leftMargin;
      }

      if (arrow1) {
        var _obj3 = {
          ctx: ctx,
          type: 2,
          min: modelObj.x + modelObj.width - modelObj.rightMargin - trangleHeight,
          start: xPos,
          max: lecftMostPos,
          incrDecrFactor: xPosIncrement,
          y: arrowY
        };
        drawTicksX(_obj3);
      }
    }

    if (modelObj.sections.axis.xAxis.arrowHead) {
      if (arrow1 && centerX < modelObj.x + modelObj.width - modelObj.rightMargin - trangleHeight) {
        drawEqTriangle(ctx, trangleHeight, Math.round(modelObj.x + modelObj.width - modelObj.rightMargin - trangleWidth - 50) + 0.5, Math.round(arrowY) + 0.5, 2);
      }

      if (arrow3 && centerX > modelObj.x + modelObj.leftMargin + trangleHeight) {// drawEqTriangle(ctx, trangleHeight, Math.round(modelObj.x + modelObj.leftMargin + trangleWidth) + 0.5, Math.round(arrowY) + 0.5, 3);
      }
    }

    var textXpos = modelObj.x + modelObj.width - modelObj.rightMargin;
    var textYpos = centerY;

    if (modelObj.graphCenter === "center-right") {
      textXpos = modelObj.x;
    }

    if (textYpos > arrowY) {
      textYpos = arrowY;
    }

    if (modelObj.showAxisLabels) {
      ctx.textAlign = "left";

      if (modelObj.LabComClass.globalLangText[modelObj.xLabelText] !== undefined) {
        var yPos = textYpos - modelObj.xLabelTextOffsetY;

        if (modelObj.y + modelObj.labelFontSize + modelObj.xLabelTextOffsetY >= textYpos - modelObj.xLabelTextOffsetY) {
          yPos = modelObj.y + modelObj.labelFontSize + modelObj.xLabelTextOffsetY;
        }

        ctx.drawStyledText(modelObj.LabComClass.globalLangText[modelObj.xLabelText], textXpos - modelObj.xLabelTextOffsetX, yPos, modelObj.LabComClass.klettFontRegular, modelObj.labelFontSize);
      }
    }
  }

  function drawTicksX(_obj) {
    var unit,
        xPos = _obj.start;
    var y = _obj.y;
    var ctx = _obj.ctx;
    unit = Number(_this.getPointByPixel(xPos + originalX, y).x.toFixed(2));
    var arrowX = restrictAxisX(ctx);

    while (_obj.type === 1 ? xPos > _obj.min : xPos < _obj.min) {
      if (_obj.type === 1 ? xPos < _obj.max : xPos > _obj.max) {
        var _showNumbers = true;

        if (modelObj.showQuadrants === "1" && xPos < arrowX) {
          _showNumbers = false;
        }

        if (_showNumbers) {
          if (modelObj.sections.axis.xAxis.ticks && unit !== 0) {
            ctx.beginPath();
            ctx.moveTo(Math.round(xPos), Math.round(y - modelObj.tickSize / 2));
            ctx.lineTo(Math.round(xPos), Math.round(y + modelObj.tickSize / 2));
            ctx.stroke();
            ctx.closePath();
          }

          var txt = unit.toString();

          if (modelObj.sections.axis.xAxis.postTxt && modelObj.LabComClass.globalLangText[modelObj.sections.axis.xAxis.postTxt]) {
            txt += modelObj.LabComClass.globalLangText[modelObj.sections.axis.xAxis.postTxt];
          }

          if (modelObj.sections.axis.xAxis.numbers) {
            if (unit === 0) {
              if (_obj.incrDecrFactor > 0 && modelObj.sections.axis.origin.visible) {
                var unitTxtX = Math.round(xPos - modelObj.tickSize / 2 - 3);
                var unitTxtY = Math.round(centerY + modelObj.tickSize / 2);

                if (!modelObj.sections.axis.yAxis.visible) {
                  unitTxtX = Math.round(xPos);
                  unitTxtY = Math.round(centerY + modelObj.tickSize / 2 + 3);
                }

                ctx.fillText("O", unitTxtX, unitTxtY);
              }
            } else {
              ctx.fillText(txt, Math.round(xPos), Math.round(y + modelObj.tickSize / 2 + modelObj.numberFontSize / 2));
            }
          }
        }
      }

      xPos += _obj.incrDecrFactor;
      unit = Number(_this.getPointByPixel(xPos + originalX, y).x.toFixed(modelObj.XunitsPerTickToFixed));
    }
  }

  function drawTicksY(_obj) {
    var unit,
        yPos = _obj.start;
    var arrowY = restrictAxisY();
    var x = _obj.x;
    var ctx = _obj.ctx;
    unit = Number(_this.getPointByPixel(x, yPos + originalY).y.toFixed(2));

    while (_obj.type === 1 ? yPos > _obj.min : yPos < _obj.min) {
      _counter++;

      if (_obj.type === 1 ? yPos < _obj.max : yPos > _obj.max) {
        var _showNumbers = true;

        if (modelObj.numbersMaxY) {
          if (unit > modelObj.numbersMaxY) {
            _showNumbers = false;
          }
        }

        if (modelObj.showQuadrants === "1" && yPos > arrowY) {
          _showNumbers = false;
        } // if (unit <= modelObj.numbersMaxY)


        if (_showNumbers) {
          // ============= Draw Ticks ====================
          if (modelObj.sections.axis.yAxis.ticks) {
            ctx.beginPath();
            ctx.moveTo(Math.round(x - modelObj.tickSize / 2) + 0.5, Math.round(yPos) + 0.5);
            ctx.lineTo(Math.round(x + modelObj.tickSize / 2) + 0.5, Math.round(yPos) + 0.5);
            ctx.stroke();
            ctx.closePath();
          } //= =======================================


          if (modelObj.sections.axis.yAxis.numbers) {
            ctx.fillStyle = modelObj.axisColor;
            ctx.fillText(unit, x - modelObj.tickSize / 2 - modelObj.numberFontSize / 2, yPos);
          }
        }
      }

      yPos += _obj.incrDecrFactor;
      unit = Number(_this.getPointByPixel(x, yPos + originalY).y.toFixed(modelObj.YunitsPerTickToFixed));
    }
  }

  function drawYAxis(ctx) {
    arrow4 = false;
    arrow2 = false;
    var arrowX = restrictAxisX(ctx);
    var arrowY = restrictAxisY(ctx);

    if (modelObj.showQuadrants === "1" || modelObj.showQuadrants === "4" || modelObj.showQuadrants === "12" || modelObj.showQuadrants === "34" || modelObj.showQuadrants === "41" || modelObj.showQuadrants === "1234") {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.topMargin + trangleHeight / 2) + 0.5);
      ctx.lineTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow4 = true;
    }

    if (modelObj.showQuadrants === "2" || modelObj.showQuadrants === "3" || modelObj.showQuadrants === "12" || modelObj.showQuadrants === "23" || modelObj.showQuadrants === "34" || modelObj.showQuadrants === "1234") {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.lineTo(Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.bottomMargin) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow2 = true;
    } // draw tick marks


    if (modelObj.sections.axis.yAxis.ticks || modelObj.sections.axis.yAxis.numbers) {
      var yPosIncrement = modelObj.YunitsPerTick * unitY;
      var yPos, unit;
      ctx.font = modelObj.numberFontSize + "px " + modelObj.LabComClass.klettFontRegular;
      ctx.textAlign = "right";
      ctx.textBaseline = "middle"; // draw top tick marks

      yPos = centerY - yPosIncrement;
      unit = modelObj.YunitsPerTick;
      var _counter = 0;

      if (arrow4) {
        var _obj4 = {
          ctx: ctx,
          type: 1,
          min: modelObj.y + modelObj.topMargin + trangleHeight,
          start: yPos,
          max: modelObj.y + modelObj.height - modelObj.bottomMargin - trangleHeight,
          incrDecrFactor: -yPosIncrement,
          x: arrowX
        };
        drawTicksY(_obj4);
      } // draw bottom tick marks


      yPos = centerY + yPosIncrement;
      unit = -1 * modelObj.YunitsPerTick; // while(yPos < modelObj.height+modelObj.y)

      var _showNumbers;

      if (arrow2) {
        var _obj5 = {
          ctx: ctx,
          type: 2,
          min: modelObj.y + modelObj.height - modelObj.bottomMargin - trangleHeight,
          start: yPos,
          max: modelObj.y + modelObj.topMargin + trangleHeight,
          incrDecrFactor: yPosIncrement,
          x: arrowX
        };
        drawTicksY(_obj5);
      }
    }

    if (modelObj.sections.axis.yAxis.arrowHead) {
      if (arrow4 && centerY > modelObj.y + modelObj.topMargin + trangleHeight) {
        drawEqTriangle(ctx, trangleHeight, Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.topMargin + trangleWidth) + 0.5, 0);
      }

      if (arrow2 && centerY < modelObj.y + modelObj.height - modelObj.bottomMargin - trangleHeight) {// drawEqTriangle(ctx, trangleHeight, Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.bottomMargin - trangleWidth) + 0.5, 1);
      }
    }

    var textXpos = centerX;
    var textYpos = modelObj.y + modelObj.topMargin;

    if (modelObj.graphCenter === "center-right") {
      textXpos = centerX;
    }

    if (textXpos < arrowX) {
      textXpos = arrowX;
    }

    if (modelObj.showAxisLabels) {
      ctx.textAlign = "left";

      if (modelObj.LabComClass.globalLangText[modelObj.yLabelText] !== undefined) {
        var xPos = textXpos + modelObj.yLabelTextOffsetX;

        if (modelObj.width - modelObj.labelFontSize - modelObj.yLabelTextOffsetX * 2 < textXpos - modelObj.yLabelTextOffsetX) {
          xPos = modelObj.width - modelObj.labelFontSize * 2 - modelObj.yLabelTextOffsetX * 2;
        }

        ctx.drawStyledText(modelObj.LabComClass.globalLangText[modelObj.yLabelText], xPos, textYpos + modelObj.yLabelTextOffsetY, modelObj.LabComClass.klettFontRegular, modelObj.labelFontSize);
      }
    }
  }

  this.updateLineArr = function (_arr) {
    lineCanvas.width = lineCanvas.width;
    graphLineArr = _arr;

    if (modelObj.cacheGraph) {
      drawGraph();
    }
  };

  this.updatePointsArr = function (_arr) {
    pointCanvas.width = pointCanvas.width;
    graphPointArr = _arr;

    if (modelObj.cacheGraph) {
      drawGraph();
    }

    addEvents();
  };

  this.updateShapesArr = function (_arr) {
    shapeCanvas.width = shapeCanvas.width;
    shapePointArr = _arr;

    if (modelObj.cacheGraph) {
      drawGraph();
    }

    addEvents();
  };

  this.plotPointArr = function (ctx) {
    if (graphPointArr.length === 0) {
      return false;
    }

    for (var i = 0; i < graphPointArr.length; i++) {
      for (var j = 0; j < graphPointArr[i].length; j++) {
        _this.plotPoint(ctx, graphPointArr[i][j].x, graphPointArr[i][j].y, graphPointArr[i][j].color, "", true);
      }
    }

    return true;
  };

  this.plotShapeArr = function (ctx) {
    if (shapePointArr.length === 0) {
      return false;
    } // sample
    // [
    //   [
    //     [
    // 'moveTo(', { val: 20, axis: 'x' }, ',', { val: 50, axis: 'y' }, ')'
    // 'arc(', { val: 20, axis: 'x' }, ',', { val: 50, axis: 'y' }, ',5', ',0', ',6.28)'
    //     ]
    //   ]
    // ]


    for (var i = 0; i < shapePointArr.length; i++) {
      // multiple shapes in different arrays
      ctx.beginPath();

      for (var j = 0; j < shapePointArr[i].length; j++) {
        // single shape
        eval("ctx." + generateShapeString(shapePointArr[i][j]));
      }

      ctx.closePath();
    }

    return true;
  };

  function generateShapeString(data) {
    var shapeMethodString = ""; // arc(0,0,5,0,Math.PI * 2)

    for (var i = 0; i < data.length; i++) {
      // single shape
      var text = "";

      if (_typeof(data[i]) === "object") {
        if (data[i].val !== undefined && data[i].axis !== undefined) {
          if (data[i].axis === "x") {
            text = _this.getPixelByPoint(data[i].val, 0).x;
          } else {
            text = _this.getPixelByPoint(0, data[i].val).y;
          }
        }
      } else {
        text = data[i];
      }

      shapeMethodString += text;
    }

    return shapeMethodString;
  }

  this.plotLineArr = function (ctx) {
    if (graphLineArr.length === 0) {
      return false;
    }

    for (var i = 0; i < graphLineArr.length; i++) {
      if (graphLineArr[i].length > 1) {
        ctx.save();

        for (var j = 1; j < graphLineArr[i].length; j++) {
          var _startXPtVal = centerX + graphLineArr[i][j - 1].x * unitX;

          var _startYPtVal = centerY - graphLineArr[i][j - 1].y * unitY;

          var _endXPtVal = centerX + graphLineArr[i][j].x * unitX;

          var _endYPtVal = centerY - graphLineArr[i][j].y * unitY;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(_startXPtVal, _startYPtVal); //= ================

          ctx.lineTo(_endXPtVal, _endYPtVal); //= =============

          ctx.restore();

          if (graphLineArr[i][j].stroke === "dash") {
            ctx.setLineDash([5, 15]);
          } else {
            ctx.setLineDash([0, 0]);
          }

          ctx.strokeStyle = graphLineArr[i][0].color;
          ctx.closePath();
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    return true;
  };

  this.resetParams = function () {
    pointsArr = [];
    coeffObj = null;
  };

  this.updateGraphParams = function (obj) {
    Object.keys(_obj).forEach(function (i) {
      modelObj[i] = _obj[i];
    });
    correctModelObj();
  };

  this.changeGraphScale = function (maxVal) {
    if (maxVal < 10) {
      modelObj.minX = -10;
      modelObj.maxX = 10;
      modelObj.minY = -10;
      modelObj.maxY = 10;
      modelObj.unitsPerTick = 1;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }

    if (maxVal >= 10 && maxVal <= 25) {
      modelObj.minX = -25;
      modelObj.maxX = 25;
      modelObj.minY = -25;
      modelObj.maxY = 25;
      modelObj.unitsPerTick = 5;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }

    if (maxVal >= 25 && maxVal <= 50) {
      modelObj.minX = -50;
      modelObj.maxX = 50;
      modelObj.minY = -50;
      modelObj.maxY = 50;
      modelObj.unitsPerTick = 10;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }

    if (maxVal >= 50 && maxVal <= 100) {
      modelObj.minX = -100;
      modelObj.maxX = 100;
      modelObj.minY = -100;
      modelObj.maxY = 100;
      modelObj.unitsPerTick = 10;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }
  };

  this.getVertex = function (coeffObj) {
    return [vertex_X, vertex_Y];
  };

  this.getXintercept = function (coeffObj) {
    if (coeffObj) {
      var interceptX1 = (-coeffObj.b + Math.sqrt(coeffObj.b * coeffObj.b - 4 * coeffObj.a * coeffObj.c)) / (2 * coeffObj.a);
      var interceptX2 = (-coeffObj.b - Math.sqrt(coeffObj.b * coeffObj.b - 4 * coeffObj.a * coeffObj.c)) / (2 * coeffObj.a);
      interceptX1 = interceptX1.toFixed(2);
      interceptX2 = interceptX2.toFixed(2);
      interceptX1 = Number(interceptX1);
      interceptX2 = Number(interceptX2);
      return [interceptX1, interceptX2];
    }

    return true;
  };

  function plotEquation(equation, color, thickness) {
    var _y = equation(modelObj.minX);

    context.moveTo(modelObj.minX, _y);
    var _lineArr = [];

    for (var _x = modelObj.minX + iteration; _x <= modelObj.maxX; _x += iteration) {
      _y = equation(_x);

      _lineArr.push({
        x: _x,
        y: _y
      });

      context.lineTo(_x, _y);
    }
  }

  this.addPoint = function (_x, _y, _color, _type) {
    var _exist = false;

    for (var i = 0; i < pointsArr.length; i++) {
      if (pointsArr[i].x === _x && pointsArr[i].y === _y && pointsArr[i].color === _color) {
        _exist = true;
      }
    }

    if (!_exist) {
      pointsArr.push({
        x: _x,
        y: _y,
        color: _color,
        type: _type
      });
      this.updateRender();
    }
  };

  this.plotPoint = function (ctx, _x, _y, color, type, visible) {
    ctx.save();
    _x = Number(_x);
    _y = Number(_y);
    ctx.beginPath();

    var point = _this.getPixelByPoint(_x, _y);

    point.x -= originalX;
    point.y -= originalY;
    var boolX = point.x > modelObj.x && point.x < modelObj.x + modelObj.width;
    var boolY = point.y > modelObj.y && point.y < modelObj.y + modelObj.height;

    if (boolX && boolY) {
      ctx.arc(point.x, point.y, modelObj.pointRadius, 0, 2 * Math.PI, false);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.font = modelObj.numberFontSize + "px " + modelObj.LabComClass.klettFontRegular;

      if (visible) {
        var xVal = Number(_x.toFixed(modelObj.decimalPoint)) === 0 ? 0 : Number(_x.toFixed(modelObj.decimalPoint));
        var yVal = Number(_y.toFixed(modelObj.decimalPoint)) === 0 ? 0 : Number(_y.toFixed(modelObj.decimalPoint));

        var _txt = "( " + xVal + ", " + yVal + " )";

        var _txtLen = ctx.measureText(_txt).width;
        point.x += 10;

        if (_x !== 0) {
          point.x -= _txtLen / 2 + 12;
        }

        if (_x === 0) {
          point.y += 10;
        }

        if (_y === 0 || _y > 0) {
          point.y -= 15;
        }

        if (_y < 0 && _x !== 0) {
          point.y += 20;
        }

        if (modelObj.showPointText) {
          ctx.beginPath();
          var gap = 5;
          ctx.fillStyle = "rgba(255,255,255,1)";
          ctx.rect(point.x - gap, point.y - (modelObj.fontsize - 2), _txtLen + gap * 2, modelObj.fontsize + 3);
          ctx.fill();
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fillText(_txt, point.x, point.y);
        }
      }
    }

    ctx.closePath();
    ctx.restore();
  };

  function transformContext(_ctx) {
    _ctx.translate(centerX, centerY);

    _ctx.scale(scaleX, -scaleY);
  } // =================================================


  this.setPanValues = function (_obj) {
    if (modelObj.panX) {
      modelObj.regX += _obj.x;
    }

    if (modelObj.panY) {
      modelObj.regY += _obj.y;
    }

    checkPanRestrictions();
  }; // =================================================
  // PRIVATE SECTION
  // =================================================

  /*
   * This function is used to save the Loaded Images.
   * @param _obj is of type Object. It contains all the image that are to be used.
   */


  function onImageLoaded(_obj) {
    imgObj = _obj;
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "componentLoaded",
      data: {
        id: modelObj.id
      }
    });
  } // =================================================

  /*
   * This function is used to add mouse events to the lab
   */


  function addEvents() {
    removeEvents();

    if (modelObj.visible) {
      var _eventDataObj = {};
      _eventDataObj.id = modelObj.id;
      _eventDataObj.r = [];

      if (modelObj.panX || modelObj.panY || modelObj.clickable || modelObj.arrowOnly) {
        _eventDataObj.r.push({
          id: "graphCnv",
          rect: {
            x: originalX,
            y: originalY,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: modelObj.clickable ? "pointer" : modelObj.arrowOnly ? "arrow" : "grab",
          downCursor: modelObj.clickable ? "pointer" : modelObj.arrowOnly ? "arrow" : "grabbing",
          eventListener: mouseHandle.bind(this)
        });
      } // onViewUpdateCls.trigger("onGlobalUpdate", {
      //   type: "addMouseEvent",
      //   data: _eventDataObj,
      // });

    }
  } // =================================================

  /*
   * This function is used to remove the mouse events.
   */


  function removeEvents() {
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "removeMouseEvent",
      data: {
        id: modelObj.id
      }
    });
  } // =================================================

  /*
   * This function is used to handle the mouse events of the Lab.
   * @param e is of type Object.It usually has 2 properties type and subId.
   */


  var mouseDownAt = {};

  function mouseHandle(e) {
    switch (e.type) {
      case "mousedown":
        mouseDown = true;
        _mouseDownPageX = e.pageX;
        _mouseDownPageY = e.pageY;
        mouseDownAt.x = e.pageX;
        mouseDownAt.y = e.pageY;
        mouseDownAt.mousemove = false;
        break;

      case "pressmove":
        if (mouseDown) {
          if (modelObj.panX || modelObj.panY) {
            changeGraphRange(e);
          }

          if (e.pageX !== mouseDownAt.x || e.pageY !== mouseDownAt.y) {
            mouseDownAt.mousemove = true;
          }
        }

        break;

      case "mouseup":
      case "mouseupout":
        mouseDown = false;
        addEvents();

        if (modelObj.clickable && mouseDownAt && typeof events.mouseDown !== "undefined" && modelObj.visible) {
          events.mouseDown({
            type: "mouseDown",
            x: mouseDownAt.x,
            y: mouseDownAt.y,
            mousemove: mouseDownAt.mousemove,
            val: _this.getPointByPixel(mouseDownAt.x, mouseDownAt.y)
          }, true);
        }

        break;

      default:
        break;
    } // event.preventDefault()

  } // =================================================


  function changeGraphRange(e) {
    if (modelObj.panX) {
      var _diffX = e.pageX - _mouseDownPageX;

      modelObj.regX += _diffX;
    }

    if (modelObj.panY) {
      var _diffY = e.pageY - _mouseDownPageY;

      modelObj.regY += _diffY;
    }

    _mouseDownPageX = e.pageX;
    _mouseDownPageY = e.pageY;
    checkPanRestrictions();
  }

  function checkPanRestrictions() {
    if (modelObj.panX) {
      var minPixelX = modelObj.minPanX * -1 * unitX;

      if (modelObj.sections.axis.xAxis.minPanInPixel !== null) {
        minPixelX = modelObj.sections.axis.xAxis.minPanInPixel;
      }

      var maxPixelX = modelObj.width - modelObj.maxPanX * unitX;

      if (modelObj.sections.axis.xAxis.maxPanInPixel !== null) {
        maxPixelX = modelObj.sections.axis.xAxis.maxPanInPixel;
      }

      if (modelObj.regX > minPixelX) {
        modelObj.regX = minPixelX;
      }

      if (modelObj.regX < maxPixelX) {
        modelObj.regX = maxPixelX;
      }
    }

    if (modelObj.panY) {
      var minPixelY = modelObj.minPanY * -1 * unitY;

      if (modelObj.sections.axis.yAxis.minPanInPixel !== null) {
        minPixelY = modelObj.sections.axis.yAxis.minPanInPixel;
      }

      var maxPixelY = modelObj.height - modelObj.maxPanY * unitY;

      if (modelObj.sections.axis.yAxis.maxPanInPixel !== null) {
        maxPixelY = modelObj.height - modelObj.sections.axis.yAxis.maxPanInPixel;
      }

      if (modelObj.regY > minPixelY) {
        modelObj.regY = minPixelY;
      }

      if (modelObj.regY < maxPixelY) {
        modelObj.regY = maxPixelY;
      }
    }

    updateZoomValues();
  } // =================================================

  /*
   * This function is used to update the Lab with the Updated Value
   */


  function onActValueUpdate() {
    if (typeof events.change !== "undefined") {
      events.change({
        type: "change"
      }, true);
    }
  }

  this.init();
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function PanelCompClass(_obj) {
  var modelObj = {
    visible: true
  };
  var events = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------

  setDefaultValues(); // --------------------

  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.show = function () {
    modelObj.visible = true;
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
  }; // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================
  // =================================================


  this.draw = function () {}; // =================================================
  // PRIVATE SECTION
  // =================================================


  function setDefaultValues() {
    modelObj.LabComClass.setHeader(modelObj.LabComClass.globalLangText[modelObj.headText]);
  }
}
/*! howler.js v2.0.4 | (c) 2013-2017, James Simpson of GoldFire Studios | MIT License | howlerjs.com */
!function(){"use strict";var e=function(){this.init()};e.prototype={init:function(){var e=this||n;return e._counter=1e3,e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.mobileAutoEnable=!0,e._setup(),e},volume:function(e){var o=this||n;if(e=parseFloat(e),o.ctx||_(),void 0!==e&&e>=0&&e<=1){if(o._volume=e,o._muted)return o;o.usingWebAudio&&(o.masterGain.gain.value=e);for(var t=0;t<o._howls.length;t++)if(!o._howls[t]._webAudio)for(var r=o._howls[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._howls[t]._soundById(r[a]);u&&u._node&&(u._node.volume=u._volume*e)}return o}return o._volume},mute:function(e){var o=this||n;o.ctx||_(),o._muted=e,o.usingWebAudio&&(o.masterGain.gain.value=e?0:o._volume);for(var t=0;t<o._howls.length;t++)if(!o._howls[t]._webAudio)for(var r=o._howls[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._howls[t]._soundById(r[a]);u&&u._node&&(u._node.muted=!!e||u._muted)}return o},unload:function(){for(var e=this||n,o=e._howls.length-1;o>=0;o--)e._howls[o].unload();return e.usingWebAudio&&e.ctx&&void 0!==e.ctx.close&&(e.ctx.close(),e.ctx=null,_()),e},codecs:function(e){return(this||n)._codecs[e.replace(/^x-/,"")]},_setup:function(){var e=this||n;if(e.state=e.ctx?e.ctx.state||"running":"running",e._autoSuspend(),!e.usingWebAudio)if("undefined"!=typeof Audio)try{var o=new Audio;void 0===o.oncanplaythrough&&(e._canPlayEvent="canplay")}catch(n){e.noAudio=!0}else e.noAudio=!0;try{var o=new Audio;o.muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||n,o=null;try{o="undefined"!=typeof Audio?new Audio:null}catch(n){return e}if(!o||"function"!=typeof o.canPlayType)return e;var t=o.canPlayType("audio/mpeg;").replace(/^no$/,""),r=e._navigator&&e._navigator.userAgent.match(/OPR\/([0-6].)/g),a=r&&parseInt(r[0].split("/")[1],10)<33;return e._codecs={mp3:!(a||!t&&!o.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!t,opus:!!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!o.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),aac:!!o.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!o.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(o.canPlayType("audio/x-m4a;")||o.canPlayType("audio/m4a;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(o.canPlayType("audio/x-mp4;")||o.canPlayType("audio/mp4;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),webm:!!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),dolby:!!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(o.canPlayType("audio/x-flac;")||o.canPlayType("audio/flac;")).replace(/^no$/,"")},e},_enableMobileAudio:function(){var e=this||n,o=/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator&&e._navigator.userAgent),t=!!("ontouchend"in window||e._navigator&&e._navigator.maxTouchPoints>0||e._navigator&&e._navigator.msMaxTouchPoints>0);if(!e._mobileEnabled&&e.ctx&&(o||t)){e._mobileEnabled=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var r=function(){n._autoResume();var o=e.ctx.createBufferSource();o.buffer=e._scratchBuffer,o.connect(e.ctx.destination),void 0===o.start?o.noteOn(0):o.start(0),"function"==typeof e.ctx.resume&&e.ctx.resume(),o.onended=function(){o.disconnect(0),e._mobileEnabled=!0,e.mobileAutoEnable=!1,document.removeEventListener("touchend",r,!0)}};return document.addEventListener("touchend",r,!0),e}},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&void 0!==e.ctx.suspend&&n.usingWebAudio){for(var o=0;o<e._howls.length;o++)if(e._howls[o]._webAudio)for(var t=0;t<e._howls[o]._sounds.length;t++)if(!e._howls[o]._sounds[t]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout(function(){e.autoSuspend&&(e._suspendTimer=null,e.state="suspending",e.ctx.suspend().then(function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())}))},3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&void 0!==e.ctx.resume&&n.usingWebAudio)return"running"===e.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state?(e.ctx.resume().then(function(){e.state="running";for(var n=0;n<e._howls.length;n++)e._howls[n]._emit("resume")}),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};var n=new e,o=function(e){var n=this;if(!e.src||0===e.src.length)return void console.error("An array of source files must be passed with any new Howl.");n.init(e)};o.prototype={init:function(e){var o=this;return n.ctx||_(),o._autoplay=e.autoplay||!1,o._format="string"!=typeof e.format?e.format:[e.format],o._html5=e.html5||!1,o._muted=e.mute||!1,o._loop=e.loop||!1,o._pool=e.pool||5,o._preload="boolean"!=typeof e.preload||e.preload,o._rate=e.rate||1,o._sprite=e.sprite||{},o._src="string"!=typeof e.src?e.src:[e.src],o._volume=void 0!==e.volume?e.volume:1,o._duration=0,o._state="unloaded",o._sounds=[],o._endTimers={},o._queue=[],o._onend=e.onend?[{fn:e.onend}]:[],o._onfade=e.onfade?[{fn:e.onfade}]:[],o._onload=e.onload?[{fn:e.onload}]:[],o._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],o._onpause=e.onpause?[{fn:e.onpause}]:[],o._onplay=e.onplay?[{fn:e.onplay}]:[],o._onstop=e.onstop?[{fn:e.onstop}]:[],o._onmute=e.onmute?[{fn:e.onmute}]:[],o._onvolume=e.onvolume?[{fn:e.onvolume}]:[],o._onrate=e.onrate?[{fn:e.onrate}]:[],o._onseek=e.onseek?[{fn:e.onseek}]:[],o._onresume=[],o._webAudio=n.usingWebAudio&&!o._html5,void 0!==n.ctx&&n.ctx&&n.mobileAutoEnable&&n._enableMobileAudio(),n._howls.push(o),o._autoplay&&o._queue.push({event:"play",action:function(){o.play()}}),o._preload&&o.load(),o},load:function(){var e=this,o=null;if(n.noAudio)return void e._emit("loaderror",null,"No audio support.");"string"==typeof e._src&&(e._src=[e._src]);for(var r=0;r<e._src.length;r++){var u,i;if(e._format&&e._format[r])u=e._format[r];else{if("string"!=typeof(i=e._src[r])){e._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}u=/^data:audio\/([^;,]+);/i.exec(i),u||(u=/\.([^.]+)$/.exec(i.split("?",1)[0])),u&&(u=u[1].toLowerCase())}if(u||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),u&&n.codecs(u)){o=e._src[r];break}}return o?(e._src=o,e._state="loading","https:"===window.location.protocol&&"http:"===o.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new t(e),e._webAudio&&a(e),e):void e._emit("loaderror",null,"No codec support for selected audio sources.")},play:function(e,o){var t=this,r=null;if("number"==typeof e)r=e,e=null;else{if("string"==typeof e&&"loaded"===t._state&&!t._sprite[e])return null;if(void 0===e){e="__default";for(var a=0,u=0;u<t._sounds.length;u++)t._sounds[u]._paused&&!t._sounds[u]._ended&&(a++,r=t._sounds[u]._id);1===a?e=null:r=null}}var i=r?t._soundById(r):t._inactiveSound();if(!i)return null;if(r&&!e&&(e=i._sprite||"__default"),"loaded"!==t._state){i._sprite=e,i._ended=!1;var d=i._id;return t._queue.push({event:"play",action:function(){t.play(d)}}),d}if(r&&!i._paused)return o||setTimeout(function(){t._emit("play",i._id)},0),i._id;t._webAudio&&n._autoResume();var _=Math.max(0,i._seek>0?i._seek:t._sprite[e][0]/1e3),s=Math.max(0,(t._sprite[e][0]+t._sprite[e][1])/1e3-_),l=1e3*s/Math.abs(i._rate);i._paused=!1,i._ended=!1,i._sprite=e,i._seek=_,i._start=t._sprite[e][0]/1e3,i._stop=(t._sprite[e][0]+t._sprite[e][1])/1e3,i._loop=!(!i._loop&&!t._sprite[e][2]);var c=i._node;if(t._webAudio){var f=function(){t._refreshBuffer(i);var e=i._muted||t._muted?0:i._volume;c.gain.setValueAtTime(e,n.ctx.currentTime),i._playStart=n.ctx.currentTime,void 0===c.bufferSource.start?i._loop?c.bufferSource.noteGrainOn(0,_,86400):c.bufferSource.noteGrainOn(0,_,s):i._loop?c.bufferSource.start(0,_,86400):c.bufferSource.start(0,_,s),l!==1/0&&(t._endTimers[i._id]=setTimeout(t._ended.bind(t,i),l)),o||setTimeout(function(){t._emit("play",i._id)},0)},p="running"===n.state;if("loaded"===t._state&&p)f();else{var v=p||"loaded"!==t._state?"load":"resume";t.once(v,f,p?i._id:null),t._clearTimer(i._id)}}else{var m=function(){c.currentTime=_,c.muted=i._muted||t._muted||n._muted||c.muted,c.volume=i._volume*n.volume(),c.playbackRate=i._rate,c.play(),l!==1/0&&(t._endTimers[i._id]=setTimeout(t._ended.bind(t,i),l)),o||t._emit("play",i._id)},h="loaded"===t._state&&(window&&window.ejecta||!c.readyState&&n._navigator.isCocoonJS);if(4===c.readyState||h)m();else{var g=function(){m(),c.removeEventListener(n._canPlayEvent,g,!1)};c.addEventListener(n._canPlayEvent,g,!1),t._clearTimer(i._id)}}return i._id},pause:function(e){var n=this;if("loaded"!==n._state)return n._queue.push({event:"pause",action:function(){n.pause(e)}}),n;for(var o=n._getSoundIds(e),t=0;t<o.length;t++){n._clearTimer(o[t]);var r=n._soundById(o[t]);if(r&&!r._paused&&(r._seek=n.seek(o[t]),r._rateSeek=0,r._paused=!0,n._stopFade(o[t]),r._node))if(n._webAudio){if(!r._node.bufferSource)continue;void 0===r._node.bufferSource.stop?r._node.bufferSource.noteOff(0):r._node.bufferSource.stop(0),n._cleanBuffer(r._node)}else isNaN(r._node.duration)&&r._node.duration!==1/0||r._node.pause();arguments[1]||n._emit("pause",r?r._id:null)}return n},stop:function(e,n){var o=this;if("loaded"!==o._state)return o._queue.push({event:"stop",action:function(){o.stop(e)}}),o;for(var t=o._getSoundIds(e),r=0;r<t.length;r++){o._clearTimer(t[r]);var a=o._soundById(t[r]);a&&(a._seek=a._start||0,a._rateSeek=0,a._paused=!0,a._ended=!0,o._stopFade(t[r]),a._node&&(o._webAudio?a._node.bufferSource&&(void 0===a._node.bufferSource.stop?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),o._cleanBuffer(a._node)):isNaN(a._node.duration)&&a._node.duration!==1/0||(a._node.currentTime=a._start||0,a._node.pause())),n||o._emit("stop",a._id))}return o},mute:function(e,o){var t=this;if("loaded"!==t._state)return t._queue.push({event:"mute",action:function(){t.mute(e,o)}}),t;if(void 0===o){if("boolean"!=typeof e)return t._muted;t._muted=e}for(var r=t._getSoundIds(o),a=0;a<r.length;a++){var u=t._soundById(r[a]);u&&(u._muted=e,t._webAudio&&u._node?u._node.gain.setValueAtTime(e?0:u._volume,n.ctx.currentTime):u._node&&(u._node.muted=!!n._muted||e),t._emit("mute",u._id))}return t},volume:function(){var e,o,t=this,r=arguments;if(0===r.length)return t._volume;if(1===r.length||2===r.length&&void 0===r[1]){t._getSoundIds().indexOf(r[0])>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else r.length>=2&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var a;if(!(void 0!==e&&e>=0&&e<=1))return a=o?t._soundById(o):t._sounds[0],a?a._volume:0;if("loaded"!==t._state)return t._queue.push({event:"volume",action:function(){t.volume.apply(t,r)}}),t;void 0===o&&(t._volume=e),o=t._getSoundIds(o);for(var u=0;u<o.length;u++)(a=t._soundById(o[u]))&&(a._volume=e,r[2]||t._stopFade(o[u]),t._webAudio&&a._node&&!a._muted?a._node.gain.setValueAtTime(e,n.ctx.currentTime):a._node&&!a._muted&&(a._node.volume=e*n.volume()),t._emit("volume",a._id));return t},fade:function(e,o,t,r){var a=this,u=Math.abs(e-o),i=e>o?"out":"in",d=u/.01,_=d>0?t/d:t;if(_<4&&(d=Math.ceil(d/(4/_)),_=4),"loaded"!==a._state)return a._queue.push({event:"fade",action:function(){a.fade(e,o,t,r)}}),a;a.volume(e,r);for(var s=a._getSoundIds(r),l=0;l<s.length;l++){var c=a._soundById(s[l]);if(c){if(r||a._stopFade(s[l]),a._webAudio&&!c._muted){var f=n.ctx.currentTime,p=f+t/1e3;c._volume=e,c._node.gain.setValueAtTime(e,f),c._node.gain.linearRampToValueAtTime(o,p)}var v=e;c._interval=setInterval(function(n,t){d>0&&(v+="in"===i?.01:-.01),v=Math.max(0,v),v=Math.min(1,v),v=Math.round(100*v)/100,a._webAudio?(void 0===r&&(a._volume=v),t._volume=v):a.volume(v,n,!0),(o<e&&v<=o||o>e&&v>=o)&&(clearInterval(t._interval),t._interval=null,a.volume(o,n),a._emit("fade",n))}.bind(a,s[l],c),_)}}return a},_stopFade:function(e){var o=this,t=o._soundById(e);return t&&t._interval&&(o._webAudio&&t._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(t._interval),t._interval=null,o._emit("fade",e)),o},loop:function(){var e,n,o,t=this,r=arguments;if(0===r.length)return t._loop;if(1===r.length){if("boolean"!=typeof r[0])return!!(o=t._soundById(parseInt(r[0],10)))&&o._loop;e=r[0],t._loop=e}else 2===r.length&&(e=r[0],n=parseInt(r[1],10));for(var a=t._getSoundIds(n),u=0;u<a.length;u++)(o=t._soundById(a[u]))&&(o._loop=e,t._webAudio&&o._node&&o._node.bufferSource&&(o._node.bufferSource.loop=e,e&&(o._node.bufferSource.loopStart=o._start||0,o._node.bufferSource.loopEnd=o._stop)));return t},rate:function(){var e,o,t=this,r=arguments;if(0===r.length)o=t._sounds[0]._id;else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var i;if("number"!=typeof e)return i=t._soundById(o),i?i._rate:t._rate;if("loaded"!==t._state)return t._queue.push({event:"rate",action:function(){t.rate.apply(t,r)}}),t;void 0===o&&(t._rate=e),o=t._getSoundIds(o);for(var d=0;d<o.length;d++)if(i=t._soundById(o[d])){i._rateSeek=t.seek(o[d]),i._playStart=t._webAudio?n.ctx.currentTime:i._playStart,i._rate=e,t._webAudio&&i._node&&i._node.bufferSource?i._node.bufferSource.playbackRate.value=e:i._node&&(i._node.playbackRate=e);var _=t.seek(o[d]),s=(t._sprite[i._sprite][0]+t._sprite[i._sprite][1])/1e3-_,l=1e3*s/Math.abs(i._rate);!t._endTimers[o[d]]&&i._paused||(t._clearTimer(o[d]),t._endTimers[o[d]]=setTimeout(t._ended.bind(t,i),l)),t._emit("rate",i._id)}return t},seek:function(){var e,o,t=this,r=arguments;if(0===r.length)o=t._sounds[0]._id;else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):(o=t._sounds[0]._id,e=parseFloat(r[0]))}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));if(void 0===o)return t;if("loaded"!==t._state)return t._queue.push({event:"seek",action:function(){t.seek.apply(t,r)}}),t;var i=t._soundById(o);if(i){if(!("number"==typeof e&&e>=0)){if(t._webAudio){var d=t.playing(o)?n.ctx.currentTime-i._playStart:0,_=i._rateSeek?i._rateSeek-i._seek:0;return i._seek+(_+d*Math.abs(i._rate))}return i._node.currentTime}var s=t.playing(o);s&&t.pause(o,!0),i._seek=e,i._ended=!1,t._clearTimer(o),s&&t.play(o,!0),!t._webAudio&&i._node&&(i._node.currentTime=e),t._emit("seek",o)}return t},playing:function(e){var n=this;if("number"==typeof e){var o=n._soundById(e);return!!o&&!o._paused}for(var t=0;t<n._sounds.length;t++)if(!n._sounds[t]._paused)return!0;return!1},duration:function(e){var n=this,o=n._duration,t=n._soundById(e);return t&&(o=n._sprite[t._sprite][1]/1e3),o},state:function(){return this._state},unload:function(){for(var e=this,o=e._sounds,t=0;t<o.length;t++){if(o[t]._paused||e.stop(o[t]._id),!e._webAudio){/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent)||(o[t]._node.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"),o[t]._node.removeEventListener("error",o[t]._errorFn,!1),o[t]._node.removeEventListener(n._canPlayEvent,o[t]._loadFn,!1)}delete o[t]._node,e._clearTimer(o[t]._id);var a=n._howls.indexOf(e);a>=0&&n._howls.splice(a,1)}var u=!0;for(t=0;t<n._howls.length;t++)if(n._howls[t]._src===e._src){u=!1;break}return r&&u&&delete r[e._src],n.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},on:function(e,n,o,t){var r=this,a=r["_on"+e];return"function"==typeof n&&a.push(t?{id:o,fn:n,once:t}:{id:o,fn:n}),r},off:function(e,n,o){var t=this,r=t["_on"+e],a=0;if("number"==typeof n&&(o=n,n=null),n||o)for(a=0;a<r.length;a++){var u=o===r[a].id;if(n===r[a].fn&&u||!n&&u){r.splice(a,1);break}}else if(e)t["_on"+e]=[];else{var i=Object.keys(t);for(a=0;a<i.length;a++)0===i[a].indexOf("_on")&&Array.isArray(t[i[a]])&&(t[i[a]]=[])}return t},once:function(e,n,o){var t=this;return t.on(e,n,o,1),t},_emit:function(e,n,o){for(var t=this,r=t["_on"+e],a=r.length-1;a>=0;a--)r[a].id&&r[a].id!==n&&"load"!==e||(setTimeout(function(e){e.call(this,n,o)}.bind(t,r[a].fn),0),r[a].once&&t.off(e,r[a].fn,r[a].id));return t},_loadQueue:function(){var e=this;if(e._queue.length>0){var n=e._queue[0];e.once(n.event,function(){e._queue.shift(),e._loadQueue()}),n.action()}return e},_ended:function(e){var o=this,t=e._sprite;if(!o._webAudio&&o._node&&!o._node.ended)return setTimeout(o._ended.bind(o,e),100),o;var r=!(!e._loop&&!o._sprite[t][2]);if(o._emit("end",e._id),!o._webAudio&&r&&o.stop(e._id,!0).play(e._id),o._webAudio&&r){o._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=n.ctx.currentTime;var a=1e3*(e._stop-e._start)/Math.abs(e._rate);o._endTimers[e._id]=setTimeout(o._ended.bind(o,e),a)}return o._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,o._clearTimer(e._id),o._cleanBuffer(e._node),n._autoSuspend()),o._webAudio||r||o.stop(e._id),o},_clearTimer:function(e){var n=this;return n._endTimers[e]&&(clearTimeout(n._endTimers[e]),delete n._endTimers[e]),n},_soundById:function(e){for(var n=this,o=0;o<n._sounds.length;o++)if(e===n._sounds[o]._id)return n._sounds[o];return null},_inactiveSound:function(){var e=this;e._drain();for(var n=0;n<e._sounds.length;n++)if(e._sounds[n]._ended)return e._sounds[n].reset();return new t(e)},_drain:function(){var e=this,n=e._pool,o=0,t=0;if(!(e._sounds.length<n)){for(t=0;t<e._sounds.length;t++)e._sounds[t]._ended&&o++;for(t=e._sounds.length-1;t>=0;t--){if(o<=n)return;e._sounds[t]._ended&&(e._webAudio&&e._sounds[t]._node&&e._sounds[t]._node.disconnect(0),e._sounds.splice(t,1),o--)}}},_getSoundIds:function(e){var n=this;if(void 0===e){for(var o=[],t=0;t<n._sounds.length;t++)o.push(n._sounds[t]._id);return o}return[e]},_refreshBuffer:function(e){var o=this;return e._node.bufferSource=n.ctx.createBufferSource(),e._node.bufferSource.buffer=r[o._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop),e._node.bufferSource.playbackRate.value=e._rate,o},_cleanBuffer:function(e){var n=this;if(n._scratchBuffer){e.bufferSource.onended=null,e.bufferSource.disconnect(0);try{e.bufferSource.buffer=n._scratchBuffer}catch(e){}}return e.bufferSource=null,n}};var t=function(e){this._parent=e,this.init()};t.prototype={init:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,o._sounds.push(e),e.create(),e},create:function(){var e=this,o=e._parent,t=n._muted||e._muted||e._parent._muted?0:e._volume;return o._webAudio?(e._node=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),e._node.gain.setValueAtTime(t,n.ctx.currentTime),e._node.paused=!0,e._node.connect(n.masterGain)):(e._node=new Audio,e._errorFn=e._errorListener.bind(e),e._node.addEventListener("error",e._errorFn,!1),e._loadFn=e._loadListener.bind(e),e._node.addEventListener(n._canPlayEvent,e._loadFn,!1),e._node.src=o._src,e._node.preload="auto",e._node.volume=t*n.volume(),e._node.load()),e},reset:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,e},_errorListener:function(){var e=this;e._parent._emit("loaderror",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener("error",e._errorFn,!1)},_loadListener:function(){var e=this,o=e._parent;o._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(o._sprite).length&&(o._sprite={__default:[0,1e3*o._duration]}),"loaded"!==o._state&&(o._state="loaded",o._emit("load"),o._loadQueue()),e._node.removeEventListener(n._canPlayEvent,e._loadFn,!1)}};var r={},a=function(e){var n=e._src;if(r[n])return e._duration=r[n].duration,void d(e);if(/^data:[^;]+;base64,/.test(n)){for(var o=atob(n.split(",")[1]),t=new Uint8Array(o.length),a=0;a<o.length;++a)t[a]=o.charCodeAt(a);i(t.buffer,e)}else{var _=new XMLHttpRequest;_.open("GET",n,!0),_.responseType="arraybuffer",_.onload=function(){var n=(_.status+"")[0];if("0"!==n&&"2"!==n&&"3"!==n)return void e._emit("loaderror",null,"Failed loading audio file with status: "+_.status+".");i(_.response,e)},_.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete r[n],e.load())},u(_)}},u=function(e){try{e.send()}catch(n){e.onerror()}},i=function(e,o){n.ctx.decodeAudioData(e,function(e){e&&o._sounds.length>0&&(r[o._src]=e,d(o,e))},function(){o._emit("loaderror",null,"Decoding audio data failed.")})},d=function(e,n){n&&!e._duration&&(e._duration=n.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},_=function(){try{"undefined"!=typeof AudioContext?n.ctx=new AudioContext:"undefined"!=typeof webkitAudioContext?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch(e){n.usingWebAudio=!1}var e=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),o=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),t=o?parseInt(o[1],10):null;if(e&&t&&t<9){var r=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());(n._navigator&&n._navigator.standalone&&!r||n._navigator&&!n._navigator.standalone&&!r)&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.value=n._muted?0:1,n.masterGain.connect(n.ctx.destination)),n._setup()};"function"==typeof define&&define.amd&&define([],function(){return{Howler:n,Howl:o}}),"undefined"!=typeof exports&&(exports.Howler=n,exports.Howl=o),"undefined"!=typeof window?(window.HowlerGlobal=e,window.Howler=n,window.Howl=o,window.Sound=t):"undefined"!=typeof global&&(global.HowlerGlobal=e,global.Howler=n,global.Howl=o,global.Sound=t)}();
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
// interactionType can be either of "point", "segment", "line", "circle".
function GeoDrawClass(_obj) {
  var events = {};
  var scaleObj = {
    x: 0,
    y: 0,
    xTo: 200,
    yTo: 200,
    pointColor: "#0892AA",
    pointRadius: 7,
    segmentColor: "#0892AA",
    segmentWidth: 3,
    visible: false
  };
  var modelObj = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    bgColor: "rgba(255, 255, 255, 0.5)",
    state: true,
    visible: true,
    interactionType: "",
    interactionElements: [],
    pointColor: "#0892AA",
    pointLabelColor: "rgba(51,51,51,1)",
    lengthLabelColor: "rgba(51,51,51,1)",
    pointRadius: 5,
    segmentColor: "#0892AA",
    segmentWidth: 2,
    tempElements: [],
    transperent: false,
    eventsEnable: true,
    fontSize: 20,
    currentStep: 0,
    snapToGrid: false,
    snappingDiff: 10,
    // in pixel,
    deviceSnappingDiff: 25,
    shapesEditable: false,
    undoRedo: false,
    pointSnapping: true,
    finalColor: "rgba(65,180,5,1)",
    screen: {},
    labelBGRatio: 1,
    waiting: false,
    shapes: {
      length: {
        digit: 0,
        onlyDistance: false
      },
      point: {
        label: {
          visible: true
        }
      },
      square: {
        label: {
          visible: true
        },
        fill: true
      },
      circle: {
        digit: 0,
        circleDistanceLabel: true
      },
      line: {
        color: {
          stroke: "#0892AA"
        }
      },
      brush1: {
        color: {
          stroke: "#0892AA"
        }
      },
      brush2: {
        color: {
          stroke: "rgba(222,108,225,1)"
        }
      },
      brush3: {
        color: {
          stroke: "rgba(255,204,0,1)"
        }
      },
      segment: {
        color: {
          stroke: "#0892AA"
        },
        label: {
          visible: false
        },
        segDistanceLabel: false,
        digit: 1
      },
      angle: {
        dotOn90: true
      },
      angleSize: {
        dotOn90: true
      }
    }
  };
  var localObj = {
    mouseDown: {
      isMouseDown: false,
      lastShapeCompleted: true
    },
    uniqueId: 0,
    currentUniqueId: 0,
    allShapesData: [],
    tempData: [],
    mouseDownData: null,
    isDevice: false,
    newPlottedShapes: [],
    lineTypes: ["line", "ray", "perpendicularLine", "parallelLine", "segment", "segmentDash"],
    isLableSelected: false,
    arbitaryX: 1,
    plotPointOnExistingPoint: false
  };

  var _this = this;

  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === "object" && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === "object" && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  }

  modelObj.centerX = modelObj.x + modelObj.width / 2;
  modelObj.centerY = modelObj.y + modelObj.height / 2;
  setScaleValues();
  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass();
  localObj.isDevice = modelObj.LabComClass.BrowserDetect.isDevice();

  if (localObj.isDevice) {
    modelObj.snappingDiff = modelObj.deviceSnappingDiff;
  } // addEvents();


  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.alpha = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.setTransperent = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.setLengthLabelColor = function (_color) {
    modelObj.lengthLabelColor = _color;
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  }; // =================================================


  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    addEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  };

  this.editable = function (flag) {
    modelObj.shapesEditable = flag;
    return modelObj.shapesEditable;
  };

  this.selectAll = function (_flag) {
    modelObj.interactionElements.forEach(function (item) {
      item.isSelected = _flag;
    });
  };

  this.snapToGrid = function (_flag) {
    modelObj.snapToGrid = _flag;
  };

  this.redoPossible = function () {
    return localObj.tempData.length !== 0;
  };

  this.setFinalView = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.finalView = _flag;
  };

  this.setPointSnapping = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.pointSnapping = _flag;
  };

  this.setStyle = function (uniqueId, _obj) {
    var styleApproved = {
      strokeColor: true,
      fillColor: true
    };
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        if (styleApproved[i]) {
          shape.shape[i] = _obj[i];
        }
      });
    }
  };

  this.deleteSelected = function () {
    if (modelObj.shapesEditable) {
      var selectedIds = [];
      modelObj.interactionElements.forEach(function (item) {
        if (item.isSelected && (item.isDeletable === undefined || item.isDeletable)) {
          selectedIds.push(item.uniqueId);
        }
      });
      removeShapes(selectedIds);
    }
  };

  this.setScaleDefaultPos = function (x1, y1, x2, y2) {
    var updateScalePos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    scaleObj.originPos = {
      x: x1,
      y: y1,
      xTo: x2,
      yTo: y2
    };

    if (updateScalePos) {
      scaleObj.x = scaleObj.originPos.x;
      scaleObj.y = scaleObj.originPos.y;
      scaleObj.xTo = scaleObj.originPos.xTo;
      scaleObj.yTo = scaleObj.originPos.yTo;
    }
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  };

  this.getStep = function () {
    return modelObj.currentStep;
  }; // =================================================


  this.showDrawing = function (_arr, _bool) {
    if (typeof _arr !== "undefined" && _arr !== null) {
      _arr.forEach(function (item) {
        if (typeof item !== "undefined") {
          item.visible = _bool;
        }
      });
    }
  }; // =================================================


  this.setInteractionType = function (_type) {
    if (typeof _type !== "undefined") {
      if (modelObj.interactionType !== _type) {
        modelObj.interactionType = _type;
        clearCache();
        addEvents();
      }
    }
  };

  this.getInteractionType = function () {
    return modelObj.interactionType;
  };

  this.setStep = function (_step) {
    if (modelObj.currentStep > _step) {
      removeShapes(modelObj.interactionElements.filter(function (e) {
        return e.step > _step;
      }).map(function (e) {
        return e.uniqueId;
      }));
    }

    modelObj.currentStep = _step;
  };

  this.setSegmentDistanceLabel = function (_flag) {
    modelObj.shapes.segment.segDistanceLabel = _flag;
  };

  this.getCount = function () {
    return modelObj.interactionElements.length;
  };

  this.getData = function () {
    return {
      visible: JSON.parse(JSON.stringify(modelObj.interactionElements)),
      nonVisible: modelObj.tempElements
    };
  };

  this.setWaiting = function (_bool) {
    modelObj.waiting = _bool;
  };

  this.getWaiting = function () {
    return modelObj.waiting;
  };

  this.setScreenData = function (_obj) {
    modelObj.graphValues = _obj;
    modelObj.x = _obj.x;
    modelObj.y = _obj.y;
    modelObj.width = _obj.width;
    modelObj.height = _obj.height;
    modelObj.screen = _obj.screen;
    modelObj.centerX = _obj.originX;
    modelObj.centerY = _obj.originY;
    modelObj.showQuadrants = _obj.showQuadrants;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var shape = modelObj.interactionElements[i];

      if ((shape.type === "line" || shape.type === "ray") && shape.label) {
        var pos = findLableByLine(shape, {
          x: shape.xTo,
          y: shape.yTo
        });
        shape.labelX = pos.x;
        shape.labelY = pos.y;
      }
    }

    setScaleValues();
    updateAllShapes();
    addEvents();
  };

  function addAngleSize(_obj, drawNewShape) {
    if (!modelObj.waiting) {
      localObj.newPlottedShapes = [];
      var angleSize = {
        type: "angleSize",
        uniqueId: ++localObj.uniqueId,
        x: 0,
        y: 0,
        xTo: 0,
        yTo: 0,
        degree: 0,
        clockwise: true,
        connectionId: []
      };
      var rayId = ++localObj.uniqueId;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var angle = modelObj.LabComClass.Maths.getAngle(angleSize.x, angleSize.y, angleSize.xTo, angleSize.yTo);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(angleSize, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + "°";
      }

      if (angleSize.labelX === undefined) {
        var angleTextPos = modelObj.LabComClass.Maths.getPoint(angleSize, angle + _obj.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleTextPos.x;
        angleSize.labelY = angleTextPos.y;
        angleSize.labelDiffX = angleSize.labelDiffX !== undefined ? angleSize.labelDiffX : 0;
        angleSize.labelDiffY = angleSize.labelDiffY !== undefined ? angleSize.labelDiffY : 0;
      }

      var newAngleSize = addNewShape(angleSize, drawNewShape);
      localObj.newPlottedShapes.push(angleSize.uniqueId);
      var ray = addNewShape({
        type: "ray",
        uniqueId: rayId,
        x: angleSize.x,
        y: angleSize.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        connectionId: []
      }, drawNewShape);
      localObj.newPlottedShapes.push(rayId);
      updateLinePoints(ray);
      angleSize.connectionId.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;
      return {
        angleSize: newAngleSize,
        ray: ray
      };
    }
  }

  this.plotAngleSize = function (_obj) {
    var drawNewShape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return addAngleSize(_obj, drawNewShape);
  };

  this.setAngleSize = function (shape) {
    var _obj = JSON.parse(JSON.stringify(shape));

    if (_obj && !_obj.uniqueId) {
      var AngleWithRay = addAngleSize(_obj);
      dispatchData(AngleWithRay.angleSize, true);
    }

    if (modelObj.waiting) {
      var rayId = ++localObj.uniqueId;
      var angleSize = findShape(_obj.uniqueId).shape;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var firstPoint = findShape(_obj.firstPointId).shape;
      var angle = modelObj.LabComClass.Maths.getAngle(_obj.x, _obj.y, firstPoint.x, firstPoint.y);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + "°";
      }

      if (angleSize.labelX === undefined) {
        var angleText = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleText.x;
        angleSize.labelY = angleText.y;
        angleSize.labelDiffX = 0;
        angleSize.labelDiffY = 0;
      }

      var newShape = addNewShape({
        type: "ray",
        uniqueId: rayId,
        firstPointId: _obj.secondPointId,
        x: _obj.x,
        y: _obj.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        connectionId: [_obj.secondPointId]
      });
      updateLinePoints(newShape);
      angleSize.connectionId.push(rayId);
      localObj.newPlottedShapes.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fpShape = findShape(angleSize.firstPointId).shape;
      fpShape.isSelected = false;
      var spShape = findShape(angleSize.secondPointId).shape;

      if (spShape) {
        spShape.isSelected = false;
      }

      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  this.setSegSize = function (_obj) {
    if (modelObj.waiting) {
      var segmentId = ++localObj.uniqueId;
      var secondPointId = ++localObj.uniqueId;
      var segSize = findShape(_obj.uniqueId).shape;
      var firstPoint = findShape(segSize.firstPointId).shape;
      addNewShape({
        type: "segment",
        uniqueId: segmentId,
        x: _obj.x,
        y: _obj.y,
        xTo: _obj.x + _obj.distance,
        yTo: _obj.y,
        connectionId: [_obj.firstPointId, secondPointId]
      });
      addNewShape({
        type: "point",
        uniqueId: secondPointId,
        x: _obj.x + _obj.distance,
        y: _obj.y,
        connectionId: [segmentId]
      });
      segSize.connectionId.push(segmentId);
      segSize.connectionId.push(secondPointId);
      segSize.secondPointId = secondPointId;
      localObj.newPlottedShapes.push(segmentId);
      localObj.newPlottedShapes.push(secondPointId);
      segSize.segmentId = segmentId;
      segSize.distance = _obj.distance;
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fp = findShape(segSize.firstPointId).shape;
      fp.isSelected = false;
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  this.setCircleSize = function (_obj) {
    if (modelObj.waiting) {
      var circleId = ++localObj.uniqueId;
      var circleSize = findShape(_obj.uniqueId).shape;
      var firstPoint = findShape(circleSize.firstPointId).shape;
      addNewShape({
        type: "circle",
        uniqueId: circleId,
        x: _obj.x,
        y: _obj.y,
        r: _obj.distance,
        connectionId: [_obj.firstPointId]
      });
      circleSize.connectionId.push(circleId);
      localObj.newPlottedShapes.push(circleId);
      circleSize.circleId = circleId;
      circleSize.r = _obj.distance;
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fp = findShape(circleSize.firstPointId).shape;
      fp.isSelected = false;
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  function getPointByPixel(_x, _y) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = (_x - _g.originX) / _g.unitX;
    pointY = -1 * (_y - _g.originY) / _g.unitY;
    return {
      x: pointX,
      y: pointY
    };
  }

  function getPixelByPoint(valueX, valueY) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = valueX * _g.unitX + _g.originX;
    pointY = valueY * _g.unitY / -1 + _g.originY;
    return {
      x: pointX,
      y: pointY
    };
  }

  function getPointUnitByPixelUnit(_pixelUnit) {
    return _pixelUnit / modelObj.graphValues.unitX;
  }

  function getPixelUnitByPointUnit(_pointUnit) {
    return _pointUnit * modelObj.graphValues.unitX;
  }

  this.setData = function (_data) {
    if (_data.visible !== undefined) {
      modelObj.interactionElements = JSON.parse(JSON.stringify(_data.visible));
    }

    if (_data.nonVisible !== undefined) {
      modelObj.tempElements = JSON.parse(JSON.stringify(_data.nonVisible));
    }

    clearCache();
  };

  this.getCurrentStepIndex = function (_num) {
    var arr = [];

    var _loop = typeof _num === "undefined" ? 1 : _num;

    if (modelObj.interactionType !== "scale") {
      for (var i = _loop; i > 0; i--) {
        arr.push(modelObj.interactionElements.length - i);
      }
    }

    return arr;
  };

  this.removeRecentShapes = function () {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (data.length) {
      removeShapes(data);
    } else {
      removeShapes(localObj.newPlottedShapes);
    }
  }; // =================================================


  this.clearAll = function () {
    modelObj.interactionElements = [];
    localObj.uniqueId = 0;
    modelObj.currentStep = 0;
    modelObj.finalView = false;

    _this.clearTemp();
  };

  this.clearTemp = function () {
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
    modelObj.tempElements = [];
    localObj.allShapesData = [];
    localObj.tempData = [];
    clearCache();
  };

  this.undo = function () {
    if (localObj.allShapesData.length) {
      localObj.tempData.push(localObj.allShapesData.pop());

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
      } else {
        modelObj.interactionElements = [];
      }
    }
  };

  this.redo = function () {
    if (localObj.tempData.length) {
      localObj.allShapesData.push(localObj.tempData.pop());

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
      } else {
        modelObj.interactionElements = [];
      }
    }
  };

  function saveData() {
    if (modelObj.undoRedo) {
      var currentData = JSON.stringify(modelObj.interactionElements);
      var addData = false;

      if (localObj.allShapesData.length) {
        var lastData = JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]);

        if (currentData !== lastData) {
          addData = true;
        }
      } else {
        addData = true;
      }

      if (addData) {
        localObj.allShapesData.push(JSON.parse(JSON.stringify(modelObj.interactionElements)));
        localObj.tempData = [];
      }
    }
  }

  this.addShape = function (_objData) {
    clearCache();

    var _obj = JSON.parse(JSON.stringify(_objData));

    _obj.uniqueId = ++localObj.uniqueId;

    if (!modelObj.shapesEditable) {
      _obj.isDraggable = false;
      _obj.isDeletable = false;
    }

    if (_obj.label) {
      if (_obj.labelX === undefined) {
        _obj.labelX = _obj.x;
        _obj.labelY = _obj.y;
      }

      if (_obj.labelDiffX === undefined) {
        _obj.labelDiffX = 0;
        _obj.labelDiffY = 0;
      }
    }

    _obj.connectionId = [];

    switch (_obj.type) {
      case "point":
        updatePoints(addNewShape(_obj));
        break;

      case "circle":
        updatePoints(addNewShape(_obj));
        break;

      case "circle_3":
        updatePoints(addNewShape(_obj));
        break;

      case "line":
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case "triangle":
        addNewShape(_obj);
        break;

      case "segment":
      case "segmentDash":
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case "ray":
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case "perpendicularLine":
        updatePLinePoints(addNewShape(_obj));
        break;

      case "parallelLine":
        updatePLinePoints(addNewShape(_obj));
        break;

      case "length":
        _obj.labelAlign = "center";
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case "polygonShape":
        addNewShape(_obj);
        break;

      case "angle":
      case "angleRay":
      case "angleB":
        addNewShape(_obj);
        break;

      case "mirrorOnLine":
      case "semiCircle":
      case "square":
        addNewShape(_obj);

      default:
        break;
    }

    updateAllShapes();
    saveData();
    return _obj.uniqueId;
  };

  function checkForConnection(_obj) {
    var allowedTypes = ["line", "ray", "length", "angleSize"];

    if (allowedTypes.includes(_obj.type)) {
      modelObj.interactionElements.forEach(function (shape) {
        if (shape.type === "point") {
          if (shape.x === _obj.x && shape.y === _obj.y) {
            _obj.firstPointId = shape.uniqueId;
            updateConncId(_obj, _obj.firstPointId);
          }

          if (shape.x === _obj.xTo && shape.y === _obj.yTo) {
            _obj.secondPointId = shape.uniqueId;
            updateConncId(_obj, _obj.secondPointId);
          }
        }
      });
    }
  }

  this.removeIncompleteShape = function () {
    if (!localObj.mouseDown.lastShapeCompleted) {
      _this.removeUnplotedShapes();
    } else {
      clearScreen(false);
    }
  };

  this.removeUnplotedShapes = function () {
    removeShapes(localObj.newPlottedShapes);
    clearScreen(true);
  };

  function clearScreen(closeThePanel) {
    localObj.newPlottedShapes = [];
    localObj.mouseDown.lastShapeCompleted = true;
    modelObj.waiting = false;

    if (closeThePanel) {
      if (typeof events.angleSize !== "undefined") {
        events.angleSize({
          id: modelObj.id,
          type: "angleSize",
          visible: false
        }, true);
      }

      if (typeof events.segSize !== "undefined") {
        events.segSize({
          id: modelObj.id,
          type: "segSize",
          visible: false
        }, true);
      }

      if (typeof events.circleSize !== "undefined") {
        events.circleSize({
          id: modelObj.id,
          type: "circleSize",
          visible: false
        }, true);
      }
    }
  }

  function updateConncId(target, value) {
    if (!target.hasOwnProperty("connectionId")) {
      target.connectionId = [];
    }

    target.connectionId.push(value);
  }

  function clearCache() {
    modelObj.waiting = false;

    _this.removeIncompleteShape();

    localObj.newPlottedShapes = [];

    if (modelObj.interactionType !== "select") {
      for (var i = 0; i < modelObj.interactionElements.length; i++) {
        modelObj.interactionElements[i].isSelected = false;
      }
    }

    scaleObj.visible = modelObj.interactionType === "scale";
  }

  function removeShapes(data) {
    for (var i = 0; i < data.length; i++) {
      var shape = findShape(data[i]);

      if (shape && shape.index !== undefined) {
        removeShape(data[i]);
      }
    }

    saveData();
  }

  function removeShape(id) {
    var shapeData = modelObj.interactionElements;
    var data = findShape(id);
    var shape = data.shape;
    var index = data.index;

    if (shape) {
      var connectionId = shape.connectionId;

      if (connectionId) {
        connectionId.forEach(function (cd) {
          shapeData.forEach(function (sd) {
            var checkingShape = sd;

            if (checkingShape && checkingShape.uniqueId === cd) {
              if (checkingShape.isDeletable === undefined || checkingShape.isDeletable === false) {
                if (checkingShape.connectionId.length > 1) {
                  var _index2 = checkingShape.connectionId.indexOf(shape.uniqueId);

                  if (_index2 > -1) {
                    checkingShape.connectionId.splice(_index2, 1);
                  }

                  if (checkType(checkingShape, ["line", "segment", "segmentDash", "ray"])) {
                    if (checkingShape.firstPointId === shape.uniqueId || checkingShape.secondPointId === shape.uniqueId) {
                      checkingShape.connectionId.forEach(function (elem) {
                        var connectedShape = findShape(elem).shape;

                        if (connectedShape) {
                          var _index = connectedShape.connectionId.indexOf(checkingShape.uniqueId);

                          if (_index2 > -1) {
                            connectedShape.connectionId.splice(_index, 1);
                          }
                        }
                      });
                      sd = null;
                    }
                  }
                }
              }
            }
          });
        });
      }

      shapeData[index] = null;
      modelObj.interactionElements = shapeData.filter(function (e) {
        return e !== null;
      });
      clearCache();
      saveData();
    }
  } // =================================================


  this.updateIndex = function (_obj) {
    var value = JSON.parse(JSON.stringify(_obj.data));
    var shapeData = findShape(value.uniqueId);
    var currentShape = shapeData.shape;
    var actionType = _obj.type;

    if (actionType === "remove") {
      removeShape(value.uniqueId);
    } else if (actionType === "update") {
      if (currentShape) {
        Object.keys(value).forEach(function (i) {
          currentShape[i] = value[i];
        });
      }

      var type = value.type;

      if (modelObj.interactionType === "scale") {
        scaleObj.x = isNaN(value.x) ? scaleObj.x : value.x;
        scaleObj.y = isNaN(value.y) ? scaleObj.y : value.y;
        scaleObj.xTo = isNaN(value.xTo) ? scaleObj.xTo : value.xTo;
        scaleObj.yTo = isNaN(value.yTo) ? scaleObj.yTo : value.yTo;
        dispatchEventScale();
      } else if (type === "point") {
        currentShape.x = value.x;
        currentShape.y = value.y;

        if (typeof value.label !== "undefined") {
          currentShape.label = value.label;
          updatePoints(currentShape);
        }
      } // else if (type === 'midPoint') {
      //   // if (typeof (value.label) !== 'undefined') {
      //   //   currentShape.label = value.label;
      //   //   updatePoints(currentShape);
      //   // }
      // }
      else if (type.includes("segment")) {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.xTo = value.xTo;
          currentShape.yTo = value.yTo;
        } else if (type === "line" || type === "ray") {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.xTo = value.xTo;
          currentShape.yTo = value.yTo;

          if (value.label) {
            currentShape.label = value.label;
          }

          if (currentShape.connectionId) {
            for (var i = 0; i < currentShape.connectionId.length; i++) {
              var _shapeData = findShape(currentShape.connectionId[i]);

              if (_shapeData.shape && _shapeData.shape.type === "point" && _shapeData.shape.uniqueId === currentShape.firstPointId) {
                _shapeData.shape.x = currentShape.x;
                _shapeData.shape.y = currentShape.y;
              }

              if (_shapeData.shape && _shapeData.shape.type === "point" && _shapeData.shape.uniqueId === currentShape.secondPointId) {
                _shapeData.shape.x = currentShape.xTo;
                _shapeData.shape.y = currentShape.yTo;
              }
            }
          }

          updateLinePoints(currentShape);
        } else if (type === "circle") {
          Object.keys(value).forEach(function (i) {
            currentShape[i] = value[i];
          });
        } else if (type === "circle_3") {} else if (type === "perpendicularLine" || type === "parallelLine") {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.slope = value.slope;

          if (currentShape.connectionId) {
            currentShape.connectionId.forEach(function (id) {
              var shapeData = findShape(id);

              if (shapeData.shape && shapeData.shape.type === "point") {
                shapeData.shape.x = currentShape.x;
                shapeData.shape.y = currentShape.y;
              }
            });
          }

          updatePLinePoints(currentShape);
        }
    }

    saveData();
  }; // =================================================


  this.draw = function () {
    var _ctx = modelObj.context;
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height,
        transperent = modelObj.transperent,
        interactionElements = modelObj.interactionElements,
        segmentColor = modelObj.segmentColor,
        fontSize = modelObj.fontSize,
        pointColor = modelObj.pointColor,
        interactionType = modelObj.interactionType,
        pointLabelColor = modelObj.pointLabelColor;

    if (modelObj.visible) {
      _ctx.save();

      _ctx.beginPath();

      _ctx.globalAlpha = transperent ? 0.5 : 1; // --------------------------------------

      _ctx.save();

      _ctx.fillStyle = "#000000";

      _ctx.rect(x, y, width, height);

      _ctx.clip();

      drawShapes(_ctx, modelObj);

      if (scaleObj.visible) {
        _ctx.save();

        _ctx.fillStyle = scaleObj.pointColor;
        _ctx.strokeStyle = scaleObj.segmentColor;
        _ctx.lineWidth = scaleObj.segmentWidth;

        _ctx.beginPath();

        _ctx.moveTo(scaleObj.x, scaleObj.y);

        _ctx.lineTo(scaleObj.xTo, scaleObj.yTo);

        _ctx.stroke();

        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.x, scaleObj.y, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.xTo, scaleObj.yTo, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.restore();
      }

      if (localObj.mouseDown.isMouseDown && interactionType === "select" && localObj.currentUniqueId === null) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.fillStyle = "rgba(69,146,176,0.1)";
        _ctx.strokeStyle = "rgba(69,146,176,0.8)";
        var _localObj$mouseDown = localObj.mouseDown,
            orignalX = _localObj$mouseDown.orignalX,
            orignalY = _localObj$mouseDown.orignalY,
            _x3 = _localObj$mouseDown.x,
            _y3 = _localObj$mouseDown.y;

        _ctx.rect(orignalX, orignalY, _x3 - orignalX, _y3 - orignalY);

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        _ctx.restore();
      }

      _ctx.restore(); // --------------------------------------


      _ctx.closePath();

      _ctx.restore(); // --------------------------------------


      _ctx.save();

      var _modelObj$screen = modelObj.screen,
          sx = _modelObj$screen.x,
          sy = _modelObj$screen.y,
          sw = _modelObj$screen.w,
          sh = _modelObj$screen.h;
      _ctx.fillStyle = "#000000";

      _ctx.beginPath();

      _ctx.moveTo(sx, sy);

      _ctx.lineTo(sx, sy + sh);

      _ctx.lineTo(sx + sw, sy + sh);

      _ctx.lineTo(sx + sw, sy);

      _ctx.closePath();

      _ctx.clip();

      drawPoints(_ctx, modelObj);

      _ctx.restore(); // --------------------------------------
      // --------------------------------------


      _ctx.save();

      _ctx.fillStyle = "#000000";

      _ctx.beginPath();

      _ctx.moveTo(x, y);

      _ctx.lineTo(x, y + height);

      _ctx.lineTo(x + width, y + height);

      _ctx.lineTo(x + width, y);

      _ctx.closePath();

      _ctx.clip();

      if (!transperent) {
        drawlabels(_ctx, modelObj);
      }

      _ctx.restore(); // --------------------------------------

    }
  };

  function drawPoints(_ctx, _ref) {
    var x = _ref.x,
        y = _ref.y,
        height = _ref.height,
        interactionElements = _ref.interactionElements;
    interactionElements.forEach(function (item) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === "point") {
          var draw = true;

          if (modelObj.showQuadrants === "1") {
            if (_xy.x < x || _xy.y > y + height) {
              draw = false;
            }
          }

          if (draw) {
            drawPoint(_ctx, item, true, false);
          }
        } // if (item.type === 'midPoint') {
        //   let draw = true;
        //   if (modelObj.showQuadrants === '1') {
        //     if (_xy.x < x || _xy.y > (y + height)) {
        //       draw = false;
        //     }
        //   }
        //   if (draw) {
        //     drawPoint(_ctx, item, true, false);
        //   }
        // }

      }
    });
  }

  function drawlabels(_ctx, _ref2) {
    var interactionElements = _ref2.interactionElements,
        pointLabelColor = _ref2.pointLabelColor,
        fontSize = _ref2.fontSize,
        lengthLabelColor = _ref2.lengthLabelColor;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === "point") {
          // If a label(visible property) for particular point is to be changed.
          var pointLabelVisible = item.labelVisible !== undefined ? item.labelVisible : true;
          drawPoint(_ctx, item, false, pointLabelVisible && modelObj.shapes.point.label.visible);
        }

        if (item.type === "length") {
          if (item.label) {
            var center = getPixelByPoint(item.labelX, item.labelY);
            center.x += item.labelDiffX;
            center.y += item.labelDiffY;

            _ctx.save();

            _ctx.beginPath();

            _ctx.font = fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;
            var textSize = _ctx.measureText(item.distanceText).width + fontSize / 2;
            _ctx.fillStyle = "rgba(255,255,255,1)";
            _ctx.strokeStyle = "rgba(199,199,199,1)";

            _ctx.rect(center.x - textSize / 2, center.y - fontSize * 1.2, textSize, fontSize * (modelObj.labelBGRatio + 0.1));

            _ctx.fill();

            _ctx.stroke();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.textBaseline = "bottom";
            _ctx.textAlign = "center";
            _ctx.fillStyle = lengthLabelColor;

            _ctx.drawStyledText(item.label, center.x, center.y, modelObj.LabComClass.polo22KlettRegular, fontSize);

            _ctx.closePath();

            _ctx.restore();
          }
        }

        if (item.type === "square" && modelObj.shapes.square.label.visible) {
          if (item.label) {
            var p = getPixelByPoint(item.labelX, item.labelY);
            var color = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            var _center = getPixelByPoint(item.labelX, item.labelY);

            _center.x += item.labelDiffX;
            _center.y += item.labelDiffY;

            _ctx.save();

            _ctx.beginPath();

            _ctx.font = fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;

            var _textSize = _ctx.measureText(item.label).width + fontSize / 2;

            _ctx.fillStyle = "rgba(255,255,255,1)";
            _ctx.strokeStyle = "rgba(199,199,199,1)";

            _ctx.rect(_center.x - _textSize * 0.25, _center.y - fontSize * 1.2, _textSize * 0.65, fontSize * (modelObj.labelBGRatio + 0.1));

            _ctx.fill();

            _ctx.stroke();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.textBaseline = "bottom";
            _ctx.textAlign = "center";
            _ctx.fillStyle = lengthLabelColor;

            _ctx.drawStyledText(item.label, _center.x, _center.y, modelObj.LabComClass.polo22KlettRegular, fontSize); // drawStroked({
            //   ctx: _ctx,
            //   text: item.label,
            //   x: p.x,
            //   y: p.y,
            //   fillColor: color,
            //   center: true,
            //   diffX: Number(item.labelDiffX),
            //   diffY: Number(item.labelDiffY)
            // });


            _ctx.closePath();

            _ctx.restore();
          }
        }

        if (item.type.includes("segment") || checkType(item, ["angle", "angleSize", "line", "ray", "perpendicularLine", "parallelLine", "angleRay"])) {
          var showLable = true;

          if (modelObj.shapes.hasOwnProperty(item.type)) {
            if (modelObj.shapes[item.type].hasOwnProperty("label") && modelObj.shapes[item.type].label.hasOwnProperty("visible") && !modelObj.shapes[item.type].label.visible) {
              showLable = false;
            }
          }

          if (showLable && item.label !== undefined && item.labelX !== undefined && item.type !== "angleSize") {
            var _p = getPixelByPoint(item.labelX, item.labelY);

            var _color2 = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            drawStroked({
              ctx: _ctx,
              text: item.label,
              x: _p.x,
              y: _p.y,
              fillColor: _color2,
              center: true,
              diffX: Number(item.labelDiffX),
              diffY: Number(item.labelDiffY)
            });
          } else if (showLable && item.label !== undefined && item.labelX !== undefined && item.type === "angleSize") {
            var angle = modelObj.LabComClass.Maths.getAngle(item.x, item.y, item.xTo, item.yTo);
            var degree = item.degree * (item.clockwise ? -1 : 1);
            var angleTextPos = modelObj.LabComClass.Maths.getPoint(item, angle + degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));

            var _p2 = getPixelByPoint(angleTextPos.x, angleTextPos.y);

            var _color3 = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            drawStroked({
              ctx: _ctx,
              text: item.label.replace(".", ","),
              x: _p2.x,
              y: _p2.y,
              fillColor: _color3,
              center: true,
              diffX: Number(item.labelDiffX),
              diffY: Number(item.labelDiffY)
            });
          }
        }
      }
    });
  }

  function reduceLineEnd(p1, p2, r) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var mag = Math.hypot(dx, dy);
    return {
      x: p2.x - r * dx / mag,
      y: p2.y - r * dy / mag
    };
  }

  function drawArrowHead(_ctx, _xy, _xTo_yTo) {
    var headlen = 10; // length of head in pixels

    var angle = modelObj.LabComClass.Maths.getAngle(_xy.x, _xy.y, _xTo_yTo.x, _xTo_yTo.y);
    var newPosition = reduceLineEnd(_xy, _xTo_yTo, modelObj.pointRadius);

    _ctx.save();

    _ctx.beginPath();

    _ctx.moveTo(newPosition.x, newPosition.y);

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle - Math.PI / 6), newPosition.y - headlen * Math.sin(angle - Math.PI / 6));

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle + Math.PI / 6), newPosition.y - headlen * Math.sin(angle + Math.PI / 6));

    _ctx.lineTo(newPosition.x, newPosition.y);

    _ctx.stroke();

    _ctx.fill();

    _ctx.closePath();

    _ctx.restore();
  }

  function drawShapes(_ctx, _ref3) {
    var interactionElements = _ref3.interactionElements,
        segmentColor = _ref3.segmentColor,
        fontSize = _ref3.fontSize,
        pointLabelColor = _ref3.pointLabelColor;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      var _xTo_yTo = item.xTo !== undefined ? getPixelByPoint(item.xTo, item.yTo) : null;

      var _xOr_yOr = item.xOr !== undefined ? getPixelByPoint(item.xOr, item.yOr) : null;

      var _xOrTo_yOrTo = item.xOrTo !== undefined ? getPixelByPoint(item.xOrTo, item.yOrTo) : null;

      if (item.visible) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.strokeStyle = segmentColor;
        _ctx.fillStyle = segmentColor;

        if (item.strokeColor) {
          _ctx.strokeStyle = item.strokeColor;
        }

        if (item.fillColor) {
          _ctx.fillStyle = item.fillColor;
        }

        if (item.lineWidth) {
          _ctx.lineWidth = item.lineWidth;
        }

        if (item.isSelected) {
          _ctx.lineWidth = 2;
        }

        if (modelObj.finalView) {
          _ctx.fillStyle = modelObj.finalColor;
          _ctx.strokeStyle = modelObj.finalColor;
        }

        if (item.type === "point") {// drawPoint(_ctx, item, true, false);
        } else if (item.type.includes("segment")) {
          _ctx.font = fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = "bottom";
          _ctx.textAlign = "left";

          if (item.type.includes("segmentDash")) {
            _ctx.setLineDash([6, 4]);
          }

          _ctx.moveTo(_xy.x, _xy.y);

          _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

          _ctx.stroke();

          if (item.arrowHead) {
            if (modelObj.LabComClass.Maths.getDistance(_xy, _xTo_yTo) > modelObj.pointRadius * 3) {
              drawArrowHead(_ctx, _xy, _xTo_yTo);
            }
          }

          if (modelObj.shapes.segment.segDistanceLabel && item.distance && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted) && modelObj.interactionType !== "move" && modelObj.interactionType !== "brush1" && modelObj.interactionType !== "brush2" && modelObj.interactionType !== "brush3") {
            var val = item.distance === undefined ? 0 : item.distance;

            if (modelObj.shapes.segment.digit !== undefined) {
              val = val.toFixed(modelObj.shapes.segment.digit).replace(".", ",");
            } // val = Number(val.toFixed(modelObj.shapes.segment.digit));


            var gap = fontSize / 3;
            var x = (_xy.x + _xTo_yTo.x) / 2.05;
            var h = fontSize;
            var y = (_xy.y + _xTo_yTo.y) / 2 + gap;

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = "rgba(255,255,255,1)";

            _ctx.rect(x, y, _ctx.measureText(val).width + gap * 2, h);

            _ctx.fill();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.fillStyle = pointLabelColor;

            _ctx.fillText(val, x + gap, y + h * 1.05);

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === "length") {
          if (item.secondPointId === undefined && item.mode === "normal") {
            _ctx.save();

            _ctx.beginPath();

            _ctx.setLineDash([5, 15]);

            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

            _ctx.stroke();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === "compass") {
          if (!item.isPloted) {
            _ctx.strokeStyle = segmentColor;

            _ctx.setLineDash([3, 3]);

            _ctx.lineWidth = 2;

            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          } else {
            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          }
        } else if (item.type === "triangle") {
          if (item.thirdSegmentPlotted) {
            var p1 = getPixelByPoint(item.firstPoint.x, item.firstPoint.y);
            var p2 = getPixelByPoint(item.secondPoint.x, item.secondPoint.y);
            var p3 = getPixelByPoint(item.thirdPoint.x, item.thirdPoint.y);

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = item.fillColor ? item.fillColor : "rgba(112,146,190,0.5)";

            _ctx.moveTo(p1.x, p1.y);

            _ctx.lineTo(p2.x, p2.y);

            _ctx.lineTo(p3.x, p3.y);

            _ctx.lineTo(p1.x, p1.y);

            _ctx.stroke();

            _ctx.fill();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === "square") {
          if (item.secondPointPlotted) {
            var _p3 = getPixelByPoint(item.firstPoint.x, item.firstPoint.y);

            var _p4 = getPixelByPoint(item.secondPoint.x, item.secondPoint.y);

            var _p5 = getPixelByPoint(item.thirdPoint.x, item.thirdPoint.y);

            var p4 = getPixelByPoint(item.fourthPoint.x, item.fourthPoint.y);

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = item.fillColor ? item.fillColor : "rgba(112,146,190,0.5)";

            _ctx.moveTo(_p3.x, _p3.y);

            _ctx.lineTo(_p4.x, _p4.y);

            _ctx.lineTo(_p5.x, _p5.y);

            _ctx.lineTo(p4.x, p4.y);

            _ctx.lineTo(_p3.x, _p3.y);

            _ctx.stroke();

            if (modelObj.shapes.square.fill) {
              _ctx.fill();
            }

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === "line") {
          _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

          _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

          _ctx.stroke();
        } else if (item.type === "ray") {
          if (_xy.x !== _xTo_yTo.x || _xy.y !== _xTo_yTo.y) {
            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.stroke();
          }
        } else if (item.type === "circle_3") {
          _ctx.font = fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = "bottom";
          _ctx.textAlign = "left";

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

          _ctx.stroke();
        } else if (item.type === "circle") {
          _ctx.font = fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = "bottom";
          _ctx.textAlign = "left";

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

          _ctx.stroke();

          if (modelObj.shapes.circle.circleDistanceLabel && item.r && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted)) {
            var _val = Number(item.r);

            if (modelObj.shapes.circle.digit !== undefined) {
              _val = _val.toFixed(modelObj.shapes.circle.digit).replace(".", ",");
            }

            var _gap = fontSize / 3;

            var _x4 = _xy.x;
            var _h = fontSize;

            var _y4 = _xy.y + _gap;

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = "rgba(255,255,255,1)";

            _ctx.rect(_x4, _y4, _ctx.measureText(_val).width + _gap * 2, _h);

            _ctx.fill();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.fillStyle = pointLabelColor;

            _ctx.fillText(_val, _x4 + _gap, _y4 + _h * 1.05);

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === "semiCircle") {
          _ctx.beginPath();

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), -item.startAngle, -item.endAngle);

          _ctx.stroke();

          _ctx.closePath();
        } else if (item.type === "angleRay") {
          _ctx.translate(_xy.x, _xy.y);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.stroke();
        } else if (item.type === "angle" || item.type === "angleSize") {
          _ctx.globalAlpha = 0.5;

          _ctx.translate(_xy.x, _xy.y);

          _ctx.beginPath();

          _ctx.moveTo(0, 0);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.fill();

          _ctx.closePath();

          if ((item.angleValue === 90 || item.degree === 90) && (modelObj.shapes.angle.dotOn90 || modelObj.shapes.angleSize.dotOn90)) {
            var _p6 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.endAngle, 16);

            var _p7 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.startAngle, 16);

            _ctx.beginPath();

            _ctx.strokeStyle = "#000000";
            _ctx.fillStyle = "#000000";

            _ctx.arc((_p7.x + _p6.x) / 2, (_p7.y + _p6.y) / 2, 2, 0, Math.PI * 2);

            _ctx.fill();

            _ctx.closePath();
          }

          _ctx.stroke();
        } else if (item.type === "perpendicularLine" || item.type === "parallelLine") {
          if (_xOr_yOr !== null && !isNaN(_xOr_yOr.x)) {
            _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

            _ctx.stroke();
          }
        } else if (item.type === "polygonShape") {
          _ctx.fillStyle = item.fillColor ? item.fillColor : "rgba(112,146,190,0.5)";
          item.path.forEach(function (elem, i) {
            var p = getPixelByPoint(elem.x, elem.y);

            if (i === 0) {
              _ctx.moveTo(p.x, p.y);
            }

            _ctx.lineTo(p.x, p.y);
          });

          _ctx.fill();
        }

        _ctx.closePath();

        _ctx.restore();
      }
    });
  }

  function drawStroked(_ref4) {
    var ctx = _ref4.ctx,
        text = _ref4.text,
        x = _ref4.x,
        y = _ref4.y,
        fillColor = _ref4.fillColor,
        _ref4$diffX = _ref4.diffX,
        diffX = _ref4$diffX === void 0 ? 0 : _ref4$diffX,
        _ref4$diffY = _ref4.diffY,
        diffY = _ref4$diffY === void 0 ? 0 : _ref4$diffY;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = "bottom";
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = "rgba(255,255,255,1)";
    ctx.lineWidth = 2;
    ctx.lineJoin = "miter"; // Experiment with "bevel" & "round" for the effect you want!

    ctx.miterLimit = 2; // if (center) {
    //   x -= (ctx.measureText(text).width / 2);
    //   y -= 5;
    // }

    y += modelObj.fontSize * 0.6; // }
    // ctx.strokeText(text, x + diffX, y + diffY);
    // ctx.fillText(text, x + diffX, y + diffY);

    ctx.drawStyledText(text, x + diffX, y + diffY, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
    ctx.closePath();
    ctx.restore();
  }

  function drawPoint(_ctx, item, _drawShape, _drawText) {
    var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

    _ctx.beginPath();

    if (_drawShape) {
      _ctx.fillStyle = modelObj.pointColor;

      if (item.fillColor) {
        _ctx.fillStyle = item.fillColor;
      }

      if (modelObj.finalView) {
        _ctx.fillStyle = modelObj.finalColor;
        _ctx.strokeStyle = modelObj.finalColor;
      }

      _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius, 0, 2 * Math.PI);

      _ctx.fill();

      _ctx.closePath();

      if (item.isSelected) {
        _ctx.beginPath();

        _ctx.strokeStyle = modelObj.pointColor;

        _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius + 2, 0, 2 * Math.PI);

        _ctx.stroke();

        _ctx.closePath();
      }
    }

    if (item.label !== undefined && _drawText) {
      if (item.labelX === undefined) {
        item.labelX = item.x;
        item.labelY = item.y;
        item.labelDiffX = 0;
        item.labelDiffY = 0;
      }

      var labelPos = getPixelByPoint(item.labelX, item.labelY);
      var color = item.fillLabelColor ? item.fillLabelColor : modelObj.pointLabelColor;
      drawStroked({
        ctx: _ctx,
        text: item.label,
        x: labelPos.x,
        y: labelPos.y,
        fillColor: color,
        center: false,
        diffX: Number(item.labelDiffX),
        diffY: Number(item.labelDiffY)
      });
    }
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function addEvents() {
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "removeMouseEvent",
      data: {
        id: modelObj.id
      }
    });

    if (modelObj.eventsEnable) {
      if (modelObj.interactionType !== null) {
        if (modelObj.state && modelObj.visible) {
          if (modelObj.interactionType === "scale") {
            _eventDataObj.r.push({
              id: "scale1",
              arc: {
                x: scaleObj.x,
                y: scaleObj.y,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            }, {
              id: "scale2",
              arc: {
                x: scaleObj.xTo,
                y: scaleObj.yTo,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            });
          } else {
            _eventDataObj.r.push({
              id: 0,
              rect: {
                x: modelObj.screen.x,
                y: modelObj.screen.y,
                w: modelObj.screen.w,
                h: modelObj.screen.h
              },
              eventListener: mouseHandle.bind(this)
            });
          }

          onViewUpdateCls.trigger("onGlobalUpdate", {
            type: "addMouseEvent",
            data: _eventDataObj
          });
        }
      }
    }
  }

  var d;

  function checkForRightClick(e) {
    localObj.mouseDownData = null;

    if (localObj.isDevice) {
      localObj.mouseDownData = JSON.parse(JSON.stringify(e));
      localObj.mouseDownData.delayCounter = 0;
      modelObj.animClass.start({
        id: "animation",
        fps: 1,
        frame: checkAfterDelay
      });
    } else {
      executeMouseDown(e);
    }
  }

  function rejectDelay() {
    modelObj.animClass.stop("animation");
    executeMouseDown(localObj.mouseDownData);
    localObj.mouseDownData = null;
  }

  function checkAfterDelay() {
    var mouseDownData = localObj.mouseDownData;
    mouseDownData.delayCounter++;

    if (mouseDownData.delayCounter > 2) {
      modelObj.animClass.stop("animation");

      if (typeof events.rightClick !== "undefined") {
        events.rightClick({
          id: modelObj.id,
          type: "rightClick",
          x: mouseDownData.pageX,
          y: mouseDownData.pageY
        }, true);
      }

      mouseDownData = null;
    }
  }

  function executeMouseDown(e) {
    var mouseDown = localObj.mouseDown;
    mouseDown.isMouseDown = true;
    mouseDown.x = e.pageX;
    mouseDown.orignalX = e.pageX;
    mouseDown.y = e.pageY;
    mouseDown.orignalY = e.pageY;
    mouseDown.objectDown = false;

    if (mouseDown.lastShapeCompleted) {
      onMouseDown(e);
    }
  } // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case "mousedown":
        checkForRightClick(e);
        break;

      case "pressmove":
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onPressMove(e);
        break;

      case "mousemove":
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseMove(e);
        break;

      case "mouseup":
        mouseUpCall(e); // addEvents();

        break;

      case "rightmouseup":
        if (localObj.mouseDown.isMouseDown) {
          mouseUpCall(e);
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      case "rightmousedown":
        localObj.mouseDown.isRightMouseDown = true;

        if (typeof events.rightClick !== "undefined") {
          events.rightClick({
            id: modelObj.id,
            type: "rightClick",
            x: e.pageX,
            y: e.pageY
          }, true);
        }

        break;

      case "mouseupout":
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseUp(e);
        localObj.mouseDown.isMouseDown = false;

        if (e.subId === "scale1" || e.subId === "scale2") {
          addEvents();
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      default:
        break;
    }
  }

  function mouseUpCall(e) {
    if (localObj.mouseDownData !== null) {
      rejectDelay();
    }

    onMouseUp(e);
    localObj.mouseDown.isMouseDown = false;
    localObj.mouseDown.objectDown = false;
    localObj.mouseDown.isRightMouseDown = false;
  }

  function setScaleValues() {
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height;
    scaleObj.originPos = {
      x: x + (width - 280),
      y: y + (height - 40),
      xTo: x + (width - 40),
      yTo: y + (height - 40)
    };
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
  }

  function addPoint(point, _obj) {
    var newShape = {
      type: "point",
      x: point.x,
      y: point.y,
      label: ""
    };
    Object.keys(_obj).forEach(function (i) {
      newShape[i] = _obj[i];
    });

    if (point.isIntersection || point.isParameter) {
      Object.keys(point).forEach(function (i) {
        newShape[i] = point[i];
      });
    }

    localObj.newPlottedShapes.push(_obj.uniqueId);
    addNewShape(newShape);
  } // =================================================


  function checkSnapping(point) {
    if (modelObj.showQuadrants === "1" && (point.x < 0 || point.y < 0)) {
      if (Math.abs(point.x) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.x = 0;
      }

      if (Math.abs(point.y) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.y = 0;
      }

      if (point.x < 0 || point.y < 0) {
        return null;
      }
    }

    var snappingPont = JSON.parse(JSON.stringify(point));
    var snappingData = {};
    var snappingFound = false;

    if (modelObj.pointSnapping) {
      var pointMinDist = isItCloseToPlotedPoint(snappingPont, true);
      var intersectionMinDist = isItCloseToIntersectionPoint(snappingPont);
      var intersectionOfParameterMinDist = isItCloseToParameterPoint(snappingPont);

      if (pointMinDist) {
        snappingData.x = pointMinDist.plotedPoint.x;
        snappingData.y = pointMinDist.plotedPoint.y;
        snappingFound = true;
      }

      if (intersectionMinDist && !snappingFound) {
        var intersectionCanBeSnapped = true;

        if (pointMinDist) {
          if (intersectionMinDist.dist > pointMinDist.dist) {
            intersectionCanBeSnapped = false;
          }
        }

        if (intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionMinDist.updateKeys;
          snappingFound = true;
        }
      }

      if (intersectionOfParameterMinDist && !snappingFound) {
        var _intersectionCanBeSnapped = true;

        if (snappingData) {
          if (intersectionOfParameterMinDist.dist > snappingData.dist) {
            _intersectionCanBeSnapped = false;
          }
        }

        if (_intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionOfParameterMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionOfParameterMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionOfParameterMinDist.updateKeys;
          snappingFound = true;
        }
      }
    } // check for point, intersection, shape parameter
    // check for snapping grid point


    if (!snappingFound && modelObj.snapToGrid) {
      var _modelObj$graphValues = modelObj.graphValues,
          XunitsPerGrid = _modelObj$graphValues.XunitsPerGrid,
          YunitsPerGrid = _modelObj$graphValues.YunitsPerGrid;
      var x = Math.round(point.x / XunitsPerGrid) * XunitsPerGrid;
      var y = Math.round(point.y / YunitsPerGrid) * YunitsPerGrid;

      if (modelObj.LabComClass.Maths.getDistance(point, {
        x: x,
        y: y
      }) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        snappingData = {};
        snappingData.x = x;
        snappingData.y = y;
        snappingFound = true;
      }
    }

    if (snappingFound) {
      Object.keys(snappingData).forEach(function (i) {
        point[i] = snappingData[i];
      });
    }

    return point;
  }

  function addNewShape(_objNew) {
    var drawNewShape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var _obj = {
      type: modelObj.interactionType,
      step: modelObj.currentStep,
      visible: true
    };
    Object.keys(_objNew).forEach(function (i) {
      _obj[i] = _objNew[i];
    });

    if (drawNewShape) {
      localObj.newPlottedShapes.push(_obj.uniqueId);
      modelObj.interactionElements.push(_obj);
    }

    return _obj;
  }

  function onMouseDown(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    localObj.newPlottedShapes = [];
    var newShapes = localObj.newPlottedShapes;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point);
    localObj.currentUniqueId = null;
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));

    if (clickingOnExistingPoint !== null) {
      localObj.currentUniqueId = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    localObj.newShapeStarted = false;

    if (tool === "point" && point !== null) {
      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: ++localObj.uniqueId,
          connectionId: []
        });
        localObj.currentUniqueId = localObj.uniqueId;
      }
    } else if (tool.includes("segment") && point !== null) {
      var firstPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      var segmentId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: firstPointId,
          connectionId: [segmentId]
        });
      } else {
        updateConncId(shapesData[clickingOnExistingPoint], segmentId);
      }

      addNewShape({
        uniqueId: segmentId,
        firstPointId: firstPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [firstPointId]
      });
      localObj.currentUniqueId = segmentId;
      newShapes.push(segmentId);
    } else if (tool === "length") {
      if (clickingOnExistingPoint !== null && point !== null) {
        var lengthId = ++localObj.uniqueId;
        var _firstPointId = localObj.currentUniqueId;
        addNewShape({
          uniqueId: lengthId,
          firstPointId: _firstPointId,
          x: point.x,
          y: point.y,
          xTo: point.x,
          yTo: point.y,
          labelAlign: "center",
          mode: "normal"
        });
        localObj.currentUniqueId = lengthId;
        newShapes.push(lengthId);
      } else {
        var selectedShapeID = selectShape(e);

        if (selectedShapeID) {
          var shapeData = findShape(selectedShapeID);

          if (shapeData.shape && shapeData.shape.type.includes("segment")) {
            var _lengthId = ++localObj.uniqueId;

            addNewShape({
              uniqueId: _lengthId,
              segmentID: selectedShapeID,
              x: shapeData.shape.x,
              y: shapeData.shape.y,
              xTo: shapeData.shape.xTo,
              yTo: shapeData.shape.yTo,
              labelAlign: "center",
              mode: "segment"
            });
            localObj.currentUniqueId = _lengthId;
            newShapes.push(_lengthId);
          } else if (shapeData.shape && (shapeData.shape.type === "circle" || shapeData.shape.type === "circle_3" || shapeData.shape.type === "compass")) {
            var _lengthId2 = ++localObj.uniqueId;

            addNewShape({
              uniqueId: _lengthId2,
              circleId: selectedShapeID,
              x: shapeData.shape.x,
              y: shapeData.shape.y,
              xTo: shapeData.shape.x + shapeData.shape.r,
              yTo: shapeData.shape.y,
              pointX: point.x,
              pointY: point.y,
              labelAlign: "center",
              mode: "circle"
            });
            localObj.currentUniqueId = _lengthId2;
            newShapes.push(_lengthId2);
          } else {
            shapeData.shape.isSelected = false;
          }
        }
      }
    } else if (tool === "compass") {
      var newShape;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId2 = localObj.currentUniqueId;
          newShape = {
            firstPointId: _firstPointId2,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _selectedShapeID = selectShape(e);

        if (_selectedShapeID) {
          var _shapeData2 = findShape(_selectedShapeID);

          if (_shapeData2.shape.visible === true) {
            if (_shapeData2.shape && _shapeData2.shape.type.includes("segment")) {
              newShape = {
                segmentID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                xTo: _shapeData2.shape.xTo,
                yTo: _shapeData2.shape.yTo
              };
            } else if (_shapeData2.shape && (_shapeData2.shape.type === "circle" || _shapeData2.shape.type === "compass")) {
              newShape = {
                circleID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                r: _shapeData2.shape.r
              };
            } else if (_shapeData2.shape.type === "line" || _shapeData2.shape.type === "parallelLine" || _shapeData2.shape.type === "perpendicularLine") {
              _shapeData2.shape.isSelected = false;
            }
          }
        }
      }

      if (newShape) {
        var _lengthId3 = ++localObj.uniqueId;

        localObj.currentUniqueId = _lengthId3;
        newShape.connectionId = [];
        newShape.uniqueId = _lengthId3;
        newShape.isPloted = false;
        newShapes.push(_lengthId3);
        addNewShape(newShape);
      }
    } else if ((tool === "line" || tool === "ray") && point !== null) {
      var _firstPointId3 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var lineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId3,
          connectionId: [lineId]
        });
      } else {
        updateConncId(shapesData[clickingOnExistingPoint], lineId);
      }

      addNewShape({
        uniqueId: lineId,
        firstPointId: _firstPointId3,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [_firstPointId3]
      });
      localObj.currentUniqueId = lineId;
      newShapes.push(lineId);
    } else if (tool === "angleRay" && point !== null) {
      var angleRayId = ++localObj.uniqueId;
      var rayId = ++localObj.uniqueId;
      var secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      newShapes.push(angleRayId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: secondPointId,
          connectionId: [rayId, angleRayId]
        });
      } else {
        updateConncId(shapesData[clickingOnExistingPoint], rayId);
      }

      addNewShape({
        uniqueId: angleRayId,
        firstPointId: secondPointId,
        firstRayPlotted: false,
        secondRayPlotted: false,
        x: point.x,
        y: point.y,
        connectionId: [secondPointId]
      });
      addNewShape({
        type: "ray",
        uniqueId: rayId,
        angleRayId: angleRayId,
        secondPointId: secondPointId,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [secondPointId]
      });
      localObj.currentUniqueId = rayId;
      newShapes.push(rayId);
    } else if (tool === "circle_3" && point !== null) {
      var circleId = ++localObj.uniqueId;

      var _firstPointId4 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId4,
          connectionId: [circleId],
          circleId: circleId
        });
      } else {
        updateConncId(shapesData[clickingOnExistingPoint], circleId);
        shapesData[clickingOnExistingPoint].circleId = circleId;
      }

      addNewShape({
        uniqueId: circleId,
        firstPointId: _firstPointId4,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId4]
      });
      var fp = findShape(_firstPointId4).shape;
      fp.isSelected = true;
      localObj.currentUniqueId = _firstPointId4;
      newShapes.push(circleId);
    } else if (tool === "angle" && point !== null) {
      var angleId = ++localObj.uniqueId;

      var _firstPointId5 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId5,
          connectionId: [angleId],
          angleId: angleId
        });
        var _fp = findShape(_firstPointId5).shape;
        _fp.isSelected = true;
      } else {
        var _fp2 = findShape(_firstPointId5).shape;
        _fp2.isSelected = true;
        updateConncId(shapesData[clickingOnExistingPoint], angleId);
        shapesData[clickingOnExistingPoint].angleId = angleId;
      }

      addNewShape({
        uniqueId: angleId,
        firstPointId: _firstPointId5,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId5]
      });
      localObj.currentUniqueId = _firstPointId5;
      newShapes.push(angleId);
    } else if (tool === "midPoint" && point !== null) {
      var midPointId = ++localObj.uniqueId;

      var _firstPointId6 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID2 = selectShape(e);

      var _shapeData3 = findShape(_selectedShapeID2).shape;

      if (clickingOnExistingPoint === null && point !== null && _selectedShapeID2 === null) {
        addPoint(point, {
          uniqueId: _firstPointId6,
          connectionId: [midPointId],
          midPointId: midPointId
        });
        addNewShape({
          uniqueId: midPointId,
          type: "midPoint",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId6]
        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
        if (_shapeData3) {
          _shapeData3.isSelected = false;
        }

        updateConncId(shapesData[clickingOnExistingPoint], midPointId);
        shapesData[clickingOnExistingPoint].midPointId = midPointId;
        addNewShape({
          uniqueId: midPointId,
          type: "midPoint",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          strokeColor: point.strokeColor != modelObj.pointColor ? point.strokeColor : modelObj.pointColor,
          fillColor: point.fillColor != modelObj.pointColor ? point.fillColor : modelObj.pointColor,
          connectionId: [_firstPointId6],
          segmentId: _selectedShapeID2
        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (_selectedShapeID2 !== null && _shapeData3.type.includes("segment")) {
        if (_shapeData3 && _shapeData3.type.includes("segment")) {
          addNewShape({
            uniqueId: midPointId,
            type: "midPoint",
            firstPointId: _firstPointId6,
            firstPointPlotted: true,
            secondPointPlotted: true,
            x: (_shapeData3.x + _shapeData3.xTo) / 2,
            y: (_shapeData3.y + _shapeData3.yTo) / 2,
            firstPointCoords: {
              x: _shapeData3.x,
              y: _shapeData3.y
            },
            secondPointCoords: {
              x: _shapeData3.xTo,
              y: _shapeData3.yTo
            },
            segmentId: _selectedShapeID2,
            connectionId: [_firstPointId6],
            onSegment: true,
            midPointId: midPointId
          });
          localObj.currentUniqueId = midPointId;
        }
      } else {
        _shapeData3.isSelected = false;
      }

      newShapes.push(midPointId);
    } else if (tool === "square" && point !== null) {
      var squareId = ++localObj.uniqueId;

      var _firstPointId7 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null && point !== null) {
        addPoint(point, {
          uniqueId: _firstPointId7,
          connectionId: [squareId],
          squareId: squareId
        });
        addNewShape({
          uniqueId: squareId,
          type: "square",
          firstPointId: _firstPointId7,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId7]
        });
        localObj.currentUniqueId = _firstPointId7;
      } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
        updateConncId(shapesData[clickingOnExistingPoint], squareId);
        shapesData[clickingOnExistingPoint].squareId = squareId;
        addNewShape({
          uniqueId: squareId,
          type: "square",
          firstPointId: _firstPointId7,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          strokeColor: point.strokeColor != modelObj.pointColor ? point.strokeColor : modelObj.pointColor,
          fillColor: point.fillColor != modelObj.pointColor ? point.fillColor : modelObj.pointColor,
          connectionId: [_firstPointId7]
        });
        localObj.currentUniqueId = _firstPointId7;
      }

      var _fp3 = findShape(_firstPointId7).shape;
      _fp3.isSelected = true;
      localObj.newPlottedShapes.push(squareId);
    } else if (tool === "mirrorOnLine" && point !== null) {
      var mirrorOnLineId = ++localObj.uniqueId;

      var _firstPointId8 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID3 = selectShape(e);

      var _shapeData4 = findShape(_selectedShapeID3).shape;

      if (_shapeData4 && _shapeData4.type === "point" || _selectedShapeID3 === null || clickingOnExistingPoint !== null && shapesData[clickingOnExistingPoint].type === "point") {
        if (_shapeData4) {
          _shapeData4.isSelected = false;
        }

        if (clickingOnExistingPoint === null) {
          addPoint(point, {
            uniqueId: _firstPointId8,
            connectionId: [mirrorOnLineId],
            mirrorOnLineId: mirrorOnLineId
          });
          var _fp4 = findShape(_firstPointId8).shape;
          _fp4.isSelected = true;
        } else {
          updateConncId(shapesData[clickingOnExistingPoint], mirrorOnLineId);
          shapesData[clickingOnExistingPoint].mirrorOnLineId = mirrorOnLineId;
          var _fp5 = findShape(_firstPointId8).shape;
          _fp5.isSelected = true;
        }

        addNewShape({
          uniqueId: mirrorOnLineId,
          firstPointId: _firstPointId8,
          firstPointPlotted: false,
          linePlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId8]
        });
        localObj.currentUniqueId = _firstPointId8;
        newShapes.push(mirrorOnLineId);
        localObj.newShapeStarted = true;
      } else {
        _shapeData4.isSelected = false;
      }
    } else if (tool === "triangle" && point !== null) {
      var triangleId = ++localObj.uniqueId;

      var _segmentId = ++localObj.uniqueId;

      var _secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      newShapes.push(triangleId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _secondPointId,
          connectionId: [_segmentId, triangleId]
        });
      } else {
        updateConncId(shapesData[clickingOnExistingPoint], _segmentId);
      }

      addNewShape({
        uniqueId: triangleId,
        firstPointId: _secondPointId,
        firstSegmentPlotted: false,
        secondSegmentPlotted: false,
        thirdSegmentPlotted: false,
        x: point.x,
        y: point.y,
        connectionId: [_secondPointId]
      });
      addNewShape({
        type: "segment",
        uniqueId: _segmentId,
        triangleId: triangleId,
        secondPointId: _secondPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [_secondPointId]
      });
      localObj.currentUniqueId = _segmentId;
      newShapes.push(_segmentId);
    } else if (tool === "perpendicularBisector" && point !== null) {
      var _selectedShapeID4 = selectShape(e);

      var selectedShapeData = findShape(_selectedShapeID4).shape;

      if (clickingOnExistingPoint !== null) {
        var perpBId = ++localObj.uniqueId;

        var _firstPointId9 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

        if (selectedShapeData) {
          selectedShapeData.isSelected = false;
        }

        shapesData[clickingOnExistingPoint].isSelected = false;
        addNewShape({
          uniqueId: perpBId,
          type: "perpendicularBisector",
          firstPointId: _firstPointId9,
          firstPointPlotted: false,
          secondPointPlotted: false,
          connectionId: [_firstPointId9],
          mode: "point"
        });
        localObj.newShapeStarted = true;
        newShapes.push(perpBId);
        localObj.currentUniqueId = perpBId;
        var _fp6 = findShape(_firstPointId9).shape;
        _fp6.isSelected = true;
      } else if (_selectedShapeID4 !== null && selectedShapeData.type.includes("segment")) {
        selectedShapeData.isSelected = false;

        var _perpBId = ++localObj.uniqueId;

        var segment = selectedShapeData;
        selectedShapeData.perpBId = _perpBId;
        addNewShape({
          uniqueId: _perpBId,
          segmentId: selectedShapeData.uniqueId,
          segment: selectedShapeData,
          segmentPlotted: false,
          connectionId: [selectedShapeData.uniqueId],
          mode: "segment"
        });
        localObj.newShapeStarted = true;
        newShapes.push(_perpBId);
        localObj.currentUniqueId = _perpBId;
      }
    } else if (tool === "angleB" && point !== null) {
      var _selectedShapeID5 = selectShape(e);

      var _shapeData5 = findShape(_selectedShapeID5).shape;

      if (clickingOnExistingPoint !== null) {
        var angleBId = ++localObj.uniqueId;
        var _firstPointId10 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleBId);
        shapesData[clickingOnExistingPoint].angleBId = angleBId;
        shapesData[clickingOnExistingPoint].isSelected = true;
        addNewShape({
          uniqueId: angleBId,
          firstPointId: _firstPointId10,
          firstPointPlotted: false,
          secondPointPlotted: false,
          thirdPointPloted: false,
          x: point.x,
          y: point.y,
          mode: "point",
          connectionId: [_firstPointId10]
        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = angleBId;
        newShapes.push(angleBId);

        if (_selectedShapeID5 !== null && _shapeData5.type !== "point") {
          _shapeData5.isSelected = false;
        }
      } else if (_selectedShapeID5 !== null && _shapeData5.type.includes("segment")) {
        _shapeData5.isSelected = true;

        var _angleBId = ++localObj.uniqueId;

        var firstSegment = _shapeData5;
        _shapeData5.angleBId = _angleBId;
        addNewShape({
          uniqueId: _angleBId,
          firstSegmentId: _shapeData5.uniqueId,
          firstSegmentPlotted: false,
          secondSegmentPlotted: false,
          firstSegment: {
            x: firstSegment.x,
            y: firstSegment.y,
            xTo: firstSegment.xTo,
            yTo: firstSegment.yTo
          },
          x: _shapeData5.x,
          y: _shapeData5.y,
          mode: "segment",
          connectionId: [_shapeData5.uniqueId]
        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = _angleBId;
        newShapes.push(_angleBId);
      } else {}
    } else if (tool === "angleSize" && point !== null) {
      localObj.mouseDown.lastShapeCompleted = false;
      var angleSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null && point !== null) {
        var _firstPointId11 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleSizeId);
        shapesData[clickingOnExistingPoint].angleSizeId = angleSizeId;
        addNewShape({
          uniqueId: angleSizeId,
          firstPointId: _firstPointId11,
          firstPointPlotted: false,
          secondPointPlotted: false,
          degree: 0,
          clockwise: true,
          x: point.x,
          y: point.y,
          mode: "point",
          connectionId: [_firstPointId11]
        });
        localObj.currentUniqueId = _firstPointId11;
        newShapes.push(angleSizeId);
        localObj.newShapeStarted = true;
      } else {
        localObj.newShapeStarted = false;
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (tool === "segSize" && point !== null) {
      var segSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId12 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(segSizeId);
        shapesData[clickingOnExistingPoint].segSizeId = segSizeId;
        addNewShape({
          uniqueId: segSizeId,
          firstPointPlotted: false,
          firstPointId: _firstPointId12,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId12]
        });
        localObj.currentUniqueId = _firstPointId12;
        newShapes.push(segSizeId);
      } else {
        var _firstPointId13 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId13,
          segSizeId: segSizeId,
          connectionId: [segSizeId]
        });
        addNewShape({
          uniqueId: segSizeId,
          firstPointId: _firstPointId13,
          firstPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId13]
        });
        localObj.currentUniqueId = _firstPointId13;
      }

      var _fp7 = findShape(localObj.currentUniqueId);

      _fp7.isSelected = true;
      localObj.newPlottedShapes.push(segSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === "circleSize" && point !== null) {
      var circleSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId14 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(circleSizeId);
        shapesData[clickingOnExistingPoint].circleSizeId = circleSizeId;
        addNewShape({
          uniqueId: circleSizeId,
          firstPointPlotted: false,
          firstPointId: _firstPointId14,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId14]
        });
        localObj.currentUniqueId = _firstPointId14;
        newShapes.push(circleSizeId);
      } else {
        var _firstPointId15 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId15,
          circleSizeId: circleSizeId,
          connectionId: [circleSizeId]
        });
        addNewShape({
          uniqueId: circleSizeId,
          firstPointId: _firstPointId15,
          firstPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId15]
        });
        localObj.currentUniqueId = _firstPointId15;
      }

      var _fp8 = findShape(localObj.currentUniqueId);

      _fp8.isSelected = true;
      localObj.newPlottedShapes.push(circleSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === "circle" && point !== null) {
      var connectionId = [];

      var _firstPointId16 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _circleId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId16,
          connectionId: [_circleId],
          isSelected: true
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(_circleId);
        shapesData[clickingOnExistingPoint].isSelected = true;
      }

      if (clickingOnExistingPoint === null) {
        connectionId = [localObj.currentUniqueId];
      }

      addNewShape({
        uniqueId: _circleId,
        firstPointId: _firstPointId16,
        x: point.x,
        y: point.y,
        r: 0,
        connectionId: connectionId
      });
      localObj.currentUniqueId = _circleId;
      newShapes.push(_circleId);
    } else if (tool === "perpendicularLine" || tool === "parallelLine") {
      var _newShape;

      var perpendLineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId17 = localObj.currentUniqueId;
          _newShape = {
            firstPointId: _firstPointId17,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _d2 = getPLine(e, tool === "perpendicularLine");

        if (_d2) {
          _newShape = _d2;
          _newShape.lineToPoint = true;
          var parentLine = findShape(_newShape.line);

          if (parentLine) {
            parentLine.shape.connectionId.push(perpendLineId);
            parentLine.shape.isSelected = true;
          }
        } else {
          var _firstPointId18 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId18,
            connectionId: [perpendLineId]
          });
          newShapes.push(_firstPointId18);
          _newShape = {
            firstPointId: _firstPointId18,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      }

      if (_newShape.pointToLine) {
        var _point = findShape(_newShape.firstPointId).shape;
        _point.isSelected = true;
      }

      _newShape.firstPointPlotted = false;
      _newShape.connectionId = [];
      _newShape.uniqueId = perpendLineId;
      localObj.currentUniqueId = perpendLineId;
      newShapes.push(_newShape.uniqueId);
      addNewShape(_newShape);
    } else if (tool === "brush1" || tool === "brush2" || tool === "brush3") {
      localObj.currentUniqueId = selectShape(e);
    } else if (tool === "select" || tool === "move") {
      localObj.currentUniqueId = moveShape(e);
    }
  } // =================================================


  function onMouseMove(e) {
    if (!localObj.mouseDown.lastShapeCompleted) {
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor: 'pointer'
      // });
      onPressMove(e);
    } else {// let cursor = 'default';
      // let downCursor = 'default';
      // if (isOnShape(e) !== null) {
      //   cursor = 'pointer';
      //   downCursor = 'pointer';
      // }
      // if (modelObj.interactionType === 'moveGraph') {
      //   cursor = 'grab';
      //   downCursor = 'grabbing';
      // }
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor,
      //   downCursor
      // });
    }
  }

  function onPressMove(e) {
    var tool = modelObj.interactionType;
    var shapesData = modelObj.interactionElements;
    var currentShape = localObj.currentUniqueId !== null ? findShape(localObj.currentUniqueId).shape : findShape(localObj.uniqueId).shape;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point);

    if (e.subId === "scale1" || e.subId === "scale2") {
      if (e.subId === "scale1") {
        scaleObj.x = point.x;
        scaleObj.y = point.y;
        dispatchEventScale();
      } else if (e.subId === "scale2") {
        scaleObj.xTo = point.x;
        scaleObj.yTo = point.y;
        dispatchEventScale();
      }
    } else {
      if (point === null || localObj.mouseDown.objectDown && !(currentShape && (currentShape.isDraggable === undefined || currentShape.isDraggable))) {
        if (!(tool === "move" && localObj.isLableSelected)) {
          console.info("rejected");
          return false;
        }
      }

      if (tool === "point") {
        if (currentShape.type == "point" && currentShape.connectionId.length == 0) {
          updatePointValues(currentShape, {
            x: point.x,
            y: point.y
          });
        }
      } else if (tool.includes("segment")) {
        currentShape.xTo = point.x;
        currentShape.yTo = point.y;
      } else if (tool === "length") {
        if (currentShape && currentShape.type === "length" && currentShape.secondPointId === undefined) {
          currentShape.xTo = point.x;
          currentShape.yTo = point.y;
        }
      } else if (tool === "compass") {
        if (currentShape && currentShape.type === "compass") {
          if (!currentShape.isPloted) {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
          } else {
            currentShape.x = point.x;
            currentShape.y = point.y;
          }
        }
      } else if (tool === "line") {
        var line = shapesData[shapesData.length - 1];
        line.xTo = point.x;
        line.yTo = point.y;
        updateLinePoints(line);
      } else if (tool === "ray") {
        var ray = shapesData[shapesData.length - 1];
        ray.xTo = point.x;
        ray.yTo = point.y;
        updateLinePoints(ray);
      } else if (tool === "angleRay") {
        if (currentShape) {
          var angleRay = findShape(currentShape.angleRayId).shape;

          if (!angleRay.firstRayPlotted) {
            currentShape.x = point.x;
            currentShape.y = point.y;
            updateLinePoints(currentShape);
          } else {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
            angleRay.thirdPoint = {
              x: point.x,
              y: point.y
            };
            updateLinePoints(currentShape);
          }
        }
      } else if (tool === "triangle") {
        if (currentShape) {
          var triangle = findShape(currentShape.triangleId).shape;

          if (!triangle.firstSegmentPlotted) {
            currentShape.x = point.x;
            currentShape.y = point.y;
          } else {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
            triangle.thirdPoint = {
              x: point.x,
              y: point.y
            };
          }
        }
      } else if (tool === "angle") {// if (currentShape && localObj.mouseDown.isMouseDown) {
        //   currentShape.x = point.x;
        //   currentShape.y = point.y;
        // }
      } else if (tool === "circle_3") {
        var index;

        for (var i = shapesData.length - 1; i >= 0; i--) {
          if (shapesData[i].type === "circle_3") {
            index = i;
            break;
          }
        }

        var _currentShape = shapesData[index];
        var cData = {};

        if (_currentShape.type === "circle_3" && _currentShape.secondPointPlotted !== false) {
          if (_currentShape.firstPointPlotted !== undefined && _currentShape.secondPointPlotted !== undefined) {
            var fp = findShape(_currentShape.firstPointId).shape;
            var sp = findShape(_currentShape.secondPointId).shape;
            cData = circle3Handler(fp, sp, point);
          }

          _currentShape.x = cData.x;
          _currentShape.y = cData.y;
          _currentShape.r = cData.r;
        }
      } // else if( tool === 'angleB'){
      //   let angleBisectorData={};
      //   if(currentShape.type==='angleB' && currentShape.secondPointPlotted !== false){
      //     if (currentShape.firstPointPlotted !== undefined && currentShape.secondPointPlotted !== undefined) {
      //       const fp = findShape(currentShape.firstPointId).shape;
      //       const sp = findShape(currentShape.secondPointId).shape;
      //       angleBisectorData = calculateBisector({firstPoint:fp, secondPoint:sp, thirdPoint:point});
      //     }
      //     currentShape.x = angleBisectorData.bisectorLine.x;
      //     currentShape.y = angleBisectorData.bisectorLine.y;
      //     currentShape.xTo = angleBisectorData.bisectorLine.xTo;
      //     currentShape.yTo= angleBisectorData.bisectorLine.yTo;
      //   }
      // }
      else if (tool === "circle") {
          var lastShape = shapesData[shapesData.length - 1];
          lastShape.r = Math.abs(modelObj.LabComClass.Maths.getDistance({
            x: lastShape.x,
            y: lastShape.y
          }, point));
          dispatchEventCircleMove(lastShape);
        } else if (tool === "perpendicularLine" || tool === "parallelLine") {
          if (localObj.mouseDown.isMouseDown) {
            if (currentShape.pointToLine && !currentShape.firstPointPlotted && currentShape.firstPointId !== undefined) {
              if (localObj.newPlottedShapes.includes(currentShape.firstPointId)) {
                var pointShape = findShape(currentShape.firstPointId).shape;
                pointShape.x = point.x;
                pointShape.y = point.y;
              }
            }
          }

          if (currentShape.lineToPoint) {
            currentShape.x = point.x;
            currentShape.y = point.y;
            updatePLinePoints(currentShape);
          }
        } else if (tool === "move" && !localObj.mouseDown.objectDown || tool === "moveGraph") {
          if (localObj.mouseDown.isMouseDown) {
            var _diffX = 0;
            var _diffY = 0;
            _diffX = e.pageX - localObj.mouseDown.x;
            _diffY = e.pageY - localObj.mouseDown.y;
            localObj.mouseDown.x = e.pageX;
            localObj.mouseDown.y = e.pageY;

            if (typeof events[tool] !== "undefined") {
              events[tool]({
                id: modelObj.id,
                type: "moveGraph",
                data: {
                  x: _diffX,
                  y: _diffY
                }
              }, true);
            }
          }
        } else if (tool === "select" || tool === "move" && localObj.mouseDown.objectDown) {
          if ((modelObj.shapesEditable || localObj.isLableSelected) && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown) {
            var _diffX2 = 0;
            var _diffY2 = 0;
            _diffX2 = e.pageX - localObj.mouseDown.x;
            _diffY2 = e.pageY - localObj.mouseDown.y;
            var center = getPixelByPoint(0, 0);
            var diffValueInPoint = getPointByPixel(center.x + _diffX2, center.y + _diffY2);
            _diffX2 = diffValueInPoint.x;
            _diffY2 = diffValueInPoint.y;

            if (localObj.isLableSelected) {
              for (var _i = 0; _i < shapesData.length; _i++) {
                var _d = shapesData[_i];
                var lablePos = getPixelByPoint(_d.labelX, _d.labelY);
                var pixelDiff = {
                  x: e.pageX - lablePos.x,
                  y: e.pageY - lablePos.y
                };

                if (_d.isSelected) {
                  updateDiff(_d, pixelDiff);
                  break;
                }
              }
            } else {
              for (var _i2 = 0; _i2 < shapesData.length; _i2++) {
                shapesData[_i2].isMoved = false;
              }

              for (var _i3 = 0; _i3 < shapesData.length; _i3++) {
                var _d3 = shapesData[_i3];

                if (_d3.isDraggable !== undefined && !_d3.isDraggable) {
                  continue;
                }

                if (_d3.isSelected && !_d3.isMoved) {
                  _d3.isMoved = true;

                  if (_d3.type === "point") {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;

                    if (tool === "move") {
                      _d3.x = point.x;
                      _d3.y = point.y;
                    }

                    updatePoints(_d3);
                  } else if (_d3.type.includes("segment")) {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;
                    _d3.xTo += _diffX2;
                    _d3.yTo += _diffY2;
                  } else if (_d3.type === "line" || _d3.type === "ray") {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;
                    _d3.xTo += _diffX2;
                    _d3.yTo += _diffY2;
                    updateLinePoints(shapesData[_i3]);
                  } else if (_d3.type === "circle") {
                    var centerPoint = findShape(_d3.firstPointId);
                    var endPoint = findShape(_d3.secondPointId);

                    if (centerPoint && endPoint) {
                      if (findDraggable([centerPoint.shape, endPoint.shape])) {
                        if (!centerPoint.shape.isMoved) {
                          updateShapeValue(centerPoint.shape, {
                            x: centerPoint.shape.x + _diffX2,
                            y: centerPoint.shape.y + _diffY2
                          });
                          centerPoint.isMoved = true;
                        }

                        if (!endPoint.shape.isMoved) {
                          updateShapeValue(endPoint.shape, {
                            x: endPoint.shape.x + _diffX2,
                            y: endPoint.shape.y + _diffY2
                          });
                          endPoint.isMoved = true;
                        }
                      }
                    }
                  } else if (_d3.type === "compass") {
                    var _centerPoint = findShape(_d3.centerPointId);

                    if (_centerPoint) {
                      updateShapeValue(_centerPoint.shape, {
                        x: _centerPoint.shape.x + _diffX2,
                        y: _centerPoint.shape.y + _diffY2
                      });
                    }
                  } else if (_d3.type === "perpendicularLine" || _d3.type === "parallelLine") {// _d.x += _diffX;
                    // _d.y += _diffY;
                    // _d.xTo += _diffX;
                    // _d.yTo += _diffY;
                    // updatePLinePoints(shapesData[i]);
                  }
                }
              }

              for (var _i4 = 0; _i4 < shapesData.length; _i4++) {
                var _d4 = shapesData[_i4];

                if (_d4.isSelected) {
                  if (_d4.type === "point") {
                    if (_d4.connectionId.length > 0) {
                      updateShapes(_d4, _diffX2, _diffY2);
                    }
                  }

                  if (_d4.type.includes("segment") || _d4.type === "line" || _d4.type === "ray") {
                    if (_d4.connectionId.length > 0) {
                      updateShapes(_d4, _diffX2, _diffY2);
                    }
                  }
                }
              }
            }
          } else if (tool === "select") {
            var _localObj$mouseDown2 = localObj.mouseDown,
                orignalX = _localObj$mouseDown2.orignalX,
                orignalY = _localObj$mouseDown2.orignalY,
                x = _localObj$mouseDown2.x,
                y = _localObj$mouseDown2.y;
            selectObjectsInPixelRange(orignalX, orignalY, x, y);
          }

          localObj.mouseDown.x = e.pageX;
          localObj.mouseDown.y = e.pageY;
        }

      updateAllShapes(e);
      updateAllShapes(e);
    }

    return true;
  }

  function updateDiff(_d, newPos) {
    var max = 50;
    var min = -50;
    _d.labelDiffX = newPos.x;
    _d.labelDiffY = newPos.y; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffX = _d.labelDiffX > max ? max : _d.labelDiffX < min ? min : _d.labelDiffX; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffY = _d.labelDiffY > max ? max : _d.labelDiffY < min ? min : _d.labelDiffY;
  }

  this.setSegmentColor = function (color) {
    modelObj.segmentColor = color;
  };

  this.getSegmentColor = function (color) {
    return modelObj.segmentColor;
  };

  this.updateShape = function (uniqueId, _obj) {
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        shape.shape[i] = _obj[i];
      });
    }
  };

  function updatePointValues(target, values) {
    var update = false;

    if (findDraggable([target])) {
      if (target.isIntersection) {
        if (target.circle1 !== undefined && target.circle2 !== undefined) {
          update = true;
        } else {
          update = true;
        }
      } else {
        update = true;
      }
    }

    if (target.x === values.x && target.y === values.y) {
      update = true;
    }

    if (update) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }

    return update;
  }

  function selectObjectsInPixelRange(x, y, maxX, maxY) {
    if (x > maxX) {
      var temp = x;
      x = maxX;
      maxX = temp;
      temp = y;
      y = maxY;
      maxY = temp;
    }

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var shape = modelObj.interactionElements[i];

      if (shape.type === "point") {
        if (!shape.isSelected) {
          var pos = getPixelByPoint(shape.x, shape.y);

          if (pos.x >= x && pos.x <= maxX && pos.y >= y && pos.y <= maxY) {
            shape.isSelected = true;
          }
        }
      }
    }
  }

  function updateAllShapes(e) {
    var _modelObj$LabComClass = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass.getDistance,
        getAngle = _modelObj$LabComClass.getAngle,
        getPoint = _modelObj$LabComClass.getPoint,
        pointInSegment = _modelObj$LabComClass.pointInSegment,
        getLineintersect = _modelObj$LabComClass.getLineintersect,
        getLinePointIntersection = _modelObj$LabComClass.getLinePointIntersection;

    var _loop2 = function _loop2(i) {
      var shape = modelObj.interactionElements[i];

      if (shape.type.includes("segment") || shape.type === "length" || shape.type === "line" || shape.type === "ray") {
        var firstPoint, secondPoint;
        var label = null;

        if (shape.firstPointId) {
          firstPoint = findShape(shape.firstPointId);

          if (firstPoint) {
            label = firstPoint.shape.label;
            updateShapeValue(shape, {
              x: firstPoint.shape.x,
              y: firstPoint.shape.y
            });
          }
        }

        if (shape.secondPointId) {
          secondPoint = findShape(shape.secondPointId);

          if (secondPoint) {
            if (label) {
              label += secondPoint.shape.label;

              if (shape.label === undefined) {
                shape.label = label;
              }
            }

            updateShapeValue(shape, {
              xTo: secondPoint.shape.x,
              yTo: secondPoint.shape.y
            });
          }
        }

        if (shape.type === "line" || shape.type === "ray") {
          updateLinePoints(shape);
        }

        if (shape.type.includes("segment")) {
          var distancePos = {
            x: (shape.x + shape.xTo) / 2,
            y: (shape.y + shape.yTo) / 2
          };
          shape.labelX = distancePos.x;
          shape.labelY = distancePos.y;
          shape.distance = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        }

        if (shape.type.includes("segment") && shape.firstPointId && shape.secondPointId) {
          if (firstPoint.shape.visible && secondPoint.shape.visible) {
            shape.visible = true;
          } else {
            shape.visible = false;
          }
        }

        if (shape.type === "length") {
          var text = "";

          if (shape.segmentID) {
            var segment = findShape(shape.segmentID);

            if (segment && segment.shape) {
              shape.x = segment.shape.x;
              shape.xTo = segment.shape.xTo;
              shape.y = segment.shape.y;
              shape.yTo = segment.shape.yTo;

              var _firstPoint = findShape(segment.shape.firstPointId);

              var _secondPoint = findShape(segment.shape.secondPointId);

              if (_firstPoint && _firstPoint.shape && _secondPoint && _secondPoint.shape) {
                if (_firstPoint.shape.label !== "" && _secondPoint.shape.label !== "") {
                  text = _firstPoint.shape.label + "" + _secondPoint.shape.label;
                }
              } else if (segment.shape.label) {
                text = segment.shape.label;
              }
            }
          } else if (shape.circleId) {
            var circle = findShape(shape.circleId);

            if (circle && circle.shape) {
              shape.x = circle.shape.x;
              shape.xTo = circle.shape.x + circle.shape.r;
              shape.y = circle.shape.y;
              shape.yTo = circle.shape.y;
              text = "C";
            }
          } else {
            if (!shape.labelText) {
              var _firstPoint2 = findShape(shape.firstPointId);

              var _secondPoint2 = findShape(shape.secondPointId);

              if (_firstPoint2 && _firstPoint2.shape && _secondPoint2 && _secondPoint2.shape) {
                if (_firstPoint2.shape.label !== "" && _secondPoint2.shape.label !== "") {
                  text = _firstPoint2.shape.label + "" + _secondPoint2.shape.label;
                }
              }
            } else {
              text = shape.labelText;
            }
          }

          if (shape.circleId !== undefined) {
            shape.circumference = 2 * Math.PI * (shape.xTo - shape.x); //Circumference

            if (modelObj.shapes.length.digit !== undefined) {
              shape.circumference = Number(shape.circumference.toFixed(modelObj.shapes.length.digit));
            }

            var _distancePos = {
              x: shape.pointX,
              y: shape.pointY
            };

            if (text && !modelObj.shapes.length.onlyDistance) {
              shape.label = "".concat(text, " = ") + shape.circumference.toString().replace(".", ",");
            } else if (text && modelObj.shapes.length.onlyDistance) {
              shape.label = shape.circumference.toString().replace(".", ",");
              shape.distanceText = shape.circumference;
            }

            shape.labelX = _distancePos.x;
            shape.labelY = _distancePos.y;

            if (shape.labelDiffX === undefined) {
              shape.labelDiffX = 0;
              shape.labelDiffY = 0;
            }
          } else {
            shape.distance = getDistance(shape, {
              x: shape.xTo,
              y: shape.yTo
            });

            if (modelObj.shapes.length.digit !== undefined) {
              shape.distance = Number(shape.distance.toFixed(modelObj.shapes.length.digit));
            }

            var _distancePos2 = {
              x: (shape.x + shape.xTo) / 2,
              y: (shape.y + shape.yTo) / 2
            };

            if (text && !modelObj.shapes.length.onlyDistance) {
              shape.label = "\xA7d".concat(text, "\xA7r = ") + shape.distance.toString().replace(".", ",");
            } else if (text && modelObj.shapes.length.onlyDistance) {
              shape.label = shape.distance.toString().replace(".", ",");
              shape.labelFor = text;
              shape.distanceText = shape.distance;
            } else if (text === "" && shape.firstPointId !== undefined && shape.secondPointId !== undefined || shape.segmentID !== undefined) {
              shape.label = shape.distance.toString().replace(".", ",");
            }

            shape.labelX = _distancePos2.x;
            shape.labelY = _distancePos2.y;

            if (shape.labelDiffX === undefined) {
              shape.labelDiffX = 0;
              shape.labelDiffY = 0;
            }
          }
        }
      }

      if (shape.type === "angleRay") {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint3 = findShape(shape.firstPointId).shape;
          var _secondPoint3 = findShape(shape.secondPointId).shape;
          var thirdPoint;

          if (shape.thirdPointId !== undefined) {
            thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            thirdPoint = shape.thirdPoint;
          }

          if (thirdPoint) {
            shape.x = _secondPoint3.x;
            shape.y = _secondPoint3.y;
            var firstRay = new modelObj.LabComClass.Vector(_secondPoint3.x - _firstPoint3.x, _secondPoint3.y - _firstPoint3.y);
            var secondRay = new modelObj.LabComClass.Vector(thirdPoint.x - _firstPoint3.x, thirdPoint.y - _firstPoint3.y);
            shape.angle = secondRay.crossProduct(firstRay).z; // shape.angle *= (Math.PI / 180);
            // if (shape.angle < 0) {
            //   shape.angle += (Math.PI * 2);
            // }

            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, thirdPoint.x, thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, _firstPoint3.x, _firstPoint3.y);
            var angle = shape.endAngle - shape.startAngle;

            if (angle < 0) {
              angle = angle * -1 * 180 / Math.PI;
            } else if (angle > 0) {
              angle = 360 - angle * 180 / Math.PI;
            }

            shape.labelX = shape.x + getPointUnitByPixelUnit(10);
            shape.labelY = shape.y - getPointUnitByPixelUnit(10);
            shape.angleText = "" + Math.round(angle);
            shape.angleValue = Math.round(angle);
          }
        }
      }

      if (shape.type === "angleB") {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var fp = findShape(shape.firstPointId).shape;
          var sp = findShape(shape.secondPointId).shape;
          var tp;

          if (shape.thirdPointId !== undefined) {
            tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            tp = shape.thirdPoint;
          }

          if (tp) {
            var angleBisectorData = calculateBisector({
              firstPoint: fp,
              secondPoint: sp,
              thirdPoint: tp
            });
            shape.x = angleBisectorData.bisectorLine.x;
            shape.y = angleBisectorData.bisectorLine.y;
            shape.xTo = angleBisectorData.bisectorLine.xTo;
            shape.yTo = angleBisectorData.bisectorLine.yTo;
          }
        }
      }

      if (shape.type === "mirrorOnLine") {
        if (shape.line !== undefined && shape.linePlotted) {
          var eqnLine = computeEqn(shape.line);
          var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, shape.x, shape.y);
          shape.x = mirrorPoint.x;
          shape.y = mirrorPoint.y;
        }
      }

      if (shape.type === "circle_3") {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _fp9 = findShape(shape.firstPointId).shape;
          var _sp = findShape(shape.secondPointId).shape;

          var _tp;

          if (shape.thirdPointId !== undefined) {
            _tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _tp = shape.thirdPoint;
          }

          if (_tp) {
            var cData = circle3Handler(_fp9, _sp, _tp);
            shape.x = cData.x;
            shape.y = cData.y;
            shape.r = cData.r;
          }
        }
      }

      if (shape.type === "angle") {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint4 = findShape(shape.firstPointId).shape;
          var _secondPoint4 = findShape(shape.secondPointId).shape;

          var _thirdPoint;

          if (shape.thirdPointId !== undefined) {
            _thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _thirdPoint = shape.thirdPoint;
          }

          if (_thirdPoint) {
            shape.x = _secondPoint4.x;
            shape.y = _secondPoint4.y;

            var _firstRay = new modelObj.LabComClass.Vector(_secondPoint4.x - _firstPoint4.x, _secondPoint4.y - _firstPoint4.y);

            var _secondRay = new modelObj.LabComClass.Vector(_thirdPoint.x - _firstPoint4.x, _thirdPoint.y - _firstPoint4.y);

            shape.angle = _secondRay.crossProduct(_firstRay).z;
            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y);

            var _angle3 = shape.endAngle - shape.startAngle;

            if (_angle3 < 0) {
              _angle3 = _angle3 * -1 * 180 / Math.PI;
            } else if (_angle3 > 0) {
              _angle3 = 360 - _angle3 * 180 / Math.PI;
            }

            shape.angleText = "" + Math.round(_angle3);
            shape.angleValue = Math.round(_angle3);
            shape.labelX = shape.x + getPointUnitByPixelUnit(10);
            shape.labelY = shape.y - getPointUnitByPixelUnit(10);
          }
        }
      }

      if (shape.type === "midPoint") {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint5 = findShape(shape.firstPointId).shape;
          var _secondPoint5 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint5.x + _secondPoint5.x) / 2;
          shape.y = (_firstPoint5.y + _secondPoint5.y) / 2;
        }
      } else if (shape.type === "triangle") {
        var _firstPoint6 = findShape(shape.firstPointId).shape;
        var _secondPoint6 = findShape(shape.secondPointId).shape;
        var _thirdPoint2 = findShape(shape.thirdPointId).shape;

        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined && shape.thirdPointId !== undefined) {
          shape.firstPoint = {
            x: _firstPoint6.x,
            y: _firstPoint6.y,
            label: _firstPoint6.label
          };
          shape.secondPoint = {
            x: _secondPoint6.x,
            y: _secondPoint6.y,
            label: _secondPoint6.label
          };
          shape.thirdPoint = {
            x: _thirdPoint2.x,
            y: _thirdPoint2.y,
            label: _thirdPoint2.label
          };
          shape.firstSegmentPlotted = true;
          shape.secondSegmentPlotted = true;
          shape.thirdSegmentPlotted = true;
        }
      } else if (shape.type === "compass") {
        if (shape.segmentID !== undefined) {
          var _segment = findShape(shape.segmentID);

          if (_segment && _segment.shape) {
            shape.r = getDistance(_segment.shape, {
              x: _segment.shape.xTo,
              y: _segment.shape.yTo
            });
          }
        } else if (shape.circleID !== undefined) {
          var _circle = findShape(shape.circleID);

          if (_circle) {
            shape.r = _circle.shape.r;
          }
        } else if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint7 = findShape(shape.firstPointId);

          var _secondPoint7 = findShape(shape.secondPointId);

          if (_firstPoint7 && _secondPoint7) {
            shape.r = getDistance(_firstPoint7.shape, _secondPoint7.shape);
          }
        } else {
          shape.r = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        }

        if (shape.centerPointId !== undefined) {
          var centerPoint = findShape(shape.centerPointId).shape;

          if (centerPoint) {
            updateShapeValue(shape, {
              x: centerPoint.x,
              y: centerPoint.y
            });
          }
        } // shape.r = getDistance(shape, { x: shape.xTo, y: shape.yTo });

      } else if (shape.type === "point" && modelObj.interactionType !== "angle") {
        if (shape.firstPointPlotted && shape.secondPointPlotted && !shape.onSegment) {
          var _firstPoint8 = findShape(shape.firstPointId).shape;
          var _secondPoint8 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint8.x + _secondPoint8.x) / 2;
          shape.y = (_firstPoint8.y + _secondPoint8.y) / 2;
        }

        if (shape.onSegment) {
          shape.x = (shape.firstPointCoords.x + shape.secondPointCoords.x) / 2;
          shape.y = (shape.firstPointCoords.y + shape.secondPointCoords.y) / 2;
        }

        if (shape.isIntersection) {
          if (shape.l1 !== undefined && shape.l2 !== undefined) {
            var l1 = findShape(shape.l1);
            var l2 = findShape(shape.l2);

            if (l1 && l2) {
              l1 = l1.shape;
              l2 = l2.shape;
              var p = getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);

              if (!p.onLine1 && l1.type.includes("segment") || !p.onLine2 && l2.type.includes("segment")) {
                shape.visible = false;
              } else {
                shape.visible = true;
              }

              updateShapeValue(shape, {
                x: p.x,
                y: p.y
              });
            }
          }

          if (shape.circle !== undefined && shape.line !== undefined) {
            var _circle2 = findShape(shape.circle);

            var line = findShape(shape.line);

            if (_circle2 && line) {
              _circle2 = _circle2.shape;
              line = line.shape;
              var data = getInteractionOfCircleLine(_circle2, line, shape);

              if (data !== null) {
                updateShapeValue(shape, {
                  x: data.x,
                  y: data.y
                });
                shape.visible = true;
              } else {
                shape.visible = false;
              }
            }
          }

          if (shape.circle1 !== undefined && shape.circle2 !== undefined) {
            var circle1 = findShape(shape.circle1);
            var circle2 = findShape(shape.circle2);

            if (circle1 && circle2) {
              circle1 = circle1.shape;
              circle2 = circle2.shape;

              var _data2 = getInteractionOfTwoCircles(circle1, circle2, shape, false, true);

              if (_data2 && _data2.x !== undefined && !isNaN(_data2.x)) {
                shape.visible = checkForCorrectIntersection(shape, circle1, circle2, _data2);
              } else {
                shape.visible = false;
              }
            }
          }
        }

        if (shape.isParameter && modelObj.shapesEditable) {
          if (shape.line !== undefined) {
            var _line = findShape(shape.line);

            if (_line) {
              _line = _line.shape;
              var dist = getDistance(_line, {
                x: _line.xTo,
                y: _line.yTo
              });
              var lineAngle = getAngle(_line.x, _line.y, _line.xTo, _line.yTo);
              var newData = {};
              var distFromFirstPoint = shape.pointAngle ? dist * shape.percentage : dist * shape.percentage * -1;

              if (e && shape.isSelected && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown) {
                var mouse = getPointByPixel(e.pageX, e.pageY);
                var intersection = getLinePointIntersection(_line, {
                  x: _line.xTo,
                  y: _line.yTo
                }, mouse);
                var intersectionDist = getDistance(_line, intersection);
                newData.pointAngle = getAngle(_line.x, _line.y, intersection.x, intersection.y);
                newData.pointAngle = Math.round(newData.pointAngle) === Math.round(lineAngle);
                newData.percentage = intersectionDist / dist;
                distFromFirstPoint = newData.pointAngle ? dist * newData.percentage : dist * newData.percentage * -1;
              }

              var _p8 = getPoint(_line, lineAngle, distFromFirstPoint);

              newData.x = _p8.x;
              newData.y = _p8.y;
              var setValues = true;

              if (_line.type.includes("segment") || _line.type === "ray") {
                var endPoint = {
                  x: _line.xTo,
                  y: _line.yTo
                };

                if (_line.type === "ray") {
                  endPoint = {
                    x: _line.xOr,
                    y: _line.yOr
                  };
                }

                setValues = pointInSegment(_p8, _line, endPoint);

                if (!setValues) {
                  var dist1 = getDistance(_p8, _line);
                  var dist2 = getDistance(_p8, endPoint);

                  if (dist1 < dist2) {
                    newData.x = _line.x;
                    newData.y = _line.y;
                  } else {
                    newData.x = endPoint.x;
                    newData.y = endPoint.y;
                  }
                }
              }

              Object.keys(newData).forEach(function (i) {
                shape[i] = newData[i];
              });
            }
          }

          if (shape.circle !== undefined) {
            var _circle3 = findShape(shape.circle);

            if (_circle3) {
              _circle3 = _circle3.shape;

              if (e && shape.isSelected && localObj.mouseDown.objectDown) {
                var _mouse = getPointByPixel(e.pageX, e.pageY);

                shape.angle = getAngle(_circle3.x, _circle3.y, _mouse.x, _mouse.y);
              }

              var newP = getPoint(_circle3, shape.angle, _circle3.r);
              updateShapeValue(shape, {
                x: newP.x,
                y: newP.y
              });
            }
          }
        }

        for (var j = 0; j < shape.connectionId.length; j++) {
          var shapeData = findShape(shape.connectionId[j]);

          if (shapeData.shape) {
            if (shapeData.shape.type === "perpendicularLine" || shapeData.shape.type === "parallelLine") {
              shapeData.shape.visible = shape.visible;
              updateShapeValue(shapeData.shape, {
                x: shape.x,
                y: shape.y
              });
              updatePLinePoints(shapeData.shape);
            } else if (shapeData.shape.type === "circle") {
              updateCircle(shapeData.shape);
            }
          }
        }
      } else if (shape.type === "perpendicularLine" || shape.type === "parallelLine") {
        updatePLinePoints(shape);
      } else if (shape.type === "circle") {
        updateCircle(shape);
      }

      if (shape && shape.label !== undefined) {
        if (shape.labelX === undefined) {
          shape.labelX = shape.x;
          shape.labelY = shape.y;
        }

        if (shape.labelDiffX === undefined) {
          shape.labelDiffX = 0;
          shape.labelDiffY = 0;
        }
      }
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      _loop2(i);
    }
  }

  function circle3Handler(fp, sp, tp) {
    var p1 = {},
        p2 = {},
        coords = {};
    p1.x = (fp.x + sp.x) / 2;
    p1.y = (fp.y + sp.y) / 2;
    p2.x = (sp.x + tp.x) / 2;
    p2.y = (sp.y + tp.y) / 2;
    p1.m = to2Dec((sp.y - fp.y) / (sp.x - fp.x));
    p2.m = to2Dec((tp.y - sp.y) / (tp.x - sp.x));
    p1.slope = to2Dec(-1 / p1.m);
    p2.slope = to2Dec(-1 / p2.m);
    var p1Val = getPLineCoeff(p1); // getPerpendicular Line

    var p2Val = getPLineCoeff(p2); // getPerpendicular Line

    coords.x = (p1Val.b * p2Val.c - p2Val.b * p1Val.c) / (p1Val.a * p2Val.b - p2Val.a * p1Val.b);
    coords.y = (p1Val.c * p2Val.a - p2Val.c * p1Val.a) / (p1Val.a * p2Val.b - p2Val.a * p1Val.b);
    coords.r = modelObj.LabComClass.Maths.getDistance(coords, fp);
    return {
      x: coords.x,
      y: coords.y,
      r: coords.r
    };
  }

  function getPLineCoeff(p) {
    var eqn = {};

    if (!isFinite(p.slope)) {
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -p.x;
    } else {
      eqn.eqn = "(y-".concat(p.y, "=").concat(p.slope, "(x-").concat(p.x, "))");
      eqn.a = -p.slope;
      eqn.b = 1;
      eqn.c = to2Dec(-p.slope * -p.x - p.y);
    }

    return eqn;
  }

  function circle3HandlerOld(fp, sp, tp) {
    var p1 = {},
        p2 = {},
        coords = {};
    p1.x = (fp.x + sp.x) / 2;
    p1.y = (fp.y + sp.y) / 2;
    p2.x = (sp.x + tp.x) / 2;
    p2.y = (sp.y + tp.y) / 2;
    p1.m = to2Dec((sp.y - fp.y) / (sp.x - fp.x));
    p2.m = to2Dec((tp.y - sp.y) / (tp.x - sp.x));
    p1.slope = to2Dec(-1 / p1.m);
    p2.slope = to2Dec(-1 / p2.m);
    p1.eqn = "(y-".concat(p1.y, "=").concat(p1.slope, "(x-").concat(p1.x, "))");
    p1.a = -p1.slope;
    p1.b = 1;
    p1.c = to2Dec(-p1.slope * -p1.x - p1.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    p2.eqn = "(y-".concat(p2.y, "=").concat(p2.slope, "(x-").concat(p2.x, "))");
    p2.a = -p2.slope;
    p2.b = 1;
    p2.c = to2Dec(-p2.slope * -p2.x - p2.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    coords.x = (p1.b * p2.c - p2.b * p1.c) / (p1.a * p2.b - p2.a * p1.b);
    coords.y = (p1.c * p2.a - p2.c * p1.a) / (p1.a * p2.b - p2.a * p1.b);
    coords.r = modelObj.LabComClass.Maths.getDistance(coords, fp);
    return {
      x: coords.x,
      y: coords.y,
      r: coords.r
    };
  }

  function to2Dec(num) {
    return Math.round(num * 100) / 100;
  }

  function updateCircle(shape) {
    if (shape.type === "circle") {
      if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
        var firstPoint = findShape(shape.firstPointId);
        var secondPoint = findShape(shape.secondPointId);

        if (firstPoint && secondPoint) {
          shape.x = firstPoint.shape.x;
          shape.y = firstPoint.shape.y;
          shape.r = modelObj.LabComClass.Maths.getDistance(firstPoint.shape, secondPoint.shape);
        }
      }
    }
  }

  function checkForCorrectIntersection(currentShape, circle1, circle2, newData) {
    var Vector = modelObj.LabComClass.Vector;

    if (currentShape.visible) {
      currentShape.x = newData.x;
      currentShape.y = newData.y;

      var _centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);

      var _firstIntersectLine = new Vector(newData.x - circle1.x, newData.y - circle1.y);

      currentShape.angle1 = _centerPointsLine.crossProduct(_firstIntersectLine).z;
      return true;
    }

    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length < 2) {
      return false;
    }

    if (modelObj.LabComClass.Maths.getDistance(intersection[0], intersection[1]) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      return false;
    }

    var centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);
    var firstIntersectLine = new Vector(intersection[0].x - circle1.x, intersection[0].y - circle1.y); // const secondIntersectLine = new Vector(intersection[1].x - circle1.x, intersection[1].y - circle1.y);

    var angle1 = centerPointsLine.crossProduct(firstIntersectLine).z; // const angle2 = centerPointsLine.crossProduct(secondIntersectLine).z;

    if (currentShape.angle1 < 0 && angle1 < 0 || currentShape.angle1 > 0 && angle1 > 0) {
      // currentShape.intersectAngle = angle1;
      currentShape.x = intersection[0].x;
      currentShape.y = intersection[0].y;
    } else {
      // currentShape.intersectAngle = angle2;
      currentShape.x = intersection[1].x;
      currentShape.y = intersection[1].y;
    }

    return true;
  } // vertical intsectin is not getting detected in circle line intersect


  function findCircleLineIntersect(circle, line) {
    return modelObj.LabComClass.Maths.findCircleLineIntersect({
      x: circle.x,
      y: circle.y,
      r: circle.r
    }, {
      x: line.x,
      y: line.y
    }, {
      x: line.xTo,
      y: line.yTo
    });
  }

  function findDraggable(elems) {
    var draggable = true;

    if (Array.isArray(elems)) {
      for (var i = 0; i < elems.length; i++) {
        if (elems[i] === undefined || !(elems[i].isDraggable === undefined || elems[i].isDraggable)) {
          draggable = false;
          break;
        }
      }
    } else if (!(elems.isDraggable === undefined || elems.isDraggable)) {
      draggable = false;
    }

    return draggable;
  }

  function updateShapeValue(target, values) {
    if (target.isDraggable === undefined || target.isDraggable) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }
  }

  function updateShapes(parentShape, _diffX, _diffY) {
    var otherShapes = parentShape.connectionId;

    for (var i = 0; i < otherShapes.length; i++) {
      var shape = findShape(otherShapes[i]).shape;

      if (shape === undefined || shape === false || shape.isMoved) {
        continue;
      }

      shape.isMoved = true;

      if (shape.type === "point") {
        var draggable = true;

        if (!shape.isSelected && shape.connectionId.length) {
          for (var j = 0; j < shape.connectionId.length; j++) {
            var connectedShape = findShape(shape.connectionId[j]).shape;

            if (connectedShape && (connectedShape.type === "line" || connectedShape.type === "ray" || connectedShape.type.includes("segment"))) {
              var checkId = connectedShape.firstPointId === shape.uniqueId ? connectedShape.secondPointId : connectedShape.firstPointId;
              var connectedPoint = findShape(checkId);

              if (connectedPoint && connectedPoint.shape) {
                if (!(connectedPoint.shape.isDraggable === undefined || connectedPoint.shape.isDraggable === true)) {
                  draggable = false;
                }
              }
            }
          }
        }

        if (draggable) {
          updateShapeValue(shape, {
            x: shape.x + _diffX,
            y: shape.y + _diffY
          });
        }
      } else if (shape.type === "line" || shape.type === "ray" || shape.type.includes("segment")) {
        if (shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        } else {
          shape.xTo = parentShape.x;
          shape.yTo = parentShape.y;
        }

        if (shape.type === "line" || shape.type === "ray") {
          updateLinePoints(shape);
        }
      } else if (shape.type === "perpendicularLine" || shape.type === "parallelLine") {
        if (parentShape.type === "point") {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
          updatePLinePoints(shape);
        }
      } else if (shape.type === "circle") {
        if (parentShape.type === "point" && shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        }
      }
    }
  }

  function findShape(uniqueId) {
    var shapesData = modelObj.interactionElements;

    for (var i = shapesData.length - 1; i >= 0; i--) {
      if (shapesData[i] && shapesData[i].uniqueId === uniqueId) {
        return {
          index: i,
          shape: shapesData[i]
        };
      }
    }

    return false;
  } // =================================================


  function onMouseUp(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    var _ctx = modelObj.context;
    _ctx.font = "".concat(modelObj.fontSize, "px ").concat(modelObj.LabComClass.polo22KlettRegular);
    var value = {
      type: tool
    };
    var _it = tool;
    var dataAvailable = false;
    var point = getPointByPixel(e.pageX, e.pageY);
    var currentShape = localObj.currentUniqueId !== null && findShape(localObj.currentUniqueId).shape;

    if (!localObj.mouseDown.lastShapeCompleted && localObj.currentUniqueId == null) {
      currentShape = findShape(localObj.uniqueId).shape;
    }

    point = checkSnapping(point);
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));
    var clickingOnExistingPointID = null;

    if (clickingOnExistingPoint !== null) {
      clickingOnExistingPointID = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    if (clickingOnExistingPointID !== null) {
      if (_it !== "select" && _it !== "move" && _it !== "moveGraph" && currentShape) {
        currentShape.isSelected = false;
      }
    }

    var pointOnGraph = point !== null;

    if (_it === "point" && currentShape && pointOnGraph) {
      var _point2 = getPointByPixel(e.pageX, e.pageY);

      var _currentShape2 = localObj.currentUniqueId !== null && findShape(localObj.currentUniqueId).shape;

      if (!localObj.mouseDown.lastShapeCompleted && localObj.currentUniqueId == null) {
        _currentShape2 = findShape(localObj.uniqueId).shape;
      }

      _point2 = checkSnapping(_point2);
      clickingOnExistingPoint = checkPointv2(getPointByPixel(e.pageX, e.pageY));
      clickingOnExistingPointID = null;

      if (clickingOnExistingPoint !== null) {
        clickingOnExistingPointID = shapesData[clickingOnExistingPoint].uniqueId;
        _point2 = shapesData[clickingOnExistingPoint];
      }

      if (clickingOnExistingPointID !== null) {
        if (_it !== "select" && _it !== "move" && _it !== "moveGraph" && _currentShape2) {
          _currentShape2.isSelected = false;
        }
      }

      if (findDraggable([_currentShape2])) {
        // if (updatePointValues(currentShape, {
        //   x: point.x,
        //   y: point.y
        // })) {
        updatePointValues(_currentShape2, _point2);

        if (!modelObj.shapesEditable) {
          _currentShape2.isDraggable = false;
          value.isDraggable = _currentShape2.isDraggable;
        }

        dataAvailable = true;
        value.x = _point2.x;
        value.y = _point2.y;
        value.uniqueId = _currentShape2.uniqueId;

        if (dataAvailable) {
          dataAvailable = checkDataAvailable(_currentShape2, ["x", "y"]);
        } // }


        filterDuplicateInteractionElements();
      } else if (modelObj.plotPointOnExistingPoint) {
        dataAvailable = true;
        var pointId = ++localObj.uniqueId;
        value.x = _currentShape2.x;
        value.y = _currentShape2.y;
        addPoint(_point2, {
          uniqueId: pointId,
          connectionId: [_currentShape2.uniqueId]
        });
        value.uniqueId = pointId;
      }
    } else if (currentShape && (_it.includes("segment") || _it === "length" || _it === "line" || _it === "ray") && pointOnGraph) {
      if (findDraggable([currentShape])) {
        currentShape.xTo = point.x;
        currentShape.yTo = point.y;
      }

      if (tool === "line" || tool === "ray") {
        updateLinePoints(currentShape);
      }

      value.x = currentShape.x;
      value.y = currentShape.y;
      value.xTo = currentShape.xTo;
      value.yTo = currentShape.yTo;
      value.slope = currentShape.slope;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (_it === "length" && (currentShape.circleId !== undefined || currentShape.segmentID !== undefined)) {
        if (currentShape.circleId) {
          var circle = findShape(currentShape.circleId).shape;
          circle.isSelected = false;
        } else if (currentShape.segmentID) {
          var segment = findShape(currentShape.segmentID).shape;
          segment.isSelected = false;
        }
      }

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ["x", "y", "xTo", "yTo"]);
      }

      if (clickingOnExistingPoint === null) {
        if (_it !== "length") {
          var secondPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: secondPointId,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = secondPointId;
          currentShape.connectionId.push(secondPointId);
        } else if (currentShape.firstPointId !== undefined) {
          if (localObj.newPlottedShapes.length > 0) {
            shapesData.pop();
          }
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        if (_it !== "length") {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
        }

        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (currentShape && _it === "angleRay" && pointOnGraph) {
      var angleRay = findShape(currentShape.angleRayId).shape;

      if (!angleRay.firstRayPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var firstPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: firstPointId,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.firstPointId = firstPointId;
          currentShape.connectionId.push(firstPointId);
          angleRay.firstRayPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          angleRay.firstRayPlotted = true;
        }

        if (angleRay.firstRayPlotted) {
          angleRay.secondPointId = currentShape.firstPointId;
          addNewShape({
            type: "ray",
            uniqueId: ++localObj.uniqueId,
            firstPointId: angleRay.secondPointId,
            angleRayId: currentShape.angleRayId,
            x: point.x,
            y: point.y,
            xOr: point.x,
            yOr: point.y,
            xTo: point.x,
            yTo: point.y,
            xOrTo: point.x,
            yOrTo: point.y,
            connectionId: [angleRay.secondPointId]
          });
          localObj.currentUniqueId = localObj.uniqueId;
          angleRay.x = point.x;
          angleRay.y = point.y;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId2 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId2,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = _secondPointId2;
          currentShape.connectionId.push(_secondPointId2);
          angleRay.secondRayPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          angleRay.secondRayPlotted = true;
        }

        if (angleRay.secondRayPlotted) {
          angleRay.thirdPointId = currentShape.secondPointId;
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleRay.secondRayPlotted) {
        var firstPoint = findShape(angleRay.firstPointId).shape;
        var secondPoint = findShape(angleRay.secondPointId).shape;
        var thirdPoint = findShape(angleRay.thirdPointId).shape;
        value.firstPoint = {
          x: firstPoint.x,
          y: firstPoint.y,
          label: firstPoint.label
        };
        value.secondPoint = {
          x: secondPoint.x,
          y: secondPoint.y,
          label: secondPoint.label
        };
        value.thirdPoint = {
          x: thirdPoint.x,
          y: thirdPoint.y,
          label: thirdPoint.label
        };
        value.x = secondPoint.x;
        value.y = secondPoint.y;
        var angleData = calculateAngle(value, "angleRay");
        value.angle = angleData.angle;
        value.angleValue = angleData.angleValue;
        angleRay.label = angleData.angleText;
        angleRay.labelX = angleRay.x + getPointUnitByPixelUnit(10);
        angleRay.labelY = angleRay.y - getPointUnitByPixelUnit(10);
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === "triangle" && pointOnGraph) {
      var triangle = findShape(currentShape.triangleId).shape;

      if (!triangle.firstSegmentPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var _firstPointId19 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId19,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.firstPointId = _firstPointId19;
          currentShape.connectionId.push(_firstPointId19);
          triangle.firstSegmentPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          triangle.firstSegmentPlotted = true;
        }

        if (triangle.firstSegmentPlotted) {
          triangle.secondPointId = currentShape.firstPointId;
          addNewShape({
            type: "segment",
            uniqueId: ++localObj.uniqueId,
            firstPointId: triangle.secondPointId,
            triangleId: currentShape.triangleId,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y,
            connectionId: [triangle.secondPointId]
          });
          localObj.newPlottedShapes.push(localObj.uniqueId);
          localObj.currentUniqueId = localObj.uniqueId;
          triangle.x = point.x;
          triangle.y = point.y;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId3 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId3,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = _secondPointId3;
          currentShape.connectionId.push(_secondPointId3);
          triangle.secondSegmentPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID || triangle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          triangle.secondSegmentPlotted = true;
        }
      }

      if (triangle.secondSegmentPlotted) {
        var _secondPoint9 = findShape(triangle.firstPointId).shape;
        triangle.thirdPointId = currentShape.secondPointId;
        addNewShape({
          type: "segment",
          uniqueId: ++localObj.uniqueId,
          firstPointId: triangle.thirdPointId,
          secondPointId: triangle.firstPointId,
          triangleId: currentShape.triangleId,
          x: point.x,
          y: point.y,
          xTo: _secondPoint9.x,
          yTo: _secondPoint9.y,
          connectionId: [triangle.thirdPointId, triangle.firstPointId]
        });
        localObj.newPlottedShapes.push(localObj.uniqueId);
        localObj.currentUniqueId = localObj.uniqueId;
        triangle.x = point.x;
        triangle.y = point.y;
        triangle.thirdSegmentPlotted = true;
        localObj.mouseDown.lastShapeCompleted = true;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (triangle.thirdSegmentPlotted) {
        var _firstPoint9 = findShape(triangle.firstPointId).shape;
        var _secondPoint10 = findShape(triangle.secondPointId).shape;
        var _thirdPoint3 = findShape(triangle.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint9.x,
          y: _firstPoint9.y,
          label: _firstPoint9.label
        };
        value.secondPoint = {
          x: _secondPoint10.x,
          y: _secondPoint10.y,
          label: _secondPoint10.label
        };
        value.thirdPoint = {
          x: _thirdPoint3.x,
          y: _thirdPoint3.y,
          label: _thirdPoint3.label
        };
        value.x = _secondPoint10.x;
        value.y = _secondPoint10.y;
        value.uniqueId = triangle.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === "circle_3" && pointOnGraph) {
      var circle3;

      if (currentShape.type !== "circle_3") {
        circle3 = findShape(currentShape.circleId).shape;
      } else {
        circle3 = currentShape;
      }

      if (!circle3.firstPointPlotted) {
        dataAvailable = false;
        var fp = findShape(circle3.firstPointId).shape;
        fp.isSelected = true;

        if (clickingOnExistingPoint === null) {
          var _secondPointId4 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId4,
            connectionId: [circle3.uniqueId],
            circleId: circle3.uniqueId
          });
          circle3.secondPointId = _secondPointId4;
          circle3.firstPointPlotted = true;
          var _fp10 = findShape(circle3.firstPointId).shape;
          _fp10.isSelected = true;
          var sp = findShape(circle3.secondPointId).shape;
          sp.isSelected = true;
        } else if (circle3.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(circle3.uniqueId);
          point.circle3Id = circle3.uniqueId;
          circle3.secondPointId = clickingOnExistingPointID;
          circle3.firstPointPlotted = true;
          var _fp11 = findShape(circle3.firstPointId).shape;
          _fp11.isSelected = true;
          var _sp2 = findShape(circle3.secondPointId).shape;
          _sp2.isSelected = true;
        }

        if (circle3.firstPointPlotted) {
          circle3.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          circle3.x = point.x;
          circle3.y = point.y;
          var _fp12 = findShape(circle3.firstPointId).shape;
          _fp12.isSelected = true;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var thirdPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: thirdPointId,
            connectionId: [circle3.uniqueId]
          });
          var _sp3 = findShape(circle3.secondPointId).shape;
          _sp3.isSelected = true;
          circle3.thirdPointId = thirdPointId;
          circle3.thirdPointPloted = true;
        } else if (circle3.secondPointId === clickingOnExistingPointID || circle3.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(circle3.uniqueId);
          circle3.thirdPointId = clickingOnExistingPointID;
          circle3.thirdPointPloted = true;
        }

        if (circle3.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (circle3.thirdPointPloted) {
        var _firstPoint10 = findShape(circle3.firstPointId).shape;
        var _secondPoint11 = findShape(circle3.secondPointId).shape;
        var _thirdPoint4 = findShape(circle3.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint10.x,
          y: _firstPoint10.y
        };
        value.secondPoint = {
          x: _secondPoint11.x,
          y: _secondPoint11.y
        };
        value.thirdPoint = {
          x: _thirdPoint4.x,
          y: _thirdPoint4.y
        };
        var circleData = computeCircle(value);
        var _fp13 = findShape(circle3.firstPointId).shape;
        _fp13.isSelected = false;
        var _sp4 = findShape(circle3.secondPointId).shape;
        _sp4.isSelected = false;
        var tp = findShape(circle3.thirdPointId).shape;
        tp.isSelected = false;
        value.r = circleData.r;
        value.x = circleData.x;
        value.y = circleData.y;
        dataAvailable = true;
      }
    } else if (currentShape && _it === "angle" && pointOnGraph) {
      var angle;

      if (currentShape.type === "point") {
        angle = findShape(currentShape.angleId).shape;
      } else {
        angle = findShape(currentShape.uniqueId).shape;
      }

      if (!angle.firstPointPlotted) {
        dataAvailable = false;
        var _fp14 = findShape(angle.firstPointId).shape;
        _fp14.isSelected = true;

        if (clickingOnExistingPoint === null) {
          var _secondPointId5 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId5,
            connectionId: [angle.uniqueId],
            angleId: currentShape.angleId
          });
          var _fp15 = findShape(angle.firstPointId).shape;
          _fp15.isSelected = true;
          var _sp5 = findShape(_secondPointId5).shape;
          _sp5.isSelected = true;
          angle.secondPointId = _secondPointId5;
          angle.firstPointPlotted = true;
        } else if (angle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(angle.uniqueId);
          point.angleId = currentShape.angleId;
          angle.secondPointId = clickingOnExistingPointID;
          angle.firstPointPlotted = true;
          var _sp6 = findShape(angle.secondPointId).shape;
          _sp6.isSelected = true;
        }

        if (angle.firstPointPlotted) {
          angle.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          angle.x = point.x;
          angle.y = point.y;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var _thirdPointId = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _thirdPointId,
            connectionId: [angle.uniqueId],
            angleId: angle.uniqueId
          });
          angle.thirdPointId = _thirdPointId;
          angle.thirdPointPloted = true;
        } else if (angle.secondPointId === clickingOnExistingPointID || angle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(angle.uniqueId);
          angle.thirdPointId = clickingOnExistingPointID;
          point.angleId = angle.uniqueId;
          angle.thirdPointPloted = true;
        }

        if (angle.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angle.thirdPointPloted) {
        var _firstPoint11 = findShape(angle.firstPointId).shape;
        var _secondPoint12 = findShape(angle.secondPointId).shape;
        var _thirdPoint5 = findShape(angle.thirdPointId).shape;
        _firstPoint11.isSelected = false;
        _secondPoint12.isSelected = false;
        _thirdPoint5.isSelected = false;
        value.firstPoint = {
          x: _firstPoint11.x,
          y: _firstPoint11.y,
          label: _firstPoint11.label
        };
        value.secondPoint = {
          x: _secondPoint12.x,
          y: _secondPoint12.y,
          label: _secondPoint12.label
        };
        value.thirdPoint = {
          x: _thirdPoint5.x,
          y: _thirdPoint5.y,
          label: _thirdPoint5.label
        };
        value.x = _secondPoint12.x;
        value.y = _secondPoint12.y;

        var _angleData = calculateAngle(value);

        value.angle = _angleData.angle;
        value.angleValue = _angleData.angleValue;
        angle.label = _angleData.angleText;
        angle.labelX = angle.x + getPointUnitByPixelUnit(10);
        angle.labelY = angle.y - getPointUnitByPixelUnit(10);
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === "angleB" && pointOnGraph && localObj.newShapeStarted) {
      var angleB;

      if (currentShape.type === "point") {
        angleB = findShape(currentShape.angleBId).shape;
      } else {
        angleB = findShape(currentShape.uniqueId).shape;
      }

      if (angleB.mode === "point") {
        var _angleB, _angleB2;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB = angleB) === null || _angleB === void 0 ? void 0 : _angleB.firstPointPlotted)) {
          dataAvailable = false;

          if (clickingOnExistingPoint === null || angleB.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            point.angleBId = currentShape.uniqueId;
            angleB.secondPointId = clickingOnExistingPointID;
            angleB.firstPointPlotted = true;
            shapesData[clickingOnExistingPoint].isSelected = true;
          }

          if (angleB.firstPointPlotted) {
            angleB.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }
        } else {
          if (clickingOnExistingPoint === null || angleB.secondPointId === clickingOnExistingPointID || angleB.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            angleB.thirdPointId = clickingOnExistingPointID;
            point.angleBId = currentShape.uniqueId;
            angleB.thirdPointPloted = true;
            shapesData[clickingOnExistingPoint].isSelected = true;
          }

          if (angleB.thirdPointPloted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if ((_angleB2 = angleB) === null || _angleB2 === void 0 ? void 0 : _angleB2.thirdPointPloted) {
          var _firstPoint12 = findShape(angleB.firstPointId).shape;
          var _secondPoint13 = findShape(angleB.secondPointId).shape;
          var _thirdPoint6 = findShape(angleB.thirdPointId).shape;
          value.firstPoint = {
            x: _firstPoint12.x,
            y: _firstPoint12.y,
            label: _firstPoint12.label
          };
          value.secondPoint = {
            x: _secondPoint13.x,
            y: _secondPoint13.y,
            label: _secondPoint13.label
          };
          value.thirdPoint = {
            x: _thirdPoint6.x,
            y: _thirdPoint6.y,
            label: _thirdPoint6.label
          };
          value.x = _secondPoint13.x;
          value.y = _secondPoint13.y;
          value.uniqueId = angleB.uniqueId;
          var angleBData = calculateBisector(value);
          angleB.firstPoint = value.firstPoint;
          angleB.secondPoint = value.secondPoint;
          angleB.thirdPoint = value.thirdPoint; // addNewShape(angleB.bisectorLine);

          var lineId = addNewShape({
            type: "line",
            uniqueId: ++localObj.uniqueId,
            x: _secondPoint13.x,
            y: _secondPoint13.y,
            xTo: angleBData.x,
            yTo: angleBData.y,
            slope: getSlope(_secondPoint13.x, _secondPoint13.y, angleBData.x, angleBData.y)
          });
          value.bisectorLine = lineId;
          angleB.bisectorLine = lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(lineId.uniqueId);
          dataAvailable = true;
        }
      } else if (angleB.mode === "segment") {
        var _angleB3;

        var selectedShapeID = isOnShape(e);
        var selectedShape = findShape(selectedShapeID).shape;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB3 = angleB) === null || _angleB3 === void 0 ? void 0 : _angleB3.firstSegmentPlotted)) {
          dataAvailable = false;

          if (selectedShape !== undefined && selectedShape.type.includes("segment") && selectedShape.uniqueId === angleB.firstSegmentId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (selectedShape !== undefined && selectedShape.type.includes("segment")) {
            selectedShape.angleBId = angleB.uniqueId;
            angleB.secondSegmentId = selectedShape.uniqueId;
            angleB.firstSegmentPlotted = true;
            angleB.secondSegment = {
              x: selectedShape.x,
              y: selectedShape.y,
              xTo: selectedShape.xTo,
              yTo: selectedShape.yTo
            };
            selectedShape.isSelected = true;
          }

          if (angleB.firstSegmentPlotted) {
            angleB.secondSegmentPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }

          if (angleB.secondSegmentPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if (angleB.secondSegmentPlotted) {
          value.firstSegment = angleB.firstSegment;
          value.secondSegment = angleB.secondSegment;
          var pCommon = findCommon(angleB.firstSegment, angleB.secondSegment);
          value.x = +pCommon.x;
          value.y = +pCommon.y;
          angleB.x = +pCommon.x;
          angleB.y = +pCommon.y;
          value.uniqueId = angleB.uniqueId;

          var _angleBData = calculateBisector(value, "segment");

          var _lineId = addNewShape({
            type: "line",
            uniqueId: ++localObj.uniqueId,
            x: +pCommon.x,
            y: +pCommon.y,
            xTo: _angleBData.x,
            yTo: _angleBData.y,
            slope: getSlope(+pCommon.x, +pCommon.y, _angleBData.x, _angleBData.y)
          });

          value.bisectorLine = _lineId;
          angleB.bisectorLine = _lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(_lineId.uniqueId);
          dataAvailable = true;
        }
      }
    } else if (currentShape && _it === "angleSize" && pointOnGraph && localObj.newShapeStarted) {
      var angleSize;

      if (currentShape.type === "point") {
        angleSize = findShape(currentShape.angleSizeId).shape;
      } else {
        angleSize = findShape(currentShape.uniqueId).shape;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleSize.mode === "point") {
        var _angleSize;

        if (angleSize === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleSize = angleSize) === null || _angleSize === void 0 ? void 0 : _angleSize.firstPointPlotted)) {
          dataAvailable = false;
          point.angleSizeId = angleSize.uniqueId;
          localObj.currentUniqueId = null;
          angleSize.firstPointPlotted = true;
          angleSize.x = point.x;
          angleSize.y = point.y;
          var fpShape = findShape(angleSize.firstPointId).shape;
          fpShape.isSelected = true;
        } else if (!angleSize.secondPointPlotted) {
          if (clickingOnExistingPointID === angleSize.firstPointId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            var _secondPointId6;

            if (clickingOnExistingPointID >= 0 && clickingOnExistingPointID !== null) {
              _secondPointId6 = clickingOnExistingPointID;
              angleSize.connectionId.push(clickingOnExistingPointID);
            } else {
              localObj.mouseDown.lastShapeCompleted = false;
              dataAvailable = false;
            }

            if (_secondPointId6 !== undefined) {
              var _firstPoint13 = findShape(angleSize.firstPointId).shape;
              angleSize.secondPointId = _secondPointId6;
              angleSize.secondPointPlotted = true;
              angleSize.x = point.x;
              angleSize.y = point.y;
              angleSize.xTo = _firstPoint13.x;
              angleSize.yTo = _firstPoint13.y;

              if (angleSize.secondPointId >= 0) {
                var spShape = findShape(_secondPointId6).shape;

                if (spShape) {
                  var _fpShape = findShape(angleSize.firstPointId).shape;
                  _fpShape.isSelected = true;
                  spShape.isSelected = true;
                }
              }

              modelObj.waiting = true;

              if (typeof events.angleSize !== "undefined") {
                events.angleSize({
                  id: modelObj.id,
                  type: "angleSize",
                  visible: true,
                  data: JSON.parse(JSON.stringify(angleSize))
                }, true);
              }

              dataAvailable = false;
            }
          }
        } else {
          _this.removeUnplotedShapes();
        }
      } else if (angleSize.mode === "segment") {
        var _selectedShapeID6 = isOnShape(e);

        var _selectedShape = findShape(_selectedShapeID6).shape;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === "segSize" && pointOnGraph) {
      var _segSize;

      var segSize;

      if (currentShape.type === "point") {
        segSize = findShape(currentShape.segSizeId).shape;
      } else {
        segSize = findShape(currentShape.uniqueId).shape;
      } // point.x = currentShape.x;
      // point.y = currentShape.y;


      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (segSize === undefined) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        localObj.mouseDown.isMouseDown = false;
      } else if (!((_segSize = segSize) === null || _segSize === void 0 ? void 0 : _segSize.firstPointPlotted)) {
        dataAvailable = false;
        point.segSizeId = segSize.uniqueId;
        localObj.currentUniqueId = null;
        segSize.firstPointPlotted = true;
        segSize.x = point.x;
        segSize.y = point.y;
        var _fp16 = findShape(segSize.firstPointId).shape;
        _fp16.isSelected = true;

        if (segSize.firstPointPlotted) {
          modelObj.waiting = true;

          if (typeof events.segSize !== "undefined") {
            events.segSize({
              id: modelObj.id,
              type: "segSize",
              visible: true,
              data: JSON.parse(JSON.stringify(segSize))
            }, true);
          }

          dataAvailable = false;
        }
      } else {
        _this.removeUnplotedShapes();
      }
    } else if (currentShape && _it === "circleSize" && pointOnGraph) {
      var _circleSize;

      var circleSize;

      if (currentShape.type === "point") {
        circleSize = findShape(currentShape.circleSizeId).shape;
      } else {
        circleSize = findShape(currentShape.uniqueId).shape;
      } // point.x = currentShape.x;
      // point.y = currentShape.y;


      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (circleSize === undefined) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        localObj.mouseDown.isMouseDown = false;
      } else if (!((_circleSize = circleSize) === null || _circleSize === void 0 ? void 0 : _circleSize.firstPointPlotted)) {
        dataAvailable = false;
        point.circleSizeId = circleSize.uniqueId;
        localObj.currentUniqueId = null;
        circleSize.firstPointPlotted = true;
        circleSize.x = point.x;
        circleSize.y = point.y;
        var _fp17 = findShape(circleSize.firstPointId).shape;
        _fp17.isSelected = true;

        if (circleSize.firstPointPlotted) {
          modelObj.waiting = true;

          if (typeof events.circleSize !== "undefined") {
            events.circleSize({
              id: modelObj.id,
              type: "circleSize",
              visible: true,
              data: JSON.parse(JSON.stringify(circleSize))
            }, true);
          }

          dataAvailable = false;
        }
      } else {
        _this.removeUnplotedShapes();
      }
    } else if (currentShape && _it === "midPoint" && pointOnGraph) {
      var _midPoint;

      var midPoint;

      var _selectedShapeID7 = isOnShape(e);

      var _selectedShape2 = findShape(_selectedShapeID7).shape;

      if (currentShape.type === "point" || currentShape.type.includes("segment")) {
        midPoint = findShape(currentShape.midPointId).shape;
      } else {
        midPoint = findShape(currentShape.uniqueId).shape;
      }

      var selectedShapeN = findShape(midPoint.firstPointId).shape;

      if (!((_midPoint = midPoint) === null || _midPoint === void 0 ? void 0 : _midPoint.firstPointPlotted)) {
        dataAvailable = false;

        if (_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes("segment")) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if (clickingOnExistingPoint === null && !(_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes("segment"))) {
          var _secondPointId7 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId7,
            connectionId: [midPoint.uniqueId],
            midPointId: currentShape.midPointId
          });
          midPoint.secondPointId = _secondPointId7;
          midPoint.firstPointPlotted = true;
        } else if (midPoint.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(midPoint.uniqueId);
          point.midPointId = currentShape.midPointId;
          midPoint.secondPointId = clickingOnExistingPointID;
          midPoint.firstPointPlotted = true;
        }

        if (midPoint.firstPointPlotted) {
          midPoint.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          midPoint.x = point.x;
          midPoint.y = point.y;
        }

        selectedShapeN.isSelected = true;
      } else {
        if (midPoint.secondPointPlotted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (midPoint.secondPointPlotted && midPoint.onSegment === undefined) {
        var _findShape;

        var _firstPoint14 = findShape(midPoint.firstPointId).shape;
        var _secondPoint14 = findShape(midPoint.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint14.x,
          y: _firstPoint14.y,
          label: _firstPoint14.label
        };
        value.secondPoint = {
          x: _secondPoint14.x,
          y: _secondPoint14.y,
          label: _secondPoint14.label
        };
        value.uniqueId = midPoint.uniqueId;
        value.x = (_firstPoint14.x + _secondPoint14.x) / 2;
        value.y = (_firstPoint14.y + _secondPoint14.y) / 2;
        midPoint.x = (_firstPoint14.x + _secondPoint14.x) / 2;
        midPoint.y = (_firstPoint14.y + _secondPoint14.y) / 2;
        value.midPointId = ++localObj.uniqueId;
        midPoint.midPointId = value.midPointId; // value.uniqueId = currentShape.uniqueId;

        dataAvailable = true;
        addPoint({
          type: "point",
          x: value.x,
          y: value.y
        }, {
          connectionId: [midPoint.uniqueId],
          uniqueId: value.midPointId,
          kshitij: true
        });

        var _segment2 = (_findShape = findShape(midPoint.segmentId)) === null || _findShape === void 0 ? void 0 : _findShape.shape;

        if (_segment2) {
          _segment2.isMouseDown = false;
          _segment2.isSelected = false;
        }

        midPoint.strokeColor = modelObj.pointColor;
        midPoint.fillColor = modelObj.pointColor;
        selectedShapeN.isSelected = false;
      } else if (midPoint.secondPointPlotted && midPoint.onSegment !== undefined) {
        // value.x=(midPoint.x+midPoint.xTo)/2;
        // value.y=(midPoint.y+midPoint.yTo)/2;
        value.x = (midPoint.firstPointCoords.x + midPoint.secondPointCoords.x) / 2;
        value.y = (midPoint.firstPointCoords.y + midPoint.secondPointCoords.y) / 2;
        value.uniqueId = midPoint.uniqueId;
        value.midPointId = ++localObj.uniqueId;
        midPoint.midPointId = value.midPointId;
        dataAvailable = true;
        addPoint({
          type: "point",
          x: value.x,
          y: value.y
        }, {
          connectionId: [midPoint.uniqueId],
          uniqueId: value.midPointId,
          kshitij: true
        });
        var _segment3 = findShape(midPoint.segmentId).shape;
        _segment3.isMouseDown = false;
        _segment3.isSelected = false;
      }
    } else if (currentShape && _it === "square" && pointOnGraph) {
      var square;

      if (currentShape.type === "point") {
        square = findShape(currentShape.squareId).shape;
      }

      if (!square.firstPointPlotted) {
        if (clickingOnExistingPointID === square.firstPointId) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          var _fp18 = findShape(square.firstPointId).shape;
          _fp18.isSelected = true;
        } else if (clickingOnExistingPoint === null) {
          var _secondPointId8 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId8,
            connectionId: [square.uniqueId],
            squareId: currentShape.squareId
          });
          square.secondPointId = _secondPointId8;
          square.firstPointPlotted = true;
          square.secondPointPlotted = true;
          var _fp19 = findShape(square.firstPointId).shape;
          _fp19.isSelected = true;
          var _sp7 = findShape(square.secondPointId).shape;
          _sp7.isSelected = true;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(square.uniqueId);
          point.squareId = currentShape.squareId;
          square.secondPointId = clickingOnExistingPointID;
          square.secondPointPlotted = true;
          square.firstPointPlotted = true;
          var _fp20 = findShape(square.firstPointId).shape;
          _fp20.isSelected = true;
          var _sp8 = findShape(square.secondPointId).shape;
          _sp8.isSelected = true;
        }
      }

      if (square.secondPointId) {
        var _firstPoint15 = findShape(square.firstPointId).shape;
        var _secondPoint15 = findShape(square.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint15.x,
          y: _firstPoint15.y
        };
        value.secondPoint = {
          x: _secondPoint15.x,
          y: _secondPoint15.y
        };
        value.firstPointId = square.firstPointId;
        value.secondPointId = square.secondPointId;
        value.side = modelObj.LabComClass.Maths.getDistance(_firstPoint15, _secondPoint15);
        value.label = "A  §qQuadrat§r = " + to2Dec(value.side * value.side);
        square.label = "A  §qQuadrat§r = " + to2Dec(value.side * value.side);

        var _thirdPoint7 = modelObj.LabComClass.Maths.getPoint(_secondPoint15, modelObj.LabComClass.Maths.getAngle(_secondPoint15.x, _secondPoint15.y, _firstPoint15.x, _firstPoint15.y) - Math.PI / 2, value.side);

        var fourthPoint = modelObj.LabComClass.Maths.getPoint(_firstPoint15, modelObj.LabComClass.Maths.getAngle(_secondPoint15.x, _secondPoint15.y, _firstPoint15.x, _firstPoint15.y) - Math.PI / 2, value.side);

        var _thirdPointId2 = ++localObj.uniqueId;

        var fourthPointId = ++localObj.uniqueId;
        square.labelX = (_firstPoint15.x + _thirdPoint7.x) / 2;
        square.labelY = (_firstPoint15.y + _thirdPoint7.y) / 2;
        addPoint(_thirdPoint7, {
          connectionId: [square.uniqueId],
          uniqueId: _thirdPointId2,
          squareId: square.uniqueId
        });
        addPoint(fourthPoint, {
          connectionId: [square.uniqueId],
          uniqueId: fourthPointId,
          squareId: square.uniqueId
        });
        value.thirdPointId = _thirdPointId2;
        value.fourthPointId = fourthPointId;
        value.thirdPoint = _thirdPoint7;
        value.fourthPoint = fourthPoint;
        value.uniqueId = square.uniqueId;
        square.thirdPointId = _thirdPointId2;
        square.fourthPointId = fourthPointId;
        square.firstPoint = _firstPoint15;
        square.secondPoint = _secondPoint15;
        square.thirdPoint = _thirdPoint7;
        square.fourthPoint = fourthPoint;
        addSegment(_firstPoint15.x, _firstPoint15.y, _secondPoint15.x, _secondPoint15.y, square.uniqueId);
        addSegment(_secondPoint15.x, _secondPoint15.y, _thirdPoint7.x, _thirdPoint7.y, square.uniqueId);
        addSegment(_firstPoint15.x, _firstPoint15.y, fourthPoint.x, fourthPoint.y, square.uniqueId);
        addSegment(_thirdPoint7.x, _thirdPoint7.y, fourthPoint.x, fourthPoint.y), square.uniqueId;
        var _fp21 = findShape(square.firstPointId).shape;
        _fp21.isSelected = false;
        var _sp9 = findShape(square.secondPointId).shape;
        _sp9.isSelected = false;
        dataAvailable = true;
      }
    } else if (currentShape && _it === "mirrorOnLine" && pointOnGraph) {
      var _mirrorOnLine;

      var mirrorOnLine;

      var _selectedShapeID8 = isOnShape(e);

      var _selectedShape3 = findShape(_selectedShapeID8).shape;

      if (currentShape.type === "point") {
        mirrorOnLine = findShape(currentShape.mirrorOnLineId).shape;
      } else {
        mirrorOnLine = findShape(currentShape.uniqueId).shape;
      }

      if (!((_mirrorOnLine = mirrorOnLine) === null || _mirrorOnLine === void 0 ? void 0 : _mirrorOnLine.firstPointPlotted) && _typeof(mirrorOnLine) !== undefined) {
        var _mirrorOnLine2, _mirrorOnLine3;

        dataAvailable = false;
        var _fp22 = findShape(mirrorOnLine.firstPointId).shape;
        _fp22.isSelected = true;

        if (clickingOnExistingPoint === null && _selectedShape3 && checkType(_selectedShape3, localObj.lineTypes)) {
          var _lineId2 = _selectedShapeID8;
          mirrorOnLine.lineId = _lineId2;
          mirrorOnLine.firstPointPlotted = true;
        } else if (((_mirrorOnLine2 = mirrorOnLine) === null || _mirrorOnLine2 === void 0 ? void 0 : _mirrorOnLine2.firstPointId) === clickingOnExistingPointID || clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if ((_mirrorOnLine3 = mirrorOnLine) === null || _mirrorOnLine3 === void 0 ? void 0 : _mirrorOnLine3.firstPointPlotted) {
          mirrorOnLine.linePlotted = true;
          localObj.currentUniqueId = null; // mirrorOnLine.x = point.x;
          // mirrorOnLine.y = point.y;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (mirrorOnLine !== undefined && mirrorOnLine.linePlotted) {
        var _firstPoint16 = findShape(mirrorOnLine.firstPointId).shape;
        value.firstPoint = {
          x: _firstPoint16.x,
          y: _firstPoint16.y,
          uniqueId: _firstPoint16.uniqueId
        };
        mirrorOnLine.firstPoint = {
          x: _firstPoint16.x,
          y: _firstPoint16.y,
          uniqueId: _firstPoint16.uniqueId
        }; // const mirrorData = computeMirrorPoint(mirrorOnLine);

        var line = findShape(mirrorOnLine.lineId).shape;
        var eqnLine = computeEqn(line);
        var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, mirrorOnLine.x, mirrorOnLine.y);
        value.x = mirrorPoint.x;
        value.y = mirrorPoint.y;
        mirrorOnLine.x = mirrorPoint.x;
        mirrorOnLine.y = mirrorPoint.y;
        value.lineId = line.uniqueId;
        value.mirrorPointId = ++localObj.uniqueId;
        addPoint(mirrorPoint, {
          uniqueId: value.mirrorPointId,
          mirrorOnLineId: mirrorOnLine.uniqueId,
          connectionId: [mirrorOnLine.uniqueId]
        });
        dataAvailable = true;
        var _fp23 = findShape(mirrorOnLine.firstPointId).shape;
        _fp23.isSelected = false;
      } else {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === "perpendicularBisector" && pointOnGraph && localObj.newShapeStarted) {
      var perpShape = currentShape;

      if (perpShape.mode === "point") {
        if (!perpShape.firstPointPlotted) {
          if (perpShape.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
            point.connectionId.push(perpShape.uniqueId);
            perpShape.secondPointId = clickingOnExistingPointID;
            perpShape.firstPointPlotted = true;
            var _fp24 = findShape(perpShape.firstPointId).shape;
            _fp24.isSelected = true;
          }

          if (perpShape.firstPointPlotted) {
            perpShape.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            perpShape.x = point.x;
            perpShape.y = point.y;
          }
        } else {
          if (perpShape.secondPointPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        if (perpShape.firstPointPlotted && perpShape.secondPointPlotted) {
          var _firstPoint17 = findShape(currentShape.firstPointId).shape;
          var _secondPoint16 = findShape(perpShape.secondPointId).shape;
          var _midPoint2 = {
            x: (_firstPoint17.x + _secondPoint16.x) / 2,
            y: (_firstPoint17.y + _secondPoint16.y) / 2
          };
          var valueObj = computePerpBisector(perpShape, _firstPoint17, _secondPoint16, _midPoint2);
          value = _objectSpread(_objectSpread({}, value), valueObj);
          dataAvailable = true;
          var _fp25 = findShape(perpShape.firstPointId).shape;
          _fp25.isSelected = false;
        }
      } else if (perpShape.mode === "segment") {
        var _firstPoint18 = {
          x: perpShape.segment.x,
          y: perpShape.segment.y
        };
        var _secondPoint17 = {
          x: perpShape.segment.xTo,
          y: perpShape.segment.yTo
        };
        var _midPoint3 = {
          x: (_firstPoint18.x + _secondPoint17.x) / 2,
          y: (_firstPoint18.y + _secondPoint17.y) / 2
        };

        var _valueObj = computePerpBisector(perpShape, _firstPoint18, _secondPoint17, _midPoint3);

        value = _objectSpread(_objectSpread({}, value), _valueObj);
        dataAvailable = true;
      }
    } else if (currentShape && (_it === "perpendicularLine" || _it === "parallelLine") && pointOnGraph) {
      // updatePLinePoints(currentShape);
      dataAvailable = true;

      if (currentShape.lineToPoint) {
        var _line3 = findShape(currentShape.line).shape;

        if (clickingOnExistingPoint === null) {
          var distance = Math.abs(modelObj.LabComClass.Maths.getPointLineDistance(point, _line3, {
            x: _line3.xTo,
            y: _line3.yTo
          }));
          var accepted = distance < getPointUnitByPixelUnit(modelObj.snappingDiff) && currentShape.lineSelected;

          if (accepted || distance > getPointUnitByPixelUnit(modelObj.snappingDiff)) {
            var _secondPointId9 = ++localObj.uniqueId;

            addPoint(point, {
              uniqueId: _secondPointId9,
              connectionId: [currentShape.uniqueId]
            });
            currentShape.secondPointId = _secondPointId9;
            currentShape.connectionId.push(_secondPointId9);
            localObj.mouseDown.lastShapeCompleted = true;
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else if (clickingOnExistingPointID === currentShape.firstPointId) {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          localObj.mouseDown.lastShapeCompleted = true;
        }

        if (dataAvailable) {
          _line3.isSelected = false;
        }
      } else {
        var _selectedShapeID9 = isOnShape(e);

        if (_selectedShapeID9) {
          var shapeData = findShape(_selectedShapeID9).shape;

          if (shapeData && checkType(shapeData, localObj.lineTypes)) {
            var _d5 = getPLine(e, _it === "perpendicularLine");

            if (_d5) {
              currentShape.slope = _d5.slope;
              var _firstPoint19 = findShape(currentShape.firstPointId).shape;
              _firstPoint19.isSelected = false;
              updatePLinePoints(currentShape);
              localObj.mouseDown.lastShapeCompleted = true;
            }
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        }
      }

      if (currentShape.pointToLine) {
        currentShape.firstPointPlotted = true;
      } else {
        currentShape.lineSelected = true;
      }

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ["x", "y", "xTo", "yTo"]);
      }

      if (dataAvailable) {
        value.x = currentShape.x;
        value.y = currentShape.y;
        value.xTo = currentShape.xTo;
        value.yTo = currentShape.yTo;
        value.slope = currentShape.slope;
        value.uniqueId = currentShape.uniqueId;
        currentShape.visible = true;
      } else {
        dataAvailable = false;
        localObj.mouseDown.lastShapeCompleted = false;
      }
    } else if (currentShape && _it === "compass") {
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (clickingOnExistingPoint === null) {
        if (currentShape.firstPointId !== undefined && !currentShape.isPloted) {
          shapesData.pop();
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = true;
        } else if (!currentShape.isPloted) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          currentShape.isPloted = true;
        } else if (pointOnGraph) {
          var centerPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: centerPointId,
            connectionId: [currentShape.uniqueId]
          }); //currentShape.centerPointId = centerPointId;

          currentShape.connectionId.push(centerPointId);
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID && !currentShape.isPloted) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else if (!currentShape.isPloted) {
        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        currentShape.isPloted = true;
      } else {
        point.connectionId.push(currentShape.uniqueId);
        currentShape.centerPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        localObj.mouseDown.lastShapeCompleted = true;
        var s = currentShape.firstPointId !== undefined ? findShape(currentShape.firstPointId) : findShape(currentShape.circleID);

        if (s) {
          s.shape.isSelected = false;
        }

        var selectedSegment = currentShape.segmentID >= 0 ? findShape(currentShape.segmentID).shape : undefined;

        if (selectedSegment) {
          selectedSegment.isSelected = false;
        }
      }
    } else if (_it === "circle" && currentShape) {
      dataAvailable = true;
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;

      if (clickingOnExistingPoint === null && pointOnGraph) {
        var _secondPointId10 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _secondPointId10,
          connectionId: [currentShape.uniqueId]
        });
        currentShape.secondPointId = _secondPointId10;
        currentShape.connectionId.push(_secondPointId10);
        var _fp26 = findShape(currentShape.firstPointId).shape;
        _fp26.isSelected = false;
      } else if (!pointOnGraph || currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        var _fp27 = findShape(currentShape.firstPointId).shape;
        _fp27.isSelected = false;
        point.connectionId.push(currentShape.uniqueId);
        currentShape.secondPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (_it === "scale") {
      dataAvailable = true;
      value.x = scaleObj.x;
      value.y = scaleObj.y;
      value.xTo = scaleObj.xTo;
      value.yTo = scaleObj.yTo;
      dispatchEventScale();
    } else if ((_it === "brush1" || _it === "brush2" || _it === "brush3") && currentShape) {
      if (currentShape.toColor) {
        if (currentShape.type === "point" || currentShape.type === "angle") {
          value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
          value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;

          switch (_it) {
            case "brush1":
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = modelObj.shapes.brush1.color.stroke;
              currentShape.strokeColor = modelObj.shapes.brush1.color.stroke;
              break;

            case "brush2":
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = modelObj.shapes.brush2.color.stroke;
              currentShape.strokeColor = modelObj.shapes.brush2.color.stroke;
              break;

            case "brush3":
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = modelObj.shapes.brush3.color.stroke;
              currentShape.strokeColor = modelObj.shapes.brush3.color.stroke;
              break;
          }
        } else {
          value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;

          switch (_it) {
            case "brush1":
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              currentShape.strokeColor = modelObj.shapes.brush1.color.stroke;
              break;

            case "brush2":
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              currentShape.strokeColor = modelObj.shapes.brush2.color.stroke;
              break;

            case "brush3":
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              currentShape.strokeColor = modelObj.shapes.brush3.color.stroke;
              break;
          }
        }

        localObj.mouseDown.lastShapeCompleted = true;
        localObj.mouseDown.isMouseDown = false;
        value.type = "colour";
        value.shapeLabel = currentShape.label;
        value.color = currentShape.strokeColor;
        value.shapeId = currentShape.uniqueId;
        value.shapeType = currentShape.type;
        dataAvailable = true;
      }

      currentShape.isSelected = false;
      currentShape.isMouseDown = false;
    } else if (_it === "select" || _it === "move" && localObj.mouseDown.objectDown) {
      dataAvailable = false;
      selectShape(e);
    } else if (_it === "move" || _it === "moveGraph") {
      dataAvailable = false;
    }

    updateAllShapes(e);
    updateAllShapes(e);
    dispatchData(value, dataAvailable);
  }

  function addSegment(x, y, xTo, yTo, squareId) {
    var seg1 = addNewShape({
      type: "segment",
      uniqueId: ++localObj.uniqueId,
      x: x,
      y: y,
      xTo: xTo,
      yTo: yTo,
      squareId: squareId
    });
    localObj.newPlottedShapes.push(seg1.uniqueId);
    return seg1;
  } // This needed to remove the duplicate shapes and keep the latest one.
  // case: This happens when two intersection need to mark, and we mark 1st and on same place we mark another
  // by dragging the point.


  function filterDuplicateInteractionElements() {
    var uniqueElements = [];
    modelObj.interactionElements.forEach(function (element) {
      var index = uniqueElements.findIndex(function (shape) {
        return shape.uniqueId === element.uniqueId;
      });

      if (index === -1) {
        uniqueElements.push(element);
      } else {
        uniqueElements[index] = element;
      }
    });
    modelObj.interactionElements = uniqueElements;
  }

  function mirrorImage(a, b, c, x1, y1) {
    var temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b);
    var x = temp * a + x1;
    var y = temp * b + y1;
    return {
      x: x,
      y: y
    };
  }

  function dispatchData(value, dataAvailable) {
    var _it = modelObj.interactionType;

    if (value.uniqueId !== undefined) {
      var target = findShape(value.uniqueId);

      if (target.shape) {
        Object.keys(target.shape).forEach(function (i) {
          if (target.shape[i] !== undefined) {
            value[i] = target.shape[i];
          }
        });
      }
    }

    saveData();

    if (_it === "select" || _it === "move" && localObj.mouseDown.objectDown) {
      if (typeof events[_it] !== "undefined") {
        events[_it]({
          id: modelObj.id,
          type: "select"
        }, true);
      }
    } else if (dataAvailable) {
      localObj.mouseDown.lastShapeCompleted = true;
      localObj.newShapeStarted = false;
      localObj.currentUniqueId = null;
      value.newPlottedShapes = localObj.newPlottedShapes;
      value.step = modelObj.currentStep;
      dispatchEventCustom(value);
    }

    localObj.isLableSelected = false;
  }

  function computePerpBisector(perpShape, firstPoint, secondPoint, midPoint) {
    var value = {};
    var angle2Point = modelObj.LabComClass.Maths.getAngle(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y);
    perpShape.x = midPoint.x;
    perpShape.y = midPoint.y;
    perpShape.angle = angle2Point + Math.PI / 2;
    perpShape.point = modelObj.LabComClass.Maths.getPoint(midPoint, perpShape.angle, getPointUnitByPixelUnit(10)); // perpShape.two=modelObj.LabComClass.Maths.getPoint(midPoint,perpShape.angle,-10);

    value.x = midPoint.x;
    value.y = midPoint.y;
    value.xTo = perpShape.point.x;
    value.yTo = perpShape.point.y;
    value.uniqueId = perpShape.uniqueId;
    value.slope = isFinite(getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y)) ? getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y) : null;
    value.firstPoint = firstPoint;
    value.secondPoint = secondPoint;
    var perpLine = addNewShape({
      type: "line",
      uniqueId: ++localObj.uniqueId,
      x: perpShape.point.x,
      y: perpShape.point.y,
      xTo: perpShape.x,
      yTo: perpShape.y,
      slope: getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y)
    });
    localObj.newPlottedShapes.push(perpLine.uniqueId);
    return value;
  }

  function findCommon(seg1, seg2) {
    var arr = [];
    var commArr = [];
    Object.values(seg1).forEach(function (el) {
      arr.push(el);
    });
    Object.values(seg2).forEach(function (el) {
      arr.push(el);
    });

    for (var i = 0; i < arr.length; i++) {
      if (i % 2 === 0) {
        commArr.push(arr[i] + "/" + arr[i + 1]);
      }
    }

    var duplicates = [];
    var tempArray = [].concat(commArr).sort();

    for (var _i5 = 0; _i5 < tempArray.length; _i5++) {
      if (tempArray[_i5 + 1] === tempArray[_i5]) {
        duplicates.push(tempArray[_i5]);
      }
    }

    var cords = duplicates[0].split("/");
    return {
      x: cords[0],
      y: cords[1]
    }; // return duplicates;
  }

  function calculateBisector(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "point";
    var bisector = {};
    var firstSegment, secondSegment;

    if (mode === "point") {
      firstSegment = computeSegment(_obj.firstPoint, _obj.secondPoint);
      secondSegment = computeSegment(_obj.secondPoint, _obj.thirdPoint);
    } else if (mode === "segment") {
      firstSegment = _obj.firstSegment;
      secondSegment = _obj.secondSegment;
    }

    bisector.eqn = computeBisectorEqn(computeEqn(firstSegment), computeEqn(secondSegment), firstSegment, secondSegment);
    bisector.formEqn = computeSolvingEqn(bisector, secondSegment);
    bisector.x = bisector.formEqn.computeX;
    bisector.y = bisector.formEqn.computeY;

    if (mode === "point") {
      bisector.bisectorLine = {
        type: "line",
        x: _obj.secondPoint.x,
        y: _obj.secondPoint.y,
        xTo: bisector.x,
        yTo: bisector.y // yTo:angleB.y

      };
    } else if (mode === "segment") {
      bisector.bisectorLine = {
        type: "line",
        x: _obj.x,
        y: _obj.y,
        xTo: bisector.x,
        yTo: bisector.y // yTo:angleB.y

      };
    }

    return bisector;
  }

  function computeBisectorEqn(first, second, m1, m2) {
    // const first={a:4,b:-3,c:4}
    // const second={a:6,b:8,c:-9};
    if (first.c < 0 && second.c >= 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
    }

    if (first.c >= 0 && second.c < 0) {
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    if (first.c < 0 && second.c < 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    var simpF = {},
        simpS = {};
    var step1LHS = "(".concat(first.a, "x+").concat(first.b, "y+").concat(first.c, ")/").concat(Math.sqrt(first.a * first.a + first.b * first.b));
    simpF.a = first.a / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.b = first.b / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.c = first.c / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.form = "".concat(simpF.a, "x+").concat(simpF.b, "y+").concat(simpF.c);
    var step1RHS = "(".concat(second.a, "x+").concat(second.b, "y+").concat(second.c, ")/").concat(Math.sqrt(second.a * second.a + second.b * second.b));
    simpS.a = second.a / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.b = second.b / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.c = second.c / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.form = "".concat(simpS.a, "x+").concat(simpS.b, "y+").concat(simpS.c);
    var answer = {};
    answer.firstCase = {};
    answer.secondCase = {};
    answer.firstCase.b = simpF.b - simpS.b;
    answer.firstCase.a = simpF.a - simpS.a;
    answer.firstCase.c = simpF.c - simpS.c;
    answer.secondCase.a = simpF.a + simpS.a;
    answer.secondCase.b = simpF.b + simpS.b;
    answer.secondCase.c = simpF.c + simpS.c;
    answer.required = {};
    var correctAnswer = checkAnswerCaseNew(first, second, answer.firstCase, answer.secondCase, m1, m2);
    answer.required = correctAnswer;
    return answer.required;
  }

  function checkAnswerCaseNew(segment1, segment2, firstCase, secondCase, m1, m2) {
    //a1a2+b1b2;
    var answer1 = findRatio(segment1, segment2, m1, m2);
    var product = {};
    var angle = answer1.degree;

    if (answer1.degree >= 270) {
      angle = answer1.degree - 270;
    }

    product.main = segment1.a * segment2.a + segment1.b * segment2.b;

    if (angle > 0 && angle < 90 && product.main < 0) {
      return firstCase;
    } else if (angle > 90 && product.main < 0) {
      return secondCase;
    } else if (angle > 90 && product.main > 0) {
      return firstCase;
    } else if (angle > 0 && angle < 90 && product.main > 0) {
      return secondCase;
    } else if (product.main === 0) {
      return secondCase;
    }
  }

  function findRatio(segment1, segment2, main1, main2) {
    var tangent = {};
    var angle = {};
    tangent.m1 = -(segment1.a / segment1.b);
    tangent.m2 = -(segment2.a / segment2.b);
    tangent.ratio = Math.abs((tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2));
    tangent.angle = Math.atan(tangent.ratio);
    tangent.degree = tangent.angle * (180 / Math.PI);
    tangent.obtuseAngle = Math.atan(-(tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2)) * (180 / Math.PI);
    tangent.tanTheta = (segment2.a * segment1.b - segment1.a * segment2.b) / (segment2.a * segment1.a + segment2.b * segment1.b);
    tangent.degSlope = Math.atan(tangent.tanTheta) * (180 / Math.PI);
    angle.startAngle = modelObj.LabComClass.Maths.getAngle(main1.xTo, main1.yTo, main1.x, main1.y);
    angle.endAngle = modelObj.LabComClass.Maths.getAngle(main2.x, main2.y, main2.xTo, main2.yTo);
    angle.angleRad = angle.startAngle - angle.endAngle;
    angle.angleS = angle.angleRad * 180 / Math.PI;

    if (angle.angleRad < 0) {
      angle.scene = 1;
      angle.degree = angle.angleRad * -1 * 180 / Math.PI;
    } else if (angle.angleRad > 0) {
      angle.scene = 2;
      angle.degree = 360 - angle.angleRad * 180 / Math.PI;
    }

    return angle;
  }

  function computeSolvingEqn(_obj, segment2) {
    var eqn = {};

    if (segment2.x === localObj.arbitaryX || segment2.xTo === localObj.arbitaryX) {
      localObj.arbitaryX = localObj.arbitaryX + 1;
    }

    eqn.eqn = "".concat(_obj.eqn.a, "x +").concat(_obj.eqn.b, "y +").concat(_obj.eqn.c);
    eqn.calcY = "y=(".concat(-_obj.eqn.a, "x + ").concat(-_obj.eqn.c, ")/").concat(_obj.eqn.b);
    eqn.computeY = (-_obj.eqn.a * localObj.arbitaryX + -_obj.eqn.c) / _obj.eqn.b;
    eqn.computeX = localObj.arbitaryX;

    if (!isFinite(eqn.computeY)) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    if (Math.trunc(_obj.eqn.b * 100) == 0) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    return eqn;
  }

  function computeEqn(segment) {
    var eqn = {};
    eqn.segment = segment.label;
    eqn.slope = isFinite(getSlope(segment.x, segment.y, segment.xTo, segment.yTo)) ? getSlope(segment.x, segment.y, segment.xTo, segment.yTo) : undefined;

    if (eqn.slope !== undefined) {
      eqn.eqn = "y-".concat(segment.y, "=").concat(eqn.slope, "*(x-").concat(segment.x, ")");
      eqn.b = 1;
      eqn.a = -eqn.slope;
      eqn.c = eqn.slope * segment.x - segment.y;
      eqn.cMod = Math.abs(eqn.slope * segment.x - segment.y);
      eqn.form = "y+".concat(eqn.a, "x+").concat(eqn.c);
    } else {
      eqn.eqn = "x=".concat(segment.x);
      eqn.form = "x-".concat(segment.x);
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -segment.x;
      eqn.cMod = Math.abs(-segment.x);
    }

    return eqn;
  }

  function computeSegment(firstPoint, secondPoint) {
    var segment = {};
    segment.x = firstPoint.x;
    segment.y = firstPoint.y;
    segment.xTo = secondPoint.x;
    segment.yTo = secondPoint.y;

    if (firstPoint.label && secondPoint.label) {
      segment.label = firstPoint.label + secondPoint.label;
    }

    return segment;
  }

  function computeCircle(_obj) {
    // Calculate Center and Raduis
    // Logic Here
    // Mid Point
    var fp = _obj.firstPoint;
    var sp = _obj.secondPoint;
    var tp = _obj.thirdPoint;
    var cData = circle3Handler(fp, sp, tp);
    return {
      r: cData.r,
      x: cData.x,
      y: cData.y
    };
  }

  function calculateAngle(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "angle";
    var firstPoint = _obj.firstPoint,
        secondPoint = _obj.secondPoint,
        thirdPoint = _obj.thirdPoint;
    var startAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, firstPoint.x, firstPoint.y);
    var endAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, thirdPoint.x, thirdPoint.y);
    var angle = startAngle - endAngle;

    if (angle < 0) {
      angle = angle * -1 * 180 / Math.PI;
    } else if (angle > 0) {
      angle = 360 - angle * 180 / Math.PI;
    }

    var angleText;

    if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === "angle") {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label, "=").concat(Math.round(angle), "\xB0");
    } else if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === "angleRay") {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label);
    } else if (mode === "angle") {
      angleText = "".concat(Math.round(angle), "\xB0");
    } else if (mode === "angleRay") {
      angleText = "";
    }

    return {
      angleText: angleText,
      angle: angle,
      angleValue: Math.round(angle),
      startAngle: startAngle,
      endAngle: endAngle
    };
  }

  function checkDataAvailable(target, keys) {
    // eslint-disable-next-line consistent-return
    for (var i = 0; i < keys.length; i++) {
      if (target[keys[i]] === null || isNaN(target[keys[i]])) {
        return false;
      }
    }

    return true;
  }

  function checkPoint(_obj) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d = modelObj.interactionElements[i]; // if (_d.type === 'point' && _d.uniqueId !== localObj.uniqueId)

      if (_d.type === "point") {
        newDist = modelObj.LabComClass.Maths.getDistance(_obj, _d);
      }

      if (dist === null && newDist !== null || dist !== null && newDist < dist) {
        dist = newDist;
        index = i;
      }
    }

    if (index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      localObj.mouseDown.objectDown = true;
      return index;
    }

    return null;
  }

  function checkPointv2(_obj) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d = modelObj.interactionElements[i]; // if (_d.type === 'point' && _d.uniqueId !== localObj.uniqueId)

      if (_d.type === "point" && _d.uniqueId !== localObj.currentUniqueId) {
        newDist = modelObj.LabComClass.Maths.getDistance(_obj, _d);
      }

      if (dist === null && newDist !== null || dist !== null && newDist < dist) {
        dist = newDist;
        index = i;
      }
    }

    if (index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      localObj.mouseDown.objectDown = true;
      return index;
    }

    return null;
  }

  function isItCloseToPlotedPoint(point, avoidCurrentPoint) {
    var dist = null,
        newDist = null,
        index = null;

    for (var i = modelObj.interactionElements.length - 1; i >= 0; i--) {
      var _d = modelObj.interactionElements[i];

      if (!avoidCurrentPoint || _d.uniqueId !== localObj.currentUniqueId || modelObj.interactionType === "move" && _d.uniqueId !== localObj.currentUniqueId) {
        if (_d.type === "point") {
          newDist = modelObj.LabComClass.Maths.getDistance(point, _d);
        } else {
          newDist = null;
        }

        if (newDist !== null && (dist === null || newDist < dist)) {
          dist = newDist;
          index = i;
        }
      }
    }

    if (newDist !== null && index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      return {
        dist: dist,
        index: index,
        plotedPoint: modelObj.interactionElements[index]
      };
    }

    return null;
  }

  function isItCloseToParameterPoint(point) {
    var dist = null,
        newDist = null;
    var _modelObj$LabComClass2 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass2.getDistance,
        getPoint = _modelObj$LabComClass2.getPoint,
        getAngle = _modelObj$LabComClass2.getAngle,
        pointInSegment = _modelObj$LabComClass2.pointInSegment,
        getLineintersect = _modelObj$LabComClass2.getLineintersect,
        getPointLineDistance = _modelObj$LabComClass2.getPointLineDistance;
    var intersectionP = null;

    for (var i = 0; i < modelObj.interactionElements.length - 1; i++) {
      var shape = modelObj.interactionElements[i];

      if (shape.type !== "point") {
        if (checkType(shape, localObj.lineTypes)) {
          var distFromLine = getPointLineDistance(point, shape, {
            x: shape.xTo,
            y: shape.yTo
          });
          newDist = Math.abs(distFromLine);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            var lineAngle = getAngle(shape.x, shape.y, shape.xTo, shape.yTo);
            var point2 = getPoint(point, lineAngle + Math.PI / 2, 2);
            var intersection = getLineintersect(shape.x, shape.y, shape.xTo, shape.yTo, point.x, point.y, point2.x, point2.y);
            var shapeLength = getDistance(shape, {
              x: shape.xTo,
              y: shape.yTo
            });
            var intersectionDist = getDistance(shape, intersection);
            var percentage = intersectionDist / shapeLength;
            var pointAngle = getAngle(shape.x, shape.y, intersection.x, intersection.y);
            var pointAccepted = true;

            if (shape.type.includes("segment")) {
              var isInSegment = pointInSegment(intersection, shape, {
                x: shape.xTo,
                y: shape.yTo
              });

              if (!isInSegment) {
                pointAccepted = false;
              }
            }

            if (shape.type === "ray") {
              var _isInSegment = pointInSegment(intersection, shape, {
                x: shape.xOr,
                y: shape.yOr
              });

              if (!_isInSegment) {
                pointAccepted = false;
              }
            }

            if (pointAccepted) {
              dist = newDist;

              if (checkDataAvailable(intersection, ["x", "y"])) {
                intersectionP = intersection;
                intersectionP.dist = dist;
                intersectionP.updateKeys = {
                  x: intersectionP.x,
                  y: intersectionP.y,
                  line: shape.uniqueId,
                  pointAngle: Math.round(pointAngle) === Math.round(lineAngle),
                  percentage: percentage,
                  isParameter: true
                };
              }
            }
          }
        }

        if (shape.type === "circle" || shape.type === "compass") {
          var distFromCenter = getDistance(shape, point);
          newDist = Math.abs(distFromCenter - shape.r);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            dist = newDist;
            var angle = getAngle(shape.x, shape.y, point.x, point.y);
            intersectionP = getPoint(shape, angle, shape.r);

            if (checkDataAvailable(intersectionP, ["x", "y"])) {
              intersectionP.dist = dist;
              intersectionP.updateKeys = {
                x: intersectionP.x,
                y: intersectionP.y,
                circle: shape.uniqueId,
                angle: angle,
                isParameter: true
              };
            } else {
              intersectionP = null;
            }
          }
        }
      }
    }

    return intersectionP;
  }

  function isItCloseToIntersectionPoint(point) {
    var dist = null,
        newDist = null;
    var shapesData = modelObj.interactionElements;
    var intersectionP = null;

    for (var i = 0; i < shapesData.length - 1; i++) {
      var firstShape = shapesData[i];

      if (firstShape.type !== "point") {
        for (var j = i + 1; j < shapesData.length; j++) {
          var secondShape = shapesData[j];

          if (secondShape.type !== "point") {
            if (checkType(firstShape, localObj.lineTypes) && checkType(secondShape, localObj.lineTypes) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var data = getInteractionOfTwoLines(firstShape, secondShape, point);

              if (data !== null) {
                if (data.dist < dist || dist === null) {
                  newDist = data.dist;
                  dist = data.dist;
                  intersectionP = data;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    l1: firstShape.uniqueId,
                    l2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if ((checkType(firstShape, localObj.lineTypes) && checkType(secondShape, ["circle", "compass"]) || checkType(secondShape, localObj.lineTypes) && checkType(firstShape, ["circle", "compass"])) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var circleShape = void 0,
                  lineShape = void 0;

              if (firstShape.type === "circle" || firstShape.type === "compass") {
                circleShape = firstShape;
                lineShape = secondShape;
              } else {
                circleShape = secondShape;
                lineShape = firstShape;
              }

              var _data3 = getInteractionOfCircleLine(circleShape, lineShape, point, modelObj.snappingDiff);

              if (_data3 !== null) {
                if (_data3.dist < dist || dist === null) {
                  newDist = _data3.dist;
                  dist = _data3.dist;
                  intersectionP = _data3;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    circle: circleShape.uniqueId,
                    line: lineShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if (checkType(firstShape, ["circle", "compass"]) && checkType(secondShape, ["circle", "compass"]) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var _data4 = getInteractionOfTwoCircles(firstShape, secondShape, point, modelObj.snappingDiff, false);

              if (_data4) {
                if (_data4.dist < dist || dist === null) {
                  newDist = _data4.dist;
                  dist = _data4.dist;
                  intersectionP = _data4;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    intersectAngle: intersectionP.angle1,
                    circle1: firstShape.uniqueId,
                    circle2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } // if (intersectionP) {
            //   break;
            // }

          }
        } // if (intersectionP) {
        //   break;
        // }

      }
    }

    return intersectionP;
  }

  function checkType(shape, types) {
    return types.includes(shape.type);
  }

  function getInteractionOfTwoCircles(circle1, circle2, point, snapDiff) {
    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length > 1) {
      var getDist = function getDist(p1, p2) {
        var dist = modelObj.LabComClass.Maths.getDistance(p1, point);

        if (snapDiff !== false) {
          if (dist <= getPointUnitByPixelUnit(snapDiff)) {
            p1.dist = dist;
            var centerPointsLine = new modelObj.LabComClass.Vector(circle2.x - circle1.x, circle2.y - circle1.y);
            var firstIntersectLine = new modelObj.LabComClass.Vector(p1.x - circle1.x, p1.y - circle1.y);
            p1.angle = centerPointsLine.crossProduct(firstIntersectLine).z;
            return dist;
          }

          return null;
        }

        p1.angle1 = modelObj.LabComClass.Maths.getAngle(circle1.x, circle1.y, p1.x, p1.y);
        p1.dist = dist;
        return dist;
      };

      var acceptedIntersections = [];
      var p = getDist(intersection[0], intersection[1]);

      if (p !== null) {
        acceptedIntersections.push(intersection[0]);
      }

      p = getDist(intersection[1], intersection[0]);

      if (p !== null) {
        acceptedIntersections.push(intersection[1]);
      }

      if (acceptedIntersections.length) {
        var lowestIndex = 0;
        var closeDist = acceptedIntersections[0].dist;

        for (var i = 0; i < acceptedIntersections.length; i++) {
          if (acceptedIntersections[i].dist < closeDist) {
            closeDist = acceptedIntersections[i].dist;
            lowestIndex = i;
          }
        }

        return acceptedIntersections[lowestIndex];
      }

      return null;
    }

    return null;
  }

  function getInteractionOfCircleLine(circle, line, point, snapDiff) {
    var lineData = {
      x: line.x,
      y: line.y,
      xTo: line.xTo,
      yTo: line.yTo
    };

    if (line.type === "ray") {
      lineData.xTo = line.xOr;
      lineData.yTo = line.yOr;
    }

    var intersection = findCircleLineIntersect(circle, lineData);

    if (intersection.p1 || intersection.p2) {
      var getDist = function getDist(p) {
        if ((line.type.includes("segment") || line.type === "ray") && !p.isInSegment) {
          return null;
        }

        var dist = modelObj.LabComClass.Maths.getDistance(p, point);

        if (snapDiff !== undefined) {
          if (dist < getPointUnitByPixelUnit(snapDiff)) {
            p.dist = dist;
            return dist;
          }

          return null;
        }

        p.dist = dist;
        return dist;
      };

      var distP1 = null,
          distP2 = null;
      distP1 = getDist(intersection.p1);
      distP2 = getDist(intersection.p2);

      if (distP1 !== null && distP2 !== null) {
        if (distP1 < distP2) {
          return intersection.p1;
        }

        return intersection.p2;
      }

      if (distP1 !== null) {
        return intersection.p1;
      }

      if (distP2 !== null) {
        return intersection.p2;
      }

      return null;
    }

    return null;
  }

  function getInteractionOfTwoLines(l1, l2, point) {
    var intersection = modelObj.LabComClass.Maths.getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);

    if (intersection) {
      if (l1.type.includes("segment") && !intersection.onLine1 || l2.type.includes("segment") && !intersection.onLine2) {
        return null;
      }

      var distance = modelObj.LabComClass.Maths.getDistance(intersection, point);

      if (distance < getPointUnitByPixelUnit(10)) {
        intersection.dist = distance;
        return intersection;
      }

      return null;
    }

    return null;
  }

  function moveShape(e) {
    //Same as select Shape but doesnt have dont Select as it's required to move label even if it is not selectable.
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;

      for (var i = 0; i < shapesData.length; i++) {
        var _d = shapesData[i];

        if (_d.type === "circle" || _d.type === "compass" || _d.type === "circle_3") {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === "line"
        /*&& !_d.dontSelect*/
        || _d.type === "perpendicularLine" || _d.type === "parallelLine") {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        } else if (_d.type.includes("segment")
        /*&& !_d.dontSelect*/
        || _d.type === "ray") {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === "ray") {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = "bottom";
    var labelId = null;

    for (var _i6 = 0; _i6 < shapesData.length; _i6++) {
      var _d6 = shapesData[_i6];
      var calculated = false;

      if (_d6.label !== undefined) {
        var label = getPixelByPoint(_d6.labelX, _d6.labelY);
        label.x += Number(_d6.labelDiffX);
        label.y += Number(_d6.labelDiffY);
        var w = ctx.measureText(_d6.label).width;

        if (_d6.labelAlign && _d6.labelAlign === "center") {
          if (pxl.x > label.x - w / 2 - 20 && pxl.x < label.x + w / 2 + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 20 && pxl.x < label.x + w + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated
      /*&& !_d.dontSelect*/
      ) {
          dist = Math.abs(newDist);
          index = _i6;
          labelId = _i6;
        }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === "mousedown") {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === "move") {
            for (var _i7 = 0; _i7 < shapesData.length; _i7++) {
              shapesData[_i7].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
        }
      }
    }

    return null;
  }

  function selectShape(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;

      for (var i = 0; i < shapesData.length; i++) {
        var _d = shapesData[i];

        if (_d.type === "circle" || _d.type === "compass" || _d.type === "circle_3") {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === "line" && !_d.dontSelect || _d.type === "perpendicularLine" || _d.type === "parallelLine") {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        } else if (_d.type.includes("segment") && !_d.dontSelect || _d.type === "ray") {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === "ray") {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = "bottom";
    var labelId = null;

    for (var _i8 = 0; _i8 < shapesData.length; _i8++) {
      var _d7 = shapesData[_i8];
      var calculated = false;

      if (_d7.label !== undefined) {
        var label = getPixelByPoint(_d7.labelX, _d7.labelY);
        label.x += Number(_d7.labelDiffX);
        label.y += Number(_d7.labelDiffY);
        var w = ctx.measureText(_d7.label).width;

        if (_d7.labelAlign && _d7.labelAlign === "center") {
          if (pxl.x > label.x - w / 2 - 20 && pxl.x < label.x + w / 2 + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 20 && pxl.x < label.x + w + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null && !_d7.dontSelect || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated && !_d7.dontSelect) {
        dist = Math.abs(newDist);
        index = _i8;
        labelId = _i8;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === "mousedown") {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === "move") {
            for (var _i9 = 0; _i9 < shapesData.length; _i9++) {
              shapesData[_i9].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
        }
      }
    }

    return null;
  }

  function isOnShape(e) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;
    var _modelObj$LabComClass3 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass3.getDistance,
        getPointLineDistance = _modelObj$LabComClass3.getPointLineDistance;
    var data = isItCloseToPlotedPoint(getPointByPixel(e.pageX, e.pageY), false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;
      var p = getPointByPixel(e.pageX, e.pageY);
      modelObj.interactionElements.forEach(function (_d, i) {
        if (_d.type === "circle" || _d.type === "compass") {
          newDist = getDistance(p, _d) - _d.r;
        }

        if (_d.type === "line" || _d.type === "perpendicularLine" || _d.type === "parallelLine") {
          // newDist = getPointLineDistance(p, _d, { x: _d.xTo, y: _d.yTo });
          if (!isNaN(_d.xTo) || !isNaN(_d.yTo)) {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });
          }
        }

        if (_d.type.includes("segment") || _d.type === "ray") {
          newDist = getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === "ray") {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = getDistance(p, _d);
            var endPointDist = getDistance(p, endPoint);
            var length = getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = newDist;
          index = i;
        }
      });
    }

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      return modelObj.interactionElements[index].uniqueId;
    }

    return null;
  }

  function getPLine(e, isPerpendicular) {
    var point = getPointByPixel(e.pageX, e.pageY);
    var data = {
      visible: true,
      x: point.x,
      y: point.y,
      xOr: point.x,
      yOr: point.y,
      xTo: point.x,
      yTo: point.y,
      xOrTo: point.x,
      yOrTo: point.y,
      slope: 0,
      distance: null
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d8 = modelObj.interactionElements[i];

      if (checkType(_d8, localObj.lineTypes) && _d8.uniqueId !== localObj.currentUniqueId) {
        var distance = getPointLineDistance({
          x: data.x,
          y: data.y
        }, {
          x: _d8.x,
          y: _d8.y
        }, {
          x: _d8.xTo,
          y: _d8.yTo
        });
        distance = Math.abs(distance);

        if (_d8.type.includes("segment") || _d8.type === "ray") {
          if (distance < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d8.xTo,
              y: _d8.yTo
            };

            if (_d8.type === "ray") {
              endPoint = {
                x: _d8.xOr,
                y: _d8.yOr
              };
            }

            if (!modelObj.LabComClass.Maths.pointInSegment(point, _d8, endPoint)) {
              continue;
            }
          } else {
            continue;
          }
        }

        if (data.distance === null || data.distance > distance) {
          data.distance = distance;
          data.line = _d8.uniqueId;
          data.slope = modelObj.LabComClass.Maths.getAngle(_d8.x, _d8.y, _d8.xTo, _d8.yTo);

          if (isPerpendicular) {
            data.slope += Math.PI / 2;
          }

          var newP = modelObj.LabComClass.Maths.getPoint({
            x: data.x,
            y: data.y
          }, data.slope, 10);
          data.xTo = newP.x;
          data.yTo = newP.y;
        }
      }
    }

    if (data.distance !== null && data.distance < getPointUnitByPixelUnit(10)) {
      return data;
    }

    return false;
  }

  function getPointLineDistance(_pt, _line1, _line2) {
    var _dist = modelObj.LabComClass.Maths.getDistance(_line1, _line2);

    var _ans = 0;

    if (_dist > 0) {
      var _num = (_line2.x - _line1.x) * (_line1.y - _pt.y) - (_line2.y - _line1.y) * (_line1.x - _pt.x);

      _ans = _num / _dist;
    }

    return _ans;
  }

  function updatePoints(shape) {
    if (shape.label) {
      // const p = findLableByPoint(shape);
      shape.labelX = shape.x;
      shape.labelY = shape.y;

      if (shape.labelDiffX === 0) {
        shape.labelDiffX = 6;
        shape.labelDiffY = -9;
      }
    }
  } // =================================================


  function updateLinePoints(curInt) {
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 10;

    var _angle = modelObj.LabComClass.Maths.getAngle(curInt.x, curInt.y, curInt.xTo, curInt.yTo);

    var _newPoint = modelObj.LabComClass.Maths.getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;

    var _angle2 = modelObj.LabComClass.Maths.getAngle(curInt.xTo, curInt.yTo, curInt.x, curInt.y);

    var _newPoint2 = modelObj.LabComClass.Maths.getPoint({
      x: curInt.xTo,
      y: curInt.yTo
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y;

    if (curInt.label) {
      var p = findLableByLine(curInt, {
        x: curInt.xTo,
        y: curInt.yTo
      });
      curInt.labelX = p.x;
      curInt.labelY = p.y;
    }

    if (curInt && curInt.connectionId && curInt.connectionId.length) {
      for (var i = 0; i < curInt.connectionId.length; i++) {
        var shapeData = findShape(curInt.connectionId[i]);

        if (shapeData && (shapeData.shape.type === "perpendicularLine" || shapeData.shape.type === "parallelLine")) {
          shapeData.shape.slope = _angle;

          if (shapeData.shape.type === "perpendicularLine") {
            shapeData.shape.slope += Math.PI / 2;
          }

          updatePLinePoints(shapeData.shape);
        }
      }
    }
  }

  function findLableByPoint(p1) {
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.font = modelObj.fontSize + "px " + modelObj.LabComClass.polo22KlettRegular;

    var width = _ctx.measureText(p1.label).width;

    var height = _ctx.measureText(p1.label).height;

    _ctx.restore();

    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = modelObj.LabComClass.Maths.getRandomNumber(0, Math.PI * 2, 1, 0.1);
      var dist = 5;
      p = modelObj.LabComClass.Maths.getPoint(p1, angle, dist);

      if (angle > Math.PI - 1 && angle < Math.PI + 1) {
        p.x -= width;
      }

      if (angle > Math.PI + 1 && angle < Math.PI * 2) {
        p.y -= height;
      }

      if (angle < 1 || angle > Math.PI * 2 - 1) {
        p.x += width;
      }

      if (angle < Math.PI - 1) {
        p.y += height;
      }

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = p1.x;
        p.y = p1.y - 5;
        break;
      }

      counter++;
    }

    return p;
  }

  function getSlope(_x1, _y1, _x2, _y2) {
    return (_y2 - _y1) / (_x2 - _x1);
  }

  function findLableByLine(shape, point2) {
    var _modelObj$LabComClass4 = modelObj.LabComClass.Maths,
        getRandomNumber = _modelObj$LabComClass4.getRandomNumber,
        getPoint = _modelObj$LabComClass4.getPoint,
        getAngle = _modelObj$LabComClass4.getAngle,
        getDistance = _modelObj$LabComClass4.getDistance,
        getPointLineDistance = _modelObj$LabComClass4.getPointLineDistance;

    if (shape.labelX !== undefined) {
      var pos = getPixelByPoint(shape.labelX, shape.labelY);

      if (pos.x > modelObj.x && pos.x < modelObj.x + modelObj.width && pos.y > modelObj.y && pos.y < modelObj.y + modelObj.height) {
        var dist = getPointLineDistance({
          x: shape.labelX,
          y: shape.labelY
        }, shape, {
          x: shape.xTo,
          y: shape.yTo
        });

        if (Math.abs(dist) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
          var nearbyPointFound = false;

          for (var i = 0; i < modelObj.interactionElements.length; i++) {
            var point = modelObj.interactionElements[i];

            if (point.type === "point" && shape.label) {
              var _dist2 = getDistance({
                x: point.x + getPointUnitByPixelUnit(10),
                y: point.y - getPointUnitByPixelUnit(10)
              }, {
                x: shape.labelX,
                y: shape.labelY
              });

              if (_dist2 < getPointUnitByPixelUnit(modelObj.snappingDiff * 1.2)) {
                nearbyPointFound = true;
                break;
              }
            }
          }

          if (!nearbyPointFound) {
            return {
              x: shape.labelX,
              y: shape.labelY
            };
          }
        }
      }
    }

    var p1 = getPixelByPoint(shape.x, shape.y);
    var p2 = getPixelByPoint(point2.x, point2.y);
    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = getAngle(p1.x, p1.y, p2.x, p2.y);

      var _dist3 = getRandomNumber(-1 * (maxX - minX), maxX - minX, 1, 1);

      if (shape.type === "ray") {
        _dist3 = Math.abs(_dist3);
      }

      p = getPoint(p1, angle, _dist3);

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        for (var _i10 = 0; _i10 < modelObj.interactionElements.length; _i10++) {
          var _shape = modelObj.interactionElements[_i10];

          if (_shape.type === "point" && _shape.label) {
            var _dist4 = getDistance({
              x: _shape.x + getPointUnitByPixelUnit(10),
              y: _shape.y - getPointUnitByPixelUnit(10)
            }, p);

            if (_dist4 < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
              breakIt = false;
            }
          }
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = (p1.x + p2.x) / 2;
        p.y = (p1.y + p2.y) / 2;
        break;
      }

      counter++;
    }

    p = getPointByPixel(p.x, p.y);
    return p;
  }

  function updatePLinePoints(curInt) {
    var _modelObj$LabComClass5 = modelObj.LabComClass.Maths,
        getAngle = _modelObj$LabComClass5.getAngle,
        getPoint = _modelObj$LabComClass5.getPoint;
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 2;

    if (curInt.line !== undefined) {
      var shapeData = findShape(curInt.line);

      if (shapeData.shape) {
        var _d9 = shapeData.shape;
        var slope = getAngle(_d9.x, _d9.y, _d9.xTo, _d9.yTo);

        if (curInt.type === "perpendicularLine") {
          slope += Math.PI / 2;
        }

        curInt.slope = slope;
      }
    }

    var _angle = curInt.slope;

    var _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;
    _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, 20);
    curInt.xTo = _newPoint.x;
    curInt.yTo = _newPoint.y;

    var _angle2 = curInt.slope + Math.PI;

    var _newPoint2 = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y;

    if (curInt.label) {
      var p = findLableByLine(curInt, {
        x: curInt.xTo,
        y: curInt.yTo
      });
      curInt.labelX = p.x;
      curInt.labelY = p.y;
    }
  } // =================================================


  function dispatchEventCustom(value) {
    var _obj = {};
    _obj.id = modelObj.id;
    _obj.type = "geoInteraction";
    value = JSON.parse(JSON.stringify(value));
    value.type = modelObj.interactionType;
    _obj.data = value;

    if (typeof events[_obj.type] !== "undefined") {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventCircleMove(value) {
    var _obj = {};
    _obj.id = modelObj.id;
    value.type = modelObj.interactionType;
    _obj.type = "geoCircle";
    _obj.data = value;

    if (typeof events[_obj.type] !== "undefined") {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventScale() {
    var value = {};
    value.id = modelObj.id;
    value.type = "geoScale";
    value.length = modelObj.LabComClass.Maths.getDistance({
      x: scaleObj.x,
      y: scaleObj.y
    }, {
      x: scaleObj.xTo,
      y: scaleObj.yTo
    });

    if (typeof events[value.type] !== "undefined") {
      events[value.type](value, true);
    }
  }
}
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";var e,i;function c(){return e.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function u(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function l(e){return void 0===e}function h(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function d(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function f(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function m(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function _(e,t){for(var n in t)m(t,n)&&(e[n]=t[n]);return m(t,"toString")&&(e.toString=t.toString),m(t,"valueOf")&&(e.valueOf=t.valueOf),e}function y(e,t,n,s){return Tt(e,t,n,s,!0).utc()}function g(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function v(e){if(null==e._isValid){var t=g(e),n=i.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function p(e){var t=y(NaN);return null!=e?_(g(t),e):g(t).userInvalidated=!0,t}i=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var r=c.momentProperties=[];function w(e,t){var n,s,i;if(l(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),l(t._i)||(e._i=t._i),l(t._f)||(e._f=t._f),l(t._l)||(e._l=t._l),l(t._strict)||(e._strict=t._strict),l(t._tzm)||(e._tzm=t._tzm),l(t._isUTC)||(e._isUTC=t._isUTC),l(t._offset)||(e._offset=t._offset),l(t._pf)||(e._pf=g(t)),l(t._locale)||(e._locale=t._locale),0<r.length)for(n=0;n<r.length;n++)l(i=t[s=r[n]])||(e[s]=i);return e}var t=!1;function M(e){w(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===t&&(t=!0,c.updateOffset(this),t=!1)}function k(e){return e instanceof M||null!=e&&null!=e._isAMomentObject}function S(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function D(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=S(t)),n}function a(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&D(e[s])!==D(t[s]))&&a++;return a+r}function Y(e){!1===c.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function n(i,r){var a=!0;return _(function(){if(null!=c.deprecationHandler&&c.deprecationHandler(null,i),a){for(var e,t=[],n=0;n<arguments.length;n++){if(e="","object"==typeof arguments[n]){for(var s in e+="\n["+n+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2)}else e=arguments[n];t.push(e)}Y(i+"\nArguments: "+Array.prototype.slice.call(t).join("")+"\n"+(new Error).stack),a=!1}return r.apply(this,arguments)},r)}var s,O={};function T(e,t){null!=c.deprecationHandler&&c.deprecationHandler(e,t),O[e]||(Y(t),O[e]=!0)}function b(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function x(e,t){var n,s=_({},e);for(n in t)m(t,n)&&(u(e[n])&&u(t[n])?(s[n]={},_(s[n],e[n]),_(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)m(e,n)&&!m(t,n)&&u(e[n])&&(s[n]=_({},s[n]));return s}function P(e){null!=e&&this.set(e)}c.suppressDeprecationWarnings=!1,c.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)m(e,t)&&n.push(t);return n};var W={};function C(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e}function H(e){return"string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function R(e){var t,n,s={};for(n in e)m(e,n)&&(t=H(n))&&(s[t]=e[n]);return s}var U={};function F(e,t){U[e]=t}function L(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(0<=e?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return L(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(s){var e,i,t,r=s.match(N);for(e=0,i=r.length;e<i;e++)E[r[e]]?r[e]=E[r[e]]:r[e]=(t=r[e]).match(/\[[\s\S]/)?t.replace(/^\[|\]$/g,""):t.replace(/\\/g,"");return function(e){var t,n="";for(t=0;t<i;t++)n+=b(r[t])?r[t].call(e,s):r[t];return n}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;0<=n&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,n,s){oe[e]=b(n)?n:function(e,t){return e&&s?s:n}}function le(e,t){return m(oe,e)?oe[e](t._strict,t._locale):new RegExp(he(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function he(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var de={};function ce(e,n){var t,s=n;for("string"==typeof e&&(e=[e]),h(n)&&(s=function(e,t){t[n]=D(e)}),t=0;t<e.length;t++)de[e[t]]=s}function fe(e,i){ce(e,function(e,t,n,s){n._w=n._w||{},i(e,n._w,n,s)})}var me=0,_e=1,ye=2,ge=3,ve=4,pe=5,we=6,Me=7,ke=8;function Se(e){return De(e)?366:365}function De(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),C("year","y"),F("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],me),ce("YYYY",function(e,t){t[me]=2===e.length?c.parseTwoDigitYear(e):D(e)}),ce("YY",function(e,t){t[me]=c.parseTwoDigitYear(e)}),ce("Y",function(e,t){t[me]=parseInt(e,10)}),c.parseTwoDigitYear=function(e){return D(e)+(68<D(e)?1900:2e3)};var Ye,Oe=Te("FullYear",!0);function Te(t,n){return function(e){return null!=e?(xe(this,t,e),c.updateOffset(this,n),this):be(this,t)}}function be(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function xe(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&De(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Pe(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function Pe(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?De(e)?29:28:31-s%7%2}Ye=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),C("month","M"),F("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[_e]=D(e)-1}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[_e]=i:g(n).invalidMonth=e});var We=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Ce="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var He="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Re(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=D(t);else if(!h(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),Pe(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Ue(e){return null!=e?(Re(this,e),c.updateOffset(this,!0),this):be(this,"Month")}var Fe=ae;var Le=ae;function Ne(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=y([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=he(s[t]),i[t]=he(i[t]);for(t=0;t<24;t++)r[t]=he(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Ge(e){var t;if(e<100&&0<=e){var n=Array.prototype.slice.call(arguments);n[0]=e+400,t=new Date(Date.UTC.apply(null,n)),isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e)}else t=new Date(Date.UTC.apply(null,arguments));return t}function Ve(e,t,n){var s=7+t-n;return-((7+Ge(e,0,s).getUTCDay()-t)%7)+s-1}function Ee(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ve(e,s,i);return a=o<=0?Se(r=e-1)+o:o>Se(e)?(r=e+1,o-Se(e)):(r=e,o),{year:r,dayOfYear:a}}function Ie(e,t,n){var s,i,r=Ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+Ae(i=e.year()-1,t,n):a>Ae(e.year(),t,n)?(s=a-Ae(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function Ae(e,t,n){var s=Ve(e,t,n),i=Ve(e+1,t,n);return(Se(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),C("week","w"),C("isoWeek","W"),F("week",5),F("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=D(e)});function je(e,t){return e.slice(t,7).concat(e.slice(0,t))}I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),C("day","d"),C("weekday","e"),C("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:g(n).invalidWeekday=e}),fe(["d","e","E"],function(e,t,n,s){t[s]=D(e)});var Ze="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var $e="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var qe=ae;var Je=ae;var Be=ae;function Qe(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=y([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=he(o[t]),u[t]=he(u[t]),l[t]=he(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Xe(){return this.hours()%12||12}function Ke(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function et(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Xe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)}),I("hmmss",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)+L(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+L(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+L(this.minutes(),2)+L(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),C("hour","h"),F("hour",13),ue("a",et),ue("A",et),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],ge),ce(["k","kk"],function(e,t,n){var s=D(e);t[ge]=24===s?0:s}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),ce(["h","hh"],function(e,t,n){t[ge]=D(e),g(n).bigHour=!0}),ce("hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s)),g(n).bigHour=!0}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i)),g(n).bigHour=!0}),ce("Hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s))}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i))});var tt,nt=Te("Hours",!0),st={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Ce,monthsShort:He,week:{dow:0,doy:6},weekdays:Ze,weekdaysMin:$e,weekdaysShort:ze,meridiemParse:/[ap]\.?m?\.?/i},it={},rt={};function at(e){return e?e.toLowerCase().replace("_","-"):e}function ot(e){var t=null;if(!it[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=tt._abbr,require("./locale/"+e),ut(t)}catch(e){}return it[e]}function ut(e,t){var n;return e&&((n=l(t)?ht(e):lt(e,t))?tt=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),tt._abbr}function lt(e,t){if(null===t)return delete it[e],null;var n,s=st;if(t.abbr=e,null!=it[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=it[e]._config;else if(null!=t.parentLocale)if(null!=it[t.parentLocale])s=it[t.parentLocale]._config;else{if(null==(n=ot(t.parentLocale)))return rt[t.parentLocale]||(rt[t.parentLocale]=[]),rt[t.parentLocale].push({name:e,config:t}),null;s=n._config}return it[e]=new P(x(s,t)),rt[e]&&rt[e].forEach(function(e){lt(e.name,e.config)}),ut(e),it[e]}function ht(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return tt;if(!o(e)){if(t=ot(e))return t;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=at(e[r]).split("-")).length,n=(n=at(e[r+1]))?n.split("-"):null;0<t;){if(s=ot(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&a(i,n,!0)>=t-1)break;t--}r++}return tt}(e)}function dt(e){var t,n=e._a;return n&&-2===g(e).overflow&&(t=n[_e]<0||11<n[_e]?_e:n[ye]<1||n[ye]>Pe(n[me],n[_e])?ye:n[ge]<0||24<n[ge]||24===n[ge]&&(0!==n[ve]||0!==n[pe]||0!==n[we])?ge:n[ve]<0||59<n[ve]?ve:n[pe]<0||59<n[pe]?pe:n[we]<0||999<n[we]?we:-1,g(e)._overflowDayOfYear&&(t<me||ye<t)&&(t=ye),g(e)._overflowWeeks&&-1===t&&(t=Me),g(e)._overflowWeekday&&-1===t&&(t=ke),g(e).overflow=t),e}function ct(e,t,n){return null!=e?e:null!=t?t:n}function ft(e){var t,n,s,i,r,a=[];if(!e._d){var o,u;for(o=e,u=new Date(c.now()),s=o._useUTC?[u.getUTCFullYear(),u.getUTCMonth(),u.getUTCDate()]:[u.getFullYear(),u.getMonth(),u.getDate()],e._w&&null==e._a[ye]&&null==e._a[_e]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ct(t.GG,e._a[me],Ie(bt(),1,4).year),s=ct(t.W,1),((i=ct(t.E,1))<1||7<i)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Ie(bt(),r,a);n=ct(t.gg,e._a[me],l.year),s=ct(t.w,l.week),null!=t.d?((i=t.d)<0||6<i)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||6<t.e)&&(u=!0)):i=r}s<1||s>Ae(n,r,a)?g(e)._overflowWeeks=!0:null!=u?g(e)._overflowWeekday=!0:(o=Ee(n,s,i,r,a),e._a[me]=o.year,e._dayOfYear=o.dayOfYear)}(e),null!=e._dayOfYear&&(r=ct(e._a[me],s[me]),(e._dayOfYear>Se(r)||0===e._dayOfYear)&&(g(e)._overflowDayOfYear=!0),n=Ge(r,0,e._dayOfYear),e._a[_e]=n.getUTCMonth(),e._a[ye]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=a[t]=s[t];for(;t<7;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ge]&&0===e._a[ve]&&0===e._a[pe]&&0===e._a[we]&&(e._nextDay=!0,e._a[ge]=0),e._d=(e._useUTC?Ge:function(e,t,n,s,i,r,a){var o;return e<100&&0<=e?(o=new Date(e+400,t,n,s,i,r,a),isFinite(o.getFullYear())&&o.setFullYear(e)):o=new Date(e,t,n,s,i,r,a),o}).apply(null,a),i=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ge]=24),e._w&&void 0!==e._w.d&&e._w.d!==i&&(g(e).weekdayMismatch=!0)}}var mt=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,yt=/Z|[+-]\d\d(?::?\d\d)?/,gt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],vt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],pt=/^\/?Date\((\-?\d+)/i;function wt(e){var t,n,s,i,r,a,o=e._i,u=mt.exec(o)||_t.exec(o);if(u){for(g(e).iso=!0,t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[1])){i=gt[t][0],s=!1!==gt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=vt.length;t<n;t++)if(vt[t][1].exec(u[3])){r=(u[2]||" ")+vt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!yt.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),Yt(e)}else e._isValid=!1}var Mt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function kt(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),He.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var St={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Dt(e){var t,n,s,i=Mt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(i){var r=kt(i[4],i[3],i[2],i[5],i[6],i[7]);if(t=i[1],n=r,s=e,t&&ze.indexOf(t)!==new Date(n[0],n[1],n[2]).getDay()&&(g(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=r,e._tzm=function(e,t,n){if(e)return St[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(i[8],i[9],i[10]),e._d=Ge.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),g(e).rfc2822=!0}else e._isValid=!1}function Yt(e){if(e._f!==c.ISO_8601)if(e._f!==c.RFC_2822){e._a=[],g(e).empty=!0;var t,n,s,i,r,a,o,u,l=""+e._i,h=l.length,d=0;for(s=j(e._f,e._locale).match(N)||[],t=0;t<s.length;t++)i=s[t],(n=(l.match(le(i,e))||[])[0])&&(0<(r=l.substr(0,l.indexOf(n))).length&&g(e).unusedInput.push(r),l=l.slice(l.indexOf(n)+n.length),d+=n.length),E[i]?(n?g(e).empty=!1:g(e).unusedTokens.push(i),a=i,u=e,null!=(o=n)&&m(de,a)&&de[a](o,u._a,u,a)):e._strict&&!n&&g(e).unusedTokens.push(i);g(e).charsLeftOver=h-d,0<l.length&&g(e).unusedInput.push(l),e._a[ge]<=12&&!0===g(e).bigHour&&0<e._a[ge]&&(g(e).bigHour=void 0),g(e).parsedDateParts=e._a.slice(0),g(e).meridiem=e._meridiem,e._a[ge]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):(null!=e.isPM&&((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0)),t)}(e._locale,e._a[ge],e._meridiem),ft(e),dt(e)}else Dt(e);else wt(e)}function Ot(e){var t,n,s,i,r=e._i,a=e._f;return e._locale=e._locale||ht(e._l),null===r||void 0===a&&""===r?p({nullInput:!0}):("string"==typeof r&&(e._i=r=e._locale.preparse(r)),k(r)?new M(dt(r)):(d(r)?e._d=r:o(a)?function(e){var t,n,s,i,r;if(0===e._f.length)return g(e).invalidFormat=!0,e._d=new Date(NaN);for(i=0;i<e._f.length;i++)r=0,t=w({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],Yt(t),v(t)&&(r+=g(t).charsLeftOver,r+=10*g(t).unusedTokens.length,g(t).score=r,(null==s||r<s)&&(s=r,n=t));_(e,n||t)}(e):a?Yt(e):l(n=(t=e)._i)?t._d=new Date(c.now()):d(n)?t._d=new Date(n.valueOf()):"string"==typeof n?(s=t,null===(i=pt.exec(s._i))?(wt(s),!1===s._isValid&&(delete s._isValid,Dt(s),!1===s._isValid&&(delete s._isValid,c.createFromInputFallback(s)))):s._d=new Date(+i[1])):o(n)?(t._a=f(n.slice(0),function(e){return parseInt(e,10)}),ft(t)):u(n)?function(e){if(!e._d){var t=R(e._i);e._a=f([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ft(e)}}(t):h(n)?t._d=new Date(n):c.createFromInputFallback(t),v(e)||(e._d=null),e))}function Tt(e,t,n,s,i){var r,a={};return!0!==n&&!1!==n||(s=n,n=void 0),(u(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||o(e)&&0===e.length)&&(e=void 0),a._isAMomentObject=!0,a._useUTC=a._isUTC=i,a._l=n,a._i=e,a._f=t,a._strict=s,(r=new M(dt(Ot(a))))._nextDay&&(r.add(1,"d"),r._nextDay=void 0),r}function bt(e,t,n,s){return Tt(e,t,n,s,!1)}c.createFromInputFallback=n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),c.ISO_8601=function(){},c.RFC_2822=function(){};var xt=n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:p()}),Pt=n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:p()});function Wt(e,t){var n,s;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return bt();for(n=t[0],s=1;s<t.length;++s)t[s].isValid()&&!t[s][e](n)||(n=t[s]);return n}var Ct=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ht(e){var t=R(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||t.isoWeek||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,h=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ye.call(Ct,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<Ct.length;++s)if(e[Ct[s]]){if(n)return!1;parseFloat(e[Ct[s]])!==D(e[Ct[s]])&&(n=!0)}return!0}(t),this._milliseconds=+h+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=ht(),this._bubble()}function Rt(e){return e instanceof Ht}function Ut(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ft(e,n){I(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+L(~~(e/60),2)+n+L(~~e%60,2)})}Ft("Z",":"),Ft("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Nt(re,e)});var Lt=/([\+\-]|\d\d)/gi;function Nt(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Lt)||["-",0,0],i=60*s[1]+D(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Gt(e,t){var n,s;return t._isUTC?(n=t.clone(),s=(k(e)||d(e)?e.valueOf():bt(e).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+s),c.updateOffset(n,!1),n):bt(e).local()}function Vt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Et(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}c.updateOffset=function(){};var It=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,At=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function jt(e,t){var n,s,i,r=e,a=null;return Rt(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:h(e)?(r={},t?r[t]=e:r.milliseconds=e):(a=It.exec(e))?(n="-"===a[1]?-1:1,r={y:0,d:D(a[ye])*n,h:D(a[ge])*n,m:D(a[ve])*n,s:D(a[pe])*n,ms:D(Ut(1e3*a[we]))*n}):(a=At.exec(e))?(n="-"===a[1]?-1:1,r={y:Zt(a[2],n),M:Zt(a[3],n),w:Zt(a[4],n),d:Zt(a[5],n),h:Zt(a[6],n),m:Zt(a[7],n),s:Zt(a[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Gt(t,e),e.isBefore(t)?n=zt(e,t):((n=zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(bt(r.from),bt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Ht(r),Rt(e)&&m(e,"_locale")&&(s._locale=e._locale),s}function Zt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function zt(e,t){var n={};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function $t(s,i){return function(e,t){var n;return null===t||isNaN(+t)||(T(i,"moment()."+i+"(period, number) is deprecated. Please use moment()."+i+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),n=e,e=t,t=n),qt(this,jt(e="string"==typeof e?+e:e,t),s),this}}function qt(e,t,n,s){var i=t._milliseconds,r=Ut(t._days),a=Ut(t._months);e.isValid()&&(s=null==s||s,a&&Re(e,be(e,"Month")+a*n),r&&xe(e,"Date",be(e,"Date")+r*n),i&&e._d.setTime(e._d.valueOf()+i*n),s&&c.updateOffset(e,r||a))}jt.fn=Ht.prototype,jt.invalid=function(){return jt(NaN)};var Jt=$t(1,"add"),Bt=$t(-1,"subtract");function Qt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return-(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Xt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=ht(e))&&(this._locale=t),this)}c.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",c.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Kt=n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function en(){return this._locale}var tn=126227808e5;function nn(e,t){return(e%t+t)%t}function sn(e,t,n){return e<100&&0<=e?new Date(e+400,t,n)-tn:new Date(e,t,n).valueOf()}function rn(e,t,n){return e<100&&0<=e?Date.UTC(e+400,t,n)-tn:Date.UTC(e,t,n)}function an(e,t){I(0,[e,e.length],0,t)}function on(e,t,n,s,i){var r;return null==e?Ie(this,s,i).year:((r=Ae(e,s,i))<t&&(t=r),function(e,t,n,s,i){var r=Ee(e,t,n,s,i),a=Ge(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),an("gggg","weekYear"),an("ggggg","weekYear"),an("GGGG","isoWeekYear"),an("GGGGG","isoWeekYear"),C("weekYear","gg"),C("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=D(e)}),fe(["gg","GG"],function(e,t,n,s){t[s]=c.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),C("quarter","Q"),F("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[_e]=3*(D(e)-1)}),I("D",["DD",2],"Do","date"),C("date","D"),F("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ye),ce("Do",function(e,t){t[ye]=D(e.match(B)[0])});var un=Te("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),C("dayOfYear","DDD"),F("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=D(e)}),I("m",["mm",2],0,"minute"),C("minute","m"),F("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],ve);var ln=Te("Minutes",!1);I("s",["ss",2],0,"second"),C("second","s"),F("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],pe);var hn,dn=Te("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),C("millisecond","ms"),F("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),hn="SSSS";hn.length<=9;hn+="S")ue(hn,ne);function cn(e,t){t[we]=D(1e3*("0."+e))}for(hn="S";hn.length<=9;hn+="S")ce(hn,cn);var fn=Te("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var mn=M.prototype;function _n(e){return e}mn.add=Jt,mn.calendar=function(e,t){var n=e||bt(),s=Gt(n,this).startOf("day"),i=c.calendarFormat(this,s)||"sameElse",r=t&&(b(t[i])?t[i].call(this,n):t[i]);return this.format(r||this.localeData().calendar(i,this,bt(n)))},mn.clone=function(){return new M(this)},mn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Gt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=H(t)){case"year":r=Qt(this,s)/12;break;case"month":r=Qt(this,s);break;case"quarter":r=Qt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:S(r)},mn.endOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year()+1,0,1)-1;break;case"quarter":t=n(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":t=n(this.year(),this.month()+1,1)-1;break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":t=n(this.year(),this.month(),this.date()+1)-1;break;case"hour":t=this._d.valueOf(),t+=36e5-nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5)-1;break;case"minute":t=this._d.valueOf(),t+=6e4-nn(t,6e4)-1;break;case"second":t=this._d.valueOf(),t+=1e3-nn(t,1e3)-1;break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.format=function(e){e||(e=this.isUtc()?c.defaultFormatUtc:c.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},mn.from=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.fromNow=function(e){return this.from(bt(),e)},mn.to=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.toNow=function(e){return this.to(bt(),e)},mn.get=function(e){return b(this[e=H(e)])?this[e]():this},mn.invalidAt=function(){return g(this).overflow},mn.isAfter=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},mn.isBefore=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},mn.isBetween=function(e,t,n,s){var i=k(e)?e:bt(e),r=k(t)?t:bt(t);return!!(this.isValid()&&i.isValid()&&r.isValid())&&("("===(s=s||"()")[0]?this.isAfter(i,n):!this.isBefore(i,n))&&(")"===s[1]?this.isBefore(r,n):!this.isAfter(r,n))},mn.isSame=function(e,t){var n,s=k(e)?e:bt(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},mn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},mn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},mn.isValid=function(){return v(this)},mn.lang=Kt,mn.locale=Xt,mn.localeData=en,mn.max=Pt,mn.min=xt,mn.parsingFlags=function(){return _({},g(this))},mn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:U[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=R(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(b(this[e=H(e)]))return this[e](t);return this},mn.startOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year(),0,1);break;case"quarter":t=n(this.year(),this.month()-this.month()%3,1);break;case"month":t=n(this.year(),this.month(),1);break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":t=n(this.year(),this.month(),this.date());break;case"hour":t=this._d.valueOf(),t-=nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5);break;case"minute":t=this._d.valueOf(),t-=nn(t,6e4);break;case"second":t=this._d.valueOf(),t-=nn(t,1e3);break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.subtract=Bt,mn.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},mn.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},mn.toDate=function(){return new Date(this.valueOf())},mn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||9999<n.year()?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):b(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},mn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},mn.toJSON=function(){return this.isValid()?this.toISOString():null},mn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},mn.unix=function(){return Math.floor(this.valueOf()/1e3)},mn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},mn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},mn.year=Oe,mn.isLeapYear=function(){return De(this.year())},mn.weekYear=function(e){return on.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},mn.isoWeekYear=function(e){return on.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},mn.quarter=mn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},mn.month=Ue,mn.daysInMonth=function(){return Pe(this.year(),this.month())},mn.week=mn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},mn.isoWeek=mn.isoWeeks=function(e){var t=Ie(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},mn.weeksInYear=function(){var e=this.localeData()._week;return Ae(this.year(),e.dow,e.doy)},mn.isoWeeksInYear=function(){return Ae(this.year(),1,4)},mn.date=un,mn.day=mn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t,n,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(t=e,n=this.localeData(),e="string"!=typeof t?t:isNaN(t)?"number"==typeof(t=n.weekdaysParse(t))?t:null:parseInt(t,10),this.add(e-s,"d")):s},mn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},mn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null==e)return this.day()||7;var t,n,s=(t=e,n=this.localeData(),"string"==typeof t?n.weekdaysParse(t)%7||7:isNaN(t)?null:t);return this.day(this.day()%7?s:s-7)},mn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},mn.hour=mn.hours=nt,mn.minute=mn.minutes=ln,mn.second=mn.seconds=dn,mn.millisecond=mn.milliseconds=fn,mn.utcOffset=function(e,t,n){var s,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null==e)return this._isUTC?i:Vt(this);if("string"==typeof e){if(null===(e=Nt(re,e)))return this}else Math.abs(e)<16&&!n&&(e*=60);return!this._isUTC&&t&&(s=Vt(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==e&&(!t||this._changeInProgress?qt(this,jt(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,c.updateOffset(this,!0),this._changeInProgress=null)),this},mn.utc=function(e){return this.utcOffset(0,e)},mn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Vt(this),"m")),this},mn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Nt(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},mn.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?bt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},mn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},mn.isLocal=function(){return!!this.isValid()&&!this._isUTC},mn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},mn.isUtc=Et,mn.isUTC=Et,mn.zoneAbbr=function(){return this._isUTC?"UTC":""},mn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},mn.dates=n("dates accessor is deprecated. Use date instead.",un),mn.months=n("months accessor is deprecated. Use month instead",Ue),mn.years=n("years accessor is deprecated. Use year instead",Oe),mn.zone=n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),mn.isDSTShifted=n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!l(this._isDSTShifted))return this._isDSTShifted;var e={};if(w(e,this),(e=Ot(e))._a){var t=e._isUTC?y(e._a):bt(e._a);this._isDSTShifted=this.isValid()&&0<a(e._a,t.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted});var yn=P.prototype;function gn(e,t,n,s){var i=ht(),r=y().set(s,t);return i[n](r,e)}function vn(e,t,n){if(h(e)&&(t=e,e=void 0),e=e||"",null!=t)return gn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=gn(e,s,n,"month");return i}function pn(e,t,n,s){t=("boolean"==typeof e?h(t)&&(n=t,t=void 0):(t=e,e=!1,h(n=t)&&(n=t,t=void 0)),t||"");var i,r=ht(),a=e?r._week.dow:0;if(null!=n)return gn(t,(n+a)%7,s,"day");var o=[];for(i=0;i<7;i++)o[i]=gn(t,(i+a)%7,s,"day");return o}yn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return b(s)?s.call(t,n):s},yn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},yn.invalidDate=function(){return this._invalidDate},yn.ordinal=function(e){return this._ordinal.replace("%d",e)},yn.preparse=_n,yn.postformat=_n,yn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return b(i)?i(e,t,n,s):i.replace(/%d/i,e)},yn.pastFuture=function(e,t){var n=this._relativeTime[0<e?"future":"past"];return b(n)?n(t):n.replace(/%s/i,t)},yn.set=function(e){var t,n;for(n in e)b(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},yn.months=function(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||We).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone},yn.monthsShort=function(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[We.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},yn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=y([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=y([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},yn.monthsRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsStrictRegex:this._monthsRegex):(m(this,"_monthsRegex")||(this._monthsRegex=Le),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},yn.monthsShortRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(m(this,"_monthsShortRegex")||(this._monthsShortRegex=Fe),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},yn.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},yn.firstDayOfYear=function(){return this._week.doy},yn.firstDayOfWeek=function(){return this._week.dow},yn.weekdays=function(e,t){var n=o(this._weekdays)?this._weekdays:this._weekdays[e&&!0!==e&&this._weekdays.isFormat.test(t)?"format":"standalone"];return!0===e?je(n,this._week.dow):e?n[e.day()]:n},yn.weekdaysMin=function(e){return!0===e?je(this._weekdaysMin,this._week.dow):e?this._weekdaysMin[e.day()]:this._weekdaysMin},yn.weekdaysShort=function(e){return!0===e?je(this._weekdaysShort,this._week.dow):e?this._weekdaysShort[e.day()]:this._weekdaysShort},yn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=y([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=y([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},yn.weekdaysRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(m(this,"_weekdaysRegex")||(this._weekdaysRegex=qe),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},yn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(m(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Je),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},yn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(m(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Be),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},yn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},yn.meridiem=function(e,t,n){return 11<e?n?"pm":"PM":n?"am":"AM"},ut("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===D(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),c.lang=n("moment.lang is deprecated. Use moment.locale instead.",ut),c.langData=n("moment.langData is deprecated. Use moment.localeData instead.",ht);var wn=Math.abs;function Mn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function kn(e){return e<0?Math.floor(e):Math.ceil(e)}function Sn(e){return 4800*e/146097}function Dn(e){return 146097*e/4800}function Yn(e){return function(){return this.as(e)}}var On=Yn("ms"),Tn=Yn("s"),bn=Yn("m"),xn=Yn("h"),Pn=Yn("d"),Wn=Yn("w"),Cn=Yn("M"),Hn=Yn("Q"),Rn=Yn("y");function Un(e){return function(){return this.isValid()?this._data[e]:NaN}}var Fn=Un("milliseconds"),Ln=Un("seconds"),Nn=Un("minutes"),Gn=Un("hours"),Vn=Un("days"),En=Un("months"),In=Un("years");var An=Math.round,jn={ss:44,s:45,m:45,h:22,d:26,M:11};var Zn=Math.abs;function zn(e){return(0<e)-(e<0)||+e}function $n(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Zn(this._milliseconds)/1e3,s=Zn(this._days),i=Zn(this._months);t=S((e=S(n/60))/60),n%=60,e%=60;var r=S(i/12),a=i%=12,o=s,u=t,l=e,h=n?n.toFixed(3).replace(/\.?0+$/,""):"",d=this.asSeconds();if(!d)return"P0D";var c=d<0?"-":"",f=zn(this._months)!==zn(d)?"-":"",m=zn(this._days)!==zn(d)?"-":"",_=zn(this._milliseconds)!==zn(d)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||h?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(h?_+h+"S":"")}var qn=Ht.prototype;return qn.isValid=function(){return this._isValid},qn.abs=function(){var e=this._data;return this._milliseconds=wn(this._milliseconds),this._days=wn(this._days),this._months=wn(this._months),e.milliseconds=wn(e.milliseconds),e.seconds=wn(e.seconds),e.minutes=wn(e.minutes),e.hours=wn(e.hours),e.months=wn(e.months),e.years=wn(e.years),this},qn.add=function(e,t){return Mn(this,e,t,1)},qn.subtract=function(e,t){return Mn(this,e,t,-1)},qn.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=H(e))||"quarter"===e||"year"===e)switch(t=this._days+s/864e5,n=this._months+Sn(t),e){case"month":return n;case"quarter":return n/3;case"year":return n/12}else switch(t=this._days+Math.round(Dn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},qn.asMilliseconds=On,qn.asSeconds=Tn,qn.asMinutes=bn,qn.asHours=xn,qn.asDays=Pn,qn.asWeeks=Wn,qn.asMonths=Cn,qn.asQuarters=Hn,qn.asYears=Rn,qn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*D(this._months/12):NaN},qn._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return 0<=r&&0<=a&&0<=o||r<=0&&a<=0&&o<=0||(r+=864e5*kn(Dn(o)+a),o=a=0),u.milliseconds=r%1e3,e=S(r/1e3),u.seconds=e%60,t=S(e/60),u.minutes=t%60,n=S(t/60),u.hours=n%24,o+=i=S(Sn(a+=S(n/24))),a-=kn(Dn(i)),s=S(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},qn.clone=function(){return jt(this)},qn.get=function(e){return e=H(e),this.isValid()?this[e+"s"]():NaN},qn.milliseconds=Fn,qn.seconds=Ln,qn.minutes=Nn,qn.hours=Gn,qn.days=Vn,qn.weeks=function(){return S(this.days()/7)},qn.months=En,qn.years=In,qn.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t,n,s,i,r,a,o,u,l,h,d,c=this.localeData(),f=(n=!e,s=c,i=jt(t=this).abs(),r=An(i.as("s")),a=An(i.as("m")),o=An(i.as("h")),u=An(i.as("d")),l=An(i.as("M")),h=An(i.as("y")),(d=r<=jn.ss&&["s",r]||r<jn.s&&["ss",r]||a<=1&&["m"]||a<jn.m&&["mm",a]||o<=1&&["h"]||o<jn.h&&["hh",o]||u<=1&&["d"]||u<jn.d&&["dd",u]||l<=1&&["M"]||l<jn.M&&["MM",l]||h<=1&&["y"]||["yy",h])[2]=n,d[3]=0<+t,d[4]=s,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d));return e&&(f=c.pastFuture(+this,f)),c.postformat(f)},qn.toISOString=$n,qn.toString=$n,qn.toJSON=$n,qn.locale=Xt,qn.localeData=en,qn.toIsoString=n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",$n),qn.lang=Kt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),ce("x",function(e,t,n){n._d=new Date(D(e))}),c.version="2.24.0",e=bt,c.fn=mn,c.min=function(){return Wt("isBefore",[].slice.call(arguments,0))},c.max=function(){return Wt("isAfter",[].slice.call(arguments,0))},c.now=function(){return Date.now?Date.now():+new Date},c.utc=y,c.unix=function(e){return bt(1e3*e)},c.months=function(e,t){return vn(e,t,"months")},c.isDate=d,c.locale=ut,c.invalid=p,c.duration=jt,c.isMoment=k,c.weekdays=function(e,t,n){return pn(e,t,n,"weekdays")},c.parseZone=function(){return bt.apply(null,arguments).parseZone()},c.localeData=ht,c.isDuration=Rt,c.monthsShort=function(e,t){return vn(e,t,"monthsShort")},c.weekdaysMin=function(e,t,n){return pn(e,t,n,"weekdaysMin")},c.defineLocale=lt,c.updateLocale=function(e,t){if(null!=t){var n,s,i=st;null!=(s=ot(e))&&(i=s._config),(n=new P(t=x(i,t))).parentLocale=it[e],it[e]=n,ut(e)}else null!=it[e]&&(null!=it[e].parentLocale?it[e]=it[e].parentLocale:null!=it[e]&&delete it[e]);return it[e]},c.locales=function(){return s(it)},c.weekdaysShort=function(e,t,n){return pn(e,t,n,"weekdaysShort")},c.normalizeUnits=H,c.relativeTimeRounding=function(e){return void 0===e?An:"function"==typeof e&&(An=e,!0)},c.relativeTimeThreshold=function(e,t){return void 0!==jn[e]&&(void 0===t?jn[e]:(jn[e]=t,"s"===e&&(jn.ss=t-1),!0))},c.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},c.prototype=mn,c.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},c});
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function LabelNewCompClass(_obj) {
  var modelObj = {
    x: 0,
    y: 0,
    width: 2000,
    visible: true,
    text: "",
    maxWidth: 0,
    fontSize: 16,
    fontColor: "rgba(0,0,0,1)",
    align: "left",
    isItalic: false,
    isBold: false,
    rotation: 0,
    // bgWidth: 100,
    // bgHeight: 50,
    textY: 0,
    textX: 0,
    bgColor: "#ffffff",
    textW: "old",
    // new for if requirement is for partial colored label.
    isQuestion: false,
    tabActive: false,
    visuallyHidden: false
  };
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------
  // if(typeof(modelObj.bgWidth)!=='undefined') {
  //   modelObj.textX =
  // }

  modelObj.fontFamilyStr = modelObj.LabComClass.polo22KlettRegular; // --------------------

  if (modelObj.text !== "") {
    modelObj.text = modelObj.LabComClass.globalLangText[modelObj.text]; // this.setValue(modelObj.text);
  }

  createDOM();
  parseText(); // --------------------

  function createDOM() {
    var _wrapper = document.querySelectorAll(".questionWrapper")[0];

    if (modelObj.isQuestion && _wrapper) {
      _wrapper.style.width = "80%";
    }

    var mainWrapper = document.getElementById("mainWrapper");

    var _label = document.createElement("label");

    _label.className = "labelClass";

    _label.setAttribute("id", modelObj.id);

    _label.innerHTML = modelObj.text;

    if (modelObj.tabActive) {
      _label.setAttribute("aria-labelledby", modelObj.text);

      if (modelObj.visuallyHidden) {
        _label.className = "labelClass visually-hidden";
      }

      _label.setAttribute("for", modelObj.text);

      _label.setAttribute("tabIndex", 0);
    } else {
      _label.setAttribute("aria-hidden", true);
    } // Default condition label without background


    if (typeof modelObj.bgWidth == "undefined") {
      _label.style.left = "".concat(modelObj.x, "px");
      _label.style.top = "".concat(modelObj.y, "px");
      _label.style.display = modelObj.visible ? "" : "none";

      if (modelObj.isQuestion && _wrapper) {
        _wrapper.append(_label);
      } else {
        mainWrapper.append(_label);
      } // if specialwidth is specified for special case - 'hypen'.


      if (typeof modelObj.specialWidth !== "undefined") {
        _label.style.width = "".concat(modelObj.specialWidth, "px");
      }
    } // Other condition label with background
    else {
        _label.style.left = "".concat(modelObj.x, "px");
        _label.style.top = "".concat(modelObj.y, "px");
        _label.style.width = "".concat(modelObj.width, "px");
        _label.style.height = "".concat(modelObj.bgHeight, "px");
        _label.style.background = "".concat(modelObj.bgColor);
        _label.style.textAlign = modelObj.align;
        _label.style.display = modelObj.visible ? "" : "none";

        if (modelObj.isQuestion && _wrapper) {
          _wrapper.append(_label);
        } else {
          mainWrapper.append(_label);
        }
      }

    setTimeout(function () {
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "componentLoaded",
        data: {
          id: modelObj.id
        }
      });
    }, 0);
  } // =================================================
  // PUBLIC SECTION
  // =================================================


  this.setValue = function (_txt) {
    modelObj.text = _txt;
    parseText();
  };

  this.setAriaLabel = function (_txt) {
    var _label = document.getElementById(modelObj.id);

    _label.setAttribute("aria-labelledby", _txt);
  };

  function parseText() {
    var _label = document.getElementById(modelObj.id);

    _label.style.color = modelObj.fontColor;
    _label.style.fontFamily = modelObj.fontFamilyStr;
    _label.style.fontSize = "".concat(modelObj.fontSize, "px");
    _label.innerHTML = modelObj.LabComClass.drawStyledTextDOM(modelObj.text); //modelObj.text;
    // if (modelObj.maxWidth > 0) {
    //   var data = modelObj.text;
    //   if (modelObj.isBold && modelObj.isItalic) {
    //     data = modelObj.LabComClass.italicbold + data + modelObj.LabComClass.end;
    //   } else {
    //     if (modelObj.isItalic) {
    //       data = modelObj.LabComClass.italic + data + modelObj.LabComClass.end;
    //     }
    //     if (modelObj.isBold) {
    //       data = modelObj.LabComClass.bold + data + modelObj.LabComClass.end;
    //     }
    //   }
    //   if(modelObj.textW === 'old') {
    //     modelObj.text = modelObj.context.textWrapperClass({
    //       xNum: 0, // modelCls.cPropObj.xInt,
    //       yNum: 0, // modelCls.cPropObj.yInt,
    //       fontFormat: 'px ',
    //       maxWidthNum: modelObj.maxWidth,
    //       textStr: data,
    //       fontFamilyStr: modelObj.fontFamilyStr,
    //       fontSizeNum: modelObj.fontSize,
    //       color: modelObj.fontColor
    //     });
    //   }
    //   else {
    //     modelObj.text = modelObj.context.textWrapperV2Class({
    //       xNum: 0, // modelCls.cPropObj.xInt,
    //       yNum: 0, // modelCls.cPropObj.yInt,
    //       maxWidthNum: modelObj.maxWidth,
    //       textStr: '' + data,
    //       fontFamilyStr: modelObj.fontFamilyStr,
    //       fontSizeNum: modelObj.fontSize,
    //       color: modelObj.fontColor
    //     },false);
    //   }
    // }
  } // =================================================


  this.getValue = function () {
    return modelObj.text;
  }; // =================================================


  this.setBGColor = function (_col) {
    modelObj.bgColor = _col;
  }; // =================================================


  this.getVisble = function () {
    return modelObj.visible;
  }; // =================================================


  this.setVisible = function (_bool) {
    modelObj.visible = _bool;

    var _label = document.getElementById(modelObj.id);

    _label.style.display = _bool ? "" : "none";
  };

  this.setFocus = function (_bool) {
    document.getElementById(modelObj.id).focus();
  }; // =================================================


  this.getBGColor = function () {
    return modelObj.bgColor;
  }; // =================================================


  this.setTextColor = function (_col) {
    modelObj.fontColor = _col;

    var _label = document.getElementById(modelObj.id);

    _label.style.color = modelObj.fontColor;
  }; // =================================================


  this.getTextColor = function () {
    return modelObj.fontColor;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;

    var _label = document.getElementById(modelObj.id);

    _label.style.display = "";
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;

    var _label = document.getElementById(modelObj.id);

    _label.style.display = "none";
  }; // =================================================


  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;

    var _label = document.getElementById(modelObj.id);

    _label.style.left = "".concat(modelObj.x, "px");
    _label.style.top = "".concat(modelObj.y, "px");
  }; // =================================================


  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.setStyle = function (_obj) {
    Object.keys(_obj).forEach(function (i) {
      modelObj[i] = _obj[i];
    });
  }; // =================================================


  this.draws = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;
      var _str = "";
      var _xTxt = modelObj.x;

      var _yTxt = modelObj.y + modelObj.fontSize; // --------------------


      _ctx.save();

      var textAlign;

      if (typeof modelObj.bgWidth !== "undefined") {
        _ctx.beginPath();

        _ctx.fillStyle = modelObj.bgColor;

        _ctx.fillRect(modelObj.x, modelObj.y, modelObj.bgWidth, modelObj.bgHeight);

        _ctx.closePath();

        textAlign = "middle";
      } else {
        textAlign = "bottom";
      }

      _ctx.beginPath();

      _ctx.fillStyle = modelObj.fontColor;
      _str += modelObj.isItalic ? "italic " : "";
      _str += modelObj.isBold ? "bold " : "";
      _ctx.font = _str + modelObj.fontSize + "px " + modelObj.fontFamilyStr;
      _ctx.textAlign = modelObj.align;
      _ctx.textBaseline = textAlign;

      if (textAlign === "middle") {
        _xTxt = modelObj.x + modelObj.bgWidth / 2;
        _yTxt = modelObj.y + modelObj.bgHeight / 2 + 1;
      }

      _ctx.translate(_xTxt, _yTxt);

      _ctx.rotate(modelObj.rotation);

      if (modelObj.text && typeof modelObj.text === "string" && modelObj.maxWidth === 0) {
        var data = modelObj.text;

        if (modelObj.isBold && modelObj.isItalic) {
          data = modelObj.LabComClass.italicbold + data + modelObj.LabComClass.end;
        } else {
          if (modelObj.isItalic) {
            data = modelObj.LabComClass.italic + data + modelObj.LabComClass.end;
          }

          if (modelObj.isBold) {
            data = modelObj.LabComClass.bold + data + modelObj.LabComClass.end;
          }
        }

        _ctx.drawStyledText(data, modelObj.textX, modelObj.textY, modelObj.fontFamilyStr, modelObj.fontSize);
      } else if (modelObj.text && modelObj.text.imageObj && modelObj.text.imageObj.imageObj) {
        if (modelObj.textW === "old") {
          _ctx.drawImage(modelObj.text.imageObj.imageObj, 0, 0, modelObj.text.imageObj.widthInt, modelObj.text.imageObj.heightInt);
        } else {
          _ctx.drawImage(modelObj.text.imageObj.imageObj, 0, -modelObj.fontSize, modelObj.text.imageObj.widthInt, modelObj.text.imageObj.heightInt);
        }
      }

      _ctx.closePath();

      _ctx.restore();
    }
  };
}
/*
    const text = String(modelObj.text);
    console.log('text',text);
    let newText = []; // First array and then performing join operation
    if(text.includes('§')){
      text.split('§').forEach((_c,i)=> {
        const c = _c.trim()
        let y = '';
        const _style = _c[0];
        switch (_style) {
          case 'r': // end
            y = _c.replace(_style,'</span>');
            break;
          case 'd': // Distance bar
            y = _c.replace(_style,'<span class ="dash">')
            break;
        }
        if(_style && _style.length) {
          newText.push(y);
        }
      })
      console.log('NT',newText);
      modelObj.text = newText.join('');
    }
*/
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
  512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
  454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
  482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
  437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
  497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
  320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
  446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
  329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
  505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
  399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
  324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
  268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
  451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
  385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
  332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
  289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];


var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
  17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
  19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
  20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
  22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
  22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];

function stackBlurImage(imageID, canvasID, radius, blurAlphaChannel, xx, yy, ww, hh) {

 	/* var img = document.getElementById( imageID );
	var w = img.naturalWidth;
    var h = img.naturalHeight; */

  var canvas = document.getElementsByClassName(canvasID)[0];

    /* canvas.style.width  = w + "px";
    canvas.style.height = h + "px";
    canvas.width = w;
    canvas.height = h; */

//   var context = canvas.getContext('2d');
    // context.clearRect( 0, 0, w, h );
    // context.drawImage( img, 0, 0 );

  if (isNaN(radius) || radius < 1) return;

  if (blurAlphaChannel) { stackBlurCanvasRGBA(canvasID, xx, yy, ww, hh, radius); } else		{ stackBlurCanvasRGB(canvasID, xx, yy, ww, hh, radius); }
}


function stackBlurCanvasRGBA(id, top_x, top_y, width, height, radius) {
  if (isNaN(radius) || radius < 1) return;
  radius |= 0;

  var canvas = document.getElementsByClassName(id);
  var context = canvas.getContext('2d');
  var imageData;

  try {
	  try {
    imageData = context.getImageData(top_x, top_y, width, height);
	  } catch (e) {

		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
    try {
      netscape.security.PrivilegeManager.enablePrivilege('UniversalBrowserRead');
      imageData = context.getImageData(top_x, top_y, width, height);
    } catch (e) {
      alert('Cannot access local image');
      throw new Error('unable to access local image data: ' + e);
      return;
    }
	  }
  } catch (e) {
	  alert('Cannot access image');
	  throw new Error('unable to access image data: ' + e);
  }

  var pixels = imageData.data;

  var x,
    y,
    i,
    p,
    yp,
    yi,
    yw,
    r_sum,
    g_sum,
    b_sum,
    a_sum,
    r_out_sum,
    g_out_sum,
    b_out_sum,
    a_out_sum,
    r_in_sum,
    g_in_sum,
    b_in_sum,
    a_in_sum,
    pr,
    pg,
    pb,
    pa,
    rbs;

  var div = radius + radius + 1;
  var w4 = width << 2;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

  var stackStart = new BlurStack();
  var stack = stackStart;
  for (i = 1; i < div; i++)	{
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1) var stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;

  yw = yi = 0;

  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];

  for (y = 0; y < height; y++)	{
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    for (i = 1; i < radiusPlus1; i++)		{
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;
      a_sum += (stack.a = (pa = pixels[p + 3])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;
    }


    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++)		{
      pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
      if (pa != 0)			{
        pa = 255 / pa;
        pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

      r_in_sum += (stackIn.r = pixels[p]);
      g_in_sum += (stackIn.g = pixels[p + 1]);
      b_in_sum += (stackIn.b = pixels[p + 2]);
      a_in_sum += (stackIn.a = pixels[p + 3]);

      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);
      a_out_sum += (pa = stackOut.a);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += 4;
    }
    yw += width;
  }


  for (x = 0; x < width; x++)	{
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    yp = width;

    for (i = 1; i <= radius; i++)		{
      yi = (yp + x) << 2;

      r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;
      a_sum += (stack.a = (pa = pixels[yi + 3])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;

      if (i < heightMinus1)			{
        yp += width;
      }
    }

    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++)		{
      p = yi << 2;
      pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
      if (pa > 0)			{
        pa = 255 / pa;
        pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
        pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
        pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
      } else {
        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

      r_sum += (r_in_sum += (stackIn.r = pixels[p]));
      g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
      b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));
      a_sum += (a_in_sum += (stackIn.a = pixels[p + 3]));

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);
      a_out_sum += (pa = stackOut.a);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += width;
    }
  }

  context.putImageData(imageData, top_x, top_y);

}


function stackBlurCanvasRGB(id, top_x, top_y, width, height, radius) {
  if (isNaN(radius) || radius < 1) return;
  radius |= 0;

  var canvas = document.getElementsByClassName(id)[0];
  var context = canvas.getContext('2d');
  var imageData;

  try {
	  try {
    imageData = context.getImageData(top_x, top_y, width, height);
	  } catch (e) {

		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
    try {
      netscape.security.PrivilegeManager.enablePrivilege('UniversalBrowserRead');
      imageData = context.getImageData(top_x, top_y, width, height);
    } catch (e) {
      alert('Cannot access local image');
      throw new Error('unable to access local image data: ' + e);
      return;
    }
	  }
  } catch (e) {
	  alert('Cannot access image');
	  throw new Error('unable to access image data: ' + e);
  }

  var pixels = imageData.data;

  var x,
    y,
    i,
    p,
    yp,
    yi,
    yw,
    r_sum,
    g_sum,
    b_sum,
    r_out_sum,
    g_out_sum,
    b_out_sum,
    r_in_sum,
    g_in_sum,
    b_in_sum,
    pr,
    pg,
    pb,
    rbs;

  var div = radius + radius + 1;
  var w4 = width << 2;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

  var stackStart = new BlurStack();
  var stack = stackStart;
  for (i = 1; i < div; i++)	{
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1) var stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;

  yw = yi = 0;

  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];

  for (y = 0; y < height; y++)	{
    r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;

    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }

    for (i = 1; i < radiusPlus1; i++)		{
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;

      stack = stack.next;
    }


    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++)		{
      pixels[yi] = (r_sum * mul_sum) >> shg_sum;
      pixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;
      pixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;

      p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

      r_in_sum += (stackIn.r = pixels[p]);
      g_in_sum += (stackIn.g = pixels[p + 1]);
      b_in_sum += (stackIn.b = pixels[p + 2]);

      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;

      stackOut = stackOut.next;

      yi += 4;
    }
    yw += width;
  }


  for (x = 0; x < width; x++)	{
    g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;

    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }

    yp = width;

    for (i = 1; i <= radius; i++)		{
      yi = (yp + x) << 2;

      r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;

      stack = stack.next;

      if (i < heightMinus1)			{
        yp += width;
      }
    }

    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++)		{
      p = yi << 2;
      pixels[p] = (r_sum * mul_sum) >> shg_sum;
      pixels[p + 1] = (g_sum * mul_sum) >> shg_sum;
      pixels[p + 2] = (b_sum * mul_sum) >> shg_sum;

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;

      p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

      r_sum += (r_in_sum += (stackIn.r = pixels[p]));
      g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
      b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;

      stackOut = stackOut.next;

      yi += width;
    }
  }

  context.putImageData(imageData, top_x, top_y);

}

function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;


}








"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function TaskTableCompClass(_obj) {
  var events = {};
  var imgObj;
  var modelObj = {
    x: 105,
    y: 313,
    height: 100,
    taskHeights: 0,
    // height  or  values.rowCount  or  values.height
    // pass any one value as auto
    // modelObj.height = 200  its table height,
    // values.rowCount = 'auto'  number of rows including empty and filled rows,
    // values.height = 42  height of rows containing values
    width: 296,
    visible: true,
    gap: 9,
    fontSize: 16,
    imgList: ["helpNormal.svg", // 'helpClicked.png'
    "helpChecked.png"],
    sliderLeftPadding: -20,
    disabledAll: false,
    values: {
      rowCount: "auto",
      height: 66,
      width: 300,
      padding: 21,
      textAlign: "left",
      border: "rgba(255,255,255,1)",
      data: [],
      fontColor: "rgba(35,35,35,1)",
      fillColor: ["rgba(224,224,224,1)"],
      textColor: "rgba(102,102,102,1)",
      activeStepColor: "rgba(73,124,190,1)",
      boxBorderColor: "rgba(112,146,190,1)",
      seperatorColor: "rgba(210, 210, 210,1)",
      counterBoxW: 54,
      textW: 195,
      helpBtn: {
        x: 239,
        y: 14,
        w: 27,
        h: 26
      },
      checkBoxBtn: {
        x: 239,
        y: 14,
        w: 27,
        h: 26
      }
    },
    closeBtnEnable: false,
    closeBtn: {
      x: 362,
      y: -20,
      w: 16,
      h: 16
    },
    stepsBar: {
      currentStep: 0,
      x: 105,
      y: 313,
      h: 100,
      w: 100,
      text: "steps"
    },
    textWrapper: "old"
  };
  var localObj = {
    // offset variables for table created in dom
    offsetX: 0,
    offsetY: -1,
    offsetWidth: 0,
    //-4,
    offsetHeight: 2,
    currentRow: 0,
    defaultRowCount: 2,
    defaultHeight: 300,
    defaultRowHeight: 42,
    pivotPoint: {
      x: null,
      y: null
    },
    slider: {
      gap: 3,
      width: 12,
      base: {
        width: 20
      },
      knob: {
        x: null,
        y: null,
        height: 30
      }
    },
    leftArrowPos: {},
    rightArrowPos: {},
    slideArrowPos: {},
    arrowW: 15,
    leftArrowEnable: true,
    rightArrowEnable: true,
    slideArrowEnable: true,
    showSteps: false
  };
  setData(modelObj, _obj);
  window.ref = this;

  var _this = this;

  function setData(source, data) {
    if (data && _typeof(data) === "object" && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === "object" && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  } // --------------------


  calculateRows();
  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass(); // --------------------

  if (modelObj.imgList[0]) {
    modelObj.LabComClass.requestGlobalImage(modelObj.imgList, onImagesLoaded, onImagesLoadingError);
  } else {
    onImagesLoaded({});
  }

  function onImagesLoadingError(_error) {
    console.log("Images Loading Error...");
  }

  function onImagesLoaded(_dataObj) {
    imgObj = _dataObj;
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "componentLoaded",
      data: {
        id: modelObj.id
      }
    });
  }

  function findGlobalText(text) {
    if (modelObj.LabComClass.globalLangText[text]) {
      return modelObj.LabComClass.globalLangText[text];
    }

    return "---";
  }

  createDOM();

  function createDOM() {
    // Setting the wrapper
    var _wrapper = document.querySelectorAll(".taskTableWrapper")[0];
    _wrapper.style.borderColor = modelObj.values.boxBorderColor;
    _wrapper.style.left = "".concat(modelObj.x + localObj.offsetX, "px");
    _wrapper.style.top = "".concat(modelObj.y + localObj.offsetY, "px");
    _wrapper.style.width = "".concat(modelObj.width + localObj.offsetWidth, "px");
    _wrapper.style.height = "".concat(modelObj.height + localObj.offsetHeight, "px");
  }

  this.addData = function (_obj) {
    var _wrapper = document.querySelectorAll(".taskTableWrapper")[0];
    var _currentRow = localObj.currentRow;
    var _rc = modelObj.values.rowCount;
    var _h = modelObj.height;
    var _vh = modelObj.values.height; // Step Wrapper

    var _stepWrapper = document.createElement("div");

    _stepWrapper.classList.add("stepWrapper"); // _stepWrapper.style.minHeight = `${_vh}px`;


    _stepWrapper.setAttribute("id", "stepWrapper_".concat(_currentRow));

    _stepWrapper.style.borderColor = modelObj.values.seperatorColor;

    _wrapper.appendChild(_stepWrapper); // Step Content


    var _stepData = document.createElement("label");

    _stepData.classList.add("stepData");

    _stepData.setAttribute("id", "stepData_".concat(_currentRow));

    _stepData.setAttribute("for", "helpBtn_".concat(_currentRow));

    _stepData.style.color = modelObj.values.textColor;

    if (modelObj.stepsBar.currentStep === localObj.currentRow) {
      _stepData.style.color = modelObj.values.activeStepColor;
    }

    var innerHTML = modelObj.LabComClass.drawStyledTextDOM(_obj.text); //_obj.text;

    _stepData.innerHTML = innerHTML;

    _stepWrapper.appendChild(_stepData); // Help/Tick Button Wrapper


    var _helpBtnWrapper = document.createElement("div");

    _helpBtnWrapper.classList.add("helpBtnWrapper");

    _helpBtnWrapper.setAttribute("id", "helpBtnWrapper_".concat(_currentRow));

    _helpBtnWrapper.style.backgroundImage = "url(assets/images/".concat(modelObj.imgList[0], ")");
    _helpBtnWrapper.style.borderColor = modelObj.values.boxBorderColor;

    _stepWrapper.appendChild(_helpBtnWrapper);

    var _helpBtn = document.createElement("input");

    _helpBtn.setAttribute("type", "checkbox");

    _helpBtn.classList.add("helpBtn");

    _helpBtn.setAttribute("id", "helpBtn_".concat(_currentRow));

    _helpBtn.setAttribute("aria-label", findGlobalText(modelObj.helpButtonAltText));

    _helpBtnWrapper.appendChild(_helpBtn); //Initally disable


    _helpBtn.classList.add("disabled");

    _helpBtn.setAttribute("tabIndex", -1);

    _helpBtn.setAttribute("disabled", true);

    _helpBtnWrapper.style.opacity = 0.5;

    _helpBtn.removeEventListener("click", onButtonClick);

    modelObj.values.data.push({
      text: _obj.text
    });
    localObj.currentRow++;
    addEvents();
  }; // =================================================
  // PUBLIC SECTION
  // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  };

  function updateSliderHeight() {
    var totalHeight = 0;

    for (var i = 0; i < modelObj.values.data.length; i++) {
      totalHeight += modelObj.values.data[i].rowHeight;
    }

    totalHeight += modelObj.gap * modelObj.values.data.length - 1;
    var percentageDiff = totalHeight / modelObj.height * 100;
    localObj.slider.knob.height = modelObj.height * 100 / percentageDiff;
    updateSlider();
    updateStepArrows();
  }

  this.addData2 = function (_obj) {
    var textWrappers = {
      old: "textWrapperClass",
      "new": "textWrapperV2Class"
    };
    var text = modelObj.context[textWrappers[modelObj.textWrapper]]({
      xNum: 0,
      yNum: 0,
      align: "left",
      maxWidthNum: modelObj.values.textW,
      textStr: "" + _obj.text,
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: modelObj.fontSize,
      color: "rgba(102,102,102,1)"
    }, false, updateSliderHeight).imageObj;
    var boldText = modelObj.context[textWrappers[modelObj.textWrapper]]({
      xNum: 0,
      yNum: 0,
      align: "left",
      maxWidthNum: modelObj.values.textW,
      textStr: "" + _obj.text,
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: modelObj.fontSize,
      color: "rgba(73,124,190,1)"
    }).imageObj;
    var maxHeight = text.heightInt > boldText.heightInt ? text.heightInt : boldText.heightInt;
    modelObj.values.data.push({
      text: text,
      boldText: boldText,
      rowHeight: maxHeight < modelObj.values.height ? modelObj.values.height : maxHeight + modelObj.gap * 3,
      fillColor: "rgba(224,224,224,1)",
      counterColor: "rgba(170,170,170,1)"
    }); // _obj.text.includes('α') && console.log('TEXT',text,"BOLD",boldText,text.heightInt > boldText.heightInt,'ROW',maxHeight < modelObj.values.height,maxHeight,modelObj.values.height,maxHeight + modelObj.gap * 3);

    updateSliderHeight();
  };

  this.getData = function () {
    return modelObj.values.data;
  };

  this.removeData = function () {
    if (modelObj.values.data.length) {
      modelObj.values.data.pop();
    }

    localObj.slider.y = 0;
    updateStepArrows();
  };

  this.clearData = function () {
    var _wrapper = document.querySelectorAll(".taskTableWrapper")[0];
    _wrapper.innerHTML = "";

    _wrapper.scrollTo(0, 0);

    localObj.currentRow = 0; // CANVAS CODE------------

    modelObj.values.data = [];
    localObj.slider.y = 0;
    localObj.currentTarget = null;
    updateStepArrows();
  };

  this.resetStates = function (flag) {
    localObj.currentRow = 0;

    var _helpBtnArr = document.querySelectorAll(".helpBtn");

    var _parentArr = document.querySelectorAll(".helpBtnWrapper"); // or we can use parent node of help btn


    _helpBtnArr.forEach(function (_btn, i) {
      // if(i < _step) {
      // All disabled except first step
      if (i != 0) {
        _btn.classList.add("disabled");

        _btn.setAttribute("tabIndex", -1);

        _btn.setAttribute("disabled", true);

        _parentArr[i].style.opacity = 0.5;

        _btn.removeEventListener("click", onButtonClick);
      }

      _btn.checked = false;
      _parentArr[i].style.backgroundImage = "url(assets/images/".concat(modelObj.imgList[0], ")");
      _parentArr[i].style.backgroundSize = "";
      _parentArr[i].style.opacity = 1; // }

      _parentArr[i].previousSibling.style.color = modelObj.values.textColor;
    }); // if(_parentArr[_step]) {
    //   // _parentArr[_step].style.backgroundImage = `url(assets/images/${modelObj.imgList[0]})`;
    //   _parentArr[_step].previousSibling.style.color = modelObj.values.activeStepColor;
    // }
    // CANVAS CODE--------------


    for (var i = 0; i < modelObj.values.data.length; i++) {
      modelObj.values.data[i].fillColor = "rgba(224,224,224,1)";
      modelObj.values.data[i].counterColor = "rgba(170,170,170,1)";
    }

    if (flag) {
      localObj.slider.y = 0;
    }

    localObj.currentTarget = null;
    updateStepArrows();
  };

  this.getStep = function () {
    return modelObj.stepsBar.currentStep;
  };

  this.setStep = function (_step) {
    // Check Marking the steps
    var _helpBtnArr = document.querySelectorAll(".helpBtn");

    var _parentArr = document.querySelectorAll(".helpBtnWrapper"); // or we can use parent node of help btn


    _helpBtnArr.forEach(function (_btn, i) {
      if (i < _step) {
        _btn.checked = true;
        _parentArr[i].style.backgroundImage = "url(assets/images/".concat(modelObj.imgList[1], ")");
        _parentArr[i].style.opacity = 1;
        _parentArr[i].style.backgroundSize = "contain";
      }

      _parentArr[i].previousSibling.style.color = modelObj.values.textColor;
    });

    if (_parentArr[_step]) {
      // _parentArr[_step].style.backgroundImage = `url(assets/images/${modelObj.imgList[0]})`;
      _parentArr[_step].previousSibling.style.color = modelObj.values.activeStepColor;
      _parentArr[_step].style.opacity = 1;
    } // CANVAS CODE-------


    modelObj.stepsBar.currentStep = _step;

    for (var i = 0; i < modelObj.values.data.length; i++) {
      if (i >= modelObj.stepsBar.currentStep) {
        modelObj.values.data[i].fillColor = "rgba(224,224,224,1)";
        modelObj.values.data[i].counterColor = "rgba(170,170,170,1)";
      }
    } // updateStepArrows();


    addEvents();
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    document.querySelectorAll(".taskTableWrapper")[0].style.display = "";
    addEvents();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
    document.querySelectorAll(".taskTableWrapper")[0].style.display = "none";
    removeAllEvents();
  };

  this.setFocus = function () {
    document.getElementById("helpBtn_".concat(modelObj.stepsBar.currentStep)).focus();
  }; // =================================================


  this.enable = function () {
    modelObj.disabledAll = false;
    addEvents();
  }; // =================================================


  this.disable = function () {
    modelObj.disabledAll = true;
    removeAllEvents();
  };

  this.setSize = function (_obj) {
    updateValues(_obj, ["x", "y", "width", "height"]);
    calculateRows();
  };

  this.getSize = function (_obj) {
    return {
      x: modelObj.x,
      y: modelObj.y,
      width: modelObj.width,
      height: modelObj.height
    };
  };

  this.getVisible = function () {
    return modelObj.visible;
  };

  this.stepsVisible = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    if (_flag !== null) {
      localObj.showSteps = !!_flag;
      updateStepArrows();
    }

    return localObj.showSteps;
  };

  function updateValues(_data, keys) {
    var temp = {};
    keys.forEach(function (i) {
      if (_data.hasOwnProperty(i)) {
        modelObj[i] = _data[i];
      }
    });
    setData(modelObj, temp);
  } // =================================================


  this.draws = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;
      var _x = modelObj.x;
      var _y = modelObj.y; // ----------------- columns

      if (modelObj.visible) {
        var heights = localObj.dataHeight;

        _ctx.save();

        _ctx.beginPath();

        _ctx.fillStyle = "rgba(255,255,255,1)";
        _ctx.strokeStyle = "rgba(73,124,190,1)";

        _ctx.rect(_x + 1, _y, modelObj.width, heights);

        _ctx.lineWidth = 1;

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        _ctx.restore(); // ---------------------------


        _ctx.save();

        _ctx.beginPath();

        _ctx.fillStyle = "rgba(0,0,0,0)";

        _ctx.rect(_x, _y + 1, modelObj.width, heights - 2);

        _ctx.closePath();

        _ctx.clip();

        var _v = modelObj.values;
        var minY = localObj.minY;
        _x = localObj.pivotPoint.x;
        _y = localObj.pivotPoint.y;

        for (var i = 0; i < modelObj.values.data.length; i++) {
          var _d = modelObj.values.data[i];
          var text = "";
          var textX = _x + _v.padding;
          var textY = _y + 10;

          if (_v.data[i] && _v.data[i].text) {
            var txt = _v.data[i].text;

            if (i === modelObj.stepsBar.currentStep && !modelObj.disabledAll) {
              txt = _v.data[i].boldText;
            }

            text = {
              textAlign: "left",
              fontColor: "rgba(0,0,0,1)",
              text: txt,
              x: textX,
              y: textY,
              fontFamily: modelObj.LabComClass.klettFontRegular,
              fontSize: modelObj.fontSize
            };
          }

          if (_v.data[i]) {
            var _obj2 = JSON.parse(JSON.stringify(_v.data[i]));

            _obj2.x = _x;
            _obj2.y = _y;
            _obj2.w = _v.width;
            _obj2.h = _v.data[i].rowHeight;
            _obj2.counter = i;
            _obj2.text = text;
            drawBox(_ctx, _obj2);
            _y += _v.data[i].rowHeight + modelObj.gap;
          }
        }

        _ctx.restore(); // --------------------------------


        if (localObj.slider.visible) {
          _ctx.save();

          _ctx.strokeStyle = "rgba(0,0,0,1)";

          _ctx.rect(modelObj.x + 0.5, modelObj.y + 0.5, modelObj.width - 1, modelObj.height - 1);

          _ctx.clip();

          _ctx.save();

          _ctx.beginPath();

          _ctx.translate(modelObj.x + modelObj.width + modelObj.sliderLeftPadding, minY);

          _ctx.strokeStyle = "rgba(210,210,210,1)";

          _ctx.rect(0, 0, localObj.slider.width, heights);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.beginPath();

          _ctx.fillStyle = "rgba(213, 213, 213, 1)";

          if (localObj.isPressed && localObj.currentTarget === "knob") {
            _ctx.fillStyle = "rgba(102, 102, 102, 1)";
          }

          _ctx.rect(0, localObj.slider.y, localObj.slider.width, localObj.slider.knob.height);

          _ctx.fill();

          _ctx.closePath();

          _ctx.restore();

          _ctx.restore();
        }
      }

      if (modelObj.closeBtnEnable) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.fillStyle = "rgba(142,142,142,1)";
        _ctx.strokeStyle = "rgba(142,142,142,0)";

        if (localObj.isPressed && localObj.currentTarget === "closeBtn_" + modelObj.id) {
          _ctx.fillStyle = "rgba(51,51,51,1)";
        }

        _ctx.rect(modelObj.x + modelObj.closeBtn.x, modelObj.y + modelObj.closeBtn.y, modelObj.closeBtn.w, modelObj.closeBtn.h);

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        _ctx.save();

        _ctx.beginPath();

        _ctx.strokeStyle = "rgba(255,255,255,1)";

        _ctx.translate(modelObj.x + modelObj.closeBtn.x + modelObj.closeBtn.w / 2, modelObj.y + modelObj.closeBtn.y + modelObj.closeBtn.h / 2);

        _ctx.rotate(Math.PI / 4);

        _ctx.moveTo(-5, 0);

        _ctx.lineTo(5, 0);

        _ctx.stroke();

        _ctx.moveTo(0, -5);

        _ctx.lineTo(0, 5);

        _ctx.stroke();

        _ctx.closePath();

        _ctx.restore();

        _ctx.restore();
      }
    }
  };

  function drawBox(ctx, _obj) {
    var x = _obj.x,
        y = _obj.y,
        w = _obj.w,
        h = _obj.h;
    var bW = 2;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.closePath();
    ctx.clip();
    ctx.save();
    ctx.beginPath();
    drawCheckBox(ctx, _obj.counter < modelObj.stepsBar.currentStep, x + modelObj.values.checkBoxBtn.x, y + modelObj.values.checkBoxBtn.y, modelObj.values.checkBoxBtn.w, modelObj.values.checkBoxBtn.h);

    if (_obj.counter >= modelObj.stepsBar.currentStep) {
      drawHelpBtn(ctx, _obj.counter, x + modelObj.values.helpBtn.x, y + modelObj.values.helpBtn.y, modelObj.values.helpBtn.w, modelObj.values.helpBtn.h);
    }

    ctx.restore();

    if (_obj.text) {
      drawText(ctx, _obj.text);
    }

    ctx.closePath();
    ctx.restore();

    if (_obj.counter !== modelObj.values.data.length - 1) {
      ctx.save();
      ctx.beginPath();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(170,170,166,0.6)"; // ctx.moveTo(x + 17, y + h + 18 - (h - _obj.text.text.heightInt) / 2);

      ctx.moveTo(x + 17, y + h + modelObj.gap / 2);

      if (localObj.slider.visible) {
        // ctx.lineTo(x + w - 17 + modelObj.sliderLeftPadding, y + h + 18 - (h - _obj.text.text.heightInt) / 2);
        ctx.lineTo(x + w - 17 + modelObj.sliderLeftPadding, y + h + modelObj.gap / 2);
      } else {
        // ctx.lineTo(x + w - 17, y + h + 18 - (h - _obj.text.text.heightInt) / 2);
        ctx.lineTo(x + w - 17, y + h + modelObj.gap / 2);
      }

      ctx.stroke();
      ctx.closePath();
      ctx.restore();
    }
  }

  function drawHelpBtn(ctx, id, x, y, w, h) {
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,1)";
    var img = imgObj[modelObj.imgList[0]];
    var imgW = 8 * 1.2;
    var imgH = 16 * 1.2;

    if (localObj.isPressed && localObj.currentTarget === "helpBtn_" + id) {
      img = imgObj[modelObj.imgList[1]];
      ctx.fillStyle = "rgba(96, 96, 96, 1)";
      imgW = 14 * 0.7;
      imgH = 26 * 0.7;
    }

    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.closePath(); // if (img) {
    //   ctx.drawImage(img, x + w / 2 - imgW / 2, y + h / 2 - imgH / 2, imgW, imgH);
    // }

    ctx.beginPath();
    drawQMark(ctx, x, y, w, h);
    ctx.closePath();

    if (!modelObj.disabledAll && id > modelObj.stepsBar.currentStep) {
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.5)";
      ctx.rect(x, y, w, h);
      ctx.fill();
      ctx.closePath();
    } else if (modelObj.disabledAll) {
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.5)";
      ctx.rect(x, y, w, h);
      ctx.fill();
      ctx.closePath();
    }
  }

  function drawQMark(ctx, x, y, w, h) {
    ctx.save();
    ctx.translate(x, y); //Top

    drawBezierCurve(ctx, 10.2, 9, 14, 4, 18.5, 7, 15.2, 11.5, 0, 3.5); //Bottom

    drawBezierCurve(ctx, 15.6, 11.5, 9.5, 13.6, 15.2, 15.2, 11.5, 14, 0, 3.5);
    ctx.lineWidth = 1;
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = "rgba(112,146,190,1)";
    ctx.arc(12.7, 19.5, 1.5, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawBezierCurve(ctx, startX, startY, controlX1, controlY1, controlX2, controlY2, endX, endY) {
    var guide = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
    var curveWidth = arguments.length > 10 ? arguments[10] : undefined;
    var curveColor = arguments.length > 11 ? arguments[11] : undefined;
    var radian = Math.PI / 180; // Draw the bezier curve

    ctx.beginPath();
    ctx.strokeStyle = curveColor || "rgba(112,146,190,1)";
    ctx.lineWidth = curveWidth || 2;
    ctx.moveTo(startX, startY);
    ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
    ctx.stroke();

    if (guide) {
      // Draw the control one point as a circle
      ctx.beginPath();
      ctx.strokeStyle = "black";
      ctx.lineWidth = 10;
      ctx.arc(controlX1, controlY1, 1, 0 * radian, 360 * radian, false);
      ctx.stroke(); // Draw the control two point as a circle

      ctx.beginPath();
      ctx.strokeStyle = "black";
      ctx.lineWidth = 10;
      ctx.arc(controlX2, controlY2, 1, 0 * radian, 360 * radian, false);
      ctx.stroke(); // Draw the lines between control points and path

      ctx.beginPath();
      ctx.lineWidth = 1;
      ctx.moveTo(startX, startY);
      ctx.lineTo(controlX1, controlY1);
      ctx.lineTo(controlX2, controlY2);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    }
  }

  function drawCheckBox(ctx) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var x = arguments.length > 2 ? arguments[2] : undefined;
    var y = arguments.length > 3 ? arguments[3] : undefined;
    var w = arguments.length > 4 ? arguments[4] : undefined;
    var h = arguments.length > 5 ? arguments[5] : undefined;
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.strokeStyle = "rgba(112,146,190,1)";
    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.stroke();
    ctx.closePath();

    if (status !== null) {
      if (status) {
        ctx.beginPath();
        ctx.fillStyle = "rgba(112,146,190,1)";
        ctx.strokeStyle = "rgba(255,255,255,1)";
        ctx.rect(x, y, w, h);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
        ctx.lineWidth = 2;
        ctx.lineJoin = "round";
        ctx.moveTo(x + 4, y + 14);
        ctx.lineTo(x + 10, y + 19);
        ctx.lineTo(x + 22, y + 5);
        ctx.stroke();

        if (modelObj.disabledAll) {
          ctx.beginPath();
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          ctx.rect(x, y, w, h);
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  function drawText(ctx, _obj) {
    var x = _obj.x,
        y = _obj.y,
        text = _obj.text,
        fontFamily = _obj.fontFamily,
        fontSize = _obj.fontSize,
        textAlign = _obj.textAlign,
        fontColor = _obj.fontColor;

    if (_typeof(text) !== "object") {
      ctx.save();
      ctx.beginPath();
      ctx.textAlign = _obj.textAlign;
      ctx.textBaseline = "bottom";
      ctx.fillStyle = _obj.fontColor;
      ctx.drawStyledText(text, x, y + fontSize / 2 + fontSize * 0.1, fontFamily, fontSize);
      ctx.closePath();
      ctx.restore();
    } else if (text.imageObj) {
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = "rgba(112,146,190,1)";
      ctx.drawImage(text.imageObj, x, y, text.widthInt, text.heightInt);
      ctx.closePath();
      ctx.restore();
    }
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function calculateRows() {
    localObj.minY = modelObj.y;
    var _rc = modelObj.values.rowCount;
    var _h = modelObj.height;
    var _vh = modelObj.values.height;
    modelObj.taskHeights = modelObj.height;

    if (_rc === "auto" && _h !== "auto" && _vh !== "auto") {
      modelObj.values.rowCount = Math.round(_h / (_vh + modelObj.gap));
      modelObj.taskHeights = modelObj.values.rowCount * _vh + modelObj.values.rowCount * modelObj.gap;
    } else if (_rc !== "auto" && _h === "auto" && _vh !== "auto") {
      modelObj.taskHeights = _rc * _vh + (_rc - 1) * modelObj.gap;
    } else if (_rc !== "auto" && _h !== "auto" && _vh === "auto") {
      modelObj.values.height = _h / _rc - modelObj.gap;
    } else {
      modelObj.values.rowCount = localObj.defaultRowCount;
      modelObj.taskHeights = localObj.defaultHeight;
      modelObj.values.height = localObj.defaultRowHeight;
    }

    modelObj.taskHeights = modelObj.height;
    localObj.pivotPoint.x = modelObj.x;
    localObj.pivotPoint.y = localObj.minY;
    localObj.unitY = modelObj.values.height + modelObj.gap;
    localObj.dataHeight = modelObj.taskHeights;
    localObj.maxY = localObj.minY + localObj.dataHeight;
    localObj.slider.x = 0;
    localObj.slider.y = 0;
    updateSlider();
    localObj.leftArrowPos = {
      x: modelObj.stepsBar.x + modelObj.stepsBar.w - 104,
      y: modelObj.stepsBar.y + modelObj.stepsBar.h / 2
    };
    localObj.rightArrowPos = {
      x: modelObj.stepsBar.x + modelObj.stepsBar.w - 75,
      y: modelObj.stepsBar.y + modelObj.stepsBar.h / 2
    };
    localObj.slideArrowPos = {
      x: modelObj.stepsBar.x + modelObj.stepsBar.w - 25,
      y: modelObj.stepsBar.y + modelObj.stepsBar.h / 2
    };

    if (modelObj.LabComClass.globalLangText[modelObj.stepsBar.text]) {
      modelObj.stepsBar.text = modelObj.LabComClass.globalLangText[modelObj.stepsBar.text];
    } else {
      modelObj.stepsBar.text = "---";
    }

    updateStepArrows();
    addEvents();
  }

  function updateSlider() {
    if (modelObj.values.rowCount < modelObj.values.data.length) {
      modelObj.values.rowCount = modelObj.values.data.length;
    }

    var totalHeight = 0;

    for (var i = 0; i < modelObj.values.data.length; i++) {
      totalHeight += modelObj.values.data[i].rowHeight;
    }

    totalHeight += modelObj.gap * modelObj.values.data.length - 1;

    if (localObj.minY + totalHeight - modelObj.gap > localObj.maxY) {
      localObj.slider.visible = true;
    } else {
      localObj.slider.visible = false;
    }

    var slidePercent = localObj.slider.y / (localObj.dataHeight - localObj.slider.knob.height) * 100;
    localObj.pivotPoint.y = localObj.minY - (totalHeight - localObj.dataHeight - modelObj.gap) * slidePercent / 100;
  }

  function removeAllEvents() {
    // All events are removed, button is disabled and tab indexing is set to -1.
    var data = modelObj.values.data;

    var _parentArr = document.querySelectorAll(".helpBtnWrapper");

    if (modelObj.visible) {
      // if(!modelObj.disabledAll){
      for (var i = 0; i < data.length; i++) {
        var _button = document.getElementById("helpBtn_".concat(i));

        _button.classList.add("disabled");

        _button.setAttribute("tabIndex", -1);

        _button.setAttribute("disabled", true);

        _parentArr[i].style.opacity = 0.5;

        _button.removeEventListener("click", onButtonClick);
      }

      document.removeEventListener("keyup", keyUpClick); // }
    } // onViewUpdateCls.trigger('onGlobalUpdate', {
    //   type: 'updateTrapFocus',
    //   data: {
    //     element: 'document.body'
    //   }
    // });

  }

  function addEvents() {
    // removeAllEvents();
    var data = modelObj.values.data;

    if (modelObj.visible) {
      if (!modelObj.disabledAll) {
        var _parentArr = document.querySelectorAll(".helpBtnWrapper");

        for (var i = 0; i < data.length; i++) {
          if (i <= modelObj.stepsBar.currentStep) {
            // console.log('Inisde',modelObj.stepsBar.currentStep);
            var _button = document.getElementById("helpBtn_".concat(i));

            _button.classList.remove("disabled");

            _button.setAttribute("tabIndex", 0);

            _button.removeAttribute("disabled");

            _parentArr[i].style.opacity = 1;

            _button.addEventListener("click", onButtonClick);

            _button.focus();
          }
        }

        document.addEventListener("keyup", keyUpClick);
      }
    }
  }

  function keyUpClick(e) {
    if (e.key === "Enter" && e.target.id.includes("helpBtn_")) {
      e.preventDefault();
      e.target.click();
    }
  }

  function onButtonClick(e) {
    var _id = this.id;

    var _helpBtnArr = document.querySelectorAll(".helpBtn");

    var _parentArr = document.querySelectorAll(".helpBtnWrapper");

    if (events.click) {
      var type;
      var value = Number(_id.split("_")[1]); //Reset

      if (!this.checked) {
        _helpBtnArr.forEach(function (_btn, i) {
          // Steps after the respective reset
          if (i > value) {
            _btn.checked = false;

            _btn.classList.add("disabled");

            _btn.setAttribute("tabIndex", -1);

            _btn.setAttribute("disabled", true);

            _parentArr[i].style.opacity = 0.5;

            _btn.removeEventListener("click", onButtonClick);

            _parentArr[i].style.backgroundImage = "url(assets/images/".concat(modelObj.imgList[0], ")");
            _parentArr[i].style.backgroundSize = "";
          } // All Step Text are changed to grey color


          _btn.parentNode.previousSibling.style.color = modelObj.values.textColor;
        });

        this.parentNode.style.backgroundImage = "url(assets/images/".concat(modelObj.imgList[0], ")");
        this.parentNode.style.backgroundSize = ""; // step color changed to active color

        this.parentNode.previousSibling.style.color = modelObj.values.activeStepColor;
        this.parentNode.style.opacity = 1;
      } // Fires click event sends update to brain class.


      if (value === modelObj.stepsBar.currentStep) {
        type = "help";
        modelObj.stepsBar.currentStep++;

        _this.setStep(modelObj.stepsBar.currentStep);
      } else {
        type = "reset";
        modelObj.stepsBar.currentStep = value;
      }

      _parentArr[value].style.opacity = 1;
      events.click({
        id: modelObj.id,
        type: type,
        value: value
      });
    }
  }

  function addEventsCanvas() {
    removeAllEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.visible) {
      var extraEventArea = 5;

      if (localObj.slider.visible) {
        _eventDataObj.r.push({
          id: "knobBase",
          rect: {
            x: modelObj.x + modelObj.width + modelObj.sliderLeftPadding - extraEventArea,
            y: modelObj.y - extraEventArea,
            w: localObj.slider.width + extraEventArea * 2,
            h: modelObj.height + extraEventArea * 2
          },
          cursor: "default",
          eventListener: mouseHandle.bind(this)
        });

        _eventDataObj.r.push({
          id: "knob",
          rect: {
            x: modelObj.x + modelObj.width + modelObj.sliderLeftPadding - extraEventArea,
            y: localObj.slider.y + localObj.minY - extraEventArea,
            w: localObj.slider.width + extraEventArea * 2,
            h: localObj.slider.knob.height + extraEventArea * 2
          },
          eventListener: mouseHandle.bind(this)
        });
      }

      if (!modelObj.disabledAll) {
        var _x = modelObj.x;
        var _y = localObj.pivotPoint.y;

        for (var i = 0; i < modelObj.values.data.length; i++) {
          if (_y >= modelObj.y - modelObj.values.helpBtn.h * 0.9 && _y <= modelObj.y + modelObj.taskHeights - 5) {
            if (i <= modelObj.stepsBar.currentStep) {
              _eventDataObj.r.push({
                id: "helpBtn_" + i,
                rect: {
                  x: _x + modelObj.values.helpBtn.x,
                  y: _y + modelObj.values.helpBtn.y,
                  w: modelObj.values.helpBtn.w,
                  h: modelObj.values.helpBtn.h
                },
                eventListener: mouseHandle.bind(this)
              });
            }
          }

          _y += modelObj.values.data[i].rowHeight + modelObj.gap;
        }
      }

      if (modelObj.closeBtnEnable) {
        var minArea = 25;
        var w = modelObj.closeBtn.w < minArea ? minArea : localObj.closeBtn.w;
        var h = modelObj.closeBtn.h < minArea ? minArea : localObj.closeBtn.h;

        _eventDataObj.r.push({
          id: "closeBtn_" + modelObj.id,
          rect: {
            x: modelObj.x + modelObj.closeBtn.x + modelObj.closeBtn.w - w,
            y: modelObj.y + modelObj.closeBtn.y,
            w: w,
            h: h
          },
          eventListener: mouseHandle.bind(this)
        });
      }
    }

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "addMouseEvent",
      data: _eventDataObj
    });
  } // This function handles all mouse events


  function mouseHandle(e) {
    var id = e.subId ? Number(e.subId.split("_")[1]) : e.subId;

    switch (e.type) {
      case "mousedown":
        localObj.isPressed = true;
        localObj.isHover = false;
        localObj.currentTarget = e.subId;
        localObj.diffY = e.pageY - (localObj.slider.y + localObj.minY);

        if (e.subId === "knobBase") {
          localObj.slider.y = e.pageY - localObj.minY - localObj.slider.knob.height / 2;
          restrictSlider();
        }

        break;

      case "pressmove":
        if (e.subId === "knob") {
          localObj.slider.y = e.pageY - localObj.minY - localObj.diffY;
          restrictSlider();
        }

        break;

      case "mouseup":
        localObj.isPressed = false;
        modelObj.selected = id;

        if (e.subId === "leftArrow") {
          modelObj.stepsBar.currentStep--;
        } else if (e.subId === "rightArrow") {
          modelObj.stepsBar.currentStep++;
        }

        switch (e.subId) {
          case "slideArrow":
            localObj.showSteps = !localObj.showSteps;

            if (events.click) {
              events.click({
                id: modelObj.id,
                type: "showSteps",
                value: localObj.showSteps
              });
            }

            break;

          default:
            break;
        }

        if (e.subId.split("_")[0] === "helpBtn") {
          if (events.click) {
            var type;
            var value = Number(e.subId.split("_")[1]);

            if (value === modelObj.stepsBar.currentStep) {
              type = "help";
              modelObj.stepsBar.currentStep++;
            } else {
              type = "reset";
              modelObj.stepsBar.currentStep = value;
            }

            events.click({
              id: modelObj.id,
              type: type,
              value: value
            });
          }
        }

        if (e.subId === "closeBtn_" + modelObj.id) {
          if (events.click) {
            events.click({
              id: modelObj.id,
              type: "close"
            });
          }
        }

        updateStepArrows();
        break;

      case "mouseenter":
        localObj.isHover = id;
        break;

      case "mouseout":
      case "mouseupout":
        localObj.isHover = false;
        localObj.isPressed = false;

        if (e.type === "mouseupout") {
          updateSlider(true);
          updateStepArrows();
        }

        break;

      default:
        break;
    }
  }

  function restrictSlider() {
    if (localObj.slider.y < 0) {
      localObj.slider.y = 0;
    }

    if (localObj.slider.y > localObj.dataHeight - localObj.slider.knob.height) {
      localObj.slider.y = localObj.dataHeight - localObj.slider.knob.height;
    }

    updateSlider();
  }

  function updateStepArrows() {
    modelObj.stepsBar.currentStep = modelObj.stepsBar.currentStep <= 0 ? 0 : modelObj.stepsBar.currentStep;
    modelObj.stepsBar.currentStep = modelObj.stepsBar.currentStep >= modelObj.values.data.length ? modelObj.values.data.length : modelObj.stepsBar.currentStep;
    localObj.rightArrowEnable = true;
    localObj.leftArrowEnable = true;

    if (modelObj.stepsBar.currentStep >= modelObj.values.data.length - 1) {
      localObj.rightArrowEnable = false;
    }

    if (modelObj.stepsBar.currentStep <= 0) {
      localObj.leftArrowEnable = false;
    }

    setControlls();
  }

  function setControlls() {
    if (!modelObj.visible) {
      localObj.leftArrowEnable = false;
      localObj.rightArrowEnable = false;
    }

    updateSlider(true);
    addEvents();
  }
}
/*
  html2canvas 0.5.0-alpha <http://html2canvas.hertzen.com>
  Copyright (c) 2014 Niklas von Hertzen

  Released under MIT License
*/

(function(window, document, module, exports, global, define, undefined){

/*
 Copyright (c) 2013 Yehuda Katz, Tom Dale, and contributors

 Permission is hereby granted, free of charge, to any person obtaining a copy of
 this software and associated documentation files (the "Software"), to deal in
 the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do
 so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
!function(){var a,b,c,d;!function(){var e={},f={};a=function(a,b,c){e[a]={deps:b,callback:c}},d=c=b=function(a){function c(b){if("."!==b.charAt(0))return b;for(var c=b.split("/"),d=a.split("/").slice(0,-1),e=0,f=c.length;f>e;e++){var g=c[e];if(".."===g)d.pop();else{if("."===g)continue;d.push(g)}}return d.join("/")}if(d._eak_seen=e,f[a])return f[a];if(f[a]={},!e[a])throw new Error("Could not find module "+a);for(var g,h=e[a],i=h.deps,j=h.callback,k=[],l=0,m=i.length;m>l;l++)"exports"===i[l]?k.push(g={}):k.push(b(c(i[l])));var n=j.apply(this,k);return f[a]=g||n}}(),a("promise/all",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to all.");return new b(function(b,c){function d(a){return function(b){f(a,b)}}function f(a,c){h[a]=c,0===--i&&b(h)}var g,h=[],i=a.length;0===i&&b([]);for(var j=0;j<a.length;j++)g=a[j],g&&e(g.then)?g.then(d(j),c):f(j,g)})}var d=a.isArray,e=a.isFunction;b.all=c}),a("promise/asap",["exports"],function(a){"use strict";function b(){return function(){process.nextTick(e)}}function c(){var a=0,b=new i(e),c=document.createTextNode("");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function d(){return function(){j.setTimeout(e,1)}}function e(){for(var a=0;a<k.length;a++){var b=k[a],c=b[0],d=b[1];c(d)}k=[]}function f(a,b){var c=k.push([a,b]);1===c&&g()}var g,h="undefined"!=typeof window?window:{},i=h.MutationObserver||h.WebKitMutationObserver,j="undefined"!=typeof global?global:this,k=[];g="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?b():i?c():d(),a.asap=f}),a("promise/cast",["exports"],function(a){"use strict";function b(a){if(a&&"object"==typeof a&&a.constructor===this)return a;var b=this;return new b(function(b){b(a)})}a.cast=b}),a("promise/config",["exports"],function(a){"use strict";function b(a,b){return 2!==arguments.length?c[a]:(c[a]=b,void 0)}var c={instrument:!1};a.config=c,a.configure=b}),a("promise/polyfill",["./promise","./utils","exports"],function(a,b,c){"use strict";function d(){var a="Promise"in window&&"cast"in window.Promise&&"resolve"in window.Promise&&"reject"in window.Promise&&"all"in window.Promise&&"race"in window.Promise&&function(){var a;return new window.Promise(function(b){a=b}),f(a)}();a||(window.Promise=e)}var e=a.Promise,f=b.isFunction;c.polyfill=d}),a("promise/promise",["./config","./utils","./cast","./all","./race","./resolve","./reject","./asap","exports"],function(a,b,c,d,e,f,g,h,i){"use strict";function j(a){if(!w(a))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof j))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._subscribers=[],k(a,this)}function k(a,b){function c(a){p(b,a)}function d(a){r(b,a)}try{a(c,d)}catch(e){d(e)}}function l(a,b,c,d){var e,f,g,h,i=w(c);if(i)try{e=c(d),g=!0}catch(j){h=!0,f=j}else e=d,g=!0;o(b,e)||(i&&g?p(b,e):h?r(b,f):a===F?p(b,e):a===G&&r(b,e))}function m(a,b,c,d){var e=a._subscribers,f=e.length;e[f]=b,e[f+F]=c,e[f+G]=d}function n(a,b){for(var c,d,e=a._subscribers,f=a._detail,g=0;g<e.length;g+=3)c=e[g],d=e[g+b],l(b,c,d,f);a._subscribers=null}function o(a,b){var c,d=null;try{if(a===b)throw new TypeError("A promises callback cannot return that same promise.");if(v(b)&&(d=b.then,w(d)))return d.call(b,function(d){return c?!0:(c=!0,b!==d?p(a,d):q(a,d),void 0)},function(b){return c?!0:(c=!0,r(a,b),void 0)}),!0}catch(e){return c?!0:(r(a,e),!0)}return!1}function p(a,b){a===b?q(a,b):o(a,b)||q(a,b)}function q(a,b){a._state===D&&(a._state=E,a._detail=b,u.async(s,a))}function r(a,b){a._state===D&&(a._state=E,a._detail=b,u.async(t,a))}function s(a){n(a,a._state=F)}function t(a){n(a,a._state=G)}var u=a.config,v=(a.configure,b.objectOrFunction),w=b.isFunction,x=(b.now,c.cast),y=d.all,z=e.race,A=f.resolve,B=g.reject,C=h.asap;u.async=C;var D=void 0,E=0,F=1,G=2;j.prototype={constructor:j,_state:void 0,_detail:void 0,_subscribers:void 0,then:function(a,b){var c=this,d=new this.constructor(function(){});if(this._state){var e=arguments;u.async(function(){l(c._state,d,e[c._state-1],c._detail)})}else m(this,d,a,b);return d},"catch":function(a){return this.then(null,a)}},j.all=y,j.cast=x,j.race=z,j.resolve=A,j.reject=B,i.Promise=j}),a("promise/race",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to race.");return new b(function(b,c){for(var d,e=0;e<a.length;e++)d=a[e],d&&"function"==typeof d.then?d.then(b,c):b(d)})}var d=a.isArray;b.race=c}),a("promise/reject",["exports"],function(a){"use strict";function b(a){var b=this;return new b(function(b,c){c(a)})}a.reject=b}),a("promise/resolve",["exports"],function(a){"use strict";function b(a){var b=this;return new b(function(b){b(a)})}a.resolve=b}),a("promise/utils",["exports"],function(a){"use strict";function b(a){return c(a)||"object"==typeof a&&null!==a}function c(a){return"function"==typeof a}function d(a){return"[object Array]"===Object.prototype.toString.call(a)}var e=Date.now||function(){return(new Date).getTime()};a.objectOrFunction=b,a.isFunction=c,a.isArray=d,a.now=e}),b("promise/polyfill").polyfill()}();

if (typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") {
    window.html2canvas = function() {
        return Promise.reject("No canvas support");
    };
    return;
}

/*! https://mths.be/punycode v1.3.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		var labels = string.split(regexSeparators);
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

var html2canvasNodeAttribute = "data-html2canvas-node";
var html2canvasCanvasCloneAttribute = "data-html2canvas-canvas-clone";
var html2canvasCanvasCloneIndex = 0;

window.html2canvas = function(nodeList, options) {
    options = options || {};
    if (options.logging) {
        window.html2canvas.logging = true;
        window.html2canvas.start = Date.now();
    }

    options.async = typeof(options.async) === "undefined" ? true : options.async;
    options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
    options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
    options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
    options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
    options.pixelRatio = typeof(options.pixelRatio) === "undefined" ? 1 : options.pixelRatio;

    if (typeof(nodeList) === "string") {
        if (typeof(options.proxy) !== "string") {
            return Promise.reject("Proxy must be used when rendering url");
        }
        return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, window.innerWidth, window.innerHeight, options).then(function(container) {
            return renderWindow(container.contentWindow.document.documentElement, container, options, window.innerWidth, window.innerHeight);
        });
    }

    var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
    node.setAttribute(html2canvasNodeAttribute, "true");
    return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight).then(function(canvas) {
        if (typeof(options.onrendered) === "function") {
            log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
            options.onrendered(canvas);
        }
        return canvas;
    });
};

window.html2canvas.punycode = this.punycode;
window.html2canvas.proxy = {};

function renderDocument(document, options, windowWidth, windowHeight) {
    return createWindowClone(document, document, windowWidth, windowHeight, options).then(function(container) {
        log("Document cloned");
        var selector = "[" + html2canvasNodeAttribute + "='true']";
        document.querySelector(selector).removeAttribute(html2canvasNodeAttribute);
        var clonedWindow = container.contentWindow;
        var node = clonedWindow.document.querySelector(selector);
        var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
        return oncloneHandler.then(function() {
            return renderWindow(node, container, options, windowWidth, windowHeight);
        });
    });
}

function renderWindow(node, container, options, windowWidth, windowHeight) {
    var clonedWindow = container.contentWindow;
    var support = new Support(clonedWindow.document);
    var imageLoader = new ImageLoader(options, support);
    var bounds = getBounds(node);
    var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
    var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
    var renderer = new CanvasRenderer(width, height, imageLoader, options, document);
    var parser = new NodeParser(node, renderer, support, imageLoader, options);
    return parser.ready.then(function() {
        log("Finished rendering");
        var canvas;

        if (options.type === "view") {
            canvas = crop(renderer.canvas, {width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0});
        } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
            canvas = renderer.canvas;
        } else {
            canvas = crop(renderer.canvas, {width:  options.width != null ? options.width : bounds.width * options.pixelRatio, height: options.height != null ? options.height : bounds.height * options.pixelRatio, top: bounds.top, left: bounds.left, x: clonedWindow.pageXOffset, y: clonedWindow.pageYOffset});
        }

        cleanupContainer(container, options);
        return canvas;
    });
}

function cleanupContainer(container, options) {
    if (options.removeContainer) {
        container.parentNode.removeChild(container);
        log("Cleaned up container");
    }
}

function crop(canvas, bounds) {
    var croppedCanvas = document.createElement("canvas");
    var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
    var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
    var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
    var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
    croppedCanvas.width = bounds.width;
    croppedCanvas.height =  bounds.height;
    log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", (x2-x1), "height:", (y2-y1));
    log("Resulting crop with width", bounds.width, "and height", bounds.height, " with x", x1, "and y", y1);
    croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, x2-x1, y2-y1, bounds.x, bounds.y, x2-x1, y2-y1);
    return croppedCanvas;
}

function documentWidth (doc) {
    return Math.max(
        Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
        Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
        Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
    );
}

function documentHeight (doc) {
    return Math.max(
        Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
        Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
        Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
    );
}

function smallImage() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
}

function createWindowClone(ownerDocument, containerDocument, width, height, options) {
    labelCanvasElements(ownerDocument);
    var documentElement = ownerDocument.documentElement.cloneNode(true),
        container = containerDocument.createElement("iframe");

    container.style.visibility = "hidden";
    container.style.position = "absolute";
    container.style.left = container.style.top = "-10000px";
    container.width = width;
    container.height = height;
    container.scrolling = "no"; // ios won't scroll without it
    containerDocument.body.appendChild(container);

    return new Promise(function(resolve) {
        var documentClone = container.contentWindow.document;
        /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
        if window url is about:blank, we can assign the url to current by writing onto the document
         */
        container.contentWindow.onload = container.onload = function() {
            var interval = setInterval(function() {
                if (documentClone.body.childNodes.length > 0) {
                    cloneCanvasContents(ownerDocument, documentClone);
                    clearInterval(interval);
                    if (options.type === "view") {
                        container.contentWindow.scrollTo(x, y);
                    }
                    resolve(container);
                }
            }, 50);
        };

        var x = ownerDocument.defaultView.pageXOffset;
        var y = ownerDocument.defaultView.pageYOffset;

        documentClone.open();
        documentClone.write("<!DOCTYPE html><html></html>");

        // Chrome scrolls the parent document for some reason after the write to the cloned window???
        if (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset) {
            ownerDocument.defaultView.scrollTo(x, y);
        }
        documentClone.replaceChild(options.javascriptEnabled === true ? documentClone.adoptNode(documentElement) : removeScriptNodes(documentClone.adoptNode(documentElement)), documentClone.documentElement);
        documentClone.close();
    });
}

function loadUrlDocument(src, proxy, document, width, height, options) {
    return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
        return createWindowClone(doc, document, width, height, options);
    });
}

function documentFromHTML(src) {
    return function(html) {
        var parser = new DOMParser(), doc;
        try {
            doc = parser.parseFromString(html, "text/html");
        } catch(e) {
            log("DOMParser not supported, falling back to createHTMLDocument");
            doc = document.implementation.createHTMLDocument("");
            try {
                doc.open();
                doc.write(html);
                doc.close();
            } catch(ee) {
                log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement
            }
        }

        var b = doc.querySelector("base");
        if (!b || !b.href.host) {
            var base = doc.createElement("base");
            base.href = src;
            doc.head.insertBefore(base, doc.head.firstChild);
        }

        return doc;
    };
}


function labelCanvasElements(ownerDocument) {
    [].slice.call(ownerDocument.querySelectorAll("canvas"), 0).forEach(function(canvas) {
        canvas.setAttribute(html2canvasCanvasCloneAttribute, "canvas-" + html2canvasCanvasCloneIndex++);
    });
}

function cloneCanvasContents(ownerDocument, documentClone) {
    [].slice.call(ownerDocument.querySelectorAll("[" + html2canvasCanvasCloneAttribute + "]"), 0).forEach(function(canvas) {
        try {
            var clonedCanvas = documentClone.querySelector('[' + html2canvasCanvasCloneAttribute + '="' + canvas.getAttribute(html2canvasCanvasCloneAttribute) + '"]');
            if (clonedCanvas) {
                clonedCanvas.width = canvas.width;
                clonedCanvas.height = canvas.height;
                clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            }
        } catch(e) {
            log("Unable to copy canvas content from", canvas, e);
        }
        canvas.removeAttribute(html2canvasCanvasCloneAttribute);
    });
}

function removeScriptNodes(parent) {
    [].slice.call(parent.childNodes, 0).filter(isElementNode).forEach(function(node) {
        if (node.tagName === "SCRIPT") {
            parent.removeChild(node);
        } else {
            removeScriptNodes(node);
        }
    });
    return parent;
}

function isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
}

function absoluteUrl(url) {
    var link = document.createElement("a");
    link.href = url;
    link.href = link.href;
    return link;
}

function DummyImageContainer(src) {
    this.src = src;
    log("DummyImageContainer for", src);
    if (!this.promise || !this.image) {
        log("Initiating DummyImageContainer");
        DummyImageContainer.prototype.image = new Image();
        var image = this.image;
        DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
            image.onload = resolve;
            image.onerror = reject;
            image.src = smallImage();
            if (image.complete === true) {
                resolve(image);
            }
        });
    }
}

function Font(family, size) {
    var container = document.createElement('div'),
        img = document.createElement('img'),
        span = document.createElement('span'),
        sampleText = 'Hidden Text',
        baseline,
        middle;

    container.style.visibility = "hidden";
    container.style.fontFamily = family;
    container.style.fontSize = size;
    container.style.margin = 0;
    container.style.padding = 0;

    document.body.appendChild(container);

    img.src = smallImage();
    img.width = 1;
    img.height = 1;

    img.style.margin = 0;
    img.style.padding = 0;
    img.style.verticalAlign = "baseline";

    span.style.fontFamily = family;
    span.style.fontSize = size;
    span.style.margin = 0;
    span.style.padding = 0;

    span.appendChild(document.createTextNode(sampleText));
    container.appendChild(span);
    container.appendChild(img);
    baseline = (img.offsetTop - span.offsetTop) + 1;

    container.removeChild(span);
    container.appendChild(document.createTextNode(sampleText));

    container.style.lineHeight = "normal";
    img.style.verticalAlign = "super";

    middle = (img.offsetTop-container.offsetTop) + 1;

    document.body.removeChild(container);

    this.baseline = baseline;
    this.lineWidth = 1;
    this.middle = middle;
}

function FontMetrics() {
    this.data = {};
}

FontMetrics.prototype.getMetrics = function(family, size) {
    if (this.data[family + "-" + size] === undefined) {
        this.data[family + "-" + size] = new Font(family, size);
    }
    return this.data[family + "-" + size];
};

function FrameContainer(container, sameOrigin, options) {
    this.image = null;
    this.src = container;
    var self = this;
    var bounds = getBounds(container);
    this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
        if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
            container.contentWindow.onload = container.onload = function() {
                resolve(container);
            };
        } else {
            resolve(container);
        }
    })).then(function(container) {
        return html2canvas(container.contentWindow.document.documentElement, {type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2});
    }).then(function(canvas) {
        return self.image = canvas;
    });
}

FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
    var container = this.src;
    return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
};

function GradientContainer(imageData) {
    this.src = imageData.value;
    this.colorStops = [];
    this.type = null;
    this.x0 = 0.5;
    this.y0 = 0.5;
    this.x1 = 0.5;
    this.y1 = 0.5;
    this.promise = Promise.resolve(true);
}

GradientContainer.prototype.TYPES = {
    LINEAR: 1,
    RADIAL: 2
};

function ImageContainer(src, cors) {
    this.src = src;
    this.image = new Image();
    var self = this;
    this.tainted = null;
    this.promise = new Promise(function(resolve, reject) {
        self.image.onload = resolve;
        self.image.onerror = reject;
        if (cors) {
            self.image.crossOrigin = "anonymous";
        }
        self.image.src = src;
        if (self.image.complete === true) {
            resolve(self.image);
        }
    });
}

function ImageLoader(options, support) {
    this.link = null;
    this.options = options;
    this.support = support;
    this.origin = this.getOrigin(window.location.href);
}

ImageLoader.prototype.findImages = function(nodes) {
    var images = [];
    nodes.reduce(function(imageNodes, container) {
        switch(container.node.nodeName) {
        case "IMG":
            return imageNodes.concat([{
                args: [container.node.src],
                method: "url"
            }]);
        case "svg":
        case "IFRAME":
            return imageNodes.concat([{
                args: [container.node],
                method: container.node.nodeName
            }]);
        }
        return imageNodes;
    }, []).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.findBackgroundImage = function(images, container) {
    container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.addImage = function(images, callback) {
    return function(newImage) {
        newImage.args.forEach(function(image) {
            if (!this.imageExists(images, image)) {
                images.splice(0, 0, callback.call(this, newImage));
                log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
            }
        }, this);
    };
};

ImageLoader.prototype.hasImageBackground = function(imageData) {
    return imageData.method !== "none";
};

ImageLoader.prototype.loadImage = function(imageData) {
    if (imageData.method === "url") {
        var src = imageData.args[0];
        if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
            return new SVGContainer(src);
        } else if (src.match(/data:image\/.*;base64,/i)) {
            return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
        } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
            return new ImageContainer(src, false);
        } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
            return new ImageContainer(src, true);
        } else if (this.options.proxy) {
            return new ProxyImageContainer(src, this.options.proxy);
        } else {
            return new DummyImageContainer(src);
        }
    } else if (imageData.method === "linear-gradient") {
        return new LinearGradientContainer(imageData);
    } else if (imageData.method === "gradient") {
        return new WebkitGradientContainer(imageData);
    } else if (imageData.method === "svg") {
        return new SVGNodeContainer(imageData.args[0], this.support.svg);
    } else if (imageData.method === "IFRAME") {
        return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
    } else {
        return new DummyImageContainer(imageData);
    }
};

ImageLoader.prototype.isSVG = function(src) {
    return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
};

ImageLoader.prototype.imageExists = function(images, src) {
    return images.some(function(image) {
        return image.src === src;
    });
};

ImageLoader.prototype.isSameOrigin = function(url) {
    return (this.getOrigin(url) === this.origin);
};

ImageLoader.prototype.getOrigin = function(url) {
    var link = this.link || (this.link = document.createElement("a"));
    link.href = url;
    link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
    return link.protocol + link.hostname + link.port;
};

ImageLoader.prototype.getPromise = function(container) {
    return this.timeout(container, this.options.imageTimeout)['catch'](function() {
        var dummy = new DummyImageContainer(container.src);
        return dummy.promise.then(function(image) {
            container.image = image;
        });
    });
};

ImageLoader.prototype.get = function(src) {
    var found = null;
    return this.images.some(function(img) {
        return (found = img).src === src;
    }) ? found : null;
};

ImageLoader.prototype.fetch = function(nodes) {
    this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
    this.images.forEach(function(image, index) {
        image.promise.then(function() {
            log("Succesfully loaded image #"+ (index+1), image);
        }, function(e) {
            log("Failed loading image #"+ (index+1), image, e);
        });
    });
    this.ready = Promise.all(this.images.map(this.getPromise, this));
    log("Finished searching images");
    return this;
};

ImageLoader.prototype.timeout = function(container, timeout) {
    var timer;
    return Promise.race([container.promise, new Promise(function(res, reject) {
        timer = setTimeout(function() {
            log("Timed out loading image", container);
            reject(container);
        }, timeout);
    })]).then(function(container) {
        clearTimeout(timer);
        return container;
    });
};

function LinearGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = this.TYPES.LINEAR;

    var hasDirection = imageData.args[0].match(this.stepRegExp) === null;

    if (hasDirection) {
        imageData.args[0].split(" ").reverse().forEach(function(position) {
            switch(position) {
                case "left":
                    this.x0 = 0;
                    this.x1 = 1;
                    break;
                case "top":
                    this.y0 = 0;
                    this.y1 = 1;
                    break;
                case "right":
                    this.x0 = 1;
                    this.x1 = 0;
                    break;
                case "bottom":
                    this.y0 = 1;
                    this.y1 = 0;
                    break;
                case "to":
                    var y0 = this.y0;
                    var x0 = this.x0;
                    this.y0 = this.y1;
                    this.x0 = this.x1;
                    this.x1 = x0;
                    this.y1 = y0;
                    break;
            }
        }, this);
    } else {
        this.y0 = 0;
        this.y1 = 1;
    }

    this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
        var colorStopMatch = colorStop.match(this.stepRegExp);
        return {
            color: colorStopMatch[1],
            stop: colorStopMatch[3] === "%" ? colorStopMatch[2] / 100 : null
        };
    }, this);

    if (this.colorStops[0].stop === null) {
        this.colorStops[0].stop = 0;
    }

    if (this.colorStops[this.colorStops.length - 1].stop === null) {
        this.colorStops[this.colorStops.length - 1].stop = 1;
    }

    this.colorStops.forEach(function(colorStop, index) {
        if (colorStop.stop === null) {
            this.colorStops.slice(index).some(function(find, count) {
                if (find.stop !== null) {
                    colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
                    return true;
                } else {
                    return false;
                }
            }, this);
        }
    }, this);
}

LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);

LinearGradientContainer.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/;

function log() {
    if (window.html2canvas.logging && window.console && window.console.log) {
        Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - window.html2canvas.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
    }
}

function NodeContainer(node, parent) {
    this.node = node;
    this.parent = parent;
    this.stack = null;
    this.bounds = null;
    this.borders = null;
    this.clip = [];
    this.backgroundClip = [];
    this.offsetBounds = null;
    this.visible = null;
    this.computedStyles = null;
    this.styles = {};
    this.backgroundImages = null;
    this.transformData = null;
    this.transformMatrix = null;
    this.isPseudoElement = false;
    this.opacity = null;
}

NodeContainer.prototype.cloneTo = function(stack) {
    stack.visible = this.visible;
    stack.borders = this.borders;
    stack.bounds = this.bounds;
    stack.clip = this.clip;
    stack.backgroundClip = this.backgroundClip;
    stack.computedStyles = this.computedStyles;
    stack.styles = this.styles;
    stack.backgroundImages = this.backgroundImages;
    stack.opacity = this.opacity;
};

NodeContainer.prototype.getOpacity = function() {
    return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
};

NodeContainer.prototype.assignStack = function(stack) {
    this.stack = stack;
    stack.children.push(this);
};

NodeContainer.prototype.isElementVisible = function() {
    return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (
        this.css('display') !== "none" &&
        // this.css('visibility') !== "hidden" && // removed by mitr
        !this.node.hasAttribute("data-html2canvas-ignore") &&
        (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden")
    );
};

NodeContainer.prototype.css = function(attribute) {
    if (!this.computedStyles) {
        this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
    }

    return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
};

NodeContainer.prototype.prefixedCss = function(attribute) {
    var prefixes = ["webkit", "moz", "ms", "o"];
    var value = this.css(attribute);
    if (value === undefined) {
        prefixes.some(function(prefix) {
            value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
            return value !== undefined;
        }, this);
    }
    return value === undefined ? null : value;
};

NodeContainer.prototype.computedStyle = function(type) {
    return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
};

NodeContainer.prototype.cssInt = function(attribute) {
    var value = parseInt(this.css(attribute), 10);
    return (isNaN(value)) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html
};

NodeContainer.prototype.cssFloat = function(attribute) {
    var value = parseFloat(this.css(attribute));
    return (isNaN(value)) ? 0 : value;
};

NodeContainer.prototype.fontWeight = function() {
    var weight = this.css("fontWeight");
    switch(parseInt(weight, 10)){
    case 401:
        weight = "bold";
        break;
    case 400:
        weight = "normal";
        break;
    }
    return weight;
};

NodeContainer.prototype.parseClip = function() {
    var matches = this.css('clip').match(this.CLIP);
    if (matches) {
        return {
            top: parseInt(matches[1], 10),
            right: parseInt(matches[2], 10),
            bottom: parseInt(matches[3], 10),
            left: parseInt(matches[4], 10)
        };
    }
    return null;
};

NodeContainer.prototype.parseBackgroundImages = function() {
    return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
};

NodeContainer.prototype.cssList = function(property, index) {
    var value = (this.css(property) || '').split(',');
    value = value[index || 0] || value[0] || 'auto';
    value = value.trim().split(' ');
    if (value.length === 1) {
        value = [value[0], value[0]];
    }
    return value;
};

NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
    var size = this.cssList("backgroundSize", index);
    var width, height;

    if (isPercentage(size[0])) {
        width = bounds.width * parseFloat(size[0]) / 100;
    } else if (/contain|cover/.test(size[0])) {
        var targetRatio = bounds.width / bounds.height, currentRatio = image.width / image.height;
        return (targetRatio < currentRatio ^ size[0] === 'contain') ?  {width: bounds.height * currentRatio, height: bounds.height} : {width: bounds.width, height: bounds.width / currentRatio};
    } else {
        width = parseInt(size[0], 10);
    }

    if (size[0] === 'auto' && size[1] === 'auto') {
        height = image.height;
    } else if (size[1] === 'auto') {
        height = width / image.width * image.height;
    } else if (isPercentage(size[1])) {
        height =  bounds.height * parseFloat(size[1]) / 100;
    } else {
        height = parseInt(size[1], 10);
    }

    if (size[0] === 'auto') {
        width = height / image.height * image.width;
    }

    return {width: width, height: height};
};

NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
    var position = this.cssList('backgroundPosition', index);
    var left, top;

    if (isPercentage(position[0])){
        left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
    } else {
        left = parseInt(position[0], 10);
    }

    if (position[1] === 'auto') {
        top = left / image.width * image.height;
    } else if (isPercentage(position[1])){
        top =  (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
    } else {
        top = parseInt(position[1], 10);
    }

    if (position[0] === 'auto') {
        left = top / image.height * image.width;
    }

    return {left: left, top: top};
};

NodeContainer.prototype.parseBackgroundRepeat = function(index) {
    return this.cssList("backgroundRepeat", index)[0];
};

NodeContainer.prototype.parseTextShadows = function() {
    var textShadow = this.css("textShadow");
    var results = [];

    if (textShadow && textShadow !== 'none') {
        var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
        for (var i = 0; shadows && (i < shadows.length); i++) {
            var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
            results.push({
                color: s[0],
                offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                blur: s[3] ? s[3].replace('px', '') : 0
            });
        }
    }
    return results;
};

NodeContainer.prototype.parseTransform = function() {
    if (!this.transformData) {
        if (this.hasTransform()) {
            var offset = this.parseBounds();
            var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
            origin[0] += offset.left;
            origin[1] += offset.top;
            this.transformData = {
                origin: origin,
                matrix: this.parseTransformMatrix()
            };
        } else {
            this.transformData = {
                origin: [0, 0],
                matrix: [1, 0, 0, 1, 0, 0]
            };
        }
    }
    return this.transformData;
};

NodeContainer.prototype.parseTransformMatrix = function() {
    if (!this.transformMatrix) {
        var transform = this.prefixedCss("transform");
        var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
        this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
    }
    return this.transformMatrix;
};

NodeContainer.prototype.parseBounds = function() {
    return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
};

NodeContainer.prototype.hasTransform = function() {
    return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
};

NodeContainer.prototype.getValue = function() {
    var value = this.node.value || "";
    value = (this.node.tagName === "SELECT") ? selectionValue(this.node) : value;
    return value.length === 0 ? (this.node.placeholder || "") : value;
};

NodeContainer.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/;
NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

function selectionValue(node) {
    var option = node.options[node.selectedIndex || 0];
    return option ? (option.text || "") : "";
}

function parseMatrix(match) {
    if (match && match[1] === "matrix") {
        return match[2].split(",").map(function(s) {
            return parseFloat(s.trim());
        });
    }
}

function isPercentage(value) {
    return value.toString().indexOf("%") !== -1;
}

function parseBackgrounds(backgroundImage) {
    var whitespace = ' \r\n\t',
        method, definition, prefix, prefix_i, block, results = [],
        mode = 0, numParen = 0, quote, args;
    var appendResult = function() {
        if(method) {
            if (definition.substr(0, 1) === '"') {
                definition = definition.substr(1, definition.length - 2);
            }
            if (definition) {
                args.push(definition);
            }
            if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1 ) + 1) > 0) {
                prefix = method.substr(0, prefix_i);
                method = method.substr(prefix_i);
            }
            results.push({
                prefix: prefix,
                method: method.toLowerCase(),
                value: block,
                args: args,
                image: null
            });
        }
        args = [];
        method = prefix = definition = block = '';
    };
    args = [];
    method = prefix = definition = block = '';
    backgroundImage.split("").forEach(function(c) {
        if (mode === 0 && whitespace.indexOf(c) > -1) {
            return;
        }
        switch(c) {
        case '"':
            if(!quote) {
                quote = c;
            } else if(quote === c) {
                quote = null;
            }
            break;
        case '(':
            if(quote) {
                break;
            } else if(mode === 0) {
                mode = 1;
                block += c;
                return;
            } else {
                numParen++;
            }
            break;
        case ')':
            if (quote) {
                break;
            } else if(mode === 1) {
                if(numParen === 0) {
                    mode = 0;
                    block += c;
                    appendResult();
                    return;
                } else {
                    numParen--;
                }
            }
            break;

        case ',':
            if (quote) {
                break;
            } else if(mode === 0) {
                appendResult();
                return;
            } else if (mode === 1) {
                if (numParen === 0 && !method.match(/^url$/i)) {
                    args.push(definition);
                    definition = '';
                    block += c;
                    return;
                }
            }
            break;
        }

        block += c;
        if (mode === 0) {
            method += c;
        } else {
            definition += c;
        }
    });

    appendResult();
    return results;
}

function removePx(str) {
    return str.replace("px", "");
}

function asFloat(str) {
    return parseFloat(str);
}

function getBounds(node) {
    if (node.getBoundingClientRect) {
        var clientRect = node.getBoundingClientRect();
        var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
        return {
            top: clientRect.top,
            bottom: clientRect.bottom || (clientRect.top + clientRect.height),
            right: clientRect.left + width,
            left: clientRect.left,
            width:  width,
            height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
        };
    }
    return {};
}

function offsetBounds(node) {
    var parent = node.offsetParent ? offsetBounds(node.offsetParent) : {top: 0, left: 0};

    return {
        top: node.offsetTop + parent.top,
        bottom: node.offsetTop + node.offsetHeight + parent.top,
        right: node.offsetLeft + parent.left + node.offsetWidth,
        left: node.offsetLeft + parent.left,
        width: node.offsetWidth,
        height: node.offsetHeight
    };
}

function NodeParser(element, renderer, support, imageLoader, options) {
    log("Starting NodeParser");
    this.renderer = renderer;
    this.options = options;
    this.range = null;
    this.support = support;
    this.renderQueue = [];
    this.stack = new StackingContext(true, 1, element.ownerDocument, null);
    var parent = new NodeContainer(element, null);
    if (element === element.ownerDocument.documentElement) {
        // http://www.w3.org/TR/css3-background/#special-backgrounds
        var canvasBackground = new NodeContainer(this.renderer.isTransparent(parent.css('backgroundColor')) ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
        renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.css('backgroundColor'));
    }
    parent.visibile = parent.isElementVisible();
    this.createPseudoHideStyles(element.ownerDocument);
    this.disableAnimations(element.ownerDocument);
    this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
        return container.visible = container.isElementVisible();
    }).map(this.getPseudoElements, this));
    this.fontMetrics = new FontMetrics();
    log("Fetched nodes, total:", this.nodes.length);
    log("Calculate overflow clips");
    this.calculateOverflowClips();
    log("Start fetching images");
    this.images = imageLoader.fetch(this.nodes.filter(isElement));
    this.ready = this.images.ready.then(bind(function() {
        log("Images loaded, starting parsing");
        log("Creating stacking contexts");
        this.createStackingContexts();
        log("Sorting stacking contexts");
        this.sortStackingContexts(this.stack);
        this.parse(this.stack);
        log("Render queue created with " + this.renderQueue.length + " items");
        return new Promise(bind(function(resolve) {
            if (!options.async) {
                this.renderQueue.forEach(this.paint, this);
                resolve();
            } else if (typeof(options.async) === "function") {
                options.async.call(this, this.renderQueue, resolve);
            } else if (this.renderQueue.length > 0){
                this.renderIndex = 0;
                this.asyncRenderer(this.renderQueue, resolve);
            } else {
                resolve();
            }
        }, this));
    }, this));
}

NodeParser.prototype.calculateOverflowClips = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container)) {
            if (isPseudoElement(container)) {
                container.appendToDOM();
            }
            container.borders = this.parseBorders(container);
            var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
            var cssClip = container.parseClip();
            if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                clip.push([["rect",
                        container.bounds.left + cssClip.left,
                        container.bounds.top + cssClip.top,
                        cssClip.right - cssClip.left,
                        cssClip.bottom - cssClip.top
                ]]);
            }
            container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
            container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
            if (isPseudoElement(container)) {
                container.cleanDOM();
            }
        } else if (isTextNode(container)) {
            container.clip = hasParentClip(container) ? container.parent.clip : [];
        }
        if (!isPseudoElement(container)) {
            container.bounds = null;
        }
    }, this);
};

function hasParentClip(container) {
    return container.parent && container.parent.clip.length;
}

NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
    asyncTimer = asyncTimer || Date.now();
    this.paint(queue[this.renderIndex++]);
    if (queue.length === this.renderIndex) {
        resolve();
    } else if (asyncTimer + 20 > Date.now()) {
        this.asyncRenderer(queue, resolve, asyncTimer);
    } else {
        setTimeout(bind(function() {
            this.asyncRenderer(queue, resolve);
        }, this), 0);
    }
};

NodeParser.prototype.createPseudoHideStyles = function(document) {
    this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' +
        '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
};

NodeParser.prototype.disableAnimations = function(document) {
    this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' +
        '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
};

NodeParser.prototype.createStyles = function(document, styles) {
    var hidePseudoElements = document.createElement('style');
    hidePseudoElements.innerHTML = styles;
    document.body.appendChild(hidePseudoElements);
};

NodeParser.prototype.getPseudoElements = function(container) {
    var nodes = [[container]];
    if (container.node.nodeType === Node.ELEMENT_NODE) {
        var before = this.getPseudoElement(container, ":before");
        var after = this.getPseudoElement(container, ":after");

        if (before) {
            nodes.push(before);
        }

        if (after) {
            nodes.push(after);
        }
    }
    return flatten(nodes);
};

function toCamelCase(str) {
    return str.replace(/(\-[a-z])/g, function(match){
        return match.toUpperCase().replace('-','');
    });
}

NodeParser.prototype.getPseudoElement = function(container, type) {
    var style = container.computedStyle(type);
    if(!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
        return null;
    }

    var content = stripQuotes(style.content);
    var isImage = content.substr(0, 3) === 'url';
    var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
    var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);

    for (var i = style.length-1; i >= 0; i--) {
        var property = toCamelCase(style.item(i));
        pseudoNode.style[property] = style[property];
    }

    pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

    if (isImage) {
        pseudoNode.src = parseBackgrounds(content)[0].args[0];
        return [pseudoContainer];
    } else {
        var text = document.createTextNode(content);
        pseudoNode.appendChild(text);
        return [pseudoContainer, new TextContainer(text, pseudoContainer)];
    }
};


NodeParser.prototype.getChildren = function(parentContainer) {
    return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
        var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
        return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
    }, this));
};

NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
    var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
    container.cloneTo(stack);
    var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
    parentStack.contexts.push(stack);
    container.stack = stack;
};

NodeParser.prototype.createStackingContexts = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
            this.newStackingContext(container, true);
        } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
            this.newStackingContext(container, false);
        } else {
            container.assignStack(container.parent.stack);
        }
    }, this);
};

NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
    return container.node.nodeName === "BODY" && this.renderer.isTransparent(container.parent.css('backgroundColor'));
};

NodeParser.prototype.isRootElement = function(container) {
    return container.parent === null;
};

NodeParser.prototype.sortStackingContexts = function(stack) {
    stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
    stack.contexts.forEach(this.sortStackingContexts, this);
};

NodeParser.prototype.parseTextBounds = function(container) {
    return function(text, index, textList) {
        if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
            if (this.support.rangeBounds && !container.parent.hasTransform()) {
                var offset = textList.slice(0, index).join("").length;
                return this.getRangeBounds(container.node, offset, text.length);
            } else if (container.node && typeof(container.node.data) === "string") {
                var replacementNode = container.node.splitText(text.length);
                var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                container.node = replacementNode;
                return bounds;
            }
        } else if(!this.support.rangeBounds || container.parent.hasTransform()){
            container.node = container.node.splitText(text.length);
        }
        return {};
    };
};

NodeParser.prototype.getWrapperBounds = function(node, transform) {
    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
    var parent = node.parentNode,
        backupText = node.cloneNode(true);

    wrapper.appendChild(node.cloneNode(true));
    parent.replaceChild(wrapper, node);
    var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
    parent.replaceChild(backupText, wrapper);
    return bounds;
};

NodeParser.prototype.getRangeBounds = function(node, offset, length) {
    var range = this.range || (this.range = node.ownerDocument.createRange());
    range.setStart(node, offset);
    range.setEnd(node, offset + length);
    return range.getBoundingClientRect();
};

function ClearTransform() {}

NodeParser.prototype.parse = function(stack) {
    // http://www.w3.org/TR/CSS21/visuren.html#z-index
    var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).
    var descendantElements = stack.children.filter(isElement);
    var descendantNonFloats = descendantElements.filter(not(isFloating));
    var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.
    var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.
    var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
    var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
    var text = stack.children.filter(isTextNode).filter(hasText);
    var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).
    negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats)
        .concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
            this.renderQueue.push(container);
            if (isStackingContext(container)) {
                this.parse(container);
                this.renderQueue.push(new ClearTransform());
            }
        }, this);
};

NodeParser.prototype.paint = function(container) {
    try {
        if (container instanceof ClearTransform) {
            this.renderer.ctx.restore();
        } else if (isTextNode(container)) {
            if (isPseudoElement(container.parent)) {
                container.parent.appendToDOM();
            }
            this.paintText(container);
            if (isPseudoElement(container.parent)) {
                container.parent.cleanDOM();
            }
        } else {
            this.paintNode(container);
        }
    } catch(e) {
        log(e);
    }
};

NodeParser.prototype.paintNode = function(container) {
    if (isStackingContext(container)) {
        this.renderer.setOpacity(container.opacity);
        this.renderer.ctx.save();
        if (container.hasTransform()) {
            this.renderer.setTransform(container.parseTransform());
        }
    }

    var bounds = container.parseBounds();
    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
    }, this);

    this.renderer.clip(container.clip, function() {
        this.renderer.renderBorders(container.borders.borders);
    }, this);

    this.renderer.clip(container.backgroundClip, function() {
        switch (container.node.nodeName) {
        case "svg":
        case "IFRAME":
            var imgContainer = this.images.get(container.node);
            if (imgContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imgContainer);
            } else {
                log("Error loading <" + container.node.nodeName + ">", container.node);
            }
            break;
        case "IMG":
            var imageContainer = this.images.get(container.node.src);
            if (imageContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imageContainer);
            } else {
                log("Error loading <img>", container.node.src);
            }
            break;
        case "CANVAS":
            this.renderer.renderImage(container, bounds, container.borders, {image: container.node});
            break;
        case "SELECT":
        case "INPUT":
        case "TEXTAREA":
            this.paintFormValue(container);
            break;
        }
    }, this);
};

NodeParser.prototype.paintFormValue = function(container) {
    if (container.getValue().length > 0) {
        var document = container.node.ownerDocument;
        var wrapper = document.createElement('html2canvaswrapper');
        var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color',
            'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom',
            'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth',
            'boxSizing', 'whiteSpace', 'wordWrap'];

        properties.forEach(function(property) {
            try {
                wrapper.style[property] = container.css(property);
            } catch(e) {
                // Older IE has issues with "border"
                log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
            }
        });
        var bounds = container.parseBounds();
        wrapper.style.position = "fixed";
        wrapper.style.left = bounds.left + "px";
        wrapper.style.top = bounds.top + "px";
        wrapper.textContent = container.getValue();
        document.body.appendChild(wrapper);
        this.paintText(new TextContainer(wrapper.firstChild, container));
        document.body.removeChild(wrapper);
    }
};

NodeParser.prototype.paintText = function(container) {
    container.applyTextTransform();
    var characters = window.html2canvas.punycode.ucs2.decode(container.node.data);
    var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
        return window.html2canvas.punycode.ucs2.encode([character]);
    });

    var weight = container.parent.fontWeight();
    var size = container.parent.css('fontSize');
    var family = container.parent.css('fontFamily');
    var shadows = container.parent.parseTextShadows();

    this.renderer.font(container.parent.css('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
    if (shadows.length) {
        // TODO: support multiple text shadows
        this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
    } else {
        this.renderer.clearShadow();
    }

    this.renderer.clip(container.parent.clip, function() {
        textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
            if (bounds) {
                this.renderer.text(textList[index], bounds.left, bounds.bottom);
                this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
            }
        }, this);
    }, this);
};

NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
    switch(container.css("textDecoration").split(" ")[0]) {
    case "underline":
        // Draws a line at the baseline of the font
        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
        this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.css("color"));
        break;
    case "overline":
        this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.css("color"));
        break;
    case "line-through":
        // TODO try and find exact position for line-through
        this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.css("color"));
        break;
    }
};

NodeParser.prototype.parseBorders = function(container) {
    var nodeBounds = container.parseBounds();
    var radius = getBorderRadiusData(container);
    var borders = ["Top", "Right", "Bottom", "Left"].map(function(side) {
        return {
            width: container.cssInt('border' + side + 'Width'),
            color: container.css('border' + side + 'Color'),
            args: null
        };
    });
    var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);

    return {
        clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
        borders: borders.map(function(border, borderSide) {
            if (border.width > 0) {
                var bx = nodeBounds.left;
                var by = nodeBounds.top;
                var bw = nodeBounds.width;
                var bh = nodeBounds.height - (borders[2].width);

                switch(borderSide) {
                case 0:
                    // top border
                    bh = borders[0].width;
                    border.args = drawSide({
                        c1: [bx, by],
                        c2: [bx + bw, by],
                        c3: [bx + bw - borders[1].width, by + bh],
                        c4: [bx + borders[3].width, by + bh]
                    }, radius[0], radius[1],
                    borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                    break;
                case 1:
                    // right border
                    bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
                    bw = borders[1].width;

                    border.args = drawSide({
                        c1: [bx + bw, by],
                        c2: [bx + bw, by + bh + borders[2].width],
                        c3: [bx, by + bh],
                        c4: [bx, by + borders[0].width]
                    }, radius[1], radius[2],
                    borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                    break;
                case 2:
                    // bottom border
                    by = (by + nodeBounds.height) - (borders[2].width);
                    bh = borders[2].width;
                    border.args = drawSide({
                        c1: [bx + bw, by + bh],
                        c2: [bx, by + bh],
                        c3: [bx + borders[3].width, by],
                        c4: [bx + bw - borders[3].width, by]
                    }, radius[2], radius[3],
                    borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                    break;
                case 3:
                    // left border
                    bw = borders[3].width;
                    border.args = drawSide({
                        c1: [bx, by + bh + borders[2].width],
                        c2: [bx, by],
                        c3: [bx + bw, by + borders[0].width],
                        c4: [bx + bw, by + bh]
                    }, radius[3], radius[0],
                    borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                    break;
                }
            }
            return border;
        })
    };
};

NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
    var backgroundClip = container.css('backgroundClip'),
        borderArgs = [];

    switch(backgroundClip) {
    case "content-box":
    case "padding-box":
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
        break;

    default:
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
        break;
    }

    return borderArgs;
};

function getCurvePoints(x, y, r1, r2) {
    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
    var ox = (r1) * kappa, // control point offset horizontal
        oy = (r2) * kappa, // control point offset vertical
        xm = x + r1, // x-middle
        ym = y + r2; // y-middle
    return {
        topLeft: bezierCurve({x: x, y: ym}, {x: x, y: ym - oy}, {x: xm - ox, y: y}, {x: xm, y: y}),
        topRight: bezierCurve({x: x, y: y}, {x: x + ox,y: y}, {x: xm, y: ym - oy}, {x: xm, y: ym}),
        bottomRight: bezierCurve({x: xm, y: y}, {x: xm, y: y + oy}, {x: x + ox, y: ym}, {x: x, y: ym}),
        bottomLeft: bezierCurve({x: xm, y: ym}, {x: xm - ox, y: ym}, {x: x, y: y + oy}, {x: x, y:y})
    };
}

function calculateCurvePoints(bounds, borderRadius, borders) {
    var x = bounds.left,
        y = bounds.top,
        width = bounds.width,
        height = bounds.height,

        tlh = borderRadius[0][0],
        tlv = borderRadius[0][1],
        trh = borderRadius[1][0],
        trv = borderRadius[1][1],
        brh = borderRadius[2][0],
        brv = borderRadius[2][1],
        blh = borderRadius[3][0],
        blv = borderRadius[3][1];

    var topWidth = width - trh,
        rightHeight = height - brv,
        bottomWidth = width - brh,
        leftHeight = height - blv;

    return {
        topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
        topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
        topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
        topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
        bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
        bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width),  brv - borders[2].width).bottomRight.subdivide(0.5),
        bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
        bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
    };
}

function bezierCurve(start, startControl, endControl, end) {
    var lerp = function (a, b, t) {
        return {
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t
        };
    };

    return {
        start: start,
        startControl: startControl,
        endControl: endControl,
        end: end,
        subdivide: function(t) {
            var ab = lerp(start, startControl, t),
                bc = lerp(startControl, endControl, t),
                cd = lerp(endControl, end, t),
                abbc = lerp(ab, bc, t),
                bccd = lerp(bc, cd, t),
                dest = lerp(abbc, bccd, t);
            return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
        },
        curveTo: function(borderArgs) {
            borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
        },
        curveToReversed: function(borderArgs) {
            borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
        }
    };
}

function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
    var borderArgs = [];

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
        outer1[1].curveTo(borderArgs);
    } else {
        borderArgs.push([ "line", borderData.c1[0], borderData.c1[1]]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
        outer2[0].curveTo(borderArgs);
        borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
        inner2[0].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
        borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
    }

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
        inner1[1].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
    }

    return borderArgs;
}

function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
        corner1[0].curveTo(borderArgs);
        corner1[1].curveTo(borderArgs);
    } else {
        borderArgs.push(["line", x, y]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
    }
}

function negativeZIndex(container) {
    return container.cssInt("zIndex") < 0;
}

function positiveZIndex(container) {
    return container.cssInt("zIndex") > 0;
}

function zIndex0(container) {
    return container.cssInt("zIndex") === 0;
}

function inlineLevel(container) {
    return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function isStackingContext(container) {
    return (container instanceof StackingContext);
}

function hasText(container) {
    return container.node.data.trim().length > 0;
}

function noLetterSpacing(container) {
    return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
}

function getBorderRadiusData(container) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
        var value = container.css('border' + side + 'Radius');
        var arr = value.split(" ");
        if (arr.length <= 1) {
            arr[1] = arr[0];
        }
        return arr.map(asInt);
    });
}

function renderableNode(node) {
    return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
}

function isPositionedForStacking(container) {
    var position = container.css("position");
    var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
    return zIndex !== "auto";
}

function isPositioned(container) {
    return container.css("position") !== "static";
}

function isFloating(container) {
    return container.css("float") !== "none";
}

function isInlineBlock(container) {
    return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function not(callback) {
    var context = this;
    return function() {
        return !callback.apply(context, arguments);
    };
}

function isElement(container) {
    return container.node.nodeType === Node.ELEMENT_NODE;
}

function isPseudoElement(container) {
    return container.isPseudoElement === true;
}

function isTextNode(container) {
    return container.node.nodeType === Node.TEXT_NODE;
}

function zIndexSort(contexts) {
    return function(a, b) {
        return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
    };
}

function hasOpacity(container) {
    return container.getOpacity() < 1;
}

function bind(callback, context) {
    return function() {
        return callback.apply(context, arguments);
    };
}

function asInt(value) {
    return parseInt(value, 10);
}

function getWidth(border) {
    return border.width;
}

function nonIgnoredElement(nodeContainer) {
    return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
}

function flatten(arrays) {
    return [].concat.apply([], arrays);
}

function stripQuotes(content) {
    var first = content.substr(0, 1);
    return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
}

function getWords(characters) {
    var words = [], i = 0, onWordBoundary = false, word;
    while(characters.length) {
        if (isWordBoundary(characters[i]) === onWordBoundary) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(window.html2canvas.punycode.ucs2.encode(word));
            }
            onWordBoundary =! onWordBoundary;
            i = 0;
        } else {
            i++;
        }

        if (i >= characters.length) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(window.html2canvas.punycode.ucs2.encode(word));
            }
        }
    }
    return words;
}

function isWordBoundary(characterCode) {
    return [
        32, // <space>
        13, // \r
        10, // \n
        9, // \t
        45 // -
    ].indexOf(characterCode) !== -1;
}

function hasUnicode(string) {
    return (/[^\u0000-\u00ff]/).test(string);
}

function Proxy(src, proxyUrl, document) {
    var callback = createCallback(supportsCORS);
    var url = createProxyUrl(proxyUrl, src, callback);

    return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
        return decode64(response.content);
    }));
}
var proxyCount = 0;

var supportsCORS = ('withCredentials' in new XMLHttpRequest());
var supportsCORSImage = ('crossOrigin' in new Image());

function ProxyURL(src, proxyUrl, document) {
    var callback = createCallback(supportsCORSImage);
    var url = createProxyUrl(proxyUrl, src, callback);
    return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
        return "data:" + response.type + ";base64," + response.content;
    }));
}

function jsonp(document, url, callback) {
    return new Promise(function(resolve, reject) {
        var s = document.createElement("script");
        var cleanup = function() {
            delete window.html2canvas.proxy[callback];
            document.body.removeChild(s);
        };
        window.html2canvas.proxy[callback] = function(response) {
            cleanup();
            resolve(response);
        };
        s.src = url;
        s.onerror = function(e) {
            cleanup();
            reject(e);
        };
        document.body.appendChild(s);
    });
}

function createCallback(useCORS) {
    return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
}

function createProxyUrl(proxyUrl, src, callback) {
    return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
}

function ProxyImageContainer(src, proxy) {
    var script = document.createElement("script");
    var link = document.createElement("a");
    link.href = src;
    src = link.href;
    this.src = src;
    this.image = new Image();
    var self = this;
    this.promise = new Promise(function(resolve, reject) {
        self.image.crossOrigin = "Anonymous";
        self.image.onload = resolve;
        self.image.onerror = reject;

        new ProxyURL(src, proxy, document).then(function(url) {
            self.image.src = url;
        })['catch'](reject);
    });
}

function PseudoElementContainer(node, parent, type) {
    NodeContainer.call(this, node, parent);
    this.isPseudoElement = true;
    this.before = type === ":before";
}

PseudoElementContainer.prototype.cloneTo = function(stack) {
    PseudoElementContainer.prototype.cloneTo.call(this, stack);
    stack.isPseudoElement = true;
    stack.before = this.before;
};

PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);

PseudoElementContainer.prototype.appendToDOM = function() {
    if (this.before) {
        this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
    } else {
        this.parent.node.appendChild(this.node);
    }
    this.parent.node.className += " " + this.getHideClass();
};

PseudoElementContainer.prototype.cleanDOM = function() {
    this.node.parentNode.removeChild(this.node);
    this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
};

PseudoElementContainer.prototype.getHideClass = function() {
    return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
};

PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

function Renderer(width, height, images, options, document) {
    this.width = width;
    this.height = height;
    this.images = images;
    this.options = options;
    this.document = document;
}

Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
    var paddingLeft = container.cssInt('paddingLeft'),
        paddingTop = container.cssInt('paddingTop'),
        paddingRight = container.cssInt('paddingRight'),
        paddingBottom = container.cssInt('paddingBottom'),
        borders = borderData.borders;

    var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
    var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
    this.drawImage(
        imageContainer,
        0,
        0,
        imageContainer.image.width || width,
        imageContainer.image.height || height,
        bounds.left + paddingLeft + borders[3].width,
        bounds.top + paddingTop + borders[0].width,
        width,
        height
    );
};

Renderer.prototype.renderBackground = function(container, bounds, borderData) {
    if (bounds.height > 0 && bounds.width > 0) {
        this.renderBackgroundColor(container, bounds);
        this.renderBackgroundImage(container, bounds, borderData);
    }
};

Renderer.prototype.renderBackgroundColor = function(container, bounds) {
    var color = container.css("backgroundColor");
    if (!this.isTransparent(color)) {
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, container.css("backgroundColor"));
    }
};

Renderer.prototype.renderBorders = function(borders) {
    borders.forEach(this.renderBorder, this);
};

Renderer.prototype.renderBorder = function(data) {
    if (!this.isTransparent(data.color) && data.args !== null) {
        this.drawShape(data.args, data.color);
    }
};

Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
    var backgroundImages = container.parseBackgroundImages();
    backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
        switch(backgroundImage.method) {
            case "url":
                var image = this.images.get(backgroundImage.args[0]);
                if (image) {
                    this.renderBackgroundRepeating(container, bounds, image, arr.length - (index+1), borderData);
                } else {
                    log("Error loading background-image", backgroundImage.args[0]);
                }
                break;
            case "linear-gradient":
            case "gradient":
                var gradientImage = this.images.get(backgroundImage.value);
                if (gradientImage) {
                    this.renderBackgroundGradient(gradientImage, bounds, borderData);
                } else {
                    log("Error loading background-image", backgroundImage.args[0]);
                }
                break;
            case "none":
                break;
            default:
                log("Unknown background-image type", backgroundImage.args[0]);
        }
    }, this);
};

Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
    var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
    var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
    var repeat = container.parseBackgroundRepeat(index);
    switch (repeat) {
    case "repeat-x":
    case "repeat no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
        break;
    case "repeat-y":
    case "no-repeat repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
        break;
    case "no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
        break;
    default:
        this.renderBackgroundRepeat(imageContainer, position, size, {top: bounds.top, left: bounds.left}, borderData[3], borderData[0]);
        break;
    }
};

Renderer.prototype.isTransparent = function(color) {
    return (!color || color === "transparent" || color === "rgba(0, 0, 0, 0)");
};

function StackingContext(hasOwnStacking, opacity, element, parent) {
    NodeContainer.call(this, element, parent);
    this.ownStacking = hasOwnStacking;
    this.contexts = [];
    this.children = [];
    this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
}

StackingContext.prototype = Object.create(NodeContainer.prototype);

StackingContext.prototype.getParentStack = function(context) {
    var parentStack = (this.parent) ? this.parent.stack : null;
    return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
};

function Support(document) {
    this.rangeBounds = this.testRangeBounds(document);
    this.cors = this.testCORS();
    this.svg = this.testSVG();
}

Support.prototype.testRangeBounds = function(document) {
    var range, testElement, rangeBounds, rangeHeight, support = false;

    if (document.createRange) {
        range = document.createRange();
        if (range.getBoundingClientRect) {
            testElement = document.createElement('boundtest');
            testElement.style.height = "123px";
            testElement.style.display = "block";
            document.body.appendChild(testElement);

            range.selectNode(testElement);
            rangeBounds = range.getBoundingClientRect();
            rangeHeight = rangeBounds.height;

            if (rangeHeight === 123) {
                support = true;
            }
            document.body.removeChild(testElement);
        }
    }

    return support;
};

Support.prototype.testCORS = function() {
    return typeof((new Image()).crossOrigin) !== "undefined";
};

Support.prototype.testSVG = function() {
    var img = new Image();
    var canvas = document.createElement("canvas");
    var ctx =  canvas.getContext("2d");
    img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";

    try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
    } catch(e) {
        return false;
    }
    return true;
};

function SVGContainer(src) {
    this.src = src;
    this.image = null;
    var self = this;

    this.promise = this.hasFabric().then(function() {
        return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
    }).then(function(svg) {
        return new Promise(function(resolve) {
            html2canvas.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
        });
    });
}

SVGContainer.prototype.hasFabric = function() {
    return !html2canvas.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
};

SVGContainer.prototype.inlineFormatting = function(src) {
    return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
};

SVGContainer.prototype.removeContentType = function(src) {
    return src.replace(/^data:image\/svg\+xml(;base64)?,/,'');
};

SVGContainer.prototype.isInline = function(src) {
    return (/^data:image\/svg\+xml/i.test(src));
};

SVGContainer.prototype.createCanvas = function(resolve) {
    var self = this;
    return function (objects, options) {
        var canvas = new html2canvas.fabric.StaticCanvas('c');
        self.image = canvas.lowerCanvasEl;
        canvas
            .setWidth(options.width)
            .setHeight(options.height)
            .add(html2canvas.fabric.util.groupSVGElements(objects, options))
            .renderAll();
        resolve(canvas.lowerCanvasEl);
    };
};

SVGContainer.prototype.decode64 = function(str) {
    return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
};

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function decode64(base64) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var len = base64.length, i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;

    var output = "";

    for (i = 0; i < len; i+=4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i+1]);
        encoded3 = chars.indexOf(base64[i+2]);
        encoded4 = chars.indexOf(base64[i+3]);

        byte1 = (encoded1 << 2) | (encoded2 >> 4);
        byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        byte3 = ((encoded3 & 3) << 6) | encoded4;
        if (encoded3 === 64) {
            output += String.fromCharCode(byte1);
        } else if (encoded4 === 64 || encoded4 === -1) {
            output += String.fromCharCode(byte1, byte2);
        } else{
            output += String.fromCharCode(byte1, byte2, byte3);
        }
    }

    return output;
}

function SVGNodeContainer(node, native) {
    this.src = node;
    this.image = null;
    var self = this;

    this.promise = native ? new Promise(function(resolve, reject) {
        self.image = new Image();
        self.image.onload = resolve;
        self.image.onerror = reject;
        self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
        if (self.image.complete === true) {
            resolve(self.image);
        }
    }) : this.hasFabric().then(function() {
        return new Promise(function(resolve) {
            html2canvas.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
        });
    });
}

SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

function TextContainer(node, parent) {
    NodeContainer.call(this, node, parent);
}

TextContainer.prototype = Object.create(NodeContainer.prototype);

TextContainer.prototype.applyTextTransform = function() {
    this.node.data = this.transform(this.parent.css("textTransform"));
};

TextContainer.prototype.transform = function(transform) {
    var text = this.node.data;
    switch(transform){
        case "lowercase":
            return text.toLowerCase();
        case "capitalize":
            return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
        case "uppercase":
            return text.toUpperCase();
        default:
            return text;
    }
};

function capitalize(m, p1, p2) {
    if (m.length > 0) {
        return p1 + p2.toUpperCase();
    }
}

function WebkitGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = (imageData.args[0] === "linear") ? this.TYPES.LINEAR : this.TYPES.RADIAL;
}

WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

function XHR(url) {
    return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url);

        xhr.onload = function() {
            if (xhr.status === 200) {
                resolve(xhr.responseText);
            } else {
                reject(new Error(xhr.statusText));
            }
        };

        xhr.onerror = function() {
            reject(new Error("Network Error"));
        };

        xhr.send();
    });
}

function CanvasRenderer(width, height) {
    Renderer.apply(this, arguments);
    this.canvas = this.options.canvas || this.document.createElement("canvas");
    if (!this.options.canvas) {
        this.canvas.width = width * this.options.pixelRatio;
        this.canvas.height = height * this.options.pixelRatio;
    }
    this.ctx = this.canvas.getContext("2d");
    if (this.options.background) {
        this.rectangle(0, 0, width, height, this.options.background);
    }
    this.taintCtx = this.document.createElement("canvas").getContext("2d");
    this.ctx.textBaseline = "bottom";
    this.variables = {};
    log("Initialized CanvasRenderer with size", width, "x", height);
}

CanvasRenderer.prototype = Object.create(Renderer.prototype);

CanvasRenderer.prototype.setFillStyle = function(color) {
    this.ctx.fillStyle = color;
    return this.ctx;
};

CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
    this.setFillStyle(color).fillRect(left, top, width, height);
};

CanvasRenderer.prototype.drawShape = function(shape, color) {
    this.shape(shape);
    this.setFillStyle(color).fill();
};

CanvasRenderer.prototype.taints = function(imageContainer) {
    if (imageContainer.tainted === null) {
        this.taintCtx.drawImage(imageContainer.image, 0, 0);
        try {
            this.taintCtx.getImageData(0, 0, 1, 1);
            imageContainer.tainted = false;
        } catch(e) {
            this.taintCtx = document.createElement("canvas").getContext("2d");
            imageContainer.tainted = true;
        }
    }

    return imageContainer.tainted;
};

CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (!this.taints(imageContainer) || this.options.allowTaint) {
        this.ctx.save();
        this.ctx.scale(this.options.pixelRatio, this.options.pixelRatio);
        this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
        this.ctx.restore();
    }
};

CanvasRenderer.prototype.clip = function(shapes, callback, context) {
    this.ctx.save();
    shapes.filter(hasEntries).forEach(function(shape) {
        this.shape(shape).clip();
    }, this);
    callback.call(context);
    this.ctx.restore();
};

CanvasRenderer.prototype.shape = function(shape) {
    this.ctx.save();
    this.ctx.scale(this.options.pixelRatio, this.options.pixelRatio);
    this.ctx.beginPath();
    shape.forEach(function(point, index) {
        if (point[0] === "rect") {
            this.ctx.rect.apply(this.ctx, point.slice(1));
        } else {
            this.ctx[(index === 0) ? "moveTo" : point[0] + "To" ].apply(this.ctx, point.slice(1));
        }
    }, this);
    this.ctx.closePath();
    this.ctx.restore();
    return this.ctx;
};

CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
    this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
};

CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
    this.setVariable("shadowColor", color)
        .setVariable("shadowOffsetY", offsetX)
        .setVariable("shadowOffsetX", offsetY)
        .setVariable("shadowBlur", blur);
};

CanvasRenderer.prototype.clearShadow = function() {
    this.setVariable("shadowColor", "rgba(0,0,0,0)");
};

CanvasRenderer.prototype.setOpacity = function(opacity) {
    this.ctx.globalAlpha = opacity;
};

CanvasRenderer.prototype.setTransform = function(transform) {
    this.ctx.translate(transform.origin[0], transform.origin[1]);
    this.ctx.transform.apply(this.ctx, transform.matrix);
    this.ctx.translate(-transform.origin[0], -transform.origin[1]);
};

CanvasRenderer.prototype.setVariable = function(property, value) {
    if (this.variables[property] !== value) {
        this.variables[property] = this.ctx[property] = value;
    }

    return this;
};

CanvasRenderer.prototype.text = function(text, left, bottom) {
    this.ctx.save();
    this.ctx.scale(this.options.pixelRatio, this.options.pixelRatio);
    this.ctx.fillText(text, left, bottom);
    this.ctx.restore();
};

CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
    var shape = [
        ["line", Math.round(left), Math.round(top)],
        ["line", Math.round(left + width), Math.round(top)],
        ["line", Math.round(left + width), Math.round(height + top)],
        ["line", Math.round(left), Math.round(height + top)]
    ];
    this.clip([shape], function() {
        this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
    }, this);
};

CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
    var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft), offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
    this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
};

CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
    if (gradientImage instanceof LinearGradientContainer) {
        var gradient = this.ctx.createLinearGradient(
            bounds.left + bounds.width * gradientImage.x0,
            bounds.top + bounds.height * gradientImage.y0,
            bounds.left +  bounds.width * gradientImage.x1,
            bounds.top +  bounds.height * gradientImage.y1);
        gradientImage.colorStops.forEach(function(colorStop) {
            gradient.addColorStop(colorStop.stop, colorStop.color);
        });
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
    }
};

CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
    var image = imageContainer.image;
    if(image.width === size.width && image.height === size.height) {
        return image;
    }

    var ctx, canvas = document.createElement('canvas');
    canvas.width = size.width;
    canvas.height = size.height;
    ctx = canvas.getContext("2d");
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height );
    return canvas;
};

function hasEntries(array) {
    return array.length > 0;
}

}).call({}, window, document);

"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function ToolPanelCompClass(_obj) {
  var _modelObj;

  var events = {};
  var modelObj = (_modelObj = {
    x: 21,
    y: 612,
    shapeTopMargin: 15,
    pointRadius: 4,
    visible: true,
    enabled: true,
    selected: "move",
    baseColor: "rgba(255,255,255,1)",
    textSelectedColor: "rgba(73,124,190,1)",
    textColor: "rgba(170,170,166,1)",
    selColor: "rgba(73,124,190,1)",
    lineColor: "rgba(73,124,190,1)",
    circleColor: "rgba(73,124,190,1)",
    disableColor: "rgba(73,124,190,1)",
    redColor: "rgba(255,0,0,1)",
    fontSize: 16,
    maxWidth: 100,
    textPadding: 10,
    trangleW: 8,
    trangleH: 9
  }, _defineProperty(_modelObj, "maxWidth", 375), _defineProperty(_modelObj, "buttons", {
    move: {
      text: "move",
      info: "moveInfo",
      maxWidth: 375
    },
    point: {
      text: "point",
      maxWidth: 375
    },
    segment: {
      text: "segment",
      maxWidth: 375
    },
    segmentDash: {
      text: "segment",
      maxWidth: 375
    },
    segSize: {
      text: "angleSize",
      maxWidth: 375
    },
    ray: {
      text: "ray",
      maxWidth: 375
    },
    line: {
      text: "line",
      maxWidth: 375
    },
    angleRay: {
      text: "angleRay",
      maxWidth: 375
    },
    angle: {
      text: "angle",
      maxWidth: 375
    },
    triangle: {
      text: "triangle",
      maxWidth: 375
    },
    parallelLine: {
      text: "parallelLine",
      maxWidth: 375
    },
    perpendicularLine: {
      text: "perpendicularLine",
      maxWidth: 375
    },
    midPoint: {
      text: "length",
      maxWidth: 375
    },
    circle: {
      text: "circle",
      maxWidth: 375
    },
    circleSize: {
      text: "circleSize",
      maxWidth: 375
    },
    compass: {
      text: "compass",
      maxWidth: 375
    },
    circle_3: {
      text: "circle_3",
      maxWidth: 375
    },
    length: {
      text: "length",
      maxWidth: 375
    },
    angleB: {
      text: "length",
      maxWidth: 375
    },
    perpendicularBisector: {
      text: "length",
      maxWidth: 375
    },
    angleSize: {
      text: "angleSize",
      maxWidth: 375
    },
    brush1: {
      text: "brush1",
      color: "rgba(10,190,220,1)",
      maxWidth: 375
    },
    brush2: {
      text: "brush2",
      color: "rgba(222,108,225,1)",
      maxWidth: 375
    },
    brush3: {
      text: "brush3",
      color: "rgba(255,204,0,1)",
      maxWidth: 375
    },
    mirrorOnLine: {
      text: "mirrorOnLine",
      maxWidth: 375
    },
    square: {
      text: "mirrorOnLine",
      maxWidth: 375
    },
    select: {
      text: "select",
      maxWidth: 375
    }
  }), _modelObj);
  var localObj = {
    isPressed: false,
    isHover: false,
    padding: 20,
    hoverOn: null
  };

  var _this = this;

  setDefaults();
  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === "object" && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === "object" && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  } // --------------------


  modelObj.fontFamily = modelObj.LabComClass.polo22KlettRegular;
  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: modelObj.id
    }
  }); // --------------------

  createDOM();
  calculatePos(); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.getVisible = function () {
    return modelObj.visible;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
    removeAllEvents();
  };

  this.setFocus = function () {
    document.getElementById("btn-".concat(modelObj.selected)).focus();
  };

  this.getSize = function () {
    return {
      width: modelObj.width,
      height: modelObj.height
    };
  }; // =================================================


  this.enable = function () {
    modelObj.enabled = true;
    addEvents();
  };

  this.reset = function () {
    modelObj.selected = "move";
    colorSelectedTool("move");

    _this.enable();
  };

  this.disable = function () {
    modelObj.enabled = false;
    removeAllEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  };

  this.setPos = function (_obj) {
    updateValues(_obj, "x", "y");
    addEvents();
  };

  function updateValues(_data) {
    for (var _len = arguments.length, key = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      key[_key - 1] = arguments[_key];
    }

    key.forEach(function (i) {
      if (_data[i] !== undefined) {
        modelObj[i] = _data[i];
      }
    });
  } // =================================================


  this.getEnabled = function () {
    return modelObj.enabled;
  }; // =================================================


  this.setSelected = function (_bool) {
    modelObj.selected = _bool;
    colorSelectedTool(_bool);
  }; // =================================================


  this.getSelected = function () {
    return modelObj.selected;
  }; // =================================================


  this.draws = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;

      _ctx.save();

      Object.keys(modelObj.buttons).forEach(function (i) {
        if (modelObj.buttons[i].visible) {
          drawTool(_ctx, modelObj.buttons[i]);

          if (modelObj.buttons[i].base && modelObj.buttons[i].type === localObj.hoverOn) {
            drawToolTip(modelObj.buttons[i]);
          }
        }
      });

      _ctx.restore();
    }
  };

  function colorSelectedTool(_tool) {
    document.querySelectorAll(".toolPanelButton").forEach(function (_btn) {
      _btn.style.color = modelObj.textColor;
    });
    document.getElementById("btn-".concat(_tool)).style.color = modelObj.textSelectedColor;
  }

  function drawToolTip(_obj) {
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.textBaseline = "bottom"; // base

    roundRectToolTip({
      ctx: _ctx,
      x: _obj.base.x,
      y: _obj.base.y,
      percent: _obj.base.percent,
      width: _obj.base.width + modelObj.textPadding * 2,
      height: _obj.base.height + _obj.base.textHead.height + modelObj.textPadding * 2,
      radius: 0,
      fill: true,
      stroke: true
    }); // text

    _ctx.save();

    _ctx.translate(_obj.base.x, _obj.base.y);

    _ctx.beginPath();

    _ctx.fillStyle = modelObj.fontColor;

    _ctx.drawImage(_obj.base.textHead.text, modelObj.textPadding, modelObj.textPadding, _obj.base.textHead.width, _obj.base.textHead.height);

    _ctx.drawImage(_obj.base.textImg, modelObj.textPadding, modelObj.textPadding + _obj.base.textHead.height, _obj.base.width, _obj.base.height);

    _ctx.closePath();

    _ctx.restore();

    _ctx.restore();
  } // This function will generate text image and set positions.


  function toolTipBase(_obj) {
    var textctx;
    var textHead;
    textctx = modelObj.context.textWrapperClass({
      xNum: 0,
      yNum: 0,
      maxWidthNum: _obj.maxWidth - modelObj.textPadding * 2,
      textStr: _obj.info,
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: 16,
      color: "rgba(142,142,142,1)",
      align: "left",
      fontFormat: "px "
    });
    textctx.text = textctx.imageObj.imageObj;
    textctx.width = textctx.imageObj.widthInt;
    textctx.height = textctx.imageObj.heightInt;
    textHead = modelObj.context.textWrapperClass({
      xNum: 0,
      yNum: 0,
      maxWidthNum: _obj.maxWidth - modelObj.textPadding * 2,
      textStr: "§b" + (_obj.headText ? _obj.headText : _obj.text) + "§r",
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: 17,
      color: "rgba(130,130,130,1)",
      align: "left",
      fontFormat: "px "
    });
    textHead.text = textHead.imageObj.imageObj;
    textHead.width = textHead.imageObj.widthInt;
    textHead.height = textHead.imageObj.heightInt;
    _obj.base = getPosition(textctx, textHead, _obj);
    _obj.base.textHead = textHead;
  } // This funcction will calculate position respect to text size and position type


  function getPosition(textctx, textHead, _obj) {
    var x = _obj.x + _obj.width / 2,
        y = _obj.y + 1;
    var factor = 50 / 100;
    var w = textctx.width + modelObj.textPadding * 2;
    x -= w * factor;
    y -= textctx.height + modelObj.textPadding * 2 + modelObj.trangleH + textHead.height;

    if (x < modelObj.x) {
      x = modelObj.x;
    } // if ((modelObj.x + w * 0.9) > _obj.x) {
    //   x = modelObj.x;
    // }


    return {
      x: x,
      y: y,
      percent: (_obj.x + _obj.width / 2 - x) / w * 100,
      width: textctx.width,
      height: textctx.height,
      textImg: textctx.text
    };
  }

  function roundRectToolTip(_obj) {
    var ctx = _obj.ctx,
        x = _obj.x,
        y = _obj.y,
        width = _obj.width,
        height = _obj.height,
        fill = _obj.fill,
        _obj$stroke = _obj.stroke,
        stroke = _obj$stroke === void 0 ? true : _obj$stroke,
        drawUpperCorners = _obj.drawUpperCorners,
        drawLowerCorners = _obj.drawLowerCorners;
    var radius = _obj.radius;
    var percent = _obj.percent / 100;
    ctx.fillStyle = "rgba(255, 255, 255, 1)";
    ctx.strokeStyle = "rgba(142, 142, 142, 1)";

    if (typeof radius === "undefined") {
      radius = 5;
    }

    if (typeof radius === "number") {
      if (drawUpperCorners) {
        radius = {
          tl: radius,
          tr: radius,
          br: 0,
          bl: 0
        };
      } else if (drawLowerCorners) {
        radius = {
          tl: 0,
          tr: 0,
          br: radius,
          bl: radius
        };
      } else {
        radius = {
          tl: radius,
          tr: radius,
          br: radius,
          bl: radius
        };
      }
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + (width - radius.tr), y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + height - radius.tr);
    ctx.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
    ctx.lineTo(x + width * percent + modelObj.trangleW, y + height);
    ctx.lineTo(x + width * percent, y + height + modelObj.trangleH);
    ctx.lineTo(x + width * percent - modelObj.trangleW, y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);

    if (fill) {
      ctx.fill();
    }

    if (stroke) {
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.closePath();
  }

  function drawTool(ctx, _obj) {
    var x = _obj.x,
        y = _obj.y,
        width = _obj.width,
        height = _obj.height;
    var r = modelObj.pointRadius;
    var maxR = r * 2.5;
    var w = 16;
    var trangleW = 5;
    var trangleH = 7;
    ctx.save();
    ctx.beginPath();

    if (!modelObj.enabled) {
      ctx.globalAlpha = 0.5;
    } // ctx.rect(x, y, width, height);
    // ctx.stroke();


    switch (_obj.type) {
      case "move":
        ctx.translate(x + width / 2 - 4, y + modelObj.shapeTopMargin / 2);
        ctx.rotate(65 * Math.PI / 180);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(10, -5);
        ctx.lineTo(10, -1);
        ctx.lineTo(15, -1);
        ctx.lineTo(15, 1);
        ctx.lineTo(10, 1);
        ctx.lineTo(10, 5);
        ctx.lineTo(0, 0);
        ctx.stroke();
        ctx.closePath();
        break;

      case "point":
        drawPoint({
          ctx: ctx,
          x: x + width / 2,
          y: y + modelObj.shapeTopMargin
        });
        break;

      case "circle":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        drawPoint({
          ctx: ctx
        });
        drawPoint({
          ctx: ctx,
          r: r * 3,
          fill: false,
          stroke: true
        });
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        break;

      case "circleSize":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(0, 0);
        ctx.lineTo(r * 3, -3);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx
        });
        drawPoint({
          ctx: ctx,
          r: r * 3,
          fill: false,
          stroke: true
        });
        break;

      case "compass":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        drawPoint({
          ctx: ctx,
          r: r * 0.7,
          x: -2,
          y: -8
        });
        ctx.closePath();
        ctx.beginPath();
        ctx.moveTo(-2, -8);
        ctx.lineTo(0, 12);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.moveTo(-2, -8);
        ctx.lineTo(-12, 12);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath(); // ctx.ellipse(0, 12, 4, 12, Math.PI/2, 0, 2 * Math.PI);

        drawEllipse(ctx, 0, 12, 12, 4, 50);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.arc(-2, -8, r * 2, 1.47, 1.97, false);
        ctx.stroke();
        ctx.closePath();
        break;

      case "circle_3":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        drawPoint({
          ctx: ctx,
          r: r * 3,
          fill: false,
          stroke: true
        });
        ctx.closePath(); // eslint-disable-next-line no-case-declarations

        var fixedAngle = 45 * Math.PI / 180;
        ctx.save();
        ctx.rotate(1 / 3 * (Math.PI * 2) - fixedAngle);
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        ctx.restore();
        ctx.save();
        ctx.rotate(2 / 3 * (Math.PI * 2) - fixedAngle);
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        ctx.restore();
        ctx.save();
        ctx.rotate(3 / 3 * (Math.PI * 2) - fixedAngle);
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        ctx.restore();
        break;

      case "midPoint":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        drawPoint({
          ctx: ctx,
          fillColor: modelObj.redColor
        });
        drawPoint({
          ctx: ctx,
          x: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case "triangle":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(0, -10);
        ctx.lineTo(-10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(0, -10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, 10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          y: -10
        });
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 10
        });
        drawPoint({
          ctx: ctx,
          x: 10,
          y: 10
        });
        break;

      case "square":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, -10);
        ctx.lineTo(-10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, -10);
        ctx.lineTo(10, -10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, 10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(10, -10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10,
          y: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10,
          y: -10
        });
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 10
        });
        drawPoint({
          ctx: ctx,
          x: 10,
          y: 10
        });
        break;

      case "segment":
      case "segmentDash":
      case "segSize":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;

        if (_obj.type === "segmentDash") {
          ctx.setLineDash([4, 2]);
        }

        if (_obj.type === "segSize") {
          ctx.font = modelObj.fontSize + "px " + modelObj.fontFamily;
          ctx.save();
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = modelObj.textColor;
          ctx.rotate(-2.6);
          ctx.drawStyledText("a", -8, modelObj.fontSize * 0.2, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
          ctx.restore();
        }

        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10 // fillColor:_obj.type === 'segSize'?'red':modelObj.circleColor,

        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case "line":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-20, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case "mirrorOnLine":
      case "line":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath();
        ctx.rotate(2.3 + Math.PI / 2);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-15, 0);
        ctx.lineTo(15, 0);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
        drawPoint({
          ctx: ctx,
          x: -5,
          y: 7,
          r: 3
        });
        drawPoint({
          ctx: ctx,
          x: 5,
          y: -7,
          r: 3
        });
        break;

      case "angleRay":
        r *= 0.6;
        ctx.translate(x + width * 0.4, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.rotate(-0.58);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 12,
          r: r
        });
        ctx.restore();
        ctx.save();
        ctx.rotate(0.58);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 12,
          r: r
        });
        ctx.restore();
        drawPoint({
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          r: r * 2.2,
          startAngle: -0.58,
          endAngle: 0.58,
          fill: false,
          stroke: true
        });
        break;

      case "angle":
        r *= 0.6;
        ctx.translate(x + width * 0.4, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath();
        ctx.rotate(-0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.rotate(0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        drawPoint({
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          r: r * 3.2,
          startAngle: -0.58,
          endAngle: 0.58,
          fillColor: "rgba(112,146,190,0.5)",
          fill: true,
          stroke: true
        });
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = modelObj.textColor;

        if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
          ctx.fillStyle = modelObj.textSelectedColor;
        }

        ctx.font = modelObj.fontSize + "px " + modelObj.fontFamily;
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.drawStyledText("α", 12, modelObj.fontSize * 0.5, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
        ctx.closePath();
        ctx.restore();
        break;

      case "angleB":
        r *= 0.6;
        ctx.translate(x + width * 0.4, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath();
        ctx.rotate(-0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.rotate(0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        drawPoint({
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          r: r * 3.2,
          startAngle: -0.58,
          endAngle: 0.58,
          fillColor: "rgba(112,146,190,0.5)",
          fill: true,
          stroke: true
        });
        ctx.save();
        ctx.beginPath(); // ctx.rotate(0.58);

        ctx.strokeStyle = "rgba(255,0,0,1)";
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = modelObj.textColor;

        if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
          ctx.fillStyle = modelObj.textSelectedColor;
        }

        ctx.font = modelObj.fontSize + "px " + modelObj.fontFamily;
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.closePath();
        ctx.restore();
        break;

      case "perpendicularLine":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin - 3);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.moveTo(0, -6);
        ctx.lineTo(0, 13);
        ctx.stroke();
        ctx.closePath(); //Quarter Circle.

        drawPoint({
          ctx: ctx,
          r: 5.7,
          fill: false,
          stroke: true,
          startAngle: 0,
          endAngle: Math.PI / 2
        }); //Point inside.

        drawPoint({
          ctx: ctx,
          x: 2.2,
          y: 2.2,
          r: 0.7,
          fill: true
        });
        break;

      case "perpendicularBisector":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.rotate(2.6 + Math.PI / 2);
        ctx.strokeStyle = "rgba(255,0,0,1)";
        ctx.lineWidth = 1;
        ctx.moveTo(-15, 0);
        ctx.lineTo(15, 0);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
        break;

      case "parallelLine":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-15, -3);
        ctx.lineTo(15, -3);
        ctx.stroke();
        ctx.moveTo(-15, 3);
        ctx.lineTo(15, 3);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 4,
          y: -3
        });
        break;

      case "brush1":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        drawBrush(ctx, modelObj.buttons.brush1.color);
        break;

      case "brush2":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        drawBrush(ctx, modelObj.buttons.brush2.color);
        break;

      case "brush3":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        drawBrush(ctx, modelObj.buttons.brush3.color);
        break;

      case "select":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);
        ctx.rect(-w / 2, -w / 2, w, w);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        drawArrow(ctx, 8, 8, 11, 15, 8, -135 * Math.PI / 180);
        ctx.closePath();
        break;

      case "ray":
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-20, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case "angleSize":
        r *= 0.6;
        ctx.translate(x + width * 0.4, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath(); // ctx.rotate(0.58);

        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 12);
        ctx.lineTo(20, 12);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 12,
          r: r
        });
        ctx.restore();
        drawPoint({
          x: 5,
          y: -8,
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 12,
          r: r * 3.2,
          startAngle: -0.99,
          endAngle: 0,
          fillColor: "rgba(112,146,190,0.5)",
          fill: true,
          stroke: true
        });
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = modelObj.textColor;

        if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
          ctx.fillStyle = modelObj.textSelectedColor;
        }

        ctx.font = modelObj.fontSize + "px " + modelObj.fontFamily;
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.drawStyledText("α", 3, modelObj.fontSize * 0.75, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
        ctx.closePath();
        ctx.restore();
        break;

      case "length":
        ctx.save();
        ctx.translate(x + width / 2, y + modelObj.shapeTopMargin);
        ctx.rotate(45 * Math.PI / 180);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor; // ctx.arc(0,0,5,0,3.14);
        // ctx.lineWidth = 1;

        ctx.moveTo(-12, -5);
        ctx.lineTo(12, -5);
        ctx.lineTo(12, 5);
        ctx.lineTo(-12, 5);
        ctx.lineTo(-12, -5);
        ctx.stroke();
        ctx.closePath();

        for (var i = -3; i <= 4; i++) {
          if (i % 2 !== 0) {
            ctx.beginPath();
            ctx.strokeStyle = modelObj.lineColor;
            ctx.lineWidth = 1;
            ctx.moveTo(3 * i, -5);
            ctx.lineTo(3 * i, -2);
            ctx.stroke();
            ctx.closePath();
          } else if (i % 2 === 0) {
            ctx.beginPath();
            ctx.strokeStyle = modelObj.lineColor;
            ctx.lineWidth = 1;
            ctx.moveTo(3 * i, -5);
            ctx.lineTo(3 * i, 0);
            ctx.stroke();
            ctx.closePath();
          }
        }

        ctx.restore();
        break;

      default:
    }

    ctx.closePath();
    ctx.restore();
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = modelObj.textColor;
    var _str = "";
    var isBold = false;

    if (modelObj.enabled && (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type)) {
      ctx.fillStyle = modelObj.textSelectedColor;
      isBold = true;
    }

    _str += isBold ? "bold " : "";
    ctx.font = _str + modelObj.fontSize + "px " + modelObj.fontFamily;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.drawStyledText(_obj.text, x + width / 2, y + height, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
    ctx.closePath();
    ctx.restore();
  }

  var drawEllipse = function drawEllipse(ctx, cx, cy, w, h, pointCount) {
    var i = 0,
        x,
        y,
        r;
    pointCount = pointCount || 100, ctx.beginPath();
    ctx.lineWidth = 0.5;

    while (i < pointCount) {
      r = Math.PI * 2 * (i / pointCount);
      x = cx + Math.cos(r) * w;
      y = cy + Math.sin(r) * h;
      ctx.lineTo(x, y);
      i += 1;
    }

    ctx.closePath();
    ctx.stroke();
  };

  function drawBrush(ctx, color) {
    ctx.rotate(2.4);
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.moveTo(4.5, 3);
    ctx.lineTo(4.5, -3);
    ctx.lineTo(6, -4);
    ctx.lineTo(9, -4);
    ctx.lineTo(15, 3);
    ctx.lineTo(12, 3);
    ctx.lineTo(9, 5);
    ctx.lineTo(4.5, 3);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.strokeStyle = modelObj.lineColor;
    ctx.lineWidth = 1;
    ctx.moveTo(-15, -3);
    ctx.lineTo(4, -3);
    ctx.stroke();
    ctx.moveTo(4, 3);
    ctx.lineTo(4, -3);
    ctx.stroke();
    ctx.moveTo(-15, 3);
    ctx.lineTo(4, 3);
    ctx.stroke();
    ctx.closePath();
    ctx.beginPath();
    ctx.strokeStyle = modelObj.lineColor;
    ctx.lineWidth = 1;
    ctx.moveTo(4, 3);
    ctx.bezierCurveTo(10, 10, 12, 1, 18, 4);
    ctx.stroke();
    ctx.moveTo(4, -3);
    ctx.bezierCurveTo(10, -8, 12, 1, 18, 4);
    ctx.stroke();
    ctx.closePath();
  }

  function drawArrow(ctx, x, y, lineW, tw, th) {
    var angle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.moveTo(0, 0);
    ctx.lineTo(lineW, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(lineW, 0);
    ctx.lineTo(lineW - tw / 2, -th / 2);
    ctx.lineTo(lineW - tw / 2, th / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.closePath();
  }

  function drawPoint(_ref) {
    var ctx = _ref.ctx,
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$r = _ref.r,
        r = _ref$r === void 0 ? modelObj.pointRadius : _ref$r,
        _ref$fill = _ref.fill,
        fill = _ref$fill === void 0 ? true : _ref$fill,
        _ref$stroke = _ref.stroke,
        stroke = _ref$stroke === void 0 ? false : _ref$stroke,
        _ref$fillColor = _ref.fillColor,
        fillColor = _ref$fillColor === void 0 ? modelObj.circleColor : _ref$fillColor,
        _ref$startAngle = _ref.startAngle,
        startAngle = _ref$startAngle === void 0 ? 0 : _ref$startAngle,
        _ref$endAngle = _ref.endAngle,
        endAngle = _ref$endAngle === void 0 ? 2 * Math.PI : _ref$endAngle;
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = modelObj.circleColor; // ctx.moveTo(x, y);

    ctx.arc(x, y, r, startAngle, endAngle);

    if (fill) {
      ctx.fill();
    }

    if (stroke) {
      ctx.stroke();
    }

    ctx.closePath();
  } // =================================================
  // =================================================


  function setDefaults() {
    var data = modelObj.buttons;
    Object.keys(data).forEach(function (i) {
      data[i].type = i;
      data[i].visible = false;
      data[i].enable = true;
      data[i].height = 49;

      if (i === "move") {
        data[i].visible = true;
      }
    });
  } // Manipulating DOM


  function createDOM() {
    var data = modelObj.buttons;
    var _wrapper = document.querySelectorAll(".toolPanelWrapper")[0];
    _wrapper.style.left = "".concat(modelObj.x, "px");

    var _mainToolTipWrapper = document.createElement("div");

    _mainToolTipWrapper.className = "mainToolTipWrapper";
    Object.keys(data).forEach(function (i) {
      if (data[i].visible) {
        var _data$i;

        //Extracting Text
        data[i].text = findGlobalText(data[i].text);

        if (data[i].headText) {
          data[i].headText = findGlobalText(data[i].headText);
        }

        if (data[i].ariaLabel) {
          data[i].ariaLabelText = findGlobalText(data[i].ariaLabel);
        }

        data[i].info = findGlobalText(data[i].info); // Button wrapper includes the tooltip and button.

        var _btnWrapper = document.createElement("div");

        _btnWrapper.className = "toolPanelButtonWrapper";

        _btnWrapper.setAttribute("id", "btnWrapper-".concat(i));

        _wrapper.appendChild(_btnWrapper); //Tooltip wrapper includes arrow and tooltip content


        var _toolTipWrapper = document.createElement("div");

        _toolTipWrapper.setAttribute("id", "toolTipWrapper-".concat(i));

        _toolTipWrapper.className = "toolTipWrapper";
        _toolTipWrapper.style.color = modelObj.textColor;
        _toolTipWrapper.style.width = "".concat(modelObj.maxWidth, "px");

        _btnWrapper.appendChild(_toolTipWrapper); //Extra Arrow For Border - Grey Color


        var _toolTipArrowBorder = document.createElement("div");

        _toolTipArrowBorder.setAttribute("id", "toolTipArrowBorder-".concat(i));

        _toolTipArrowBorder.className = "toolTipArrowBorder";

        _toolTipWrapper.appendChild(_toolTipArrowBorder); //Arrow - White Color


        var _toolTipArrow = document.createElement("div");

        _toolTipArrow.setAttribute("id", "toolTipArrow-".concat(i));

        _toolTipArrow.className = "toolTipArrow";

        _toolTipWrapper.appendChild(_toolTipArrow); //Tooltip content


        var _toolTipDiv = document.createElement("div");

        _toolTipDiv.setAttribute("id", "toolTipContent-".concat(i));

        _toolTipDiv.className = "toolTipContent";

        _toolTipWrapper.appendChild(_toolTipDiv);

        _toolTipDiv.innerHTML = "<p style ='padding-bottom: 10px;'><b>".concat(data[i].headText ? data[i].headText : data[i].text, "</b></p><p>").concat(data[i].info, "</p>"); // Button

        var _button = document.createElement("button");

        _button.className = "toolPanelButton";

        _button.setAttribute("id", "btn-".concat(i));

        _button.style.color = i === modelObj.selected ? modelObj.textSelectedColor : modelObj.textColor;
        _button.innerHTML = "<img class =\"toolImage\" src=\"assets/images/".concat(i, ".svg\"></img><div>").concat(data[i].text, "</div>");
        var text = data[i].headText ? data[i].headText : data[i].text;
        text = "".concat(text, " ").concat(data[i].info);

        _button.setAttribute("aria-label", ((_data$i = data[i]) === null || _data$i === void 0 ? void 0 : _data$i.ariaLabelText) || text);

        _btnWrapper.appendChild(_button);
      }
    });
    addEvents();
  }

  function onToolClick(e) {
    var _selected = this.id.split("-")[1];
    colorSelectedTool(_selected);
    modelObj.selected = _selected;

    if (typeof events.click !== "undefined") {
      events.click({
        id: modelObj.id,
        type: "click"
      });
    }
  }

  function calculatePos() {
    var x = modelObj.x;
    var data = modelObj.buttons;
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.font = modelObj.fontSize + "px " + modelObj.fontFamily;
    Object.keys(data).forEach(function (i) {
      if (data[i].visible) {
        data[i].x = x;
        data[i].y = modelObj.y;
        data[i].text = findGlobalText(data[i].text);

        if (data[i].headText) {
          data[i].headText = findGlobalText(data[i].headText);
        }

        data[i].info = findGlobalText(data[i].info);

        if (data[i].unitText) {
          data[i].unitText = findGlobalText(data[i].unitText);
        }

        data[i].width = _ctx.measureText(data[i].text).width;
        x += data[i].width + localObj.padding;
        toolTipBase(data[i]);
      }
    });

    _ctx.restore();

    addEvents();
  }

  function findGlobalText(text) {
    if (modelObj.LabComClass.globalLangText[text]) {
      return modelObj.LabComClass.globalLangText[text];
    }

    return "---";
  }

  function removeAllEvents() {
    var data = modelObj.buttons; // All events are removed, button is disabled and tab indexing is set to -1.

    Object.keys(data).forEach(function (i) {
      if (data[i].visible) {
        var _button = document.getElementById("btn-".concat(i));

        _button.classList.add("disabled");

        _button.setAttribute("tabIndex", -1);

        _button.setAttribute("disabled", true);

        _button.removeEventListener("click", onToolClick);

        _button.removeEventListener("mouseover", onToolMouseOver);

        _button.removeEventListener("mouseout", onToolMouseOut);
      }
    });
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "updateTrapFocus",
      data: {
        id: modelObj.id,
        element: "document.body"
      }
    });
  }

  function addEvents() {
    // All events are added, button is enabled and tab indexing is set to 0.
    var data = modelObj.buttons;

    if (modelObj.enabled && modelObj.visible) {
      Object.keys(data).forEach(function (i) {
        if (data[i].visible) {
          var _button = document.getElementById("btn-".concat(i));

          _button.classList.remove("disabled");

          _button.setAttribute("tabIndex", 0);

          _button.removeAttribute("disabled");

          _button.addEventListener("click", onToolClick);

          _button.addEventListener("mouseover", onToolMouseOver);

          _button.addEventListener("mouseout", onToolMouseOut);
        }
      });
    }

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "updateTrapFocus",
      data: {
        id: modelObj.id,
        element: "document.body"
      }
    });
  } // =================================================


  function onToolMouseOver(e) {
    // Pop up is shown on mouseover.
    this.style.color = modelObj.textSelectedColor;
    var _tool = this.id.split("-")[1];
    document.querySelectorAll(".toolTipWrapper").forEach(function (_tt, i) {
      _tt.style.display = "none";
    });

    var _toolTipWrapper = document.getElementById("toolTipWrapper-".concat(_tool));

    _toolTipWrapper.style.display = "block";

    var _toolTipArrow = document.getElementById("toolTipArrow-".concat(_tool));

    var _toolTipArrowBorder = document.getElementById("toolTipArrowBorder-".concat(_tool));

    var _btnWidth = this.getBoundingClientRect().width;
    var _btnOff = this.offsetLeft; // Checks if the starting position of tooltip wrapper is less than the default 'x'

    if (_btnOff + _btnWidth / 2 - modelObj.maxWidth / 2 < modelObj.x) {
      _toolTipWrapper.style.left = "0px"; // tooltip is set to left 0px

      _toolTipArrow.style.left = "".concat(_btnOff + _btnWidth / 2, "px");
      _toolTipArrowBorder.style.left = "".concat(_btnOff + _btnWidth / 2, "px");
    } // Checks if the starting position of tooltip wrapper is greater than the default 'x'
    else {
        _toolTipWrapper.style.left = "".concat(_btnOff + _btnWidth / 2 - modelObj.maxWidth / 2, "px");
        _toolTipArrow.style.left = "".concat(modelObj.maxWidth / 2, "px");
        _toolTipArrowBorder.style.left = "".concat(modelObj.maxWidth / 2, "px");
      }
  }

  function onToolMouseOut(e) {
    var _tool = this.id.split("-")[1];

    if (_tool !== modelObj.selected) {
      this.style.color = modelObj.textColor;
    }

    document.getElementById("toolTipWrapper-".concat(_tool)).style.display = "none";
  } // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case "mousedown":
        localObj.isPressed = true;
        localObj.hoverOn = e.subId;
        break;

      case "mouseenter":
        localObj.isHover = true;
        localObj.isPressed = false;
        localObj.hoverOn = e.subId;
        break;

      case "mouseout":
      case "mouseupout":
        localObj.isHover = false;
        localObj.isPressed = false;
        localObj.hoverOn = null;
        break;

      case "mouseup":
        modelObj.selected = e.subId;

        if (typeof events.click !== "undefined") {
          events.click({
            id: modelObj.id,
            type: "click"
          });
        }

        localObj.isPressed = false;
        localObj.hoverOn = null;
        break;

      default:
        break;
    }
  }
}
"use strict";

function ContainerCompClass(_obj) {
  var events = {};
  var modelObj = {
    x: 0,
    y: 0,
    width: 326,
    height: 177,
    dragMinX: 0,
    dragMinY: 0,
    dragMaxX: 1280,
    dragMaxY: 720,
    visible: true,
    enable: true,
    headText: "",
    padding: 16,
    fontSize: 16,
    fontColor: "rgba(0,0,0,1)",
    bgColor: "rgba(112,146,190,0.5)"
  };
  var isContainerPressed = false;
  var localObj = {
    headLine: null,
    mouseEventData: {
      mouseMove: false,
      diffX: 0,
      diffY: 0
    }
  };
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });
  createDOM();
  createHeadLine();
  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: modelObj.id
    }
  });

  function createDOM() {
    var mainWrapper = document.getElementById("mainWrapper");

    var _containerWrapper = document.createElement("div");

    _containerWrapper.className = "containerWrapper";

    _containerWrapper.setAttribute("id", "containerWrapper_" + modelObj.id);

    mainWrapper.append(_containerWrapper);
    _containerWrapper.style.left = "".concat(modelObj.x, "px");
    _containerWrapper.style.top = "".concat(modelObj.y, "px");
    _containerWrapper.style.width = "".concat(modelObj.width, "px");
    _containerWrapper.style.height = "".concat(modelObj.height, "px");
    _containerWrapper.style.backgroundColor = modelObj.bgColor;
    _containerWrapper.style.display = modelObj.visible ? "" : "none";
  } // =================================================
  // PUBLIC SECTION
  // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  };

  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;

    var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

    _container.style.left = "".concat(modelObj.x, "px");
    _container.style.top = "".concat(modelObj.y, "px");
    addEvents();
  };

  this.setText = function (_text) {
    modelObj.headText = _text;
    var headTextDiv = document.getElementById("containerHeadText_".concat(modelObj.id));
    headTextDiv.innerHTML = _text;
    createTextWrapper();
    addEvents();
  };

  this.getPos = function () {
    var data = {
      x: modelObj.x + modelObj.padding,
      y: modelObj.y + modelObj.padding
    };

    if (localObj.headLine !== null) {
      data.bodyX = modelObj.x + modelObj.padding;
      data.bodyY = modelObj.y + modelObj.padding * 2 + localObj.headLine.imageObj.heightInt;
    } else {
      data.bodyX = modelObj.x + modelObj.padding;
      data.bodyY = modelObj.y + modelObj.padding;
    }

    return data;
  };

  this.setHeight = function (_val) {
    modelObj.height = _val;

    var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

    if (_container && _container.style) {
      _container.style.height = "".concat(modelObj.height, "px");
    }
  };

  this.show = function () {
    var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

    modelObj.visible = true;

    if (_container && _container.style) {
      _container.style.display = "";
    }

    addEvents();
  };

  this.hide = function () {
    var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

    modelObj.visible = false;
    _container.style.display = "none";

    if (_container && _container.style) {
      _container.style.display = "none";
    }

    addEvents();
  };

  this.enable = function () {
    var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

    modelObj.enable = true;

    if (_container && _container.style) {
      _container.style.pointerEvents = "none";
      _container.style.cursor = "default";
    }

    addEvents();
  };

  this.disable = function () {
    var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

    modelObj.enable = false;
    _container.style.pointerEvents = "";
    _container.style.cursor = "grab";
    addEvents();
  };

  this.draws = function () {
    var _ctx = modelObj.context;

    if (modelObj.visible) {
      _ctx.save();

      _ctx.lineWidth = 1;

      _ctx.beginPath();

      _ctx.strokeStyle = "rgba(255,255,255,1)";
      _ctx.fillStyle = modelObj.bgColor;

      _ctx.rect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

      _ctx.fill();

      _ctx.stroke();

      _ctx.closePath();

      if (localObj.headLine !== null) {
        _ctx.beginPath();

        _ctx.fillStyle = modelObj.fontColor;
        _ctx.textBaseline = "middle";

        _ctx.drawImage(localObj.headLine.imageObj.imageObj, modelObj.x + modelObj.padding, modelObj.y + modelObj.padding, localObj.headLine.imageObj.widthInt, localObj.headLine.imageObj.heightInt);

        _ctx.closePath();
      }

      _ctx.restore();
    }
  }; // =================================================
  // PRIVATE SECTION
  // ================================================


  function removeMouseEvents() {
    // DOM
    if (modelObj.visible) {
      var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

      if (modelObj.enable) {
        _container === null || _container === void 0 ? void 0 : _container.addEventListener("mousedown", mouseHandleDOM); // for moving the alert box

        _container === null || _container === void 0 ? void 0 : _container.addEventListener("mouseup", mouseHandleDOM); // for moving the alert box

        document.addEventListener("mousemove", mouseHandleDOM); // for moving the alert box throughout document

        document.addEventListener("mouseup", mouseHandleDOM); // for moving the alert box throughout document - to stop the movement
      }
    } // CANVAS


    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "removeMouseEvent",
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeMouseEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = []; // DOM

    if (modelObj.visible) {
      var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

      if (modelObj.enable) {
        _container.addEventListener("mousedown", mouseHandleDOM); // for moving the container


        _container.addEventListener("mouseup", mouseHandleDOM); // for moving the container


        document.addEventListener("mousemove", mouseHandleDOM); // for moving the container throughout document

        document.addEventListener("mouseup", mouseHandleDOM); // for moving the container throughout document - to stop the movement
      }
    } // CANVAS


    if (modelObj.visible) {
      if (modelObj.enable) {
        _eventDataObj.r.push({
          id: "base_" + modelObj.id,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: "grab",
          downCursor: "grabbing" // eventListener: mouseHandle.bind(this)

        });
      } else {
        _eventDataObj.r.push({
          id: "baseNonDrag_" + modelObj.id,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: "default",
          eventListener: mouseHandle.bind(this)
        });
      }
    }

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "addMouseEvent",
      data: _eventDataObj
    });
  } // =================================================


  function mouseHandleDOM(e) {
    var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

    if (modelObj.enable) {
      switch (e.type) {
        case "mousedown":
          localObj.mouseEventData.diffX = e.pageX - modelObj.x;
          localObj.mouseEventData.diffY = e.pageY - modelObj.y;
          isContainerPressed = true;
          break;

        case "mouseup":
          isContainerPressed = false;
          addEvents();
          break;

        case "mousemove":
          if (isContainerPressed) {
            modelObj.x = e.pageX - localObj.mouseEventData.diffX;
            modelObj.y = e.pageY - localObj.mouseEventData.diffY;
            var minX = modelObj.dragMinX;
            var minY = modelObj.dragMinY;
            var maxX = modelObj.dragMaxX - modelObj.width;
            var maxY = modelObj.dragMaxY - modelObj.height;
            modelObj.x = modelObj.x < minX ? minX : modelObj.x;
            modelObj.x = modelObj.x > maxX ? maxX : modelObj.x;
            modelObj.y = modelObj.y < minY ? minY : modelObj.y;
            modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;
            _container.style.left = "".concat(modelObj.x, "px");
            _container.style.top = "".concat(modelObj.y, "px");

            if (typeof events.change !== "undefined") {
              events.change({
                id: modelObj.id
              });
            }

            onViewUpdateCls.trigger("onGlobalUpdate", {
              type: "rendererUpdate"
            });
            addEvents();
          }

          break;
      }
    }
  } // =================================================


  function mouseHandle(e) {
    if (modelObj.enable) {
      switch (e.type) {
        case "mousedown":
          localObj.mouseEventData.diffX = e.pageX - modelObj.x;
          localObj.mouseEventData.diffY = e.pageY - modelObj.y;
          break;

        case "mouseenter":
          break;

        case "mouseup":
        case "mouseupout":
          addEvents();
          break;

        case "mouseout":
          break;

        case "pressmove":
          modelObj.x = e.pageX - localObj.mouseEventData.diffX;
          modelObj.y = e.pageY - localObj.mouseEventData.diffY;
          var minX = modelObj.dragMinX;
          var minY = modelObj.dragMinY;
          var maxX = modelObj.dragMaxX - modelObj.width;
          var maxY = modelObj.dragMaxY - modelObj.height;
          modelObj.x = modelObj.x < minX ? minX : modelObj.x;
          modelObj.x = modelObj.x > maxX ? maxX : modelObj.x;
          modelObj.y = modelObj.y < minY ? minY : modelObj.y;
          modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;

          if (typeof events.change !== "undefined") {
            events.change({
              id: modelObj.id
            });
          }

          break;

        case "stageevent":
          break;

        default:
          break;
      }
    }
  }

  function createHeadLine() {
    if (modelObj.headText !== "" && modelObj.LabComClass.globalLangText[modelObj.headText]) {
      modelObj.headText = modelObj.LabComClass.globalLangText[modelObj.headText];
      createTextWrapper();

      var _container = document.getElementById("containerWrapper_".concat(modelObj.id));

      var headTextDiv = document.createElement("div");
      headTextDiv.setAttribute("id", "containerHeadText_".concat(modelObj.id));
      headTextDiv.classList.add("containerHeadText");
      headTextDiv.style.color = modelObj.fontColor;
      headTextDiv.style.fontFamily = modelObj.LabComClass.klettFontRegular;
      headTextDiv.style.fontSize = "".concat(modelObj.fontSize, "px");
      headTextDiv.style.padding = "".concat(modelObj.padding, "px");
      headTextDiv.innerHTML = modelObj.headText;

      _container.append(headTextDiv);
    } else {
      modelObj.headText = "";
    }

    addEvents();
  }

  function createTextWrapper() {
    localObj.headLine = modelObj.context.textWrapperClass({
      xNum: 0,
      // modelCls.cPropObj.xInt,
      yNum: 0,
      // modelCls.cPropObj.yInt,
      fontFormat: "px ",
      maxWidthNum: modelObj.width - modelObj.padding * 2,
      textStr: modelObj.headText,
      fontFamilyStr: modelObj.LabComClass.klettFontRegular,
      fontSizeNum: modelObj.fontSize,
      color: modelObj.fontColor
    });
  }
}
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function InputBoxClass(_dataObj) {
  var self = this; // -- Configurable required props starts here --

  var idStr = _dataObj.id;
  var contextObj = _dataObj.context;
  var typeStr = getConfigurableVal(_dataObj.type, "inputBox"); // -- Configurable required props ends here --
  // -- Configurable optional props starts here --

  var xInt = getConfigurableVal(_dataObj.x, 0);
  var yInt = getConfigurableVal(_dataObj.y, 0);
  var widthInt = getConfigurableVal(_dataObj.width, 56);
  var heightInt = getConfigurableVal(_dataObj.height, 30);
  var radiusInt = getConfigurableVal(_dataObj.radius, 0);
  var strokeStyleStr = getConfigurableVal(_dataObj.strokeStyle, "auto");
  var fillStyleStr = getConfigurableVal(_dataObj.fillStyle, "rgba(255,255,255,1)");
  var borderWidthInt = getConfigurableVal(_dataObj.borderWidth, 1);
  var shadowVisibleBool = getConfigurableVal(_dataObj.shadowVisible, false);
  var shadowColorStr = getConfigurableVal(_dataObj.shadowColor, "rgba(0,0,0,0.5)");
  var shadowOffsetXInt = getConfigurableVal(_dataObj.shadowOffsetX, 2);
  var shadowOffsetYInt = getConfigurableVal(_dataObj.shadowOffsetY, 2);
  var shadowBlurInt = getConfigurableVal(_dataObj.shadowBlur, 10);
  var fontSizeNum = getConfigurableVal(_dataObj.fontSize, 16);
  var fontFamilyStr = getConfigurableVal(_dataObj.fontFamily, _dataObj.LabComClass.klettFontRegular);
  var fontColorStr = getConfigurableVal(_dataObj.fontColor, "rgba(0,0,0,1)");
  var fontDisableColorStr = getConfigurableVal(_dataObj.disableFillStyle, "rgba(0,0,0,0.5)");
  var valueStr = getConfigurableVal(_dataObj.value, "");
  var filterTypeInt = getConfigurableVal(_dataObj.filterType, 1);
  var maxLengthInt = getConfigurableVal(_dataObj.maxLength, 2);
  var maxLengthFilterInt = getConfigurableVal(_dataObj.maxLengthFilter, 1);
  var textAlignStr = getConfigurableVal(_dataObj.textAlign, "center");
  var textPadInt = getConfigurableVal(_dataObj.textPadding, 5);
  var cursorColorStr = getConfigurableVal(_dataObj.cursorColor, "rgba(0, 0, 0, 1)");
  var showComponent = getConfigurableVal(_dataObj.showComponent, false);
  var showEnter = getConfigurableVal(_dataObj.showEnter, false);
  var enterSize = getConfigurableVal(_dataObj.enterSize, 16);
  var enterToSubmit = getConfigurableVal(_dataObj.enterToSubmit, false);
  var spaceToSubmit = getConfigurableVal(_dataObj.spaceToSubmit, false);
  var useCommaAsDecimal = getConfigurableVal(_dataObj.useCommaAsDecimal, false);
  var germanUmlaute = getConfigurableVal(_dataObj.useCommaAsDecimal, false); // -- Configurable optional props ends here --

  var preTxt = getConfigurableVal(_dataObj.LabComClass.globalLangText[_dataObj.preTxt], "");
  var postTxt = getConfigurableVal(_dataObj.LabComClass.globalLangText[_dataObj.postTxt], "");
  var staticMode = getConfigurableVal(_dataObj.staticMode, false);
  var showEventBool = getConfigurableVal(_dataObj.showEventBool, true);
  var isNumeric = getConfigurableVal(_dataObj.isNumeric, true);
  var minValue = getConfigurableVal(_dataObj.minValue, 0);
  var maxValue = getConfigurableVal(_dataObj.maxValue, false);
  var capitalInputAllowed = getConfigurableVal(_dataObj.maxValue, true);
  var ariaLabel = getConfigurableVal(_dataObj.ariaLabel, ""); // -- Configurable optional props ends here --

  var leftMinDecimalCountInt = _dataObj.leftMinDecimalCountInt;
  var rightMaxDecimalCountInt = _dataObj.rightMaxDecimalCountInt;
  var modelObj = {
    outsidePreTxt: "",
    // text []
    outsidePreTxtPadding: 10,
    outsidePreTxtAlign: "right",
    outsidePostTxt: "",
    // [] text
    outsidePostTxtPadding: 10,
    outsidePostTxtAlign: "left",
    allowEmptyState: true,
    ariaLabel: ""
  };
  var localObj = {
    strokeStyle: "rgba(170,170,166,1)"
  };
  Object.keys(_dataObj).forEach(function (i) {
    modelObj[i] = _dataObj[i];
  });
  getGlobalText(["outsidePreTxt", "outsidePostTxt"]);

  if (ariaLabel.length) {
    getGlobalText(["ariaLabel"]);
  } // -- Configurable optional props ends here --


  var disableBool = false;
  var showCursorBool = false;
  var isCorrect = null;
  var addEventBool = false;
  var mouseEntered = false;
  var drawCursor = false;
  var cursorIndex = 0;
  var cursorPositiontoText = 0;
  var addedDecimal = false;
  var enabledBeforeHide;
  var cursorIntervalObj;
  var eventListeners = {};
  var eventsToListen = ["focusIn", "focusOut", "click", "keyup", "mouseenter", "mouseout"];
  var numberPadCompId = null;
  var tabCompId = null;
  var BrowserDetect = _dataObj.LabComClass.BrowserDetect;

  if (strokeStyleStr === "auto") {
    strokeStyleStr = "rgba(170, 170, 166,1)";
  }

  var defaultMaxLength = maxLengthInt;
  Object.defineProperties(this, {
    compId: {
      get: function get() {
        return idStr;
      }
    },
    hasFocus: {
      get: function get() {
        return showCursorBool;
      }
    },
    isVisible: {
      get: function get() {
        return showComponent;
      }
    },
    numberPadCompId: {
      set: function set(value) {
        numberPadCompId = value;
      }
    }
  });

  function createDOM() {
    var mainWrapper = document.getElementById("mainWrapper");

    var _input = document.createElement("input");

    _input.classList.add("inputClass");

    _input.setAttribute("id", "input_" + modelObj.id);

    mainWrapper.append(_input);

    if (modelObj.ariaLabel.length) {
      _input.setAttribute("aria-label", modelObj.ariaLabel); // _input.setAttribute('aria-hidden','false');

    } else {
      _input.setAttribute("aria-label", "Please enter");
    } //=======================
    // if pure number without decimal it will be type number, with decimal will be treated as type text


    var pureNumber = isNumeric && (_typeof(rightMaxDecimalCountInt) === undefined || _typeof(leftMinDecimalCountInt) === undefined);

    _input.setAttribute("type", pureNumber ? "number" : "text");

    if (pureNumber) {
      _input.setAttribute("min", minValue);

      _input.setAttribute("max", maxValue ? maxValue : "9".repeat(maxLengthInt));
    } else if (isNumeric && typeof rightMaxDecimalCountInt !== "undefined") {
      // Max length is calcuated with maxDefalut length + digits after decimal (right) + '1' for decimal maybe '.' or ',' depending on german/english
      if (maxLengthInt < defaultMaxLength + rightMaxDecimalCountInt) {
        maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt + 1;
      }

      _input.setAttribute("maxLength", maxLengthInt);
    } else if (isNumeric && typeof leftMinDecimalCountInt !== "undefined") {
      // Max length is calcuated with maxDefalut length + digits before decimal (left) + '1' for decimal maybe '.' or ',' depending on german/english
      if (maxLengthInt < defaultMaxLength + leftMinDecimalCountInt) {
        maxLengthInt = defaultMaxLength + leftMinDecimalCountInt + 1;
      }

      _input.setAttribute("maxLength", maxLengthInt);
    } else {
      _input.setAttribute("maxLength", maxLengthInt);
    } //=======================


    _input.style.left = "".concat(modelObj.x, "px");
    _input.style.top = "".concat(modelObj.y, "px");
    _input.style.width = "".concat(modelObj.width, "px");
    _input.style.height = "".concat(modelObj.height, "px");
    _input.style.display = showComponent ? "" : "none";
    _input.style.fontSize = "".concat(fontSizeNum, "px");
    _input.style.color = fontColorStr;
    _input.style.fontFamily = fontFamilyStr;
    _input.style.textAlign = textAlignStr;

    _input.setAttribute("disabled", true);

    _input.setAttribute("tabIndex", -1); // PRETEXT


    if (modelObj.outsidePreTxt !== "") {
      var outPreTxt = document.createElement("label");
      outPreTxt.classList.add("outPreTxt");
      outPreTxt.setAttribute("id", "outPreTxt_" + modelObj.id);
      mainWrapper.append(outPreTxt);
      outPreTxt.style.fontSize = "".concat(fontSizeNum, "px");
      outPreTxt.style.color = fontColorStr;
      outPreTxt.style.fontFamily = fontFamilyStr;
      outPreTxt.style.left = "".concat(modelObj.x - modelObj.outsidePreTxtPadding, "px");
      outPreTxt.innerHTML = modelObj.outsidePreTxt;
      outPreTxt.style.top = "".concat(modelObj.y + (heightInt - fontSizeNum) / 2, "px"); // outPreTxt.style.top = `${modelObj.y+ fontSizeNum * 0.65}px`;

      outPreTxt.style.display = showComponent ? "" : "none";
    } // POSTEXT


    if (modelObj.outsidePostTxt !== "") {
      var outPostTxt = document.createElement("label");
      outPostTxt.classList.add("outPostTxt");
      outPostTxt.setAttribute("id", "outPostTxt_" + modelObj.id);
      mainWrapper.append(outPostTxt);
      outPostTxt.style.fontSize = "".concat(fontSizeNum, "px");
      outPostTxt.style.color = fontColorStr;
      outPostTxt.style.fontFamily = fontFamilyStr;
      outPostTxt.style.left = "".concat(modelObj.x + widthInt + modelObj.outsidePostTxtPadding, "px");
      outPostTxt.innerHTML = modelObj.outsidePostTxt;
      outPostTxt.style.top = "".concat(modelObj.y + (heightInt - fontSizeNum) / 2, "px"); // outPostTxt.style.top = `${modelObj.y+ fontSizeNum * 0.65}px`;

      outPostTxt.style.display = showComponent ? "" : "none";
    }
  }

  createDOM();

  this.focusIn = function () {
    drawCursor = true;

    var _input = document.getElementById("input_".concat(modelObj.id));

    if (BrowserDetect.isDevice() === false) {
      document.getElementById("inputFieldDummyDiv").focus();

      _input.focus();
    } // cursorIndex = valueStr.length;
    // setCursorPosition();


    toggleKeyEvents(true);
    showCursorBool = true; // animateCursor();
    // doRender();

    dispatchEvent("focusIn");
    self.setState("normal");
    updateStage();
  };

  this.focusOut = function (e) {
    var _input = document.getElementById("input_".concat(modelObj.id));

    var isSafari = navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && navigator.userAgent.indexOf("CriOS") == -1 && navigator.userAgent.indexOf("FxiOS") == -1;

    if (!isSafari && BrowserDetect.isDevice() === false) {// document.getElementById('inputFieldDummyDiv').blur();
      // _input.blur();
    } // toggleKeyEvents(false);


    showCursorBool = false;
    dispatchEvent("focusOut");
    checkForTrailingDot();
    updateStage();
  };

  this.enable = function () {
    var updateInteractionStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (showComponent) {
      toggleMouseEvents(true);
    }

    if (!showEnter && getConfigurableVal(_dataObj.showEnter, false)) {
      showEnter = true;
    }

    disableBool = false;

    if (updateInteractionStatus) {
      enabledBeforeHide = true;
    }

    toggleKeyEvents(true); // toggleMouseEvents(true);

    var _input = document.getElementById("input_".concat(modelObj.id));

    _input.removeAttribute("disabled");

    _input.setAttribute("tabIndex", 0); // showComponent = true;

  };

  this.disable = function () {
    var updateInteractionStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    var _input = document.getElementById("input_".concat(modelObj.id));

    _input.setAttribute("disabled", true);

    self.focusOut(true);

    if (showEnter) {
      showEnter = false;
    }

    toggleKeyEvents(false); // showComponent = false;

    toggleMouseEvents(false);
    disableBool = true;

    if (updateInteractionStatus) {
      enabledBeforeHide = false;
    } // showComponent = false;

  };

  this.isEnabled = function () {
    return !disableBool;
  };

  this.show = function () {
    showComponent = true;

    var _input = document.getElementById("input_".concat(modelObj.id));

    _input.style.display = "";

    if (modelObj.outsidePreTxt !== "") {
      var outPreTxt = document.getElementById("outPreTxt_".concat(modelObj.id));
      outPreTxt.style.display = "";
    }

    if (modelObj.outsidePostTxt !== "") {
      var outPostTxt = document.getElementById("outPostTxt_".concat(modelObj.id));
      outPostTxt.style.display = "";
    }

    if (enabledBeforeHide) {
      this.enable(false);
    }
  };

  this.hide = function () {
    showComponent = false;

    var _input = document.getElementById("input_".concat(modelObj.id));

    _input.style.display = "none";

    if (modelObj.outsidePreTxt !== "") {
      var outPreTxt = document.getElementById("outPreTxt_".concat(modelObj.id));
      outPreTxt.style.display = "none";
    }

    if (modelObj.outsidePostTxt !== "") {
      var outPostTxt = document.getElementById("outPostTxt_".concat(modelObj.id));
      outPostTxt.style.display = "none";
    }

    this.disable(false);
  };

  this.getVisble = function () {
    return showComponent;
  };

  this.getEnterToSubmit = function () {
    return enterToSubmit;
  };

  this.setPos = function (_x, _y) {
    var _input = document.getElementById("input_".concat(modelObj.id));

    _input.style.left = "".concat(_x, "px");
    _input.style.top = "".concat(_y, "px");

    if (modelObj.outsidePreTxt !== "") {
      var outPreTxt = document.getElementById("outPreTxt_".concat(modelObj.id));
      outPreTxt.style.left = "".concat(_x - modelObj.outsidePreTxtPadding, "px"); // outPreTxt.style.top = `${_y+ fontSizeNum*0.6}px`;

      outPreTxt.style.top = "".concat(_y + (heightInt - fontSizeNum) / 2, "px");
    }

    if (modelObj.outsidePostTxt !== "") {
      var outPostTxt = document.getElementById("outPostTxt_".concat(modelObj.id));
      outPostTxt.style.left = "".concat(_x + widthInt + modelObj.outsidePostTxtPadding, "px");
      outPostTxt.style.top = "".concat(_y + (heightInt - fontSizeNum) / 2, "px");
    }

    xInt = _x;
    yInt = _y;

    if (!disableBool) {
      toggleMouseEvents(showComponent);
    }
  };

  this.getState = function () {
    return addEventBool;
  };

  this["static"] = function (_flag) {
    if (_flag !== undefined) {
      staticMode = _flag;
    }

    return staticMode;
  }; // =================================================


  this.setVisible = function (_bool) {
    if (_bool) {
      this.show();
    } else {
      this.hide();
    }
  };

  this.on = function (event, callback) {
    if (isValidEvent(event)) {
      if (!eventListeners[event]) {
        eventListeners[event] = [];
      }

      eventListeners[event].push(callback);
    }
  };

  this.off = function (event, callback) {
    if (isValidEvent(event)) {
      if (isListenerRegister(event)) {
        var index = eventListeners[event].indexOf(callback);
        eventListeners[event].splice(index, 1);

        if (eventListeners[event].length === 0) {
          delete eventListeners[event];
        }
      }
    }
  };

  this.getValue = function () {
    var _input = document.getElementById("input_".concat(modelObj.id));

    var _valueStr = _input.value;

    if (useCommaAsDecimal) {
      var valueStrCopy = _valueStr;
      return valueStrCopy.replace(",", ".");
    } else {
      return _valueStr;
    }
  };

  this.setValue = function (value) {
    // DOM
    var _input = document.getElementById("input_".concat(modelObj.id));

    _input.value = value;

    if (value === "" || value === null) {
      self.setState("normal");
    } // CANVAS


    valueStr = value.toString();
    cursorIndex = valueStr.length;
    checkForTrailingDot();

    if (valueStr.indexOf(".") !== -1 && typeof rightMaxDecimalCountInt !== "undefined") {
      // Max length is calcuated with maxDefalut length + digits after decimal (right)
      if (maxLengthInt < defaultMaxLength + rightMaxDecimalCountInt) {
        maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt;
      }
    }

    setCursorPosition();
    updateStage();
  };

  this.decimalCount = function (_count) {
    rightMaxDecimalCountInt = _count;

    if (valueStr.indexOf(".") !== -1 && typeof rightMaxDecimalCountInt !== "undefined") {
      // maxLengthInt -= rightMaxDecimalCountInt;
      maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt;
    }

    return rightMaxDecimalCountInt;
  };

  this.getCorrect = function () {
    return isCorrect;
  };

  this.setNumberPadValue = function (value) {
    // processCallback(value);
    processNum(value);

    if (value !== "enter" || value !== " " && !modelObj.spaceToSubmit || value === "enter" && !modelObj.enterToSubmit) {
      dispatchEvent("keyup");
    } else {
      dispatchEventForEnter("keyup");
    }
  };

  this.draws = function () {
    if (showComponent) {
      contextObj.save(); // -- Set shadow

      if (shadowVisibleBool === true) {
        contextObj.shadowColor = shadowColorStr;
        contextObj.shadowOffsetX = shadowOffsetXInt;
        contextObj.shadowOffsetY = shadowOffsetYInt;
        contextObj.shadowBlur = shadowBlurInt;
      } // -- Draw bg


      contextObj.fillStyle = fillStyleStr;
      contextObj.strokeStyle = strokeStyleStr;

      if ((showCursorBool || mouseEntered) && isCorrect === null) {
        // if (showCursorBool && isCorrect === null) {
        contextObj.strokeStyle = "rgba(170, 170, 166,1)";
      }

      if (!showCursorBool && isCorrect === null && !mouseEntered) {
        contextObj.strokeStyle = "rgba(170, 170, 166,1)";
      }

      if (!showCursorBool && mouseEntered) {// contextObj.strokeStyle = 'rgba(237, 237, 237,1)';
      }

      var fontColor = fontColorStr;

      if (valueStr !== "" && modelObj.allowEmptyState || !modelObj.allowEmptyState) {
        if (!isCorrect && isCorrect !== null) {
          contextObj.fillStyle = "rgba(255, 0, 0, 1)";
          fontColor = "rgba(255, 255, 255, 1)";
        } else if (isCorrect && isCorrect !== null) {
          contextObj.fillStyle = "rgba(65, 180, 5, 1)";
          fontColor = "rgba(255, 255, 255, 1)";
        }
      }

      contextObj.lineWidth = 1; // contextObj.fillStyle =  'rgba(255, 255, 255, 1)';

      roundRect(contextObj, xInt, yInt, widthInt, heightInt, radiusInt, true, true); // -- Reset shadow so border doesnt draw shadow

      contextObj.shadowColor = "transparent";
      contextObj.shadowOffsetX = 0;
      contextObj.shadowOffsetY = 0;
      contextObj.shadowBlur = 0; // -- Draw text

      if (valueStr !== "") {
        contextObj.textBaseline = "bottom";
        contextObj.font = fontSizeNum + "px " + fontFamilyStr;

        if (disableBool && !staticMode) {
          contextObj.fillStyle = fontDisableColorStr;

          if (isCorrect !== null) {
            contextObj.fillStyle = "rgba(255,255,255,0.7)";
          }
        } else {
          contextObj.fillStyle = fontColor;
        }

        contextObj.strokeStyle = "rgba(255,255,255,1)";

        var _tempYInt = yInt + heightInt / 2 + fontSizeNum / 2 + fontSizeNum * 0.125;

        if (fontFamilyStr.indexOf("league") !== -1) {
          _tempYInt += fontSizeNum * 4 / 28;
        }

        var text = preTxt + valueStr + postTxt;

        switch (textAlignStr) {
          case "left":
            contextObj.textAlign = "left";
            contextObj.drawStyledText(text, xInt + textPadInt, _tempYInt);
            break;

          case "right":
            contextObj.textAlign = "right";
            contextObj.drawStyledText(text, xInt + widthInt - (textPadInt + 4), _tempYInt);
            break;

          case "center":
          default:
            contextObj.textAlign = "center";
            contextObj.drawStyledText(text, xInt + widthInt / 2, _tempYInt);
            break;
        }
      } // -- Draw cursor


      if (drawCursor === true && showCursorBool === true) {
        var cursorXInt;
        var cursorYInt;
        var newValStr = valueStr.substring(0, cursorIndex);
        contextObj.font = fontSizeNum + "px " + fontFamilyStr;

        switch (textAlignStr) {
          case "left":
            // cursorXInt = valueStr === '' ? xInt + textPadInt + 2 : xInt + textPadInt + contextObj.measureText(valueStr).width + 2;
            cursorXInt = valueStr === "" ? xInt + textPadInt + 2 : xInt + textPadInt + contextObj.measureText(newValStr).width + 2;
            break;

          case "right":
            // cursorXInt = (xInt + widthInt) - (textPadInt + 2);
            newValStr = valueStr.substring(cursorIndex, valueStr.length);
            cursorXInt = xInt + widthInt - contextObj.measureText(newValStr).width - (textPadInt + 2);
            break;

          case "center":
          default:
            // cursorXInt = valueStr === '' ? xInt + (widthInt / 2) : xInt + (widthInt / 2) + (contextObj.measureText(valueStr).width / 2) + 2;
            cursorXInt = cursorPositiontoText;
            break;
        }

        cursorYInt = yInt + (heightInt - fontSizeNum) / 2;
        contextObj.beginPath();
        contextObj.moveTo(cursorXInt, cursorYInt);
        contextObj.lineTo(cursorXInt, cursorYInt + fontSizeNum);
        contextObj.closePath();
        contextObj.lineWidth = 1;
        contextObj.strokeStyle = cursorColorStr;
        contextObj.stroke();
      }

      if (!showCursorBool && valueStr === "" && showEnter) {
        contextObj.fillStyle = "rgba(0, 0, 0, 1)";
        contextObj.textAlign = "start";
        contextObj.textBaseline = "alphabetic";
        contextObj.drawStyledText("Enter", xInt + 8, yInt + heightInt / 2 + fontSizeNum / 2 - 2, "Alef-Regular", enterSize);
      }

      if (disableBool && !staticMode) {
        contextObj.strokeStyle = "rgba(237, 237, 237,1)";
        contextObj.fillStyle = "rgba(255, 255, 255, 0.03)";
        roundRect(contextObj, xInt, yInt, widthInt, heightInt, radiusInt, true, true);
      }

      if (modelObj.outsidePostTxt !== "") {
        contextObj.save();
        contextObj.beginPath();
        contextObj.fillStyle = fontColorStr;
        contextObj.textAlign = modelObj.outsidePostTxtAlign;
        contextObj.textBaseline = "bottom";
        contextObj.drawStyledText(modelObj.outsidePostTxt, xInt + widthInt + modelObj.outsidePostTxtPadding, yInt + heightInt / 2 + fontSizeNum * 0.65, modelObj.LabComClass.klettFontRegular, fontSizeNum);
        contextObj.closePath();
        contextObj.restore();
      }

      if (modelObj.outsidePreTxt !== "") {
        contextObj.save();
        contextObj.beginPath();
        contextObj.fillStyle = fontColorStr;
        contextObj.textAlign = modelObj.outsidePreTxtAlign;
        contextObj.textBaseline = "bottom";
        contextObj.drawStyledText(modelObj.outsidePreTxt, xInt - modelObj.outsidePreTxtPadding, yInt + heightInt / 2 + fontSizeNum * 0.65, modelObj.LabComClass.klettFontRegular, fontSizeNum);
        contextObj.closePath();
        contextObj.restore();
      }

      contextObj.restore();
    }
  };

  this.destroy = function () {
    self.disable();
  };

  this.setState = function (str) {
    // CANVAS
    if (str === "correct") {
      isCorrect = true;
    } else if (str === "incorrect") {
      isCorrect = false;
    } else if (str === "normal") {
      isCorrect = null;
    } // DOM


    var _input = document.getElementById("input_".concat(modelObj.id));

    if (isCorrect == null) {
      _input.style.color = fontColorStr;
      _input.style.backgroundColor = "rgba(255, 255, 255, 1)";
    } else if (isCorrect) {
      _input.style.backgroundColor = "rgba(65, 180, 5, 1)";
      _input.style.color = "rgba(255, 255, 255, 1)";
    } else {
      _input.style.backgroundColor = "rgba(255, 0, 0, 1)";
      _input.style.color = "rgba(255, 255, 255, 1)";
    }
  };

  function checkForTrailingDot() {
    if (valueStr.charAt(valueStr.length - 1) === ".") {
      valueStr = valueStr.substring(0, valueStr.length - 1);
    }
  }

  function isValidEvent(eventType) {
    if (eventsToListen.indexOf(eventType) !== -1) {
      return true;
    }

    throw new Error("Invalid event ".concat(eventType, " provided, following events ").concat(eventListeners, " are allowed"));
  }

  function isListenerRegister(eventType) {
    return eventListeners[eventType] && eventListeners[eventType].length > 0;
  }

  function dispatchEvent(type) {
    if (isListenerRegister(type)) {
      eventListeners[type].forEach(function (callback) {
        callback({
          type: type,
          id: idStr
        });
      });
    }
  }

  function dispatchEventForEnter(type) {
    if (isListenerRegister(type)) {
      eventListeners[type].forEach(function (callback) {
        callback({
          type: type,
          enterPressed: true,
          id: idStr
        });
      });
    }
  }
  /**
   * Draws a rounded rectangle using the current state of the canvas.
   * If you omit the last three params, it will draw a rectangle
   * outline with a 5 pixel border radius
   * @param {CanvasRenderingContext2D} contextObj
   * @param {Number} x The top left x coordinate
   * @param {Number} y The top left y coordinate
   * @param {Number} width The width of the rectangle
   * @param {Number} height The height of the rectangle
   * @param {Number} [radius = 5] The corner radius; It can also be an object
   *                 to specify different radii for corners
   * @param {Number} [radius.tl = 0] Top left
   * @param {Number} [radius.tr = 0] Top right
   * @param {Number} [radius.br = 0] Bottom right
   * @param {Number} [radius.bl = 0] Bottom left
   * @param {Boolean} [fill = false] Whether to fill the rectangle.
   * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
   */


  function roundRect(contextObj, x, y, width, height, radius, fill, stroke) {
    if (typeof stroke === "undefined") {
      stroke = true;
    }

    if (typeof radius === "undefined") {
      radius = 5;
    }

    if (typeof radius === "number") {
      radius = {
        tl: radius,
        tr: radius,
        br: radius,
        bl: radius
      };
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    contextObj.beginPath();
    contextObj.moveTo(x + radius.tl, y);
    contextObj.lineTo(x + (width - radius.tr), y);
    contextObj.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    contextObj.lineTo(x + width, y + (height - radius.br));
    contextObj.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
    contextObj.lineTo(x + radius.bl, y + height);
    contextObj.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
    contextObj.lineTo(x, y + radius.tl);
    contextObj.quadraticCurveTo(x, y, x + radius.tl, y);
    contextObj.closePath();
    contextObj.lineWidth = borderWidthInt;

    if (fill) {
      contextObj.fill();
    }

    if (stroke) {
      contextObj.lineWidth = 1;
      contextObj.stroke();
    }
  }

  function getGlobalText(keys) {
    for (var i = 0; i < keys.length; i++) {
      modelObj[keys[i]] = modelObj.LabComClass.globalLangText[modelObj[keys[i]]] || "";
    }
  }

  function animateCursor() {
    clearTimeout(cursorIntervalObj);

    if (showCursorBool === true) {
      cursorIntervalObj = setTimeout(function () {
        drawCursor = !drawCursor;
        updateStage();
        setCursorPosition();
        animateCursor();
      }, 530);
    } else {
      updateStage();
    }
  }

  function doRender() {
    if (showCursorBool) {
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "rendererUpdate"
      });
      requestAnimationFrame(doRender);
    }
  }

  function toggleMouseEvents(interactive) {
    // DOM
    var _input = document.getElementById("input_".concat(modelObj.id));

    if (interactive) {
      _input.addEventListener("mousedown", mouseEventHandlerDOM);

      _input.addEventListener("mouseup", mouseEventHandlerDOM);
    } else {
      _input.removeEventListener("mousedown", mouseEventHandlerDOM);

      _input.removeEventListener("mouseup", mouseEventHandlerDOM);
    } //CANVAS


    var eventDataObj = {};
    var _removeArr = [];
    eventDataObj.id = idStr;
    eventDataObj.r = [];
    eventDataObj.r.push({
      id: 0,
      rect: {
        x: xInt,
        y: yInt,
        w: widthInt,
        h: heightInt
      },
      eventListener: mouseEventHandler
    });

    if (interactive) {
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "addMouseEvent",
        data: eventDataObj
      });
    } else {
      showCursorBool = false;
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "removeMouseEvent",
        data: {
          id: idStr
        }
      });
    }

    addEventBool = interactive; // animateCursor();
  }

  function mouseEventHandlerDOM(e) {
    switch (e.type) {
      case "mouseupout":
        mouseEntered = false;
        break;

      case "mousedown":
        if (!self.hasFocus) {
          self.focusIn();
        }

        break;

      case "mouseup":
        if (!self.hasFocus) {
          self.focusIn();
        }

        mouseEntered = false;
        dispatchEvent("click");
        break;

      case "mouseenter":
        dispatchEvent("mouseenter");
        mouseEntered = true;
        break;

      case "mouseout":
        dispatchEvent("mouseout");
        mouseEntered = false;
        break;

      default:
        break;
    }
  }

  function toggleKeyEvents(interactive) {
    var _input = document.getElementById("input_".concat(modelObj.id));

    if (interactive) {
      _input.addEventListener("keydown", keyEventHandlerDOM);

      _input.addEventListener("keypress", keyEventHandlerDOM);

      _input.addEventListener("keyup", keyEventHandlerDOM);
    } else {
      _input.removeEventListener("keydown", keyEventHandlerDOM);

      _input.removeEventListener("keypress", keyEventHandlerDOM);

      _input.removeEventListener("keyup", keyEventHandlerDOM);
    }
  } // function toggleKeyEvents_(interactive) {
  //   if (interactive) {
  //     onViewUpdateCls.trigger('onGlobalUpdate', {
  //       type: 'addKeyEvent',
  //       data: {
  //         id: idStr,
  //         callback: keyEventHandler,
  //       },
  //     });
  //   } else {
  //     onViewUpdateCls.trigger('onGlobalUpdate', {
  //       type: 'removeKeyEvent',
  //       data: {
  //         id: idStr,
  //         callback: keyEventHandler,
  //       },
  //     });
  //   }
  // }


  function keyEventHandlerDOM(e) {
    // console.log('E>TY',e.type);
    switch (e.type) {
      case "keydown":
        if (e.which === 38 || e.which === 40) {
          e.preventDefault();
        }

        if (e.key === "Tab") {
          self.focusOut(e.key);
        }

        break;

      case "keypress":
        // maybe german or english decimal system
        var keyCode = getKeyCodeObjV2();
        var isEmpty = e.target.value.trim();
        var isDecimal = useCommaAsDecimal ? e.target.value.includes(",") : e.target.value.includes(".");
        var isOpenParenthesis = e.target.value.includes("("); // console.log('FILTER',filterTypeInt,keyCode[e.key],e.key);

        var isValidKey = false;

        if (keyCode[e.key] || capitalInputAllowed && keyCode[e.key.toLowerCase()]) {
          isValidKey = true;
        }

        if (!isValidKey) {
          e.preventDefault();
          e.returnValue = false;
        } else {
          // NEGATION Will allow only if input box is empty
          if (e.key === "-" && isEmpty && isNumeric) {
            e.preventDefault();
            e.returnValue = false;
          } // DECIMAL '.' will allow only one decimal notation '.' or ',' only once


          if ((e.key === "." || e.key === ",") && isDecimal && isNumeric) {
            e.preventDefault();
            e.returnValue = false;
          } // Bracket will allow closing bracket only if opening is present


          if (e.key === ")" && !isOpenParenthesis) {
            e.preventDefault();
            e.returnValue = false;
          }
        }

        break;

      case "keyup":
        switch (e.key) {
          case "Enter":
          case "ArrowRight":
          case "ArrowLeft":
          case "ArrowUp":
          case "ArrowDown":
          case " ":
            if (e.key !== " " || e.key === " " && modelObj.spaceToSubmit) {
              e.target.value = e.target.value.trim();
              self.focusOut();
            }

            break;

          case "Delete":
            e.target.value = "";
            break;
          // if the state of input box is other than normal and the user presses backspace then the state will return to normal

          case "Backspace":
            self.setState("normal");
            break;
          // case 'Tab':
          //   self.focusOut();
          //   break;

          default:
            if (e.key !== "shift") {// processCallback(e.key, e);
              // keyupFunction(e.key,e);
            }

            break;
        }

        if (e.type === "keyup" && (e.key === "Enter" && modelObj.enterToSubmit || e.target.value == " " && modelObj.spaceToSubmit)) {
          dispatchEventForEnter("keyup");
        } else {
          dispatchEvent("keyup");
        }

        break;

      default:
        // if(e.type === 'keydown' && e.key === 'Backspace'){
        //   e.preventDefault();
        // }
        break;
    }
  }

  function processNum(_key) {
    var keyCode = getKeyCodeObjV2();
    var isValidKey = false;

    if (keyCode[_key] || capitalInputAllowed && keyCode[_key.toLowerCase()]) {
      isValidKey = true;
    }

    var _input = document.getElementById("input_".concat(modelObj.id));

    if (_key === "back") {
      _input.value = _input.value.slice(0, _input.value.length - 1);
    } else if (_key === "clear") {
      _input.value = "";
    } else if (_key === "caps") {} else if (isValidKey && _input.value.length < maxLengthInt && String(_key).length === 1) {
      _input.value = _input.value + _key;
    } // const _input = document.getElementById(`input_${modelObj.id}`);
    // _input.dispatchEvent(new KeyboardEvent('keypress',  {'key':_key}));

  }

  function processCallback(_key, _dataObj) {
    var _bool = false;

    var _keyCodeObj = getKeyCodeObj();

    if (typeof _dataObj !== "undefined") {
      if (_dataObj.ctrlKey === true) {
        _dataObj.preventDefault();

        return false;
      }

      if (_dataObj.key === "Tab") {
        if (tabCompId !== null) {
          tabCompId.onTabEvent(self.compId);
        } // _dataObj.preventDefault();


        return false;
      }

      if (_dataObj.shiftKey && (_dataObj.key === "ArrowLeft" || _dataObj.key === "ArrowRight" || _dataObj.key === "Left" || _dataObj.key === "Right")) {
        // setCursorPosition(_dataObj.key);
        _dataObj.preventDefault();

        return false;
      } // -- Input from keyboard


      if (typeof _keyCodeObj[_dataObj.keyCode] !== "undefined") {
        _bool = true;
        _key = _keyCodeObj[_dataObj.keyCode].toString(); // if (_key === 'ö' || _key === 'ü' || _key === 'ä') {
        //   _key = _dataObj.key.toString();
        // }
        // if (_key === '?') {
        //   _key = 'ß'
        // }
      }
    } else {
      // -- Input from keypad (devices)
      _key = _key.toString();
      Object.keys(_keyCodeObj).forEach(function (_keyCodeObjKey) {
        if (_key === _keyCodeObj[_keyCodeObjKey].toString() && filterTypeInt !== 13) {
          _bool = true;
        } else if ((_key === _keyCodeObj[_keyCodeObjKey].toString() || _key.toLowerCase() === _keyCodeObj[_keyCodeObjKey].toString()) && filterTypeInt == 13) {
          _bool = true;
        }
      });
    }

    if (_bool) {
      var _input = document.getElementById("input_".concat(modelObj.id));

      _input.value = _input.value + _bool;
    } // if (_bool === true) {
    //   switch (_key) {
    //     case 'diff':
    //       if (valueStr === '' || cursorIndex === 0 || valueStr[cursorIndex - 1] === '(') {
    //         // valueStr += '-';
    //         updateValueStr('-');
    //       }
    //       break;
    //     case 'Ö':
    //     case 'ö':
    //       if( valueStr.length < getMaxLength()){
    //         updateValueStr(_key)
    //       }
    //       break;
    //     case '(':
    //       if(_dataObj === undefined || _dataObj.shiftKey) {
    //         updateValueStr(_key);
    //       }
    //       else {
    //         updateValueStr('8');
    //       }
    //       break;
    //     case ')':
    //       if(valueStr.length < getMaxLength() && (_dataObj === undefined || _dataObj.shiftKey)) {
    //         let strArray = valueStr.split('');
    //         let count = strArray.reduce((a, v) => (v === '('? a + 1 : a),0);
    //         if(count && (_dataObj === undefined ||_dataObj.shiftKey)) {
    //           updateValueStr(')');
    //         }
    //       }
    //       else if(!_dataObj.shiftKey) {
    //         updateValueStr('9');
    //       }
    //       break;
    //     case 'Ä':
    //     case 'ä':
    //       if(valueStr.length < getMaxLength()){
    //         updateValueStr(_key);
    //       }
    //       break;
    //     case 'Ü':
    //     case 'ü':
    //     case 'ß':
    //       if(valueStr.length < getMaxLength()){
    //         updateValueStr(_key);
    //       }
    //       break;
    //     case 'dot':
    //       if(_dataObj?.shiftKey === true && valueStr.length < getMaxLength()){
    //         updateValueStr('>');
    //       } else if (valueStr.indexOf('.') === -1 && valueStr.length <= getMaxLength() && rightMaxDecimalCountInt) {
    //         maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt;
    //         addedDecimal = true;
    //         if (typeof (leftMinDecimalCountInt) !== 'undefined') {
    //           if (valueStr.length >= leftMinDecimalCountInt) {
    //             // valueStr += '.';
    //             updateValueStr('.');
    //           }
    //         } else {
    //           // valueStr += '.';
    //           updateValueStr('.');
    //         }
    //         /*
    //          if (valueStr === '') {
    //          if (allowFirstDecimalBool === true) {
    //          valueStr += '.';
    //          } else {
    //          playSfx('error');
    //          }
    //          } else {
    //          valueStr += '.';
    //          }
    //          */
    //       }
    //       break;
    //     case 'back':
    //     case 'Backspace':
    //       if (addedDecimal && valueStr.charAt(valueStr.length - 1) === '.') {
    //         maxLengthInt = defaultMaxLength;
    //         addedDecimal = false;
    //       }
    //       // valueStr = valueStr.substring(0, valueStr.length - 1);
    //       // updateValueStr('back');
    //       valueStr = _input.value;
    //       break;
    //     case 'clear':
    //       // valueStr = '';
    //       updateValueStr('clear');
    //       break;
    //     case 'comma':
    //       if(_dataObj?.shiftKey === true && valueStr.length < getMaxLength() && (filterTypeInt !== 12 && filterTypeInt !== 14)){
    //         updateValueStr('<');
    //       } else if ((!useCommaAsDecimal && valueStr.length < getMaxLength() && valueStr !== '' && valueStr.charAt(valueStr.length - 1) !== '.' && valueStr.charAt(valueStr.length - 1) !== ',' && valueStr.charAt(valueStr.length - 1) !== '/')
    //       || (useCommaAsDecimal && valueStr.indexOf(',') === -1 && valueStr !== '' && valueStr.charAt(valueStr.length - 1) !== ',' )
    //       ) {
    //         // valueStr += ',';
    //         updateValueStr(',');
    //       }
    //       break;
    //     case 'equal':
    //       if( valueStr.length < getMaxLength()){
    //         updateValueStr('=');
    //       }
    //     break;
    //     case 'space':
    //       if (
    //         valueStr.length < getMaxLength()
    //         && valueStr !== ''
    //         && valueStr.charAt(valueStr.length - 1) !== '.'
    //         && valueStr.charAt(valueStr.length - 1) !== ','
    //         && valueStr.charAt(valueStr.length - 1) !== '/'
    //       ) {
    //         // valueStr += ',';
    //         updateValueStr(' ');
    //       }
    //       break;
    //     case 'slash':
    //       if (valueStr.length < getMaxLength() && valueStr !== '' && valueStr.charAt(valueStr.length - 1) !== '.' && valueStr.charAt(valueStr.length - 1) !== ',' && valueStr.charAt(valueStr.length - 1) !== '/') {
    //         // valueStr += '/';
    //         updateValueStr('/');
    //       }
    //       break;
    //     default:
    //       if (valueStr.length < getMaxLength()) {
    //         // valueStr += _key;
    //         if (filterTypeInt !== 13) {
    //           updateValueStr(_key.toUpperCase(), true);
    //         }
    //         else {
    //           if(_dataObj?.key !== undefined) { //keyborad case
    //             updateValueStr(_dataObj.key, true);
    //           }
    //           else { //numPad case
    //             updateValueStr(_key, true);
    //           }
    //         }
    //         // if (valueStr.indexOf('.') !== -1 && typeof (rightMaxDecimalCountInt) !== 'undefined' && valueStr.split('.')[1].length > rightMaxDecimalCountInt) {
    //         //   valueStr = valueStr.substring(0, valueStr.length - 1);
    //         // }
    //         // if (!isNaN(Number(valueStr)) && valueStr !== '') {
    //         //   if (minVal !== null && Number(valueStr) < minVal) {
    //         //     valueStr = minVal.toString();
    //         //   }
    //         //   if (maxVal !== null && Number(valueStr) > maxVal) {
    //         //     valueStr = maxVal.toString();
    //         //   }
    //         // }
    //         // updateValueStr('reset');
    //       }
    //       break;
    //   }
    //   updateStage();
    // }
    // if (_dataObj && _dataObj.keyCode === 8) { // Prevent the backspace key from navigating back.
    //   console.log('BS');
    //   // _dataObj.preventDefault();
    //   return false;
    // }


    return 1;
  }

  function processCallback_(_key, _dataObj) {
    var _bool = false;

    var _keyCodeObj = getKeyCodeObj();

    if (typeof _dataObj !== "undefined") {
      if (_dataObj.ctrlKey === true) {
        _dataObj.preventDefault();

        return false;
      }

      if (_dataObj.key === "Tab") {
        if (tabCompId !== null) {
          tabCompId.onTabEvent(self.compId);
        } // _dataObj.preventDefault();


        return false;
      }

      if (_dataObj.key === "ArrowLeft" || _dataObj.key === "ArrowRight" || _dataObj.key === "Left" || _dataObj.key === "Right") {
        // setCursorPosition(_dataObj.key);
        // _dataObj.preventDefault();
        return false;
      } // -- Input from keyboard


      if (typeof _keyCodeObj[_dataObj.keyCode] !== "undefined") {
        _bool = true;
        _key = _keyCodeObj[_dataObj.keyCode].toString();

        if (_key === "ö" || _key === "ü" || _key === "ä") {
          _key = _dataObj.key.toString();
        }

        if (_key === "?") {
          _key = "ß";
        }
      }
    } else {
      // -- Input from keypad (devices)
      _key = _key.toString();
      Object.keys(_keyCodeObj).forEach(function (_keyCodeObjKey) {
        if (_key === _keyCodeObj[_keyCodeObjKey].toString() && filterTypeInt !== 13) {
          _bool = true;
        } else if ((_key === _keyCodeObj[_keyCodeObjKey].toString() || _key.toLowerCase() === _keyCodeObj[_keyCodeObjKey].toString()) && filterTypeInt == 13) {
          _bool = true;
        }
      });
    }

    if (_bool === true) {
      switch (_key) {
        case "diff":
          if (valueStr === "" || cursorIndex === 0 || valueStr[cursorIndex - 1] === "(") {
            // valueStr += '-';
            updateValueStr("-");
          }

          break;

        case "Ö":
        case "ö":
          if (valueStr.length < getMaxLength()) {
            updateValueStr(_key);
          }

          break;

        case "(":
          if (_dataObj === undefined || _dataObj.shiftKey) {
            updateValueStr(_key);
          } else {
            updateValueStr("8");
          }

          break;

        case ")":
          if (valueStr.length < getMaxLength() && (_dataObj === undefined || _dataObj.shiftKey)) {
            var strArray = valueStr.split("");
            var count = strArray.reduce(function (a, v) {
              return v === "(" ? a + 1 : a;
            }, 0);

            if (count && (_dataObj === undefined || _dataObj.shiftKey)) {
              updateValueStr(")");
            }
          } else if (!_dataObj.shiftKey) {
            updateValueStr("9");
          }

          break;

        case "Ä":
        case "ä":
          if (valueStr.length < getMaxLength()) {
            updateValueStr(_key);
          }

          break;

        case "Ü":
        case "ü":
        case "ß":
          if (valueStr.length < getMaxLength()) {
            updateValueStr(_key);
          }

          break;

        case "dot":
          if ((_dataObj === null || _dataObj === void 0 ? void 0 : _dataObj.shiftKey) === true && valueStr.length < getMaxLength()) {
            updateValueStr(">");
          } else if (valueStr.indexOf(".") === -1 && valueStr.length <= getMaxLength() && rightMaxDecimalCountInt) {
            maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt;
            addedDecimal = true;

            if (typeof leftMinDecimalCountInt !== "undefined") {
              if (valueStr.length >= leftMinDecimalCountInt) {
                // valueStr += '.';
                updateValueStr(".");
              }
            } else {
              // valueStr += '.';
              updateValueStr(".");
            }
            /*
             if (valueStr === '') {
             if (allowFirstDecimalBool === true) {
             valueStr += '.';
             } else {
             playSfx('error');
             }
             } else {
             valueStr += '.';
             }
             */

          }

          break;

        case "back":
        case "Backspace":
          if (addedDecimal && valueStr.charAt(valueStr.length - 1) === ".") {
            maxLengthInt = defaultMaxLength;
            addedDecimal = false;
          } // valueStr = valueStr.substring(0, valueStr.length - 1);


          updateValueStr("back");
          break;

        case "clear":
          // valueStr = '';
          updateValueStr("clear");
          break;

        case "comma":
          if ((_dataObj === null || _dataObj === void 0 ? void 0 : _dataObj.shiftKey) === true && valueStr.length < getMaxLength() && filterTypeInt !== 12 && filterTypeInt !== 14) {
            updateValueStr("<");
          } else if (!useCommaAsDecimal && valueStr.length < getMaxLength() && valueStr !== "" && valueStr.charAt(valueStr.length - 1) !== "." && valueStr.charAt(valueStr.length - 1) !== "," && valueStr.charAt(valueStr.length - 1) !== "/" || useCommaAsDecimal && valueStr.indexOf(",") === -1 && valueStr !== "" && valueStr.charAt(valueStr.length - 1) !== ",") {
            // valueStr += ',';
            updateValueStr(",");
          }

          break;

        case "equal":
          if (valueStr.length < getMaxLength()) {
            updateValueStr("=");
          }

          break;

        case "space":
          if (valueStr.length < getMaxLength() && valueStr !== "" && valueStr.charAt(valueStr.length - 1) !== "." && valueStr.charAt(valueStr.length - 1) !== "," && valueStr.charAt(valueStr.length - 1) !== "/") {
            // valueStr += ',';
            updateValueStr(" ");
          }

          break;

        case "slash":
          if (valueStr.length < getMaxLength() && valueStr !== "" && valueStr.charAt(valueStr.length - 1) !== "." && valueStr.charAt(valueStr.length - 1) !== "," && valueStr.charAt(valueStr.length - 1) !== "/") {
            // valueStr += '/';
            updateValueStr("/");
          }

          break;

        default:
          if (valueStr.length < getMaxLength()) {
            // valueStr += _key;
            if (filterTypeInt !== 13) {
              updateValueStr(_key.toUpperCase(), true);
            } else {
              if ((_dataObj === null || _dataObj === void 0 ? void 0 : _dataObj.key) !== undefined) {
                //keyborad case
                updateValueStr(_dataObj.key, true);
              } else {
                //numPad case
                updateValueStr(_key, true);
              }
            } // if (valueStr.indexOf('.') !== -1 && typeof (rightMaxDecimalCountInt) !== 'undefined' && valueStr.split('.')[1].length > rightMaxDecimalCountInt) {
            //   valueStr = valueStr.substring(0, valueStr.length - 1);
            // }
            // if (!isNaN(Number(valueStr)) && valueStr !== '') {
            //   if (minVal !== null && Number(valueStr) < minVal) {
            //     valueStr = minVal.toString();
            //   }
            //   if (maxVal !== null && Number(valueStr) > maxVal) {
            //     valueStr = maxVal.toString();
            //   }
            // }
            // updateValueStr('reset');

          }

          break;
      }

      updateStage();
    }

    if (_dataObj && _dataObj.keyCode === 8) {
      // Prevent the backspace key from navigating back.
      console.log("BS"); // _dataObj.preventDefault();

      return false;
    }

    console.log("UVS", valueStr);
    return 1;
  }

  function getKeyCodeObj() {
    var _obj = {
      48: 0,
      49: 1,
      50: 2,
      51: 3,
      52: 4,
      53: 5,
      54: 6,
      55: 7,
      56: 8,
      57: 9,
      96: 0,
      97: 1,
      98: 2,
      99: 3,
      100: 4,
      101: 5,
      102: 6,
      103: 7,
      104: 8,
      105: 9,
      8: "back",
      // 46: 'clear',
      32: "space"
    };
    var letters = {
      65: "a",
      66: "b",
      67: "c",
      68: "d",
      69: "e",
      70: "f",
      71: "g",
      72: "h",
      73: "i",
      74: "j",
      75: "k",
      76: "l",
      77: "m",
      78: "n",
      79: "o",
      80: "p",
      81: "q",
      82: "r",
      83: "s",
      84: "t",
      85: "u",
      86: "v",
      87: "w",
      88: "x",
      89: "y",
      90: "z"
    };

    if (!isNumeric) {
      Object.keys(letters).forEach(function (i) {
        _obj[i] = letters[i];
      });
    }

    switch (filterTypeInt) {
      case 14:
        // -- 0 to 9, Comma,Backspace, Clear, (,)
        _obj[188] = "comma";
        _obj[8] = "back";
        _obj[46] = "clear";
        _obj[189] = "diff";
        _obj[109] = "diff";
        _obj[173] = "diff";
        _obj[56] = "("; // For German

        _obj[57] = ")"; // For German

        break;

      case 13:
        // All Gamar
        var firefoxAg = modelObj.LabComClass.BrowserDetect.browserUserAgentName().indexOf("Firefox") > -1; // -- 0 to 9,backspace,clear,ö,ü,ä.

        if (!firefoxAg) {
          _obj[8] = "back"; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = "ö"; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = "ä"; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[186] = "ü"; // Toggle Comment for using Ü on German Keybaord.

          _obj[219] = "ß";
        } else {
          _obj[8] = "back"; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = "ö"; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = "ä"; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[59] = "ü"; // Toggle Comment for using Ü on German Keybaord.

          _obj[63] = "ß";
        }

        _obj[188] = "comma";
        break;

      case 12:
        // -- 0 to 9, Comma,Backspace, Clear
        _obj[188] = "comma";
        _obj[8] = "back";
        _obj[46] = "clear";
        _obj[189] = "diff";
        _obj[109] = "diff";
        _obj[173] = "diff";
        break;

      case 11:
        var firefoxAgent = modelObj.LabComClass.BrowserDetect.browserUserAgentName().indexOf("Firefox") > -1; // -- 0 to 9,backspace,clear,ö,ü,ä.

        if (!firefoxAgent) {
          _obj[8] = "back"; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = "ö"; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = "ä"; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[186] = "ü"; // Toggle Comment for using Ü on German Keybaord.
        } else {
          _obj[8] = "back"; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = "ö"; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = "ä"; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[59] = "ü"; // Toggle Comment for using Ü on German Keybaord.
        }

        break;

      case 10:
        // -- 0 to 9, Comma,Backspace, Clear
        _obj[188] = "comma";
        _obj[8] = "back";
        _obj[46] = "clear";
        break;

      case 9:
        _obj = [];
        _obj[187] = "equal";
        _obj[188] = "comma";
        _obj[190] = "dot";
        _obj[8] = "back";
        _obj[46] = "clear";
        break;

      case 8:
        // -- 0 to 9, Comma, Negation, Slash, Decimal Point
        _obj[188] = "comma";
        _obj[189] = "diff";
        _obj[109] = "diff";
        _obj[173] = "diff";
        _obj[191] = "slash";
        _obj[111] = "slash";
        _obj[190] = "dot";
        _obj[110] = "dot";
        break;

      case 7:
        // -- 0 to 9, Backspace, Clear, Decimal Point
        _obj[190] = "dot";
        _obj[110] = "dot";
        break;

      case 6:
        // -- 0 to 9, Backspace, Clear, Comma
        _obj[188] = "comma";
        _obj[189] = "space";
        break;

      case 5:
        // -- 0 to 9, Backspace, Clear, Slash
        _obj[191] = "slash";
        _obj[111] = "slash";
        break;

      case 4:
        // -- 0 to 9, Backspace, Clear
        break;

      case 3:
        // -- 0 to 9, Backspace, Clear, Negation
        _obj[189] = "diff";
        _obj[109] = "diff";
        _obj[173] = "diff";
        break;

      case 2:
        // -- 0 to 9, Backspace, Clear, Decimal Point, Negation
        _obj[189] = "diff";
        _obj[109] = "diff";
        _obj[173] = "diff";
        _obj[190] = "dot";
        _obj[110] = "dot";
        break;

      case 1:
      default:
        // -- 0 to 9, Backspace, Clear, Decimal Point, Negation, Comma
        _obj[189] = "diff";
        _obj[109] = "diff";
        _obj[173] = "diff";
        _obj[190] = "dot";
        _obj[110] = "dot";
        _obj[188] = "comma";
        break;
    }

    return _obj;
  }

  function getKeyCodeObjV2() {
    var _obj = {
      0: true,
      1: true,
      2: true,
      3: true,
      4: true,
      5: true,
      6: true,
      7: true,
      8: true,
      9: true,
      Backspace: true,
      Delete: true,
      //'clear',
      Tab: true,
      // for focusing out
      " ": true // space

    };
    var letters = {
      a: true,
      b: true,
      c: true,
      d: true,
      e: true,
      f: true,
      g: true,
      h: true,
      i: true,
      j: true,
      k: true,
      l: true,
      m: true,
      n: true,
      o: true,
      p: true,
      q: true,
      r: true,
      s: true,
      t: true,
      u: true,
      v: true,
      w: true,
      x: true,
      y: true,
      z: true
    };

    if (!isNumeric) {
      Object.keys(letters).forEach(function (i) {
        _obj[i] = letters[i];
      });
    }

    if (enterToSubmit) {
      _obj["enter"] = true;
    }

    switch (filterTypeInt) {
      case 14:
        // -- 0 to 9, Comma,Backspace, Clear, comma,hypen, (,)
        _obj[","] = true;
        _obj["-"] = true;
        _obj["("] = true;
        _obj[")"] = true;
        break;

      case 13:
        // All Gamar
        var firefoxAg = modelObj.LabComClass.BrowserDetect.browserUserAgentName().indexOf("Firefox") > -1; // -- 0 to 9,backspace,clear,ö,ü,ä,',',.

        _obj[","] = true;
        _obj["ä"] = true;
        _obj["ö"] = true;
        _obj["ü"] = true;
        _obj["ß"] = true;
        break;

      case 12:
        // -- 0 to 9, Comma,Backspace, Clear, - , ',' ,
        _obj[","] = true;
        _obj["-"] = true;
        break;

      case 11:
        var firefoxAgent = modelObj.LabComClass.BrowserDetect.browserUserAgentName().indexOf("Firefox") > -1; // -- 0 to 9,backspace,clear,ö,ü,ä.

        _obj["ä"] = true;
        _obj["ö"] = true;
        _obj["ü"] = true;
        break;

      case 9:
        // only = , <, >
        _obj = [];
        _obj["="] = true;
        _obj[">"] = true;
        _obj["<"] = true;
        break;

      case 7:
        // -- 0 to 9, Backspace, Clear, Decimal Point
        _obj["."] = true;
        break;

      case 10:
      case 6:
        // -- 0 to 9, Backspace, Clear, Comma
        _obj[","] = true;
        break;

      case 4:
      case 1:
      default:
        // -- 0 to 9, Backspace, Clear
        break;
    }

    return _obj;
  }

  function updateStage() {
    if (addedDecimal && valueStr.indexOf(".") === -1) {
      addedDecimal = false;
      maxLengthInt = defaultMaxLength;
    }

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "updateView"
    });
  }

  function updateValueStr(__str, __reset) {
    if (__str === "back") {
      valueStr = valueStr.substring(0, cursorIndex - 1) + valueStr.substring(cursorIndex, valueStr.length);
      cursorIndex--;
    } else if (__str === "clear") {
      valueStr = "";
      cursorIndex = 0;
    } else {
      // valueStr += __str;
      var txt = valueStr.substring(0, cursorIndex) + __str + valueStr.substring(cursorIndex, valueStr.length);

      if (contextObj.measureText(txt).width < modelObj.width) {
        valueStr = valueStr.substring(0, cursorIndex) + __str + valueStr.substring(cursorIndex, valueStr.length);
        cursorIndex++;

        if (__reset) {
          if (valueStr.indexOf(".") !== -1 && typeof rightMaxDecimalCountInt !== "undefined" && valueStr.split(".")[1].length > rightMaxDecimalCountInt) {
            valueStr = valueStr.substring(0, valueStr.length - 1);
            cursorIndex = valueStr.length;
          }

          if (!isNaN(Number(valueStr)) && valueStr !== "") {// if (minVal !== null && Number(valueStr) < minVal) {
            //   valueStr = minVal.toString();
            //   cursorIndex = valueStr.length;
            // }
            // if (maxVal !== null && Number(valueStr) > maxVal) {
            //   valueStr = maxVal.toString();
            //   cursorIndex = valueStr.length;
            // }
          }
        }
      }
    }

    if (cursorIndex < 0) cursorIndex = 0;

    if (valueStr.indexOf(".") === -1) {
      maxLengthInt = defaultMaxLength;
    }

    setCursorPosition();
  }

  function setCursorPosition(__key) {
    if (__key === "ArrowLeft" || __key === "Left") {
      cursorIndex--;

      if (cursorIndex < 0) {
        cursorIndex = 0;
      }
    } else if (__key === "ArrowRight" || __key === "Right") {
      cursorIndex++;

      if (cursorIndex > valueStr.length) {
        cursorIndex = valueStr.length;
      }
    }

    contextObj.font = fontSizeNum + "px " + fontFamilyStr; // valueStr === '' ? xInt + (widthInt / 2) : xInt + (widthInt / 2) + (cursorPositiontoText / 2) + 2;

    var clippedText = valueStr.substring(cursorIndex, valueStr.length);
    var clippedWidth = 0;

    if (clippedText !== "") {
      clippedWidth = contextObj.measureText(clippedText).width + 2;
    } // cursorPositiontoText = contextObj.measureText(valueStr).width - contextObj.measureText(clippedText).width;


    cursorPositiontoText = valueStr === "" ? xInt + widthInt / 2 : xInt + widthInt / 2 + contextObj.measureText(valueStr).width / 2 + 2 - clippedWidth;
  }

  function getMaxLength() {
    var lengthInt = maxLengthInt;

    switch (maxLengthFilterInt) {
      case 2:
        // -- Inlcude - . / , in maxLengthInt;
        break;

      case 1:
      default:
        // -- Exclude - . / , from maxLengthInt;
        if (valueStr.charAt(0) === "-") {
          lengthInt += 1;
        }

        if (valueStr.indexOf(".") !== -1) {
          lengthInt += 1;
        }

        if (valueStr.indexOf("/") !== -1) {
          lengthInt += 1;
        }

        if (valueStr.indexOf(",") !== -1) {
          lengthInt += valueStr.split(",").length - 1;
        }

        break;
    }

    return lengthInt;
  }

  function getIndex(text, diff) {
    contextObj.save();
    contextObj.textBaseline = "bottom";
    contextObj.font = fontSizeNum + "px " + fontFamilyStr;
    var index = text.length;
    diff = diff < 0 ? 0 : diff;
    var minDiff = diff;

    for (var i = 0; i < text.length; i++) {
      var w = contextObj.measureText(valueStr.substring(0, i)).width;

      if (Math.abs(diff - w) <= minDiff) {
        minDiff = Math.abs(diff - w);
        index = i;
      }
    }

    var total = contextObj.measureText(valueStr).width;

    if (diff >= total) {
      index = text.length;
    }

    contextObj.restore();
    return index;
  }

  function changeCursorPossitionByMouse(_dataObj) {
    contextObj.save();
    contextObj.textBaseline = "bottom";
    contextObj.font = fontSizeNum + "px " + fontFamilyStr;
    var total = contextObj.measureText(valueStr).width;
    contextObj.restore();
    var startX = xInt + textPadInt; // eslint-disable-next-line default-case

    switch (textAlignStr) {
      case "left":
        cursorIndex = getIndex(valueStr, _dataObj.pageX - startX);
        break;

      case "right":
        cursorIndex = getIndex(valueStr, _dataObj.pageX - (xInt + widthInt - total - textPadInt));
        break;

      case "center":
      case "default":
        cursorIndex = getIndex(valueStr, _dataObj.pageX - (xInt + widthInt / 2 - total / 2));
        break;
    }
  }

  function mouseEventHandler(_dataObj) {
    switch (_dataObj.type) {
      case "mouseupout":
        mouseEntered = false;
        break;
      // case 'mousedown':
      //   if (!self.hasFocus) {
      //     self.focusIn();
      //   }
      //   changeCursorPossitionByMouse(_dataObj);
      //   setCursorPosition();
      //   break;
      // case 'mouseup':
      //   if (!self.hasFocus) {
      //     self.focusIn();
      //   }
      //   changeCursorPossitionByMouse(_dataObj);
      //   mouseEntered = false;
      //   dispatchEvent('click');
      //   break;

      case "mouseenter":
        dispatchEvent("mouseenter");
        mouseEntered = true;
        break;

      case "mouseout":
        dispatchEvent("mouseout");
        mouseEntered = false;
        break;

      case "stageevent":
        if (!mouseEntered && showCursorBool && (numberPadCompId === null || [numberPadCompId, idStr].indexOf(_dataObj.id) === -1)) {
          self.focusOut(_dataObj.id);
        }

        break;

      default:
        break;
    }
  }

  function keyEventHandler(_ref) {
    var nativeEvent = _ref.nativeEvent,
        compId = _ref.compId;

    if (compId === idStr) {
      switch (nativeEvent.type) {
        case "keyup":
          switch (nativeEvent.key) {
            case "Enter":
              self.focusOut();
              break;

            default:
              // if (nativeEvent.key !== 'shift') {
              processCallback(nativeEvent.key, nativeEvent); // }

              break;
          }

          if (nativeEvent.type === "keyup" && (nativeEvent.key === "Enter" && modelObj.enterToSubmit || e.target.value == " " && modelObj.spaceToSubmit)) {
            dispatchEventForEnter("keyup");
          } else {
            dispatchEvent("keyup");
          }

          break;

        default:
          if (nativeEvent.type === "keydown" && nativeEvent.key === "Backspace") {
            nativeEvent.preventDefault();
          }

          break;
      }
    }
  }

  function getConfigurableVal(_argVal, _defaultVal) {
    if (_typeof(_argVal) === _typeof(_defaultVal)) {
      return _argVal;
    }

    return _defaultVal;
  }

  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: idStr
    }
  });
}
"use strict";

function RadioButtonCompClass(_obj) {
  var events = {};
  var modelObj = {
    disableColor: 'rgba(193, 170, 155, 1)',
    bgColor: 'rgba(112,146,190,0.5)',
    whitebgColor: 'rgba(255,255,255,0)',
    circleBGColor: 'rgba(255, 255, 255, 1)',
    downColor: 'rgba(255, 102, 0, 1)',
    borderColor: 'rgba(170, 170, 170, 1)',
    show: true,
    state: true,
    selected: null,
    selectedArr: [],
    x: 0,
    y: 0,
    bgTopPadding: 0,
    bgLeftPadding: 0,
    width: 200,
    height: 50,
    margin: 10,
    topMargin: 0,
    leftMargin: 0,
    padding: 10,
    radius: 13,
    textMaxWidth: 200,
    isItalic: false,
    isBold: false,
    fontSize: 15,
    data: [],
    fontColor: '#000000',
    orientation: 'v',
    isDraggable: false,
    bgVisible: false,
    correctOption: null
  };
  var localObj = {
    mouseEventData: {
      mouseMove: false,
      diffX: 0,
      diffY: 0
    }
  };
  var elements = [];
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });
  var isPressed = false;
  var baseWid = modelObj.playerConfigObj.baseWidth;
  var baseHgt = modelObj.playerConfigObj.baseHeight;
  setGlobalTexts();
  createDOM();
  calPosition();
  addEvents();
  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  });

  function createDOM() {
    var mainWrapper = document.getElementById('mainWrapper');

    var _radioWrapper = document.createElement('div');

    _radioWrapper.className = 'radioWrapper';

    _radioWrapper.setAttribute('id', 'radioWrapper_' + modelObj.id);

    mainWrapper.append(_radioWrapper);
    _radioWrapper.style.left = "".concat(modelObj.x, "px");
    _radioWrapper.style.top = "".concat(modelObj.y, "px");
    _radioWrapper.style.width = "".concat(modelObj.width, "px");
    _radioWrapper.style.height = "".concat(modelObj.height, "px");
    _radioWrapper.style.display = modelObj.show ? '' : 'none';
    _radioWrapper.style.color = modelObj.fontColor;
    _radioWrapper.style.fontFamily = modelObj.LabComClass.klettFontRegular;
    _radioWrapper.style.fontSize = "".concat(modelObj.fontSize, "px");
    createRadio();
  }

  function createRadio() {
    var _radioWrapper = document.getElementById("radioWrapper_".concat(modelObj.id));

    _radioWrapper.innerHTML = ''; // const ;

    modelObj.data.forEach(function (ques, i) {
      var _rowWrapper = document.createElement('div');

      _rowWrapper.classList.add('rowWrapper');

      _rowWrapper.setAttribute('id', "radioLabel_".concat(modelObj.id, "_").concat(i));

      _radioWrapper.appendChild(_rowWrapper); // let _radio = document.createElement('input');
      // _radio.setAttribute('type','radio');
      // _radio.setAttribute('name',`radio_${modelObj.id}`);
      // _radio.setAttribute('value',i);


      var _radio = document.createElement('button');

      _radio.classList.add('radioClass');

      _radio.classList.add("radio_".concat(modelObj.id));

      _radio.setAttribute('id', "radio_".concat(modelObj.id, "_").concat(i));

      _radio.setAttribute('role', "radio");

      _radio.setAttribute('aria-checked', "false");

      _radio.style.width = "".concat(modelObj.radius * 2, "px");
      _radio.style.height = "".concat(modelObj.radius * 2, "px");

      _rowWrapper.appendChild(_radio);

      var innerCircleRadius = Math.round(modelObj.radius * 2 * 0.5) % 2 === 0 ? Math.round(modelObj.radius * 2 * 0.5) : Math.round(modelObj.radius * 2 * 0.5) + 1;

      var _radioInnerCircle = document.createElement('div');

      _radioInnerCircle.classList.add('radioInnerCircle');

      _radioInnerCircle.classList.add("radioInnerCircle_".concat(modelObj.id));

      _radioInnerCircle.setAttribute('id', "radioInnerCircle_".concat(modelObj.id, "_").concat(i));

      _radioInnerCircle.style.width = "".concat(innerCircleRadius, "px");
      _radioInnerCircle.style.height = "".concat(innerCircleRadius, "px");

      _radio.appendChild(_radioInnerCircle);

      var _radioLabel = document.createElement('label');

      _radioLabel.classList.add('radioLabel');

      _radioLabel.setAttribute('id', "radioLabel_".concat(modelObj.id, "_").concat(i));

      _radioLabel.setAttribute('for', "radio_".concat(modelObj.id, "_").concat(i));

      _radioLabel.innerHTML = ques;

      _rowWrapper.appendChild(_radioLabel);
    });
  }

  function dispatchTrapFocus() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'updateTrapFocus',
      data: {
        id: modelObj.id,
        element: 'document.body'
      }
    });
  } // =================================================
  // PUBLIC SECTION
  // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  };

  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;

    var _radioWrapper = document.getElementById("radioWrapper_".concat(modelObj.id));

    _radioWrapper.style.left = "".concat(modelObj.x, "px");
    _radioWrapper.style.top = "".concat(modelObj.y, "px");
    updatePositions();
    addEvents();
  };

  this.setText = function (_textData) {
    modelObj.data = _textData;
    createRadio();
    calPosition();
    addEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  };

  this.getValue = function () {
    return modelObj.selected;
  };

  this.setCorrectOption = function (_val) {
    modelObj.correctOption = _val;
  };

  this.setValue = function (_val) {
    modelObj.selected = _val;
    modelObj.selectedArr = []; //Making Selected Arr Empty

    calPosition(); // DOM

    if (modelObj.selected === null) {
      // If null, all are deselected.
      document.querySelectorAll(".radioInnerCircle_".concat(modelObj.id)).forEach(function (_radio, i) {
        _radio.style.display = 'none';
      }); // aria checked ...

      document.querySelectorAll(".radio_".concat(modelObj.id)).forEach(function (_radio, i) {
        _radio.setAttribute('aria-checked', false);
      });
    } else {
      var _selected = document.getElementById("radioInnerCircle_".concat(modelObj.id, "_").concat(modelObj.selected));

      _selected.style.display = 'block';
      _selected.style.backgroundColor = modelObj.downColor; // reset
      // aria checked ...

      document.querySelectorAll(".radio_".concat(modelObj.id)).forEach(function (_radio, i) {
        if (i !== modelObj.selected) {
          _radio.setAttribute('aria-checked', false);
        } else {
          _radio.setAttribute('aria-checked', true);
        }
      });
    }
  };

  this.setMulVal = function (_val) {
    modelObj.selected = null; //Making Selected Empty

    modelObj.selectedArr = [];

    if (_val !== null) {
      _val.forEach(function (el) {
        modelObj.selectedArr.push(el);

        var _radioInnerCircles = document.querySelectorAll("#radioInnerCircle_".concat(modelObj.id, "_").concat(el));

        _radioInnerCircles.forEach(function (_ric, i) {
          _ric.style.color = modelObj.downColor;
          _ric.style.display = 'block';
        });
      });
    }

    calPosition();
  };

  this.show = function () {
    modelObj.show = true;
    var radioWrapper = document.getElementById("radioWrapper_".concat(modelObj.id));
    radioWrapper.style.display = '';
    addEvents();
  };

  this.getVisible = function () {
    return modelObj.show;
  };

  this.hide = function () {
    modelObj.show = false;
    var radioWrapper = document.getElementById("radioWrapper_".concat(modelObj.id));
    radioWrapper.style.display = 'none';
    addEvents();
  };

  this.enable = function () {
    modelObj.state = true; // const _container = document.getElementById(`containerWrapper_${modelObj.id}`);
    // modelObj.enable = true;
    // _container.style.pointerEvents = 'none';
    // _container.style.cursor = 'default';

    document.querySelectorAll(".radio_".concat(modelObj.id)).forEach(function (_radio, i) {
      _radio.setAttribute('tabIndex', 0);

      _radio.removeAttribute('disabled');

      _radio.addEventListener('click', onRadioClick);

      _radio.addEventListener('keydown', keyHandleDOM);

      var _label = document.getElementById("radioLabel_".concat(modelObj.id, "_").concat(i));

      _label.addEventListener('click', onRadioClick);
    });
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    document.querySelectorAll(".radio_".concat(modelObj.id)).forEach(function (_radio, i) {
      _radio.setAttribute('tabIndex', -1);

      _radio.setAttribute('disabled', true);

      _radio.removeEventListener('click', onRadioClick);

      var _label = document.getElementById("radioLabel_".concat(modelObj.id, "_").concat(i));

      _label.removeEventListener('click', onRadioClick);
    });
    document.querySelectorAll(".radioInnerCircle_".concat(modelObj.id)).forEach(function (_radio, i) {
      _radio.style.backgroundColor = modelObj.disableColor;
    });
    addEvents();
  };

  this.draws = function () {
    var _ctx = modelObj.context;

    if (modelObj.show) {
      _ctx.save();

      _ctx.lineWidth = 1;

      if (modelObj.bgVisible) {
        _ctx.beginPath();

        _ctx.strokeStyle = 'rgba(255,255,255,1)';
        _ctx.fillStyle = modelObj.whitebgColor;

        _ctx.rect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

        _ctx.fill();

        _ctx.stroke();

        _ctx.fillStyle = modelObj.bgColor;

        _ctx.fillRect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

        _ctx.closePath();
      }

      for (var _i = 0; _i < elements.length; _i++) {
        _ctx.beginPath();

        _ctx.beginPath();

        _ctx.fillStyle = elements[_i].baseColor;

        _ctx.arc(elements[_i].circleX, elements[_i].circleY, 13, 0, 2 * Math.PI);

        _ctx.fill();

        _ctx.closePath(); // if (_i === modelObj.correctOption) {
        //   drawCheckMark(_ctx, true, elements[_i].circleX + 5, elements[_i].circleY - 25, 18, 18);
        // } else if (_i === modelObj.selected) {
        //   drawCrossMark(_ctx, true, elements[_i].circleX + 5, elements[_i].circleY - 25, 18, 18);
        // }


        _ctx.beginPath();

        _ctx.fillStyle = elements[_i].fillColor;

        if (modelObj.selectedArr !== null && modelObj.selectedArr.length > 1) {
          modelObj.selectedArr.forEach(function (selected) {
            if (_i === selected && !modelObj.state) {
              _ctx.fillStyle = modelObj.disableColor;
            }
          });
        } else if (_i === modelObj.selected && !modelObj.state) {
          _ctx.fillStyle = modelObj.disableColor;
        }

        _ctx.arc(elements[_i].circleX, elements[_i].circleY, 6, 0, 2 * Math.PI);

        _ctx.fill();

        _ctx.closePath();

        _ctx.closePath();

        if (elements[_i].text) {
          _ctx.beginPath();

          var _str = '';
          var _xTxt = elements[_i].textX;
          var _yTxt = elements[_i].textY;
          _ctx.fillStyle = modelObj.fontColor;
          _str += elements[_i].isHeadItalic ? 'italic ' : '';
          _str += elements[_i].isHeadBold ? 'bold ' : '';
          _ctx.font = _str + "".concat(modelObj.fontSize, "px ") + modelObj.LabComClass.klettFontRegular;
          _ctx.textBaseline = 'middle';

          _ctx.drawImage(elements[_i].text, _xTxt, _yTxt, elements[_i].textWidth, elements[_i].textHeight);

          _ctx.closePath();
        }
      }

      _ctx.restore();
    }
  };

  function drawCheckMark(ctx) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var x = arguments.length > 2 ? arguments[2] : undefined;
    var y = arguments.length > 3 ? arguments[3] : undefined;
    var w = arguments.length > 4 ? arguments[4] : undefined;
    var h = arguments.length > 5 ? arguments[5] : undefined;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.closePath();

    if (status !== null) {
      if (status) {
        ctx.beginPath();
        ctx.fillStyle = 'rgba(112,188,38,1)';
        ctx.rect(x, y, w, h);
        ctx.fill();
        ctx.closePath();
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.moveTo(x + 2, y + 10);
        ctx.lineTo(x + 8, y + 14);
        ctx.lineTo(x + w - 2, y + 3);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }
    }
  }

  function drawCrossMark(ctx) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var x = arguments.length > 2 ? arguments[2] : undefined;
    var y = arguments.length > 3 ? arguments[3] : undefined;
    var w = arguments.length > 4 ? arguments[4] : undefined;
    var h = arguments.length > 5 ? arguments[5] : undefined;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.closePath();

    if (status !== null) {
      if (status) {
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,0,0,1)';
        ctx.rect(x, y, w, h);
        ctx.fill();
        ctx.closePath();
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.moveTo(x + w / 2 - 5, y + w / 2 - 5);
        ctx.lineTo(x + w / 2 + 5, y + w / 2 + 5);
        ctx.stroke();
        ctx.moveTo(x + w / 2 + 5, y + w / 2 - 5);
        ctx.lineTo(x + w / 2 - 5, y + w / 2 + 5);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }
    }
  } // =================================================
  // PRIVATE SECTION
  // ================================================


  function removeMouseEvents() {
    // DOM
    document.querySelectorAll(".radio_".concat(modelObj.id)).forEach(function (_radio, i) {
      // _radio.classList.remove("disabled");
      _radio.setAttribute('tabIndex', -1);

      _radio.setAttribute('disabled', true);

      _radio.removeEventListener('click', onRadioClick);

      _radio.removeEventListener('keydown', keyHandleDOM);

      var _label = document.getElementById("radioLabel_".concat(modelObj.id, "_").concat(i));

      _label.removeEventListener('click', onRadioClick);
    }); // CANVAS

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeMouseEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.show) {
      if (modelObj.state) {
        var _radioWrapper = document.getElementById("radioWrapper_".concat(modelObj.id));

        document.querySelectorAll(".radio_".concat(modelObj.id)).forEach(function (_radio, i) {
          // _radio.classList.remove("disabled");
          _radio.setAttribute('tabIndex', 0);

          _radio.removeAttribute('disabled');

          _radio.addEventListener('click', onRadioClick);

          _radio.addEventListener('keydown', keyHandleDOM);

          var _label = document.getElementById("radioLabel_".concat(modelObj.id, "_").concat(i));

          _label.addEventListener('click', onRadioClick);
        });
      }
    }

    if (modelObj.show) {
      if (modelObj.isDraggable) {
        _eventDataObj.r.push({
          id: 'base_' + modelObj.id,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: 'grab',
          downCursor: 'grabbing' // eventListener: mouseHandle.bind(this)

        });
      }

      if (modelObj.state) {
        for (var _i = 0; _i < elements.length; _i++) {
          _eventDataObj.r.push({
            id: 'circle_' + _i,
            arc: {
              x: elements[_i].circleX,
              y: elements[_i].circleY,
              r: elements[_i].circleRadius
            } // eventListener: mouseHandle.bind(this)

          });

          _eventDataObj.r.push({
            id: 'box_' + _i,
            rect: {
              x: elements[_i].textX,
              y: elements[_i].textY,
              w: elements[_i].textWidth,
              h: elements[_i].textHeight
            } // eventListener: mouseHandle.bind(this)

          });
        }
      }
    }

    dispatchTrapFocus();
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'addMouseEvent',
      data: _eventDataObj
    });
  } // =================================================


  function mouseHandleDOM(e) {} // =================================================


  function onRadioClick(e) {
    var _selected = this.id.split('_');

    modelObj.selected = +_selected.slice(-1)[0];
    console.log('Click', modelObj.selected);
    clickRadio();
  }

  function clickRadio() {
    // Deslecting all inner circle
    document.querySelectorAll(".radioInnerCircle_".concat(modelObj.id)).forEach(function (_innerCircle, i) {
      _innerCircle.style.display = 'none';
    }); // aria checked ...

    document.querySelectorAll(".radio_".concat(modelObj.id)).forEach(function (_radio, i) {
      if (i !== modelObj.selected) {
        _radio.setAttribute('aria-checked', false);
      } else {
        _radio.setAttribute('aria-checked', true);
      }
    });

    var _radioInnerCircle = document.getElementById("radioInnerCircle_".concat(modelObj.id, "_").concat(modelObj.selected));

    _radioInnerCircle.style.display = 'block';
    _radioInnerCircle.style.backgroundColor = modelObj.downColor;

    if (typeof events.change !== 'undefined') {
      events.change({
        id: modelObj.id,
        value: modelObj.selected
      });
    }
  }

  function keyHandleDOM(e) {
    // console.log('E',e.keyCode,e.key,this.id);
    var currentRadio = +this.id.split('_').slice(-1)[0]; // modelObj.selected = +_selected.slice(-1)[0];

    var parentWrapper = document.getElementById("radioWrapper_".concat(modelObj.id));
    var totalRadio = parentWrapper.childElementCount;

    switch (e.keyCode) {
      // Arrow Up
      case 38:
        if (currentRadio === 0) {
          modelObj.selected = totalRadio - 1;
        } else {
          modelObj.selected = currentRadio - 1;
        }

        clickRadio();
        var btn = document.getElementById("radio_".concat(modelObj.id, "_").concat(modelObj.selected));
        console.log('Down', modelObj.selected, btn.id);
        btn.focus();
        break;
      // Arrow Down

      case 40:
        if (currentRadio === totalRadio - 1) {
          modelObj.selected = 0;
        } else {
          modelObj.selected = currentRadio + 1;
        }

        clickRadio();
        var btn_ = document.getElementById("radio_".concat(modelObj.id, "_").concat(modelObj.selected));
        console.log('Up', modelObj.selected, btn_.id);
        btn_.focus();
        break;
    }
  } // =================================================


  function mouseHandle(e) {
    var oldX, oldY;

    switch (e.type) {
      case 'mousedown':
        isPressed = true;
        localObj.mouseEventData.mouseMove = false;
        localObj.mouseEventData.diffX = e.pageX - modelObj.x;
        localObj.mouseEventData.diffY = e.pageY - modelObj.y;
        break;

      case 'mouseenter':
        break;

      case 'mouseup':
        if (e.subId !== 'base_' + modelObj.id && !localObj.mouseEventData.mouseMove) {
          if (e.subId.indexOf('box_') >= 0 || e.subId.indexOf('circle_') >= 0) {
            var _str = e.subId.split('_');

            modelObj.selected = _str[1] * 1;
            calPosition();

            if (typeof events.change !== 'undefined') {
              events.change({
                id: modelObj.id,
                value: modelObj.selected
              });
            }
          }
        }

        localObj.mouseEventData.mouseMove = false;
        isPressed = false;
        break;

      case 'mouseupout':
        isPressed = false;
        break;

      case 'mouseout':
        break;

      case 'pressmove':
        if (modelObj.isDraggable) {
          oldX = modelObj.x;
          oldY = modelObj.y;
          localObj.mouseEventData.mouseMove = true;
          modelObj.x = e.pageX - localObj.mouseEventData.diffX;
          modelObj.y = e.pageY - localObj.mouseEventData.diffY;
          var maxX = baseWid - modelObj.width;
          var maxY = baseHgt - modelObj.height;
          var minY = 0;
          var minX = 0;
          modelObj.x = modelObj.x < minX ? minX : modelObj.x;
          modelObj.x = modelObj.x > maxX ? maxX : modelObj.x;
          modelObj.y = modelObj.y < minY ? minY : modelObj.y;
          modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;

          if (oldX === modelObj.x && oldY === modelObj.y) {
            localObj.mouseEventData.mouseMove = false;
          }

          updatePositions();
        }

        addEvents();
        break;

      case 'stageevent':
        break;

      default:
        break;
    }
  }

  function setGlobalTexts() {
    for (var _i = 0; _i < modelObj.data.length; _i++) {
      modelObj.data[_i] = modelObj.LabComClass.globalLangText[modelObj.data[_i]];
    }
  }

  function calPosition() {
    var _ctx = modelObj.context;
    var _str = '';

    _ctx.save();

    _str += modelObj.isItalic ? 'italic ' : '';
    _str += modelObj.isBold ? 'bold ' : '';
    _ctx.font = _str + "".concat(modelObj.fontSize, "px ") + modelObj.LabComClass.klettFontRegular;
    _ctx.textBaseline = 'top';
    elements.length = 0;
    var textParam = 0;

    for (var _i = 0; _i < modelObj.data.length; _i++) {
      textParam = _ctx.measureText(modelObj.data[_i]);
      var data = modelObj.context.textWrapperClass({
        xNum: 0,
        // modelCls.cPropObj.xInt,
        yNum: 0,
        // modelCls.cPropObj.yInt,
        fontFormat: 'px ',
        maxWidthNum: modelObj.textMaxWidth,
        textStr: modelObj.data[_i],
        fontFamilyStr: modelObj.LabComClass.klettFontRegular,
        fontSizeNum: modelObj.fontSize,
        color: modelObj.fontColor
      });
      elements.push({
        circleRadius: modelObj.radius,
        text: modelObj.data[_i] ? data.imageObj.imageObj : undefined,
        borderColor: modelObj.borderColor,
        baseColor: modelObj.circleBGColor,
        fillColor: _i === modelObj.selected ? modelObj.downColor : 'rgba(0,0,0,0)',
        textWidth: data.imageObj.widthInt,
        textHeight: data.imageObj.heightInt,
        textParam: textParam
      });
    }

    _ctx.restore();

    updatePositions();
  }

  function updatePositions() {
    var _x = modelObj.x + modelObj.bgLeftPadding;

    var _y = modelObj.y + modelObj.bgTopPadding;

    for (var i = 0; i < modelObj.data.length; i++) {
      elements[i].circleX = _x + modelObj.radius;
      elements[i].circleY = _y + modelObj.radius;
      elements[i].textX = _x + modelObj.padding + modelObj.radius * 2;
      elements[i].textY = _y + modelObj.radius - elements[i].textHeight / 2.5;

      if (modelObj.orientation === 'v') {
        _y += modelObj.radius * 2 + (modelObj.topMargin > 0 ? modelObj.topMargin : modelObj.margin);
      } else if (modelObj.orientation === 'h') {
        _x += modelObj.radius * 2 + (modelObj.leftMargin > 0 ? modelObj.leftMargin : modelObj.margin) + modelObj.padding + elements[i].textParam.width;
      } else if (modelObj.orientation === 'box') {
        var odd = i % 2;

        if (odd === 1) {
          _y = modelObj.y;
          _x += modelObj.radius * 2 + (modelObj.leftMargin > 0 ? modelObj.leftMargin : modelObj.margin) + modelObj.padding + elements[i].textParam.width;
        } else {
          _y += modelObj.radius * 2 + (modelObj.topMargin > 0 ? modelObj.topMargin : modelObj.margin);
        }
      }
    }
  }
}
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function ButtonCompClass(_obj) {
  var events = {};
  var modelObj = {
    x: 105,
    y: 313,
    width: 44,
    height: 30,
    visible: true,
    state: true,
    imgList: ["ArrowIcon.svg", "SolBtnIcon.svg"],
    hasImage: false,
    text: "",
    isItalic: false,
    isBold: false,
    fontSize: 16,
    textColor: "#ffffff",
    curveR: 15,
    imageAlign: "left",
    paddingLeft: 10,
    textPadding: 0,
    toggleMode: false,
    toggleState: false,
    shape: [],
    type: 1,
    // 1 for firstOrder blue & 2 for secondOrder light gray
    // -----------▼ do not use below keys without any supervisor permission ▼------------------------
    // bgColorState: {
    //   normal: "rgba(170, 170, 166, 1)", // #4592b0
    //   secondOrderNormal: "rgba(170, 170, 166, 1)", // #aaaaaa
    //   hover: "rgba(96, 96, 96, 1)", // #606060
    //   down: "rgba(96, 96, 96, 1)", // #606060
    //   disable: "rgba(233, 233, 233, 1)", // #e9e9e9
    // },
    // textColorState: {
    //   normal: "rgba(255, 255, 255, 1)", // #FFFFFF
    //   secondOrderNormal: "rgba(255, 255, 255, 1)", // #FFFFFF
    //   hover: "rgba(255, 255, 255, 1)", // #FFFFFF
    //   down: "rgba(255, 255, 255, 1)", // #FFFFFF
    //   disable: "rgba(142, 142, 142, 1)", // #8e8e8e
    // },
    // -----------▼ temporary for accesibility mode ▼------------------------
    bgColorState: {
      normal: "#757575",
      // #4592b0
      secondOrderNormal: "#757575",
      // #aaaaaa
      hover: "#606060 ",
      // #606060
      down: "#606060 ",
      // #606060
      disable: "#404040 " // #e9e9e9

    },
    textColorState: {
      normal: "#FFFFFF",
      // #FFFFFF
      secondOrderNormal: "#FFFFFF",
      // #FFFFFF
      hover: "FFFFFF",
      // #FFFFFF
      down: "FFFFFF",
      // #FFFFFF
      disable: "#C2C2C2" // #8e8e8e

    }
  };
  var isPressed = false;
  var isHover = false;
  var isFocused = false;
  var imgObj = {}; // window.ref = this;

  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });

  if (modelObj.type === 2) {
    modelObj.bgColorState.normal = modelObj.bgColorState.secondOrderNormal;
  }

  var _wd = modelObj.imageWidth > 0 ? modelObj.imageWidth : 27;

  var _ht = modelObj.imageHeight > 0 ? modelObj.imageHeight : 27;

  var _xTxt = modelObj.x + modelObj.width / 2 - _wd / 2;

  var _yTxt = modelObj.y + modelObj.height / 2 - _ht / 2;

  if (modelObj.LabComClass.globalLangText[modelObj.text]) {
    modelObj.text = modelObj.LabComClass.globalLangText[modelObj.text];
  } else {
    modelObj.text = "";
  }

  if (modelObj.imgList[0]) {
    modelObj.LabComClass.requestGlobalImage(modelObj.imgList, onImagesLoaded, onImagesLoadingError);
  } else {
    createDOM();
    addEvents();
  }

  function createDOM() {
    var mainWrapper = document.getElementById("mainWrapper");

    var _button = document.createElement("button");

    _button.classList.add("buttonClass");

    _button.setAttribute("id", "button_" + modelObj.id);

    _button.setAttribute("aria-label", modelObj.text);

    mainWrapper.append(_button);
    _button.style.left = "".concat(modelObj.x, "px");
    _button.style.top = "".concat(modelObj.y, "px");
    _button.style.width = "".concat(modelObj.width, "px");
    _button.style.height = "".concat(modelObj.height, "px");
    _button.style.borderRadius = "".concat(modelObj.height / 1.5, "px");
    _button.style.display = modelObj.visible ? "" : "none";
    _button.style.backgroundColor = modelObj.bgColorState.normal;
    _button.style.color = modelObj.textColor;
    _button.style.fontFamily = modelObj.LabComClass.klettFontRegular;
    _button.style.fontSize = "".concat(modelObj.fontSize, "px"); // Images inside button

    if (modelObj.id.includes("showSolution") || modelObj.id.includes("nextTask") || modelObj.hasImage) {
      _button.classList.add("btnWithImage");

      var _img = document.createElement("img");

      _img.classList.add("buttonImage");

      if (modelObj.hasImage) {
        _img.setAttribute("id", "btnImage_".concat(modelObj.id));

        _img.src = "assets/images/".concat(modelObj.imgList[0]);
      } else {
        _img.setAttribute("id", "btnImage_".concat(modelObj.id.includes("nextTask") ? "ArrowIcon" : "SolIcon"));

        _img.src = "assets/images/".concat(modelObj.id.includes("nextTask") ? modelObj.imgList[0] : modelObj.imgList[1]);
      }

      _button.append(_img);

      var _text = document.createElement("div");

      _text.classList.add("buttonText");

      _text.setAttribute("id", "buttonText_".concat(modelObj.id));

      _text.innerHTML = modelObj.text;

      _button.append(_text);
    } // else if (modelObj.id.includes("a11y_tool_SubmitBtn")) {
    //   const draggable_div = document.getElementById(
    //     `containerWrapper_a11yStep_1_Draggable`
    //   );
    //   _button.style.position = "absolute";
    //   _button.innerHTML = "Submit";
    //   draggable_div.append(_button);
    // }
    else {
        _button.innerHTML = modelObj.text;
      }

    setTimeout(function () {
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "componentLoaded",
        data: {
          id: modelObj.id
        }
      });
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "manageIndex",
        data: {
          id: modelObj.id,
          state: modelObj.state
        }
      });
    }, 100);
  } // =================================================
  // PUBLIC SECTION
  // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.setValue = function (_val) {
    modelObj.text = _val;
    var btn = document.getElementById("button_".concat(modelObj.id));

    if (btn.classList.contains("btnWithImage")) {
      var nestedText = document.getElementById("buttonText_".concat(modelObj.id));
      nestedText.innerHTML = _val; // btn.innerText = modelObj.text;
    } else {
      btn.innerHTML = modelObj.text;
    }
  };

  this.getVisible = function () {
    return modelObj.visible;
  };

  this.getValue = function () {
    return modelObj.text;
  };

  this.getSize = function () {
    return {
      width: modelObj.width,
      height: modelObj.height
    };
  };

  this.show = function () {
    modelObj.visible = true;
    var btn = document.getElementById("button_".concat(modelObj.id));
    btn.style.display = "";
    addEvents();
    dispatchTrapFocus();
  };

  this.hide = function () {
    modelObj.visible = false;
    isPressed = false;
    var btn = document.getElementById("button_".concat(modelObj.id));
    btn.style.display = "none";
    addEvents();
    dispatchTrapFocus();
  };

  this.setPos = function (x, y) {
    var obj = {};

    if (_typeof(x) === "object") {
      _obj = x;
    } else {
      _obj = {
        x: x,
        y: y
      };
    }

    updateValues(_obj, "x", "y");
    var btn = document.getElementById("button_".concat(modelObj.id));
    btn.style.left = "".concat(_obj.x, "px");
    btn.style.top = "".concat(_obj.y, "px");
    addEvents();
  };

  function updateValues(_data) {
    for (var _len = arguments.length, key = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      key[_key - 1] = arguments[_key];
    }

    key.forEach(function (i) {
      if (_data[i] !== undefined) {
        modelObj[i] = _data[i];
      }
    });
  }

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    var btn = document.getElementById("button_".concat(modelObj.id));
    btn.style.backgroundColor = modelObj.toggleMode && modelObj.toggleState ? modelObj.bgColorState.down : modelObj.bgColorState.normal;
    btn.style.color = modelObj.textColorState.normal;
    addEvents();
    dispatchTrapFocus();
  };

  this.disable = function () {
    modelObj.state = false;
    var btn = document.getElementById("button_".concat(modelObj.id));
    btn.style.backgroundColor = modelObj.bgColorState.disable;
    btn.style.color = modelObj.textColorState.disable;
    addEvents();
    dispatchTrapFocus();
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  };

  this.setToggleState = function (_flag) {
    modelObj.toggleState = _flag;
    var btn = document.getElementById("button_".concat(modelObj.id));

    if (modelObj.state) {
      btn.style.backgroundColor = modelObj.toggleMode && modelObj.toggleState ? modelObj.bgColorState.down : modelObj.bgColorState.normal;
    }
  };

  this.getToggleState = function () {
    return modelObj.toggleState;
  };

  this.showBorder = function () {
    isFocused = true;
    this.draw();
  };

  this.hideBorder = function () {
    isFocused = false;
    this.draw();
  }; // =================================================


  this.draws = function () {
    var _ctx = modelObj.context;

    var _x = modelObj.x + modelObj.paddingLeft;

    var _y = modelObj.y + modelObj.height / 2 - _ht / 2;

    if (modelObj.imageAlign === "center") {
      _x = modelObj.x + modelObj.width / 2 - _wd / 2;
    } // --------------------


    _ctx.save();

    var textColor = modelObj.textColor;

    if (modelObj.visible) {
      var img;
      var fillColor;
      var strokeColor;

      if (modelObj.state) {
        if (isPressed || modelObj.toggleState) {
          fillColor = modelObj.bgColorState.down;
          textColor = modelObj.textColorState.down;
          strokeColor = modelObj.bgColorState.down; // normal

          if (modelObj.imgList[1]) {
            img = imgObj[modelObj.imgList[1]];
          } else if (modelObj.imgList[0]) {
            // check image available or not
            img = imgObj[modelObj.imgList[0]];
          }
        } else {
          if (isHover) {
            fillColor = modelObj.bgColorState.normal; // hover

            textColor = modelObj.textColorState.normal;
          } else {
            fillColor = modelObj.bgColorState.normal;
            textColor = modelObj.textColorState.normal;
          }

          if (modelObj.imgList[0]) {
            img = imgObj[modelObj.imgList[0]];
          }
        }
      } else {
        fillColor = modelObj.bgColorState.disable;
        strokeColor = modelObj.bgColorState.disable;
        textColor = modelObj.textColorState.disable;

        if (modelObj.imgList[0]) {
          img = imgObj[modelObj.imgList[0]];
        }
      }

      if (modelObj.state && isPressed) {
        if (modelObj.imgList[1]) {
          img = imgObj[modelObj.imgList[1]];
        } else if (modelObj.imgList[0]) {
          img = imgObj[modelObj.imgList[0]];
        }
      } else if (modelObj.imgList[0]) {
        img = imgObj[modelObj.imgList[0]];
      }

      if (fillColor) {
        _ctx.fillStyle = fillColor;
      }

      if (strokeColor) {
        _ctx.strokeStyle = strokeColor;
      }

      roundRect(_ctx, modelObj.x, modelObj.y, modelObj.width, modelObj.height, modelObj.curveR, true, isPressed);

      if (img) {
        _ctx.drawImage(img, _x, _y, _wd, _ht);
      }

      if (isFocused) {
        _ctx.strokeStyle = "red";
        roundRect(_ctx, modelObj.x, modelObj.y, modelObj.width, modelObj.height, modelObj.curveR, false, true);
      }
    } // To add text on button


    if (modelObj.text && modelObj.visible) {
      _ctx.beginPath();

      _xTxt = modelObj.x + modelObj.textPadding + (modelObj.width - modelObj.textPadding) / 2;

      if (modelObj.imgList.length) {
        _xTxt = modelObj.x + modelObj.paddingLeft + _wd + (modelObj.width - modelObj.paddingLeft - _wd) / 2;
      }

      _yTxt = modelObj.y + modelObj.height / 2 + modelObj.fontSize * 0.6;
      _ctx.fillStyle = textColor;
      var _str = "";
      _str += modelObj.isItalic ? "italic " : "";
      _str += modelObj.isBold ? "bold " : "";
      _ctx.font = _str + "".concat(modelObj.fontSize, "px ") + modelObj.LabComClass.klettFontRegular;
      _ctx.textBaseline = "bottom";
      _ctx.textAlign = "center";

      _ctx.fillText(modelObj.text, _xTxt, _yTxt);

      _ctx.closePath();
    }

    if (modelObj.shape.length) {
      _ctx.save();

      _ctx.translate(modelObj.x + modelObj.paddingLeft, modelObj.y + modelObj.height / 2);

      for (var i = 0; i < modelObj.shape.length; i++) {
        // multiple shapes in different arrays
        for (var j = 0; j < modelObj.shape[i].length; j++) {
          // single shape
          eval("_ctx." + modelObj.shape[i][j]);
        }
      }

      _ctx.restore();
    }

    _ctx.restore();
  };

  function onImagesLoaded(_dataObj) {
    createDOM();
    addEvents();
    imgObj = _dataObj;
  }

  function onImagesLoadingError(_error) {
    console.log("Images Loading Error...");
  }

  function removeAllEvents() {
    // DOM
    var btn = document.getElementById("button_".concat(modelObj.id));
    btn.setAttribute("tabIndex", -1);
    btn.setAttribute("disabled", true);
    btn.removeEventListener("mousedown", mouseHandleDOM);
    btn.removeEventListener("mouseup", mouseHandleDOM);
    btn.removeEventListener("mouseover", mouseHandleDOM);
    btn.removeEventListener("mouseout", mouseHandleDOM);
    btn.removeEventListener("click", mouseHandleDOM); // CANVAS

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "removeMouseEvent",
      data: {
        id: modelObj.id
      }
    });
  } // =================================================


  function addEvents() {
    removeAllEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.state && modelObj.visible) {
      var btn = document.getElementById("button_".concat(modelObj.id));
      btn.addEventListener("mousedown", mouseHandleDOM);
      btn.addEventListener("mouseup", mouseHandleDOM);
      btn.addEventListener("mouseover", mouseHandleDOM);
      btn.addEventListener("mouseout", mouseHandleDOM);
      btn.addEventListener("click", mouseHandleDOM);
      btn.setAttribute("tabIndex", 0);
      btn.removeAttribute("disabled");
    }

    if (modelObj.state && modelObj.visible) {
      _eventDataObj.r.push({
        id: modelObj.id,
        rect: {
          x: modelObj.x,
          y: modelObj.y,
          w: modelObj.width,
          h: modelObj.height
        } // eventListener: mouseHandle.bind(this)

      });

      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "addMouseEvent",
        data: _eventDataObj
      });
    } // dispatchTrapFocus();

  }

  function dispatchTrapFocus() {
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "updateTrapFocus",
      data: {
        id: modelObj.id,
        element: "document.body"
      }
    });
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function mouseHandleDOM(e) {
    var btn = document.getElementById("button_".concat(modelObj.id));

    switch (e.type) {
      case "mousedown":
        btn.style.backgroundColor = modelObj.bgColorState.down;
        btn.style.color = modelObj.textColorState.down;
        isPressed = true;
        break;

      case "mouseup":
        isPressed = false;
        btn.style.backgroundColor = modelObj.bgColorState.normal;
        btn.style.color = modelObj.textColorState.normal;
        break;

      case "mouseover":
        break;

      case "mouseout":
        btn.style.backgroundColor = modelObj.toggleMode && modelObj.toggleState ? modelObj.bgColorState.down : modelObj.bgColorState.normal;
        btn.style.color = modelObj.textColorState.normal;
        break;

      case "click":
        onKeyPressed();
        addEvents();
        break;
    }
  } // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case "mousedown":
        isPressed = true;
        isHover = false;
        break;

      case "mouseup":
        onKeyPressed();
        addEvents();
        isPressed = false;
        break;

      case "mouseenter":
        isHover = true;
        isPressed = false;
        break;

      case "mouseout":
      case "mouseupout":
        isHover = false;
        isPressed = false;
        break;

      default:
        break;
    }
  }

  function onKeyPressed() {
    if (modelObj.toggleMode) {
      modelObj.toggleState = !modelObj.toggleState;
      var btn = document.getElementById("button_".concat(modelObj.id));
      btn.style.backgroundColor = modelObj.toggleState ? modelObj.bgColorState.down : modelObj.bgColorState.normal;
    }

    if (typeof events.click !== "undefined") {
      events.click({
        id: modelObj.id,
        value: isPressed,
        toggleState: modelObj.toggleState
      });
    }
  }

  function roundRect(ctx, x, y, width, height, radius, fill, stroke, drawUpperCorners, drawLowerCorners) {
    if (typeof stroke === "undefined") {
      stroke = true;
    }

    if (typeof radius === "undefined") {
      radius = 5;
    }

    if (typeof radius === "number") {
      if (drawUpperCorners) {
        radius = {
          tl: radius,
          tr: radius,
          br: 0,
          bl: 0
        };
      } else if (drawLowerCorners) {
        radius = {
          tl: 0,
          tr: 0,
          br: radius,
          bl: radius
        };
      } else {
        radius = {
          tl: radius,
          tr: radius,
          br: radius,
          bl: radius
        };
      }
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + (width - radius.tr), y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + (height - radius.br));
    ctx.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath();
    ctx.lineWidth = modelObj.strokeWidth;

    if (fill) {
      ctx.fill();
    }

    if (stroke) {
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function ZoomControlsCompClass(_obj) {
  var events = {};
  var modelObj = {
    visible: true,
    state: true,
    imgList: ["moveTop.svg", "moveBottom.svg", "moveLeft.svg", "moveRight.svg", "zoomReset.svg", "zoomIn.svg", "zoomOut.svg"],
    x: 1068,
    y: 573,
    buttonWidth: 30,
    buttonHeight: 30,
    movementInPxl: {
      moveLeft: {
        x: 10
      },
      moveRight: {
        x: -10
      },
      moveTop: {
        y: 10
      },
      moveBottom: {
        y: -10
      }
    },
    zoomInAriaLabel: "",
    zoomOutAriaLabel: "",
    zoomResetAriaLabel: "",
    moveLeftAriaLabel: "",
    moveBottomAriaLabel: "",
    moveTopAriaLabel: "",
    moveRightAriaLabel: "",
    buttons: [{
      type: "zoomOut",
      enable: true,
      text: "-",
      imgIndex: 6,
      ariaLabel: "zoomOutAriaLabel"
    }, {
      type: "zoomReset",
      enable: true,
      text: "o",
      //'◯',
      imgIndex: 4,
      ariaLabel: "zoomResetAriaLabel"
    }, {
      type: "zoomIn",
      enable: true,
      text: "+",
      imgIndex: 5,
      ariaLabel: "zoomInAriaLabel"
    }, {
      type: "moveLeft",
      enable: true,
      text: "←",
      imgIndex: 2,
      ariaLabel: "moveLeftAriaLabel"
    }, {
      type: "moveBottom",
      enable: true,
      text: "↓",
      imgIndex: 1,
      ariaLabel: "moveBottomAriaLabel"
    }, {
      type: "moveTop",
      enable: true,
      text: "↑",
      imgIndex: 0,
      ariaLabel: "moveTopAriaLabel"
    }, {
      type: "moveRight",
      enable: true,
      text: "→",
      imgIndex: 3,
      ariaLabel: "moveRightAriaLabel"
    }],
    resetVal: 1,
    currentBtn: null,
    isHover: false,
    isDown: false,
    keyDown: false
  };
  var imgObj = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });

  if (modelObj.imgList.length) {
    modelObj.LabComClass.requestGlobalImage(modelObj.imgList, onImagesLoaded, onImagesLoadingError);
  } else {
    onImagesLoaded({});
  }

  var baseCube = 32;
  var zoomFactor = 1.5;
  var data = [{
    pixelQube: baseCube * (zoomFactor / 1477.8918800354004),
    tick: 5000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 985.2612533569336),
    tick: 2000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 656.8408355712891),
    tick: 1000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 437.8938903808594),
    tick: 1000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 291.92926025390625),
    tick: 500,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 194.6195068359375),
    tick: 500,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 129.746337890625),
    tick: 200,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 86.49755859375),
    tick: 200,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 57.6650390625),
    tick: 100,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 38.443359375),
    tick: 100,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 25.62890625),
    tick: 50,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 17.0859375),
    tick: 50,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 11.390625),
    tick: 20,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 7.59375),
    tick: 20,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 5.0625),
    tick: 10,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 3.375),
    tick: 5,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 2.25),
    tick: 2,
    toFixed: 0
  }, {
    pixelQube: baseCube,
    tick: 1,
    toFixed: 0,
    reset: true
  }, {
    pixelQube: baseCube * (zoomFactor * 1),
    tick: 1,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor * 1.5),
    tick: 1,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor * 2.25),
    tick: 0.5,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 3.375),
    tick: 0.5,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 5.0625),
    tick: 0.2,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 7.59375),
    tick: 0.2,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 11.390625),
    tick: 0.1,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 17.0859375),
    tick: 0.1,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 25.62890625),
    tick: 0.05,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 38.443359375),
    tick: 0.05,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 57.6650390625),
    tick: 0.02,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 86.49755859375),
    tick: 0.02,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 129.746337890625),
    tick: 0.01,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 194.6195068359375),
    tick: 0.01,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 291.92926025390625),
    tick: 0.005,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 437.8938903808594),
    tick: 0.005,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 550),
    tick: 0.002,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 1800),
    tick: 0.001,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 3600),
    tick: 0.0005,
    toFixed: 4
  }, {
    pixelQube: baseCube * (zoomFactor * 7200),
    tick: 0.0002,
    toFixed: 4
  }, {
    pixelQube: baseCube * (zoomFactor * 15000),
    tick: 0.0001,
    toFixed: 4
  }, {
    pixelQube: baseCube * (zoomFactor * 30000),
    tick: 0.00005,
    toFixed: 5
  }, {
    pixelQube: baseCube * (zoomFactor * 80000),
    tick: 0.00002,
    toFixed: 5
  }, {
    pixelQube: baseCube * (zoomFactor * 190000),
    tick: 0.00001,
    toFixed: 5
  }];

  for (var i = 0; i < data.length; i++) {
    if (data[i].reset) {
      modelObj.resetVal = i;
      break;
    }
  }

  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass();

  function findGlobalText(text) {
    if (modelObj.LabComClass.globalLangText[text]) {
      return modelObj.LabComClass.globalLangText[text];
    }

    return "---";
  }

  createDOM(); // addEvents();

  function createDOM() {
    var mainWrapper = document.getElementById("mainWrapper");
    var zoomWrapper = document.createElement("div");
    zoomWrapper.classList.add("zoomWrapper");
    zoomWrapper.setAttribute("id", "zoomWrapper_" + modelObj.id);
    mainWrapper.append(zoomWrapper);
    zoomWrapper.style.left = "".concat(modelObj.x, "px");
    zoomWrapper.style.top = "".concat(modelObj.y, "px");
    zoomWrapper.style.width = "".concat(modelObj.buttonWidth * modelObj.buttons.length, "px");
    zoomWrapper.style.height = "".concat(modelObj.buttonHeight, "px");
    zoomWrapper.style.display = modelObj.visible ? "" : "none";
    modelObj.buttons.forEach(function (_btn, i) {
      var button = document.createElement("button");
      button.classList.add("zoomButtons");
      button.setAttribute("id", _btn.type);
      button.style.width = "".concat(modelObj.buttonWidth, "px");
      button.style.height = "".concat(modelObj.buttonHeight, "px");

      if (_btn.imgIndex >= 0) {
        button.innerHTML = "<img class ='zoomControlsCompClassImg' src = assets/images/".concat(modelObj.imgList[_btn.imgIndex], " />");
      } else {
        button.innerHTML = _btn.text;
      }

      button.style.color = "rgba(96, 96, 96, 1)";
      button.setAttribute("aria-label", findGlobalText(modelObj[_btn.ariaLabel]));
      zoomWrapper.append(button);
    });
  } // =================================================
  // PUBLIC SECTION
  // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.setValue = function (_val) {
    modelObj.zoomVal = _val;
    updateStates();
    var _obj = {
      id: modelObj.id,
      value: "zoomIn",
      data: data[modelObj.zoomVal]
    };

    if (typeof events.click !== "undefined") {
      events.click(_obj);
    }
  };

  this.getValue = function () {
    return {
      zoomVal: modelObj.zoomVal,
      resetVal: modelObj.resetVal
    };
  };

  this.setText = function (_val) {
    modelObj.text = _val;
  };

  this.getText = function () {
    return modelObj.text;
  };

  this.show = function () {
    modelObj.visible = true;
    var zoomWrapper = document.getElementById("zoomWrapper_".concat(modelObj.id));
    zoomWrapper.style.display = "";
    addEvents();
  };

  this.hide = function () {
    modelObj.visible = false;
    var zoomWrapper = document.getElementById("zoomWrapper_".concat(modelObj.id));
    zoomWrapper.style.display = "none";
    addEvents();
  };

  this.reset = function () {
    modelObj.zoomVal = modelObj.resetVal;
    updateControls({
      subId: "zoomReset",
      forceReset: true
    });
    updateStates();
  };

  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    var zoomWrapper = document.getElementById("zoomWrapper_".concat(modelObj.id));
    zoomWrapper.style.left = "".concat(modelObj.x, "px");
    zoomWrapper.style.top = "".concat(modelObj.y, "px");
    setPositions();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  }; // =================================================


  this.draws = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;
      var i; // --------------------

      _ctx.save();

      _ctx.beginPath();

      _ctx.strokeStyle = "rgba(35,35,35,0.2)";

      _ctx.rect(modelObj.x - 0.5, modelObj.y - 0.5, modelObj.buttonWidth * modelObj.buttons.length + 1, modelObj.buttonHeight + 1);

      _ctx.stroke();

      _ctx.closePath();

      for (i = 0; i < modelObj.buttons.length; i++) {
        if (modelObj.currentBtn !== modelObj.buttons[i].type) {
          drawShape(_ctx, modelObj.buttons[i]);
        }
      }

      for (i = 0; i < modelObj.buttons.length; i++) {
        if (modelObj.currentBtn === modelObj.buttons[i].type) {
          drawShape(_ctx, modelObj.buttons[i]);
        }
      }

      _ctx.restore();
    }
  };

  function drawShape(ctx, _obj) {
    ctx.save();
    var length = 5;
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,1)";

    if (_obj.enable && modelObj.isDown && modelObj.currentBtn === _obj.type) {
      ctx.fillStyle = "rgba(96, 96, 96, 1)";
    }

    ctx.rect(_obj.x, _obj.y, modelObj.buttonWidth, modelObj.buttonHeight);

    if (_obj.enable && modelObj.isHover && !modelObj.isDown && modelObj.currentBtn === _obj.type) {
      ctx.strokeStyle = "rgba(96, 96, 96, 1)";
      ctx.stroke();
    }

    ctx.fill();
    ctx.closePath();
    ctx.strokeStyle = "rgba(53,53,53,1)";

    if (!_obj.enable) {
      ctx.strokeStyle = "rgba(144,144,144,1)";
    }

    ctx.lineWidth = 1;

    if (_obj.enable && (modelObj.isHover || modelObj.isDown) && modelObj.currentBtn === _obj.type) {
      if (modelObj.isHover) {
        ctx.strokeStyle = "rgba(96, 96, 96, 1)";
      }

      if (modelObj.isDown) {
        ctx.strokeStyle = "rgba(255,255,255,1)";
      }

      ctx.lineWidth = 2;
    }

    switch (_obj.type) {
      case "zoomIn":
        ctx.beginPath();
        ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
        ctx.moveTo(-length, 0);
        ctx.lineTo(length, 0);
        ctx.stroke();
        ctx.moveTo(0, -length);
        ctx.lineTo(0, length);
        ctx.stroke();
        ctx.closePath();
        break;

      case "zoomReset":
        ctx.beginPath();
        ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
        ctx.arc(0, 0, length, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        break;

      case "zoomOut":
        ctx.beginPath();
        ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
        ctx.moveTo(-length, 0);
        ctx.lineTo(length, 0);
        ctx.stroke();
        ctx.closePath();
        break;

      case "moveLeft":
        drawArrow(ctx, _obj, 180 * Math.PI / 180);
        break;

      case "moveRight":
        drawArrow(ctx, _obj, 0);
        break;

      case "moveBottom":
        drawArrow(ctx, _obj, 90 * Math.PI / 180);
        break;

      case "moveTop":
        drawArrow(ctx, _obj, 270 * Math.PI / 180);
        break;

      default:
    }

    ctx.restore();
  }

  function drawArrow(ctx, _obj, angle) {
    var length = 7;
    var arrowHeight = 5;
    var arrowWidth = 6;
    ctx.save();
    ctx.beginPath();
    ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
    ctx.rotate(angle);
    ctx.moveTo(-length, 0);
    ctx.lineTo(length, 0);
    ctx.stroke();
    ctx.moveTo(length - arrowWidth, -arrowHeight);
    ctx.lineTo(length, 0);
    ctx.lineTo(length - arrowWidth, arrowHeight);
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
  }

  function onImagesLoaded(_dataObj) {
    imgObj = _dataObj;
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "componentLoaded",
      data: {
        id: modelObj.id
      }
    });
    setPositions();
  }

  function setPositions() {
    for (var i = 0; i < modelObj.buttons.length; i++) {
      modelObj.buttons[i].x = modelObj.x + modelObj.buttonWidth * i;
      modelObj.buttons[i].y = modelObj.y;
    }

    addEvents();
  }

  function onImagesLoadingError(_error) {
    console.log("Images Loading Error...");
  }

  function updateStates() {
    modelObj.buttons[0].enable = true;
    modelObj.buttons[1].enable = true;
    modelObj.buttons[2].enable = true;

    if (modelObj.zoomVal <= 0) {
      modelObj.buttons[0].enable = false;
    }

    if (modelObj.zoomVal >= data.length - 1) {
      modelObj.buttons[2].enable = false;
    }

    addEvents();
  } // =================================================


  function removeAllEvents() {
    // DOM
    modelObj.buttons.forEach(function (_btnData, i) {
      var btn = document.getElementById(_btnData.type);

      if (btn) {
        btn.removeEventListener("mouseenter", mouseHandleDOM);
        btn.removeEventListener("mouseout", mouseHandleDOM);
        btn.removeEventListener("mousedown", mouseHandleDOM);
        btn.removeEventListener("mouseup", mouseHandleDOM);
        btn.removeEventListener("keydown", mouseHandleDOM); // btn.removeEventListener('keypress',mouseHandleDOM);

        btn.removeEventListener("keyup", mouseHandleDOM); // btn.removeEventListener('click',mouseHandleDOM);

        btn.setAttribute("tabIndex", -1);
        btn.setAttribute("disabled", true);
      }
    }); // CANVAS

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "removeMouseEvent",
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeAllEvents(); // DOM

    if (modelObj.state
    /*&& modelObj.visible*/
    ) {
        modelObj.buttons.forEach(function (_btnData, i) {
          if (_btnData.enable) {
            var btn = document.getElementById(_btnData.type);

            if (btn) {
              btn.addEventListener("mouseenter", mouseHandleDOM);
              btn.addEventListener("mouseout", mouseHandleDOM);
              btn.addEventListener("mousedown", mouseHandleDOM);
              btn.addEventListener("mouseup", mouseHandleDOM);
              btn.addEventListener("keydown", mouseHandleDOM); // btn.addEventListener('keypress',mouseHandleDOM);

              btn.addEventListener("keyup", mouseHandleDOM); // btn.addEventListener('click',mouseHandleDOM);

              btn.setAttribute("tabIndex", 0);
              btn.removeAttribute("disabled");
            }
          }
        });
      } // CANVAS


    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    _eventDataObj.r.push({
      id: "base",
      rect: {
        x: modelObj.x,
        y: modelObj.y,
        w: modelObj.buttonWidth * 3,
        h: modelObj.buttonHeight
      },
      cursor: "default",
      eventListener: mouseHandle.bind(this)
    });

    if (modelObj.state && modelObj.visible) {
      for (var i = 0; i < modelObj.buttons.length; i++) {
        if (modelObj.buttons[i].enable) {
          _eventDataObj.r.push({
            id: modelObj.buttons[i].type,
            rect: {
              x: modelObj.buttons[i].x,
              y: modelObj.buttons[i].y,
              w: modelObj.buttonWidth,
              h: modelObj.buttonHeight
            },
            eventListener: mouseHandle.bind(this)
          });
        }
      }
    }

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "addMouseEvent",
      data: _eventDataObj
    });
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function mouseHandleDOM(e) {
    var _id = e.target.id;
    var animId = "scroll" + modelObj.id;
    var animationStarted = false;
    var delayCounter = 0;
    modelObj.currentBtn = _id;

    switch (e.type) {
      case "mousedown":
        modelObj.isDown = true;
        modelObj.animClass.stop(animId);

        if (!_id.includes("zoom")) {
          modelObj.animClass.start({
            id: animId,
            fps: 40,
            frame: function frame() {
              delayCounter++;

              if (delayCounter > 10) {
                animationStarted = true;
                updateControls(e);
              }
            }
          });
        }

        break;

      case "mouseup":
        if (!animationStarted) {
          updateControls(e);
        }

        modelObj.isDown = false;
        modelObj.animClass.stop(animId);
        break;

      case "keydown":
        // Space / Enter For TAB.
        if (!modelObj.keyDown && (e.keyCode === 32 || e.keyCode === 13)) {
          modelObj.isDown = true;
          modelObj.keyDown = true;
          modelObj.animClass.stop(animId);

          if (!_id.includes("zoom")) {
            modelObj.animClass.start({
              id: animId,
              fps: 40,
              frame: function frame() {
                delayCounter++;

                if (delayCounter > 10) {
                  animationStarted = true;
                  updateControls(e);
                }
              }
            });
          }
        }

        break;

      case "keyup":
        // Space / Enter For TAB.
        if (modelObj.keyDown && (e.keyCode === 32 || e.keyCode === 13)) {
          modelObj.keyDown = false;

          if (!animationStarted) {
            updateControls(e);
          }

          modelObj.isDown = false;
          modelObj.animClass.stop(animId);
        }

        break;
      // case 'mouseupout':
      //   modelObj.isDown = false;
      //   modelObj.isHover = false;
      //   modelObj.animClass.stop(animId);
      //   break;

      case "mouseenter":
        this.classList.add("zoomButtonsHover");
        this.style.borderColor = "rgba(96, 96, 96, 1)";
        break;

      case "mouseout":
        this.classList.remove("zoomButtonsHover");
        this.style.borderColor = "rgba(255,255,255,1)";
        modelObj.isHover = false;
        break;

      default:
        break;
    }
  } // This function handles all mouse events


  function mouseHandle(e) {// if (e.subId && e.subId !== 'base') {
    //   if (e.subId && e.subId !== 'base') {
    //     modelObj.currentBtn = e.subId;
    //   }
    //   const animId = 'scroll' + modelObj.id;
    //   // console.log('**ty',e.type);
    //   let animationStarted = false;
    //   let delayCounter = 0;
    //   // switch (e.type) {
    //   //   case 'mousedown':
    //   //     modelObj.isDown = true;
    //   //     modelObj.animClass.stop(animId);
    //   //     if (!(e.subId).includes('zoom')) {
    //   //       modelObj.animClass.start({
    //   //         id: animId,
    //   //         fps: 40,
    //   //         frame: () => {
    //   //           delayCounter++;
    //   //           if (delayCounter > 10) {
    //   //             animationStarted = true;
    //   //             updateControls(e);
    //   //           }
    //   //         },
    //   //       });
    //   //     }
    //   //     break;
    //   //   case 'mouseup':
    //   //     if (!animationStarted) {
    //   //       updateControls(e);
    //   //     }
    //   //     modelObj.isDown = false;
    //   //     modelObj.animClass.stop(animId);
    //   //     break;
    //   //   case 'mouseupout':
    //   //     modelObj.isDown = false;
    //   //     modelObj.isHover = false;
    //   //     modelObj.animClass.stop(animId);
    //   //     break;
    //   //   case 'mouseenter':
    //   //     if (e.subId && e.subId !== 'base') {
    //   //       modelObj.isHover = true;
    //   //     }
    //   //     break;
    //   //   case 'mouseout':
    //   //     modelObj.isHover = false;
    //   //     break;
    //   //   default:
    //   //     break;
    //   // }
    // }
  }

  function updateControls(e) {
    var _id = e.forceReset ? e.subId : e.target.id;

    if (modelObj.isDown && modelObj.currentBtn !== null || e.forceReset) {
      var _obj2 = {
        id: modelObj.id,
        value: _id
      };

      if (_id.includes("move")) {
        _obj2.data = {
          x: 0,
          y: 0
        };

        if (modelObj.movementInPxl[_id].x) {
          _obj2.data.x = modelObj.movementInPxl[_id].x;
        }

        if (modelObj.movementInPxl[_id].y) {
          _obj2.data.y = modelObj.movementInPxl[_id].y;
        }
      } else if (_id.includes("zoom")) {
        switch (_id) {
          case "zoomIn":
            modelObj.zoomVal++;
            break;

          case "zoomReset":
            modelObj.zoomVal = modelObj.resetVal;
            break;

          case "zoomOut":
            modelObj.zoomVal--;
            break;

          default:
        }

        if (modelObj.zoomVal < 0) {
          modelObj.zoomVal = 0;
        }

        if (modelObj.zoomVal > data.length - 1) {
          modelObj.zoomVal = data.length - 1;
        }

        _obj2.data = data[modelObj.zoomVal];
        updateStates();
      }

      if (typeof events.click !== "undefined") {
        events.click(_obj2);
      }
    }
  }
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function TimeLineCompClass(_obj) {
  var modelObj = {
    x: 0,
    y: 0,
    width: 100,
    height: 31,
    visible: true,
    bgColor: "rgba(255,255,255,0)",
    borderColor: "rgba(255,255,255,0)",
    borderWidth: 1,
    currentTask: 0,
    totalTasks: 4,
    fontSize: 14,
    maxVisibleTasks: 4,
    taskStatus: [],
    priviousTask: null,
    minTaskNumber: 0
  };
  var localObj = {
    currentTaskR: 7,
    currentTaskColor: "rgba(10,190,220,1)",
    currentTaskStrokeColor: "rgba(10,190,220,1)",
    complitedTaskR: 8,
    complitedTaskColor: "#338A05",
    //"rgba(65,180,5,1)",
    complitedTaskStrokeColor: "#338A05",
    //"rgba(65,180,5,1)",
    normalTaskR: 6,
    normalTaskColor: "#8C8C87",
    //"rgba(170,170,166,1)",
    normalTaskStrokeColor: "#8C8C87",
    //"rgba(170,170,166,1)",
    helpTaskR: 6,
    helpTaskColor: "#998B15",
    //"rgba(240,230,140,1)",
    helpTaskStrokeColor: "#998B15",
    //"rgba(240,230,140,1)",
    failedTaskR: 6,
    failedTaskColor: "rgba(255,0,0,1)",
    failedTaskStrokeColor: "rgba(255,0,0,1)",
    counterPos: {},
    leftArrowPos: {},
    rightArrowPos: {},
    arrowW: 21,
    pointsPos: [],
    leftArrow: {
      enable: false,
      visible: false
    },
    rightArrow: {
      enable: false,
      visible: false
    },
    totalTask: 4
  };
  var events = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });
  console.info("timeLineWrapper");
  createDOM(); // --------------------

  function createDOM() {
    var mainWrapper = document.getElementById("mainWrapper");
    var timeLineWrapper = document.createElement("div");
    timeLineWrapper.className = "timeLineWrapper";
    timeLineWrapper.setAttribute("id", "timeLineWrapper_" + modelObj.id);
    mainWrapper.append(timeLineWrapper);
    timeLineWrapper.style.left = "".concat(modelObj.x - 6, "px"); // These are offset will pass it dynamically to match the current UI placement

    timeLineWrapper.style.top = "".concat(modelObj.y - 4, "px"); // timeLineWrapper.style.width = `${modelObj.width}px`;

    timeLineWrapper.style.height = "".concat(modelObj.height, "px");
    timeLineWrapper.style.display = modelObj.visible ? "" : "none"; // lEFT button

    var leftBtn = document.createElement("button");
    leftBtn.classList.add("timeLineBtn", "timeLineLeftBtn");
    leftBtn.setAttribute("id", "timeLineBtn_Left_" + modelObj.id);
    leftBtn.setAttribute("aria-label", findGlobalText(modelObj === null || modelObj === void 0 ? void 0 : modelObj.leftAriaLabel));
    timeLineWrapper.append(leftBtn);
    leftBtn.style.borderLeftColor = localObj.normalTaskColor; // Ideally should be rightbordercolor, but it's rotated in css   /* done purposefully as there was some weird color shift in border color( right and bottom) as compared to top and left */
    // Task Circles

    for (var i = 0; i < modelObj.maxVisibleTasks; i++) {
      var _wrapper = document.createElement("div");

      _wrapper.className = "timeLineCircleWrapper";

      _wrapper.setAttribute("id", "timeCircleWrapper_".concat(modelObj.id, "_").concat(i));

      timeLineWrapper.append(_wrapper); // current task / selected -> arrow

      var _statusArrow = document.createElement("div");

      _statusArrow.className = "timeLineStatusArow";

      _statusArrow.setAttribute("id", "timeLineStatusArow_".concat(modelObj.id, "_").concat(i));

      _wrapper.append(_statusArrow);

      _statusArrow.style.borderTopColor = localObj.normalTaskColor;
      _statusArrow.style.display = "none";

      var _dot = document.createElement("div");

      _dot.className = "timeLineDot";

      _dot.setAttribute("id", "timeLineDot_".concat(modelObj.id, "_").concat(i));

      _wrapper.append(_dot);

      _dot.style.width = "".concat(localObj.normalTaskR * 2, "px");
      _dot.style.height = "".concat(localObj.normalTaskR * 2, "px");
      _dot.style.background = localObj.normalTaskColor; //localObj.normalTaskColor  localObj.normalTaskR
    } // right button


    var rightBtn = document.createElement("button");
    rightBtn.classList.add("timeLineBtn", "timeLineRightBtn");
    rightBtn.setAttribute("id", "timeLineBtn_Right_" + modelObj.id);
    rightBtn.setAttribute("aria-label", findGlobalText(modelObj === null || modelObj === void 0 ? void 0 : modelObj.rightAriaLabel));
    timeLineWrapper.append(rightBtn);
    rightBtn.style.borderLeftColor = localObj.normalTaskColor;
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "componentLoaded",
      data: {
        id: modelObj.id
      }
    });
  }

  calculatePoints(); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.getTotalTasks = function () {
    return modelObj.totalTasks;
  }; // =================================================


  this.getVisble = function () {
    return modelObj.visible;
  }; // =================================================
  //= ============== ANIMATION FUNCTIONS ===============


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;

    var _timeLine = document.getElementById("timeLineWrapper_" + modelObj.id);

    _timeLine.style.display = "";
    addEvents();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;

    var _timeLine = document.getElementById("timeLineWrapper_" + modelObj.id);

    _timeLine.style.display = "none";
    addEvents();
  };

  this.setTaskStatus = function (_data) {
    modelObj.taskStatus = _data;

    if (modelObj.taskStatus.length > 3) {
      modelObj.minTaskNumber = modelObj.taskStatus.length - 3;
    }

    if (modelObj.taskStatus.length === modelObj.totalTasks) {
      modelObj.minTaskNumber = modelObj.taskStatus.length - 4;
    }

    updateTaskDots();
  }; // =================================================


  this.draw_ = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;

      _ctx.save(); // background rectangle


      _ctx.beginPath();

      _ctx.fillStyle = modelObj.bgColor;
      _ctx.strokeStyle = modelObj.borderColor;
      _ctx.lineWidth = modelObj.borderWidth;

      _ctx.rect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

      _ctx.stroke();

      _ctx.fill();

      _ctx.closePath();

      var p = localObj.pointsPos;
      var w = 5; // circles

      for (var i = 0; i < p.length; i++) {
        _ctx.beginPath();

        _ctx.fillStyle = p[i].color;
        _ctx.strokeStyle = p[i].strokeColor;

        _ctx.arc(p[i].x, p[i].y, w, 0, Math.PI * 2);

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        if (p[i].selected) {
          _ctx.beginPath();

          _ctx.fillStyle = "rgba(170, 170, 166, 1)";
          _ctx.strokeStyle = "rgba(170, 170, 166, 1)";

          _ctx.moveTo(p[i].x, p[i].y - w - 3);

          _ctx.lineTo(p[i].x + 4, p[i].y - w - 7);

          _ctx.lineTo(p[i].x - 4, p[i].y - w - 7);

          _ctx.fill();

          _ctx.stroke();

          _ctx.closePath();
        }
      }

      var arrowTrangH = 6; // left arrow

      if (localObj.leftArrow.visible) {
        _ctx.beginPath();

        _ctx.fillStyle = "rgba(170, 170, 166, 1)";

        if (!localObj.leftArrow.enable) {
          _ctx.fillStyle = "rgba(233,233,233,1)";
        }

        _ctx.lineWidth = 2;
        var l = localObj.leftArrowPos;

        _ctx.moveTo(l.x, l.y);

        _ctx.lineTo(l.x + arrowTrangH, l.y - arrowTrangH);

        _ctx.lineTo(l.x + arrowTrangH, l.y + arrowTrangH);

        _ctx.fill();

        _ctx.closePath();
      }

      if (localObj.rightArrow.visible) {
        _ctx.beginPath();

        _ctx.fillStyle = "rgba(170, 170, 166, 1)";

        if (!localObj.rightArrow.enable) {
          _ctx.fillStyle = "rgba(233,233,233,1)";
        }

        _ctx.lineWidth = 2;
        var r = localObj.rightArrowPos;

        _ctx.moveTo(r.x, r.y);

        _ctx.lineTo(r.x - arrowTrangH, r.y - arrowTrangH);

        _ctx.lineTo(r.x - arrowTrangH, r.y + arrowTrangH);

        _ctx.fill();

        _ctx.closePath();
      }

      _ctx.restore();
    }
  };

  function calculatePoints() {
    var centerY = modelObj.y;
    var gap = 18;
    var startX = modelObj.x + gap;
    localObj.pointsPos = [];
    localObj.counterPos = {
      x: startX - 90,
      y: centerY
    };
    localObj.leftArrowPos = {
      x: modelObj.x,
      y: centerY
    };
    modelObj.taskStatus = [];

    for (var i = 0; i < modelObj.maxVisibleTasks; i++) {
      localObj.pointsPos.push({
        x: startX,
        y: centerY,
        r: localObj.normalTaskR,
        color: localObj.normalTaskColor
      });
      startX += gap;
    }

    localObj.rightArrowPos = {
      x: startX,
      y: centerY
    };
    updateTaskDots();
  }

  function updateTaskDots() {
    modelObj.currentTask = modelObj.currentTask < 0 ? 0 : modelObj.currentTask;
    modelObj.currentTask = modelObj.currentTask > modelObj.totalTasks - 1 ? modelObj.totalTasks - 1 : modelObj.currentTask;
    var min = modelObj.minTaskNumber;
    var taskCircles = document.querySelectorAll(".timeLineDot");

    for (var i = 0; i < localObj.pointsPos.length; i++) {
      var color = localObj.normalTaskColor;
      var strokeColor = localObj.normalTaskStrokeColor;
      var r = localObj.normalTaskR;
      localObj.pointsPos[i].selected = false;

      var _statusArrowArr = document.querySelectorAll(".timeLineStatusArow");

      _statusArrowArr[i].style.display = "none";

      if (modelObj.taskStatus[min + i]) {
        // Red
        color = localObj.failedTaskColor;
        strokeColor = localObj.failedTaskStrokeColor;
        r = localObj.failedTaskR; // yellow

        if (modelObj.taskStatus[min + i].totalShapesByHelp || modelObj.taskStatus[min + i].totalCorrectShapes) {
          color = localObj.helpTaskColor;
          strokeColor = localObj.helpTaskStrokeColor;
          r = localObj.helpTaskR;
        } // green


        if (modelObj.taskStatus[min + i].solved || modelObj.taskStatus[min + i].solvedWithHelp) {
          color = localObj.complitedTaskColor;
          strokeColor = localObj.complitedTaskStrokeColor;
          r = localObj.complitedTaskR;
        }
      } else if (min + i === modelObj.taskStatus.length) {
        color = localObj.currentTaskColor;
        strokeColor = localObj.currentTaskStrokeColor;
        r = localObj.currentTaskR;
      }

      if (min + i === modelObj.taskStatus.length) {
        localObj.pointsPos[i].selected = true;
        _statusArrowArr[i].style.display = "block";
        color = localObj.normalTaskColor;
        strokeColor = localObj.normalTaskStrokeColor;
        localObj.pointsPos[i].pointerColor = localObj.currentTaskColor;
        localObj.pointsPos[i].pointerStrokeColor = localObj.currentTaskStrokeColor;
      }

      localObj.pointsPos[i].color = color;
      localObj.pointsPos[i].strokeColor = strokeColor;
      localObj.pointsPos[i].r = r;
      taskCircles[i].style.background = color;
    }

    var leftBtn = document.getElementById("timeLineBtn_Left_" + modelObj.id);
    var rightBtn = document.getElementById("timeLineBtn_Right_" + modelObj.id);
    localObj.rightArrow.enable = false;
    localObj.rightArrow.visible = false;
    localObj.leftArrow.enable = false;
    localObj.leftArrow.visible = false;
    leftBtn.style.visibility = "hidden";
    rightBtn.style.visibility = "hidden";

    if (modelObj.minTaskNumber !== 0) {
      localObj.leftArrow.enable = true;
      localObj.leftArrow.visible = true;
      leftBtn.style.visibility = "";
    } // second condition added to not allow right button at the last task.


    if (modelObj.taskStatus.length >= modelObj.minTaskNumber + localObj.totalTask && modelObj.minTaskNumber + localObj.totalTask !== modelObj.totalTasks) {
      localObj.rightArrow.enable = true;
      localObj.rightArrow.visible = true;
      rightBtn.style.visibility = "";
    }

    addEvents();
  } // =================================================

  /*
   * This function is used to remove the mouse events.
   */


  function removeEvents() {
    var _btnArray = document.querySelectorAll(".timeLineBtn");

    _btnArray.forEach(function (_btn, i) {
      _btn.removeEventListener("click", mouseHandleDOM);

      _btn.setAttribute("tabIndex", -1);

      _btn.setAttribute("disabled", true);
    });

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "removeMouseEvent",
      data: {
        id: modelObj.id
      }
    });
  }

  function findGlobalText(text) {
    if (modelObj.LabComClass.globalLangText[text]) {
      return modelObj.LabComClass.globalLangText[text];
    }

    return "---";
  } // =================================================


  function addEvents() {
    removeEvents(); // DOM

    if (modelObj.visible) {
      if (localObj.leftArrow.enable) {
        var _btn = document.getElementById("timeLineBtn_Left_" + modelObj.id);

        _btn.addEventListener("click", mouseHandleDOM);

        _btn.setAttribute("tabIndex", 0);

        _btn.removeAttribute("disabled");
      }

      if (localObj.rightArrow.enable) {
        var _btn2 = document.getElementById("timeLineBtn_Right_" + modelObj.id);

        _btn2.addEventListener("click", mouseHandleDOM);

        _btn2.setAttribute("tabIndex", 0);

        _btn2.removeAttribute("disabled");
      }
    } // CANVAS


    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.visible) {
      var minArea = 25;

      if (localObj.leftArrow.enable) {
        _eventDataObj.r.push({
          id: "leftArrow",
          arc: {
            x: localObj.leftArrowPos.x,
            y: localObj.leftArrowPos.y,
            r: minArea
          },
          eventListener: mouseHandle.bind(this)
        });
      }

      if (localObj.rightArrow.enable) {
        _eventDataObj.r.push({
          id: "rightArrow",
          arc: {
            x: localObj.rightArrowPos.x,
            y: localObj.rightArrowPos.y,
            r: minArea
          },
          eventListener: mouseHandle.bind(this)
        });
      }
    } // onViewUpdateCls.trigger('onGlobalUpdate', {
    //   type: 'addMouseEvent',
    //   data: _eventDataObj
    // });

  } // =================================================


  function mouseHandleDOM(e) {
    // click event
    if (this.id.includes("Left")) {
      modelObj.minTaskNumber -= 1;
    } else if (this.id.includes("Right")) {
      modelObj.minTaskNumber += 1;
    }

    updateTaskDots();
  } // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case "mousedown":
        break;

      case "mouseup":
        if (e.subId === "leftArrow") {
          modelObj.minTaskNumber -= 1;
        } else if (e.subId === "rightArrow") {
          modelObj.minTaskNumber += 1;
        }

        updateTaskDots();
        break;

      case "mouseupout":
        break;

      default:
        break;
    }
  }
}
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function MsgBoxClass(_obj) {
  var images;
  var modelObj = {
    x: null,
    y: null,
    position: "top-left",
    prevX: null,
    prevY: null,
    width: 410,
    maxWidth: 410,
    height: 100,
    visible: false,
    bgColor: "rgba(0, 0, 0, 0.6)",
    baseColor: "#e0e0e0",
    headHeight: 40,
    headColor: "#999999",
    headText: "header",
    headTextX: 20,
    headTextY: 12,
    headFontSize: 20,
    headFontColor: "rgba(255, 255, 255, 1)",
    bodyTextX: 20,
    bodyTextY: 20,
    bodyFontSize: 16,
    bodyFontColor: "rgba(0, 0, 0, 1)",
    // radius: 5,
    radius: 0,
    strokeWidth: 1,
    isItalic: false,
    isBold: false,
    type: "alert",
    delayCount: 0,
    totalDelayCount: 0,
    alpha: 1,
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    defaultImages: ["whiteClose_btn_nrml.png", "whiteClose_btn_hvr.png"],
    closeBtn: {
      isHover: false,
      x: 0,
      y: 0,
      padding: 10,
      width: 24,
      radius: 24,
      height: 24
    },
    mousedown: {
      diffX: 0,
      diffY: 0
    },
    text: ""
  };
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------

  var thisObj = this;
  var textContextObjs = [];
  var events = {};
  var isPressed = false;
  var isHeaderPressed = false;
  var baseWid = modelObj.playerConfigObj.baseWidth;
  var baseHgt = modelObj.playerConfigObj.baseHeight; // --------------------
  // --------------------

  modelObj.text = modelObj.LabComClass.globalLangText[modelObj.bodyText];
  updateTextWrappers();
  createDOM();
  addEvents(); // --------------------

  modelObj.LabComClass.requestGlobalImage(_toConsumableArray(modelObj.defaultImages), onImageLoaded);

  function createDOM() {
    var mainWrapper = document.getElementById("mainWrapper");

    var _msgBoxWrapper = document.createElement("div");

    _msgBoxWrapper.className = "msgBoxWrapper";

    _msgBoxWrapper.setAttribute("id", "msgBoxWrapper_" + modelObj.id);

    mainWrapper.append(_msgBoxWrapper); // _msgBoxWrapper.setAttribute("tabIndex", 0);

    var _msgBoxHeader = document.createElement("div");

    _msgBoxHeader.className = "msgBoxHeader";

    _msgBoxHeader.setAttribute("id", "msgBoxHeader_" + modelObj.id);

    _msgBoxWrapper.append(_msgBoxHeader);

    var _msgBoxHeaderText = document.createElement("div");

    _msgBoxHeaderText.className = "msgBoxHeaderText";

    _msgBoxHeaderText.setAttribute("id", "msgBoxHeaderText_" + modelObj.id);

    _msgBoxHeader.append(_msgBoxHeaderText);

    var _msgBoxBody = document.createElement("div");

    _msgBoxBody.className = "msgBoxBody";

    _msgBoxBody.setAttribute("id", "msgBoxBody_" + modelObj.id);

    _msgBoxWrapper.append(_msgBoxBody);

    var _msgBoxCloseBtn = document.createElement("button");

    _msgBoxCloseBtn.className = "msgBoxCloseBtn";

    _msgBoxCloseBtn.setAttribute("id", "msgBoxCloseBtn_" + modelObj.id);

    _msgBoxCloseBtn.style.backgroundImage = "url(assets/images/".concat(modelObj.defaultImages[0], ")");

    _msgBoxHeader.append(_msgBoxCloseBtn);

    _msgBoxCloseBtn.setAttribute("disabled", true);

    _msgBoxCloseBtn.setAttribute("tabIndex", 0);

    _msgBoxCloseBtn.setAttribute("aria-hidden", false);

    _msgBoxCloseBtn.setAttribute("aria-label", modelObj.LabComClass.globalTextObj.ariaLabel["closeBtn"]); // Setting at default


    if (modelObj.position === "bottom-right") {
      // modelObj.x -= modelObj.width;
      // modelObj.y -= modelObj.height;
      _msgBoxWrapper.style.left = "".concat(modelObj.x, "px");
      _msgBoxWrapper.style.top = "".concat(modelObj.y, "px");
    }

    _msgBoxWrapper.style.width = "".concat(modelObj.width, "px");
    _msgBoxWrapper.style.height = "".concat(modelObj.height, "px");
    _msgBoxWrapper.style.display = modelObj.visible ? "" : "none";
    _msgBoxWrapper.style.borderColor = modelObj.type === "correct" ? "#7da961" : "#999999"; // Header

    _msgBoxHeader.style.color = modelObj.headFontColor;

    if (modelObj.type === "correct") {
      _msgBoxHeader.style.background = "#5E8849"; //"#7da961";
    } else if (modelObj.type === "incorrect") {
      _msgBoxHeader.style.background = "#7D7D7D"; //"#999999";
    } else {
      _msgBoxHeader.style.color = modelObj.headFontColor;
    }

    _msgBoxHeader.style.height = "".concat(modelObj.headHeight, "px");
    _msgBoxHeaderText.innerHTML = modelObj.LabComClass.globalLangText[modelObj.headText] ? modelObj.LabComClass.globalLangText[modelObj.headText] : "-";
    _msgBoxHeaderText.style.fontSize = "".concat(modelObj.headFontSize, "px"); // Body

    _msgBoxBody.style.background = modelObj.baseColor;

    if (modelObj.type === "correct") {
      _msgBoxBody.style.color = modelObj.bodyFontColor;
    } else if (modelObj.type === "incorrect") {
      _msgBoxBody.style.color = modelObj.bodyFontColor;
    } else {
      _msgBoxBody.style.color = modelObj.headColor;
    }

    _msgBoxBody.style.height = "".concat(modelObj.height - modelObj.headHeight, "px");
    _msgBoxBody.innerHTML = modelObj.text;
    _msgBoxBody.style.fontSize = "".concat(modelObj.bodyFontSize, "px");
  }

  function dispatchTrapFocus(element) {
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "updateTrapFocus",
      data: {
        id: modelObj.id,
        element: element
      }
    });
  } // =================================================
  // PUBLIC SECTION
  // =================================================


  this.show = function (_flag) {
    modelObj.visible = true; // modelObj.x = modelObj.defaultPos.x;
    // modelObj.y = modelObj.defaultPos.y;
    // Hiding others and showing 1

    document.querySelectorAll(".msgBoxWrapper").forEach(function (_box, i) {
      _box.style.display = "none";
    });

    var _msgBox = document.getElementById("msgBoxWrapper_".concat(modelObj.id));

    var _closeBtn = document.getElementById("msgBoxCloseBtn_".concat(modelObj.id));

    _msgBox.style.display = "flex";
    _closeBtn.style.backgroundImage = "url(assets/images/".concat(modelObj.defaultImages[0], ")"); // Image change to default

    isHeaderPressed = false;
    addEvents();

    _closeBtn.setAttribute("tabIndex", 0);

    _closeBtn.removeAttribute("disabled");

    dispatchTrapFocus("document.body"); // if (_flag) {

    setTimeout(function () {
      _closeBtn.focus();
    }, 200); // }
  };

  this.isVisible = function () {
    return modelObj.visible;
  };

  this.setValue = function (_text) {
    modelObj.text = _text;
    updateTextWrappers();

    var _msgBoxBody = document.getElementById("msgBoxBody_".concat(modelObj.id));

    _msgBoxBody.innerHTML = modelObj.text;

    var _msgBoxHeaderText = document.getElementById("msgBoxHeaderText_".concat(modelObj.id));

    _msgBoxHeaderText.setAttribute("aria-label", modelObj.text);
  };

  this.setPosition = function (x, y) {
    modelObj.x = x;
    modelObj.y = y;
    addEvents();
  };

  this.setFocus = function () {
    document.getElementById("msgBoxCloseBtn_".concat(modelObj.id)).focus();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;

    var _msgBox = document.getElementById("msgBoxWrapper_".concat(modelObj.id));

    _msgBox.style.display = "none";
    addEvents();

    var _closeBtn = document.getElementById("msgBoxCloseBtn_".concat(modelObj.id));

    _closeBtn.setAttribute("tabIndex", -1);

    _closeBtn.setAttribute("disabled", "");

    dispatchTrapFocus("document.body");
  }; // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.draws = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;

      _ctx.save(); // _ctx.globalAlpha = modelObj.alpha;
      // _ctx.globalAlpha = 0.5;
      // --------------------
      // Black drawing
      // _ctx.beginPath();
      // _ctx.fillStyle = modelObj.bgColor;
      // _ctx.fillRect(0, 0, baseWid, baseHgt);
      // _ctx.closePath();
      // --------------------
      // Base drawing


      _ctx.beginPath();

      _ctx.fillStyle = modelObj.baseColor;
      _ctx.strokeStyle = modelObj.headColor;

      if (modelObj.type === "correct") {
        _ctx.strokeStyle = "#7da961";
      }

      if (modelObj.type === "incorrect") {
        _ctx.strokeStyle = "#999999";
      }

      roundRect(_ctx, modelObj.x, modelObj.y, modelObj.width, modelObj.height, modelObj.radius, true, true, false, false);

      _ctx.closePath(); // --------------------
      // Head drawing


      _ctx.beginPath();

      _ctx.fillStyle = modelObj.headColor;

      if (modelObj.type === "correct") {
        _ctx.fillStyle = "#7da961";
      }

      if (modelObj.type === "incorrect") {
        _ctx.fillStyle = "#999999";
      }

      roundRect(_ctx, modelObj.x, modelObj.y, modelObj.width, modelObj.headHeight, modelObj.radius, true, false, true, false);

      _ctx.closePath(); // --------------------
      // Head Text drawing


      _ctx.beginPath();

      var _xTxt = modelObj.x + modelObj.headTextX;

      var _yTxt = modelObj.y + modelObj.headTextY;

      _ctx.fillStyle = modelObj.headFontColor;

      if (modelObj.type === "correct") {
        _ctx.fillStyle = "#ffffff";
      }

      _ctx.font = modelObj.headFontSize + "px " + modelObj.LabComClass.klettFontRegular;
      _ctx.textAlign = "left";
      _ctx.textBaseline = "bottom";
      var text = modelObj.LabComClass.globalLangText[modelObj.headText] ? modelObj.LabComClass.globalLangText[modelObj.headText] : "-";

      _ctx.fillText(text, _xTxt, _yTxt + modelObj.headFontSize);

      _ctx.closePath(); // --------------------


      if (typeof textContextObjs[0].imageObj !== "undefined") {
        _ctx.drawImage(textContextObjs[0].imageObj.imageObj, modelObj.x + modelObj.bodyTextX, modelObj.y + modelObj.headHeight + modelObj.bodyTextY, textContextObjs[0].imageObj.widthInt, textContextObjs[0].imageObj.heightInt);
      } // --------------------


      if (!modelObj.closeBtn.isHover) {
        _ctx.drawImage(images[modelObj.defaultImages[0]], modelObj.closeBtn.x - modelObj.closeBtn.width / 2, modelObj.closeBtn.y - modelObj.closeBtn.height / 2, modelObj.closeBtn.width, modelObj.closeBtn.height);
      } else {
        _ctx.drawImage(images[modelObj.defaultImages[1]], modelObj.closeBtn.x - modelObj.closeBtn.width / 2, modelObj.closeBtn.y - modelObj.closeBtn.height / 2, modelObj.closeBtn.width, modelObj.closeBtn.height);
      }

      _ctx.restore();
    }
  }; // =================================================
  // PRIVATE SECTION
  // =================================================


  function updateSize() {
    if (modelObj.x === null || modelObj.y === null) {
      modelObj.x = baseWid / 2 - modelObj.width / 2;
      modelObj.y = baseHgt / 2 - modelObj.height / 2;
    } else if (modelObj.position === "bottom-right") {
      modelObj.x -= modelObj.width;
      modelObj.y -= modelObj.height;
    }

    modelObj.defaultPos = {
      x: modelObj.x,
      y: modelObj.y
    };
    modelObj.closeBtn.x = modelObj.x + (modelObj.width - modelObj.closeBtn.padding - modelObj.closeBtn.width / 2);
    modelObj.closeBtn.y = modelObj.y + modelObj.headHeight / 2;
  } // =================================================


  function updateCloseBtnPosition() {
    modelObj.closeBtn.x = modelObj.x + (modelObj.width - modelObj.closeBtn.padding - modelObj.closeBtn.width / 2);
    modelObj.closeBtn.y = modelObj.y + modelObj.headHeight / 2;
    addEvents();
  } // =================================================


  function removeMouseEvents() {
    // DOM
    var _button = document.getElementById("msgBoxCloseBtn_".concat(modelObj.id));

    var _header = document.getElementById("msgBoxHeader_".concat(modelObj.id));

    var _msgBody = document.getElementById("msgBoxBody_".concat(modelObj.id)); // _button.removeEventListener('mousedown',mouseHandleDOM);
    // _button.removeEventListener('mouseup',mouseHandleDOM);


    _button.removeEventListener("click", mouseHandleDOM);

    _button.removeEventListener("mouseover", mouseHandleDOM);

    _button.removeEventListener("mouseout", mouseHandleDOM); // _button.setAttribute("tabIndex", -1);
    // _button.setAttribute("disabled", "");


    _header.removeEventListener("mousedown", mouseHandleDOM);

    _header.removeEventListener("mouseup", mouseHandleDOM);

    document.removeEventListener("mousemove", mouseHandleDOM);
    document.removeEventListener("mouseup", mouseHandleDOM);

    _msgBody.removeEventListener("mouseup", mouseHandleDOM); // CANVAS


    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "removeMouseEvent",
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeMouseEvents(); // DOM

    if (modelObj.visible) {
      var _button = document.getElementById("msgBoxCloseBtn_".concat(modelObj.id));

      var _header = document.getElementById("msgBoxHeader_".concat(modelObj.id));

      var _msgBody = document.getElementById("msgBoxBody_".concat(modelObj.id)); // _button.setAttribute("tabIndex", 0);
      // _button.removeAttribute("disabled");
      // _button.addEventListener('mousedown',mouseHandleDOM); // for click
      // _button.addEventListener('mouseup',mouseHandleDOM); // for click


      _button.addEventListener("click", mouseHandleDOM);

      _button.addEventListener("mouseover", mouseHandleDOM); // for hover


      _button.addEventListener("mouseout", mouseHandleDOM); // for hover


      _header.addEventListener("mousedown", mouseHandleDOM); // for moving the alert box


      _header.addEventListener("mouseup", mouseHandleDOM); // for moving the alert box


      document.addEventListener("mousemove", mouseHandleDOM); // for moving the alert box throughout document

      document.addEventListener("mouseup", mouseHandleDOM); // for moving the alert box throughout document - to stop the movement

      _msgBody.addEventListener("mouseup", mouseHandleDOM); // to not allow the box to close when firing up' on msg body.
      // _header.addEventListener('mousemove',mouseHandleDOM);

    } // CANVAS


    if (modelObj.visible === true) {
      modelObj.closeBtn.x = modelObj.x + (modelObj.width - modelObj.closeBtn.padding - modelObj.closeBtn.width / 2);
      modelObj.closeBtn.y = modelObj.y + modelObj.headHeight / 2;
      var _eventDataObj = {};
      _eventDataObj.id = modelObj.id;
      _eventDataObj.r = [];

      if (modelObj.alpha === 1) {
        _eventDataObj.r.push({
          id: 1,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: "default" // eventListener: mouseHandle.bind(this)

        });

        _eventDataObj.r.push({
          id: 2,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.headHeight
          } // cursor: 'default',
          // eventListener: mouseHandle.bind(this)

        });

        _eventDataObj.r.push({
          id: "close",
          arc: {
            x: modelObj.closeBtn.x,
            y: modelObj.closeBtn.y,
            r: modelObj.closeBtn.radius
          } // eventListener: mouseHandle.bind(this)

        });
      }

      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "addMouseEvent",
        data: _eventDataObj
      });
    }
  }

  function mouseHandleDOM(e) {
    // console.log(e.type,'MOUSE',this);
    var _msgBoxWrapper = document.getElementById("msgBoxWrapper_".concat(modelObj.id));

    switch (e.type) {
      case "mousedown":
        modelObj.mousedown.diffX = e.pageX - modelObj.x;
        modelObj.mousedown.diffY = e.pageY - modelObj.y;

        if (this.id.includes("Header")) {
          isHeaderPressed = true;
        }

        break;

      case "mouseup":
      case "click":
        // only for close msg box button.
        if (this.id && (this.id.includes("msgBoxBody") || this.id.includes("msgBoxHeader"))) {
          addEvents();
          isHeaderPressed = true; // Still it is clicked as clicking the header/body won't close the msg BOx

          break;
        } // need to check further ! console.log('EEEE',e,e.target);


        console.log(e.type, "---", document.activeElement.tagName, e.target.id);

        if (this.id && this.id.includes("msgBoxCloseBtn") || !isHeaderPressed && e.target.tagName !== "SELECT") {
          // !isHeaderPressed to close the msgbox if user clicks (mouseup to be specific) anywhere on the document other than header and msgBox
          console.log("CLOSE");
          popupClose();
        }

        addEvents();
        isHeaderPressed = false;
        break;

      case "mouseover":
        if (this.id.includes("msgBoxCloseBtn")) {
          this.style.backgroundImage = "url(assets/images/".concat(modelObj.defaultImages[1], ")");
        }

        break;

      case "mouseout":
        if (this.id.includes("msgBoxCloseBtn")) {
          this.style.backgroundImage = "url(assets/images/".concat(modelObj.defaultImages[0], ")");
        }

        break;

      case "mousemove":
        if (isHeaderPressed) {
          modelObj.x = e.pageX - modelObj.mousedown.diffX;
          modelObj.y = e.pageY - modelObj.mousedown.diffY; // _msgBoxWrapper.style.left = `${modelObj.x}px`;
          // _msgBoxWrapper.style.top = `${modelObj.y}px`;

          modelObj.maxX = baseWid - modelObj.width;
          var maxY = modelObj.maxY - modelObj.height;
          modelObj.x = modelObj.x < modelObj.minX ? modelObj.minX : modelObj.x;
          modelObj.x = modelObj.x > modelObj.maxX ? modelObj.maxX : modelObj.x;
          modelObj.y = modelObj.y < modelObj.minY ? modelObj.minY : modelObj.y;
          modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;
          _msgBoxWrapper.style.left = "".concat(modelObj.x, "px");
          _msgBoxWrapper.style.top = "".concat(modelObj.y, "px");
        }

        addEvents();
        break;
    }
  } // =================================================


  function mouseHandle(e) {
    switch (e.type) {
      case "mousedown":
        isPressed = true; // modelObj.mousedown.diffX = e.pageX - modelObj.x;
        // modelObj.mousedown.diffY = e.pageY - modelObj.y;

        break;

      case "mouseenter":
        if (e.subId === "close") {
          modelObj.closeBtn.isHover = true;
        }

        break;

      case "mouseup":
        switch (e.subId) {
          case "close":
            popupClose();
            break;

          default:
            break;
        }

        isPressed = false;
        break;

      case "mouseupout":
        isPressed = false;

        if (e.subId === "close") {
          modelObj.closeBtn.isHover = false;
        }

        break;

      case "mouseout":
        if (e.subId === "close") {
          modelObj.closeBtn.isHover = false;
        }

        break;

      case "pressmove":
        if (e.subId === 2) {// modelObj.x = e.pageX - modelObj.mousedown.diffX;
          // modelObj.y = e.pageY - modelObj.mousedown.diffY;
          // modelObj.maxX = baseWid - modelObj.width;
          // let maxY = (modelObj.maxY - modelObj.height);
          // modelObj.x = modelObj.x < modelObj.minX ? modelObj.minX : modelObj.x;
          // modelObj.x = modelObj.x > modelObj.maxX ? modelObj.maxX : modelObj.x;
          // modelObj.y = modelObj.y < modelObj.minY ? modelObj.minY : modelObj.y;
          // modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;
          // var maxX = baseWid - modelObj.width;
          // var maxY = (baseHgt - modelObj.height);
          // var minY = 0;
          // var minX = 0;
          // modelObj.x = modelObj.x < minX ? minX : modelObj.x;
          // modelObj.x = modelObj.x > maxX ? maxX : modelObj.x;
          // modelObj.y = modelObj.y < minY ? minY : modelObj.y;
          // modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;
        }

        addEvents();
        break;

      case "stageevent":
        if (!isPressed) {
          popupClose();
        }

        break;

      default:
        break;
    }
  } // =================================================


  function popupClose() {
    modelObj.delayCount = 0;
    thisObj.hide();
    modelObj.closeBtn.isHover = false;

    if (typeof events.popupClose !== "undefined") {
      events.popupClose({
        id: modelObj.id,
        type: "popupClose"
      }, true);
    }
  } // =================================================


  function onImageLoaded(_obj) {
    images = _obj;
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "componentLoaded",
      data: {
        id: modelObj.id
      }
    });
  }

  function roundRect(contextObj, x, y, width, height, radius, fill, stroke, drawUpperCornersOnly, drawRoundedSides) {
    if (typeof stroke === "undefined") {
      stroke = true;
    }

    if (typeof radius === "undefined") {
      radius = 5;
    }

    if (typeof radius === "number") {
      if (drawUpperCornersOnly) {
        radius = {
          tl: radius,
          tr: radius,
          br: 0,
          bl: 0
        };
      } else {
        radius = {
          tl: radius,
          tr: radius,
          br: radius,
          bl: radius
        };
      }
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    contextObj.beginPath();

    if (!drawRoundedSides) {
      contextObj.moveTo(x + radius.tl, y);
      contextObj.lineTo(x + (width - radius.tr), y);
      contextObj.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      contextObj.lineTo(x + width, y + (height - radius.br));
      contextObj.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
      contextObj.lineTo(x + radius.bl, y + height);
      contextObj.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
      contextObj.lineTo(x, y + radius.tl);
      contextObj.quadraticCurveTo(x, y, x + radius.tl, y);
    } else {
      contextObj.moveTo(x + radius.tl, y);
      contextObj.lineTo(x + (width - radius.tr), y);
      contextObj.arc(x + width, y + height / 2, height / 2, 3 * Math.PI / 2, Math.PI / 2);
      contextObj.lineTo(x + radius.bl, y + height);
      contextObj.arc(x, y + height / 2, height / 2, Math.PI / 2, 3 * Math.PI / 2);
    }

    contextObj.closePath();
    contextObj.lineWidth = modelObj.strokeWidth;

    if (fill) {
      contextObj.fill();
    }

    if (stroke) {
      contextObj.stroke();
    }
  }

  function updateTextWrappers() {
    textContextObjs = [];
    textContextObjs.push(modelObj.context.textWrapperClass({
      xNum: 0,
      // modelCls.cPropObj.xInt,
      yNum: 0,
      // modelCls.cPropObj.yInt,
      maxWidthNum: modelObj.maxWidth - modelObj.bodyTextX * 2,
      textStr: modelObj.text,
      fontFamilyStr: modelObj.LabComClass.klettFontRegular,
      fontSizeNum: modelObj.bodyFontSize,
      fontColor: modelObj.bodyFontColor,
      fontFormat: "px "
    }));
    modelObj.width = modelObj.maxWidth;
    modelObj.height = modelObj.headHeight + modelObj.bodyTextY + textContextObjs[0].imageObj.heightInt + modelObj.bodyTextY;
    updateSize();
  }
}
"use strict";

function ConstructPLineMathClass(_obj) {
  var modelObj = {};
  var brainObj = {};

  var _thisObj = this; // --------------------


  var events = {}; // --------------------

  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------
  // --------------------

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.findCirclesIntersect = function (c1, c2, c3) {
    // const a = c1.x;
    // const b = c1.y;
    // const r0 = c1.r;
    // const c = c2.x;
    // const d = c2.y;
    // const r1 = c2.r;
    // const D = Math.sqrt(Math.pow((c - a), 2), Math.pow((d - b), 2));
    // const p1 = D + r0 + r1;
    // const p2 = D + r0 - r1;
    // const p3 = D - r0 + r1;
    // const p4 = -1 * D + r0 + r1;
    // const p = (1 / 4) * (Math.sqrt(p1 * p2 * p3 * p4));
    // const xP1 = ((a + c) / 2);
    // const xP2 = ((c - a) * (Math.pow(r0, 2) - Math.pow(r1, 2))) / (2 * Math.pow(D, 2));
    // const xP3 = 2 * ((b - d) / Math.pow(D, 2)) * p;
    // const x1 = xP1 + xP2 + xP3;
    // const x2 = xP1 + xP2 - xP3;
    // const yP1 = (b + d) / 2;
    // const yP2 = ((d - b) * (Math.pow(r0, 2) - Math.pow(r1, 2))) / (2 * Math.pow(D, 2));
    // const yP3 = 2 * ((a - c) / Math.pow(D, 2)) * p;
    // const y1 = yP1 + yP2 - yP3;
    // const y2 = yP1 + yP2 + yP3;
    var midPoint = {
      x: (c1.x + c2.x) / 2,
      y: (c1.y + c2.y) / 2
    };
    var distance = Math.abs(modelObj.LabComClass.Maths.getDistance(c1, c2));
    var lengthHalf = distance / 2;
    var midPointAngle = modelObj.LabComClass.Maths.getAngle(c1.x, c1.y, midPoint.x, midPoint.y);
    var axis = Math.sqrt(c1.r * c1.r - lengthHalf * lengthHalf);
    var point1 = modelObj.LabComClass.Maths.getPoint(midPoint, Math.PI / 2 + midPointAngle, axis);
    var point2 = modelObj.LabComClass.Maths.getPoint(midPoint, Math.PI / 2 + midPointAngle, -1 * axis);
    point1.type = 'point';
    point2.type = 'point';
    var line = {
      type: 'line',
      l1: point1,
      l2: point2
    };
    var arry = [point1, point2, line];

    if (c3 !== undefined) {
      var data = _thisObj.findCircleLineIntersect(c3, line.l1, line.l2);

      for (var i = 0; i < data.length; i++) {
        arry.push(data[i]);
      }
    }

    return arry;
  };

  this.findCirclesIntersect2 = function (c1, c2, c3) {
    var J = 2 * c1.x - 2 * c2.x;
    var K = 2 * c1.y - 2 * c2.y;
    var L = Math.pow(c1.r, 2) - Math.pow(c2.r, 2) + (Math.pow(c2.x, 2) - Math.pow(c1.x, 2)) + (Math.pow(c2.y, 2) - Math.pow(c1.y, 2));
    var a = L + Math.pow(J, 2) / Math.pow(K, 2);
    var b = 2 * J * L / Math.pow(K, 2) + 2 * J * c1.y / K - 2 * c1.x;
    var c = Math.pow(c1.x, 2) + Math.pow(c1.y, 2) - Math.pow(c1.r, 2) + Math.pow(L, 2) / Math.pow(K, 2) + 2 * L * c1.y / K;
    var x1 = (-1 * b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
    var x2 = (-1 * b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
    var y1 = -1 * ((J * x1 + L) / K);
    var y2 = -1 * ((J * x2 + L) / K);
    var p1 = {
      type: 'point',
      x: x1,
      y: y1
    };
    var p2 = {
      type: 'point',
      x: x2,
      y: y2
    };
    var line = {
      type: 'line',
      l1: p1,
      l2: p2
    };
    var arry = [p1, p2, line];

    if (c3 !== undefined) {
      var data = _thisObj.findCircleLineIntersect(c3, line.l1, line.l2);

      for (var i = 0; i < data.length; i++) {
        arry.push(data[i]);
      }
    }

    return arry;
  };

  this.findCircleLineIntersect = function (point, line, linePoint2) {
    var m = (linePoint2.y - line.y) / (linePoint2.x - line.x);
    var c1 = line.y - m * line.x;
    var a = Math.pow(m, 2) + 1;
    var b = -2 * point.x + 2 * m * c1 - 2 * m * point.y;
    var c = Math.pow(point.x, 2) + Math.pow(c1, 2) + Math.pow(point.y, 2) - 2 * c1 * point.y - Math.pow(point.r, 2);
    var x1 = (-1 * b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
    var x2 = (-1 * b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
    var p1 = {
      type: 'point',
      x: x1,
      y: m * x1 + c1
    };
    var p2 = {
      type: 'point',
      x: x2,
      y: m * x2 + c1
    };
    var dist = modelObj.LabComClass.Maths.getDistance(p1, p2) / 2 + 0.1;
    var circle1 = {
      type: 'circle',
      x: p1.x,
      y: p1.y,
      r: dist
    };
    var circle2 = {
      type: 'circle',
      x: p2.x,
      y: p2.y,
      r: dist
    };
    return [p1, p2, circle1, circle2];
  };

  this.generateQuestion = function () {
    var line = {
      x: 0,
      y: modelObj.LabComClass.Maths.getRandomNumber(-15, -2, 0, 1)
    };
    var m = modelObj.LabComClass.Maths.getRandomNumber(1, 4, 1, 0.5);
    var c1 = line.y - m * line.x;
    var linePoint2 = {
      x: 5,
      y: m * 5 + c1
    };
    var point = {
      x: line.x,
      y: line.y,
      r: 3
    };
    var distance = modelObj.LabComClass.Maths.getPointLineDistance(point, line, linePoint2);

    while (Math.abs(distance) <= 1) {
      point = {
        x: modelObj.LabComClass.Maths.getRandomNumber(2, 6, 0, 1),
        y: modelObj.LabComClass.Maths.getRandomNumber(2, 6, 0, 1),
        r: 3
      };
      distance = modelObj.LabComClass.Maths.getPointLineDistance(point, line, linePoint2);
    }

    var a = Math.pow(m, 2) + 1;
    var b = -2 * point.x + 2 * m * c1 - 2 * m * point.y;
    var c = Math.pow(point.x, 2) + Math.pow(c1, 2) + Math.pow(point.y, 2) - 2 * c1 * point.y - Math.pow(point.r, 2);
    var x1 = (-1 * b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
    var x2 = (-1 * b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
    return {
      l1: line,
      l2: linePoint2,
      circle: point,
      intersect1: {
        x: x1,
        y: m * x1 + c1
      },
      intersect2: {
        x: x2,
        y: m * x2 + c1
      }
    };
  };

  this.getAllShapes = function (data) {
    data = JSON.parse(JSON.stringify(data));
    var ansData = [];
    ansData.push(data.c);
    ansData.push(data.g);
    var centerCircle = {};

    if (data.C === undefined) {
      centerCircle = {
        type: 'circle',
        x: data.c.x,
        y: data.c.y,
        r: Math.abs(modelObj.LabComClass.Maths.getPointLineDistance(data.c, {
          x: data.g.x,
          y: data.g.y
        }, {
          x: data.g.xTo,
          y: data.g.yTo
        })) + 1
      };
    } else {
      centerCircle = data.C;
    }

    ansData.push(centerCircle);

    var cLineIntP = _thisObj.findCircleLineIntersect(centerCircle, {
      x: data.g.x,
      y: data.g.y
    }, {
      x: data.g.xTo,
      y: data.g.yTo
    });

    var A;

    if (data.A === undefined) {
      A = cLineIntP[0];
      A.type = cLineIntP[0].type;
      A.label = 'A';
    } else {
      A = data.A;
    }

    ansData.push(A);
    var B;

    if (data.B === undefined) {
      B = cLineIntP[1];
      B.type = cLineIntP[1].type;
      B.label = 'B';
    } else {
      B = data.B;
    }

    ansData.push(B);
    var k1;

    if (data.k1 === undefined) {
      k1 = {
        type: 'circle',
        x: A.x,
        y: A.y,
        r: Math.abs(modelObj.LabComClass.Maths.getDistance(A, B)) / 2 + 1
      };
    } else {
      k1 = data.k1;
    }

    ansData.push(k1);
    var k2;

    if (data.k2 === undefined) {
      k2 = {
        type: 'circle',
        x: B.x,
        y: B.y,
        r: k1.r
      };
    } else {
      k2 = data.k2;
    }

    ansData.push(k2);

    var circleIntersect = _thisObj.findCirclesIntersect(k1, k2, centerCircle);

    var D = {
      type: circleIntersect[0].type,
      label: 'D'
    };
    Object.keys(circleIntersect[0]).forEach(function (i) {
      D[i] = circleIntersect[0][i];
    });
    ansData.push(D);
    var E = {
      type: circleIntersect[1].type,
      label: 'E'
    };
    Object.keys(circleIntersect[1]).forEach(function (i) {
      E[i] = circleIntersect[1][i];
    });
    ansData.push(E);
    var f = {
      type: circleIntersect[2].type,
      label: 'f',
      x: circleIntersect[2].l1.x,
      y: circleIntersect[2].l1.y,
      xTo: circleIntersect[2].l2.x,
      yTo: circleIntersect[2].l2.y
    };
    ansData.push(f);
    var F = {
      type: circleIntersect[3].type,
      label: 'F'
    };
    Object.keys(circleIntersect[3]).forEach(function (i) {
      F[i] = circleIntersect[3][i];
    });
    ansData.push(F);
    var G = {
      type: circleIntersect[4].type,
      label: 'G'
    };
    Object.keys(circleIntersect[4]).forEach(function (i) {
      G[i] = circleIntersect[4][i];
    });
    ansData.push(G);
    var k3;

    if (data.k3 === undefined) {
      k3 = {
        type: 'circle',
        x: F.x,
        y: F.y,
        r: Math.abs(modelObj.LabComClass.Maths.getDistance(F, G)) / 2 + 1
      };
    } else {
      k3 = data.k3;
    }

    ansData.push(k3);
    var k4;

    if (data.k4 === undefined) {
      k4 = {
        type: 'circle',
        x: G.x,
        y: G.y,
        r: k3.r
      };
    } else {
      k4 = data.k4;
    }

    ansData.push(k4);

    var finalCircleIntersect = _thisObj.findCirclesIntersect(k3, k4);

    var H = {
      type: finalCircleIntersect[0].type,
      label: 'H'
    };
    Object.keys(finalCircleIntersect[0]).forEach(function (i) {
      H[i] = finalCircleIntersect[0][i];
    });
    ansData.push(H);
    var I = {
      type: finalCircleIntersect[1].type,
      label: 'I'
    };
    Object.keys(finalCircleIntersect[1]).forEach(function (i) {
      I[i] = finalCircleIntersect[1][i];
    });
    ansData.push(I);
    var h = {
      type: finalCircleIntersect[2].type,
      label: 'h',
      x: finalCircleIntersect[2].l1.x,
      y: finalCircleIntersect[2].l1.y,
      xTo: finalCircleIntersect[2].l2.x,
      yTo: finalCircleIntersect[2].l2.y
    };
    ansData.push(h);
    return ansData;
  }; // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  };
}
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Gamar_38_Construct_equilateral_polygonsMathClass(_obj) {
  ConstructPLineMathClass.call(this, _obj);
  var defaultQuestions = [];
  var MathObj = null;

  this.setMathObj = function (_MathObj) {
    MathObj = _MathObj;
  };

  this.populateDefaultQuestions = function () {
    defaultQuestions.push(getDataForQuestionType1(0, 0, 0, 1, 5), getDataForQuestionType1(0, 0, 0, 1, 8), getDataForQuestionType2(0, 0, 0, 1, 6), getDataForQuestionType2(0, 0, 0, 1, 9), getDataForQuestionType3(0, 0, 0, 1, 5) // getDataForQuestionType2(18, 6, 6, 6, 4),
    // getDataForQuestionType2(12, 6, 24, 2, 4),
    // getDataForQuestionType2(16, 6, 16, 10.5, 4),
    );
  };

  this.toFixed = function (value) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return +value.toFixed(precision);
  };

  this.getQuestion = function (index) {
    return defaultQuestions[index];
  };

  function getDataForQuestionType1(cx, cy, x, y, polygonSides) {
    var centerAngle = 360 / polygonSides;
    var r = MathObj.getDistance({
      x: cx,
      y: cy
    }, {
      x: x,
      y: y
    });
    var points = [];

    for (var i = 1; i <= polygonSides; i++) {
      var point = MathObj.getPoint({
        x: cx,
        y: cy
      }, MathObj.TO_RADIANS * (i * centerAngle), r);
      points.push(_objectSpread(_objectSpread({}, point), {}, {
        x: point.y,
        y: point.x
      }));
    }

    return {
      centerAngle: centerAngle,
      circle: {
        x: cx,
        y: cy,
        label: "M",
        type: "circle",
        r: r
      },
      point: {
        x: x,
        y: y,
        type: "point",
        label: "A"
      },
      centerPoint: {
        x: cx,
        y: cy,
        type: "point",
        label: "M"
      },
      points: points,
      type: 1
    };
  }

  function getDataForQuestionType2() {
    return _objectSpread(_objectSpread({}, getDataForQuestionType1.apply(void 0, arguments)), {}, {
      type: 2
    });
  }

  function getDataForQuestionType3() {
    var question = getDataForQuestionType1.apply(void 0, arguments);
    var circle = question.circle,
        points = question.points;
    points = _toConsumableArray(points).reverse();
    var tangentIntersectionPoints = points.map(function (point, i) {
      i = i + 1;

      if (i >= points.length) {
        i = 0;
      }

      var point1 = point;
      var point2 = points[i];
      var newPoint1 = MathObj.getPoint(point1, MathObj.getAngle(circle.x, circle.y, point1.x, point1.y) + 90 * MathObj.TO_RADIANS, circle.r);
      var newPoint2 = MathObj.getPoint(point2, MathObj.getAngle(circle.x, circle.y, point2.x, point2.y) + 90 * MathObj.TO_RADIANS, circle.r);
      var intersectPoint = MathObj.getLineintersect(point1.x, point1.y, newPoint1.x, newPoint1.y, point2.x, point2.y, newPoint2.x, newPoint2.y);
      intersectPoint.forLinesPoints = [point1, point2];
      return intersectPoint;
    });
    return _objectSpread(_objectSpread({}, question), {}, {
      tangentIntersectionPoints: tangentIntersectionPoints,
      type: 3
    });
  }
}
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable indent */
function Gamar_38_Construct_equilateral_polygonsLogicClass(_obj) {
  var mathObj,
      Maths,
      currentStepData = [];
  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: _obj.id
    }
  });

  this.setMathObj = function (_mathObj, _Maths) {
    mathObj = _mathObj;
    Maths = _Maths;
  };

  this.reset = function () {
    currentStepData = [];
  };

  this.checkStep = function (step, data, question, getGraphdata) {
    var match = false;
    var completed = true;

    switch (question.type) {
      case 1:
        switch (step) {
          case 1:
            var _checkStep = checkStep1(data, question);

            var _checkStep2 = _slicedToArray(_checkStep, 2);

            match = _checkStep2[0];
            completed = _checkStep2[1];
            break;

          case 2:
            var _checkStep3 = checkStep2(data, question, getGraphdata);

            var _checkStep4 = _slicedToArray(_checkStep3, 2);

            match = _checkStep4[0];
            completed = _checkStep4[1];
            break;

          case 3:
            if (data.type === "angleSize" && currentStepData.length % 2 === 0) {
              var centerPoint = question.centerPoint,
                  centerAngle = question.centerAngle;
              var graphShapes = getGraphdata().visible;
              var lastDirection = graphShapes.find(function (shape) {
                return shape.type === "angleSize";
              }).clockwise;
              var point = graphShapes.reverse().find(function (shape) {
                return shape.type === "point";
              });
              match = checkPoints(data, centerPoint) && checkPoints({
                x: data.xTo,
                y: data.yTo
              }, point) && data.degree === centerAngle && lastDirection === data.clockwise;

              if (match) {
                currentStepData.push(data);
              }
            } else if (data.type === "point" && currentStepData.length % 2 !== 0) {
              var _checkStep5 = checkStep2(data, question, getGraphdata);

              var _checkStep6 = _slicedToArray(_checkStep5, 1);

              match = _checkStep6[0];
            }

            completed = currentStepData.length / 2 === question.points.length - 2;
            break;

          case 4:
            var _checkStep7 = checkStep4(data, question);

            var _checkStep8 = _slicedToArray(_checkStep7, 2);

            match = _checkStep8[0];
            completed = _checkStep8[1];
            break;

          default:
            break;
        }

        break;

      case 2:
        switch (step) {
          case 1:
            var _checkStep9 = checkStep1(data, question);

            var _checkStep10 = _slicedToArray(_checkStep9, 2);

            match = _checkStep10[0];
            completed = _checkStep10[1];
            break;

          case 2:
            var _checkStep11 = checkStep2(data, question, getGraphdata);

            var _checkStep12 = _slicedToArray(_checkStep11, 2);

            match = _checkStep12[0];
            completed = _checkStep12[1];
            break;

          case 3:
          case 4:
            if ((data.type === "compass" || data.type === "circle") &&
            /*&& (step === 3 || !data.newPlottedShapes)*/
            currentStepData.length % 2 === 0) {
              var _data$newPlottedShape;

              var _graphShapes = getGraphdata().visible;

              var points = _graphShapes.filter(function (shape) {
                return shape.type === "point";
              }).slice(-2);

              if (data.type === "circle" && ((_data$newPlottedShape = data.newPlottedShapes) === null || _data$newPlottedShape === void 0 ? void 0 : _data$newPlottedShape.length) === 2) {
                match = checkPoints(data, points[0]) && toFixed(Maths.getDistance(points[0], points[1])) === toFixed(data.r);
              } else {
                match = checkPoints(data, points[1]) && toFixed(Maths.getDistance(points[0], points[1])) === toFixed(data.r);
              }
            } else if (data.type === "point" && currentStepData.length % 2 !== 0) {
              var circle = question.circle;
              var prevCircle = currentStepData[currentStepData.length - 1];
              var intersectionPoints = Maths.getIntersectOfTwoCircles(circle.x, circle.y, circle.r, prevCircle.x, prevCircle.y, prevCircle.r);
              match = !!intersectionPoints.find(function (point) {
                return checkPoints(data, point);
              });
            }

            if (match) {
              currentStepData.push(data);
            }

            if (step === 3) {
              completed = currentStepData.length === 2;
            } else {
              completed = currentStepData.length / 2 === question.points.length - 3;
            }

            break;

          case 5:
            var _checkStep13 = checkStep4(data, question);

            var _checkStep14 = _slicedToArray(_checkStep13, 2);

            match = _checkStep14[0];
            completed = _checkStep14[1];
            break;

          default:
            break;
        }

        break;

      case 3:
        switch (step) {
          case 1:
          case 2:
          case 3:
            return this.checkStep(step, data, _objectSpread(_objectSpread({}, question), {}, {
              type: 1
            }), getGraphdata);

          case 4:
          case 5:
            if (data.type === "perpendicularLine" || data.type === "line" && !data.newPlottedShapes) {
              var _points = question.points,
                  _centerPoint = question.centerPoint;
              var shapes = getGraphdata().visible;
              var firstTwoPoints = shapes.filter(function (shape) {
                return shape.type === "point" && ["A", "B"].includes(shape.label);
              });

              var tanglentAndLinePoint = _points.find(function (point) {
                return checkPoints(point, data) && (step === 4 ? firstTwoPoints.find(function (point) {
                  return checkPoints(data, point);
                }) : true);
              });

              if (tanglentAndLinePoint) {
                shapes.pop();
                var degree = this.angleBetweenLines(data.x, data.y, data.xTo, data.yTo, _centerPoint.x, _centerPoint.y, tanglentAndLinePoint.x, tanglentAndLinePoint.y);
                match = Math.round(degree) === 90 && !shapes.find(function (shape) {
                  return (shape.type === "perpendicularLine" || shape.type === "line") && checkPoints(data, shape);
                });
              }
            } else if (data.type === "point") {
              var tangentIntersectionPoints = question.tangentIntersectionPoints;
              var tangentIntersectionPoint = tangentIntersectionPoints.find(function (point) {
                return checkPoints(data, point);
              });

              if (tangentIntersectionPoint) {
                var _shapes = getGraphdata().visible;

                _shapes.pop();

                var isTangentLinesDrawn = function isTangentLinesDrawn() {
                  return tangentIntersectionPoint.forLinesPoints.every(function (point) {
                    return _shapes.find(function (shape) {
                      return (shape.type === "perpendicularLine" || shape.type === "line") && checkPoints(point, shape);
                    });
                  });
                };

                match = !!tangentIntersectionPoint && !_shapes.find(function (shape) {
                  return shape.type === "point" && checkPoints(data, shape);
                }) && isTangentLinesDrawn();
              }
            }

            if (match) {
              currentStepData.push(data);
            }

            if (step === 4) {
              completed = currentStepData.length === 3;
            } else {
              completed = currentStepData.length === question.tangentIntersectionPoints.length * 2 - 3;
            }

            break;

          case 6:
            var _checkStep15 = checkStep4(data, question, question.tangentIntersectionPoints);

            var _checkStep16 = _slicedToArray(_checkStep15, 2);

            match = _checkStep16[0];
            completed = _checkStep16[1];
            break;
        }

      default:
        break;
    }

    if (completed) {
      currentStepData = [];
    }

    return [match, completed];
  };

  this.angleBetweenLines = function (A1x, A1y, A2x, A2y, B1x, B1y, B2x, B2y) {
    var dAx = A2x - A1x;
    var dAy = A2y - A1y;
    var dBx = B2x - B1x;
    var dBy = B2y - B1y;
    var angle = Math.atan2(dAx * dBy - dAy * dBx, dAx * dBx + dAy * dBy);

    if (angle < 0) {
      angle = angle * -1;
    }

    var degree_angle = angle * (180 / Math.PI);
    return +degree_angle.toFixed(2);
  };

  this.getDegree = function (angle, clockwise) {
    return Maths.abs(angle) * (clockwise ? -1 : 1);
  };

  this.getIntersectingPointsBetweenCircleAndLine = function (circle, line) {
    var point2Angle = Maths.getAngle(circle.x, circle.y, line.xTo, line.yTo);
    var point1Angle = point2Angle + Math.PI;
    var p1 = Maths.getPoint(circle, point1Angle, circle.r);
    var p2 = Maths.getPoint(circle, point2Angle, circle.r);
    p2.isInSegment = true;

    if (line.type === "line") {
      p1.isInSegment = true;
    }

    return {
      p1: p1,
      p2: p2
    };
  };

  this.checkPoints = checkPoints;

  function checkStep1(data, question) {
    var match = false;

    if (data.type === "ray") {
      var centerPoint = question.centerPoint,
          point = question.point;
      match = checkPoints(data, centerPoint) && checkPoints({
        x: data.xTo,
        y: data.yTo
      }, point);
    } else if (data.type === "centerAngleInput") {
      match = data.correct;
    }

    if (match) {
      currentStepData.push(data);
    }

    var completed = currentStepData.length === 2;
    return [match, completed];
  }

  function checkStep2(data, question, getGraphdata) {
    var match = false;

    if (data.type === "angleSize" && currentStepData.length % 2 === 0) {
      var centerPoint = question.centerPoint,
          point = question.point,
          centerAngle = question.centerAngle;
      match = checkPoints(data, centerPoint) && checkPoints({
        x: data.xTo,
        y: data.yTo
      }, point) && +data.degree === centerAngle;
    } else if (data.type === "point" && currentStepData.length % 2 !== 0) {
      var points = question.points;

      var isExitingPoint = function isExitingPoint() {
        var graphShapes = getGraphdata().visible;
        graphShapes.pop();
        return !!graphShapes.find(function (shape) {
          return shape.type === "point" && checkPoints(data, shape);
        });
      };

      match = !!points.find(function (point) {
        return checkPoints(data, point);
      }) && !isExitingPoint();
    }

    if (match) {
      currentStepData.push(data);
    }

    var completed = currentStepData.length === 2;
    return [match, completed];
  }

  function checkStep4(data, question, source) {
    var match = false;

    if (data.type === "segment") {
      if (!currentStepData.find(function (storedData) {
        return isSameConnection(storedData.connectionId, data.connectionId);
      })) {
        var points = source ? source : question.points;
        match = points.find(function (point, i) {
          i = i + 1;

          if (i >= points.length) {
            i = 0;
          }

          var p1 = point;
          var p2 = points[i];
          return checkPoints(data, p1) && checkPoints({
            x: data.xTo,
            y: data.yTo
          }, p2) || checkPoints(data, p2) && checkPoints({
            x: data.xTo,
            y: data.yTo
          }, p1);
        });
      }

      if (match) {
        var alreadyAdded = currentStepData.find(function (e) {
          return e.x == data.x && e.xTo == data.xTo && e.y == data.y && e.yTo == data.yTo;
        });
        !alreadyAdded && currentStepData.push(data);
      }
    }

    var completed = currentStepData.length === question.points.length;
    return [match, completed];
  }

  function toFixed(value) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    return mathObj.toFixed(value, precision);
  }

  function isSameConnection(array1, array2) {
    if (!(Array.isArray(array1) && Array.isArray(array2))) {
      return false;
    }

    return sort(array1).toString() === sort(array2).toString();
  }

  function sort(array) {
    return array.sort(function (a, b) {
      return a - b;
    });
  }

  function checkPoints(point1, point2) {
    if (!(point1 && point2)) {
      return false;
    }

    return toFixed(point1.x) === toFixed(point2.x) && toFixed(point1.y) === toFixed(point2.y);
  }
}
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable react/no-this-in-sfc */
function PlayerClass() {
  // ===================================================================================
  function ModelClass() {
    var thisObj = this;
    var hasOProp = Object.prototype.hasOwnProperty;
    this.cPropObj = {}; // controller prop

    this.vPropObj = {}; // view prop

    this.sildePropObj = {}; // slide property
    // ----------------------------

    onModelUpdateCls.on("setCProp", onSetCProp);
    onModelUpdateCls.on("setVProp", onSetVProp);
    onModelUpdateCls.on("setSlideProp", onSetSlideProp); // ----------------------------

    LabComClass.defineObject(this.cPropObj, "playerPath", ""); // path to the player

    LabComClass.defineObject(this.cPropObj, "playerConfigObj", {}); // html dom wrapper to append stage

    LabComClass.defineObject(this.cPropObj, "globalTextObj", {}); // html dom wrapper to append stage

    LabComClass.defineObject(this.cPropObj, "configObj", {}); // config to launch leeson character names

    LabComClass.defineObject(this.cPropObj, "deviceTypeBool", false); // Is player running on devices.

    LabComClass.defineObject(this.cPropObj, "audioContextCls", new AudioContextClass()); // Global BGs for lesson holder.

    LabComClass.defineObject(this.cPropObj, "audioNativeCls", new AudioNativeClass()); // Global BGs for lesson holder.

    LabComClass.defineObject(this.cPropObj, "mouseHandleCls", new MouseHandlerClass()); // Global BGs for lesson holder.

    LabComClass.defineObject(this.cPropObj, "keyHandlerCls", new KeyHandlerClass()); // Navigation.

    LabComClass.defineObject(this.cPropObj, "labObj", {}); // Gizmo Structure.

    LabComClass.defineObject(this.cPropObj, "compListObj", {}); // All global component list.

    LabComClass.defineObject(this.cPropObj, "brainObj", {}); // Brain component.

    LabComClass.defineObject(this.cPropObj, "compCountInt", 0); // All global component list.

    LabComClass.defineObject(this.cPropObj, "totalCompCountInt", 0); // All global component list.

    LabComClass.defineObject(this.cPropObj, "activityObj", {}); // All global component list.

    LabComClass.defineObject(this.cPropObj, "interactiveLayerArr", []); // All interactive elements with layer.

    LabComClass.defineObject(this.cPropObj, "toolsUsed", []);
    LabComClass.defineObject(this.cPropObj, "indexingArr", []);
    LabComClass.defineObject(this.cPropObj, "tabCounter", -1); // ----------------------------

    LabComClass.defineObject(this.vPropObj, "domLayerObj", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "headerObj", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "helpObj", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "headerLogoItemObj", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "headerLogoObj", document.createElement("img"));
    LabComClass.defineObject(this.vPropObj, "headerTextObj", document.createElement("h1"));
    LabComClass.defineObject(this.vPropObj, "headerHelpObjWrapper", document.createElement("div")); //changed

    LabComClass.defineObject(this.vPropObj, "headerHelpObjMenu", document.createElement("div")); //changed

    LabComClass.defineObject(this.vPropObj, "headerHelpObj", document.createElement("button")); //changed

    LabComClass.defineObject(this.vPropObj, "headerHelpIconObj", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "headerCopyRightObjWrapper", document.createElement("div")); //changed

    LabComClass.defineObject(this.vPropObj, "headerCopyRightObjMenu", document.createElement("div")); //changed

    LabComClass.defineObject(this.vPropObj, "headerCopyRightObj", document.createElement("button")); //changed
    // MainWrapper apart from header

    LabComClass.defineObject(this.vPropObj, "mainWrapper", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "infoPopupObj", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "headerCopyRightIconObj", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "questionWrapper", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "taskTableWrapper", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "toolPanelWrapper", document.createElement("div"));
    LabComClass.defineObject(this.vPropObj, "preloadObj", document.createElement("div")); // Div to show Pre-loader

    LabComClass.defineObject(this.vPropObj, "bgCanvasObj", document.createElement("canvas")); // Canvas to show the background

    LabComClass.defineObject(this.vPropObj, "bgContextObj", {}); // Context to show the background

    LabComClass.defineObject(this.vPropObj, "contCanvasObj", document.createElement("canvas")); // Canvas to show the content

    LabComClass.defineObject(this.vPropObj, "virtualCanvasObj", document.createElement("canvas")); // Virtual Canvas to calculate the content

    LabComClass.defineObject(this.vPropObj, "contContextObj", {}); // Context to show the content

    LabComClass.defineObject(this.vPropObj, "mouseCanvasObj", document.createElement("canvas")); // Canvas for buttons

    LabComClass.defineObject(this.vPropObj, "mTextWrapperObj", document.createElement("canvas")); // Canvas

    LabComClass.defineObject(this.vPropObj, "snapshotCnvObj", document.createElement("canvas")); // Canvas

    LabComClass.defineObject(this.vPropObj, "playerImagesObj", {}); // Canvas

    LabComClass.defineObject(this.vPropObj, "componentImagesObj", {}); // Canvas

    LabComClass.defineObject(this.vPropObj, "resizeTimeoutObj", {}); // wait for resize.

    LabComClass.defineObject(this.vPropObj, "scaledDataObj", {}); // Scale resize value

    LabComClass.defineObject(this.vPropObj, "bgImageObj", {}); // Scale resize value
    // ----------------------------
    // Setter and getter for controller properties

    function onSetCProp(_dataObj, _typeStr) {
      updateProp(_dataObj, _typeStr, "cPropObj");
    } // ----------------------------
    // Setter and getter for view properties


    function onSetVProp(_dataObj, _typeStr) {
      updateProp(_dataObj, _typeStr, "vPropObj");
    } // ----------------------------
    // Setter and getter for slide properties


    function onSetSlideProp(_dataObj, _typeStr) {
      updateProp(_dataObj, _typeStr, "sildePropObj");
    } // ----------------------------
    // Add/Update properties.


    function updateProp(_dataObj, _typeStr, _varRef) {
      var _tempArr = []; // Whatever properties got updated, the names will be transferred to the event.

      Object.keys(_dataObj).forEach(function (i) {
        // _typeStr === '' && console.log('...',i,_dataObj,thisObj[_varRef],thisObj[_varRef][i]);
        if (hasOProp.call(thisObj[_varRef], i)) {
          _tempArr.push(i);

          LabComClass.defineObject(thisObj[_varRef], i, _dataObj[i]);
        } else {
          console.log(i + ": property doesnt exist in Model " + _varRef + ".");
        } // _typeStr === 'onLessonStructureLoad' && console.log('BFTR',Object.keys(_dataObj),thisObj,thisObj[_varRef],thisObj[_varRef][i]);

      });
      onModelUpdateCls.trigger("onChange", {
        type: _typeStr,
        propList: _tempArr
      }); // Change function for any controller property update
    }
  } // ===================================================================================
  // VIEW CLASS
  // ===================================================================================


  function ViewClass() {
    var vPropObj = {};
    var hasOProp = Object.prototype.hasOwnProperty;
    var firstFocusableEl;
    var lastFocusableEl; // ---------------------------------

    function init() {} // ---------------------------------


    function onChange(_dataObj) {
      switch (_dataObj.type) {
        case "onPlayerConfigLoad":
          createDropDowntMenu("Help");
          createDropDowntMenu("CopyRight");
          createPopup();
          break;

        case "onActivityInited":
          modelCls.cPropObj.mouseHandleCls.updateInteractiveLayer(modelCls.cPropObj.interactiveLayerArr);
          drawBg();
          document.body.removeChild(modelCls.vPropObj.preloadObj);
          trapFocus(document.body);
          break;

        case "mouseEventAdded":
          break;

        case "onScaleSet":
          document.addEventListener("contextmenu", function (event) {
            return event.preventDefault();
          }); // to disable rigth click

          modelCls.cPropObj.mouseHandleCls.init({
            deviceTypeBool: modelCls.cPropObj.deviceTypeBool,
            mouseCanvasObj: modelCls.vPropObj.mouseCanvasObj
          });
          modelCls.cPropObj.mouseHandleCls.updateOnResize(modelCls.vPropObj.scaledDataObj);
          break;

        default:
          break;
      }
    } // ---------------------------------


    function trapFocus(element) {
      var focusableEls = element.querySelectorAll("div.popupContent, label[for], a[href]:not([disabled]), button:not([disabled]),button_:not([hidden]),  select:not([disabled]), canvass[role=\"canvas\"]"); // console.log("ELE", element.tagName, focusableEls);

      firstFocusableEl = focusableEls[0];
      lastFocusableEl = focusableEls[focusableEls.length - 1]; // console.log(firstFocusableEl.className,'**',lastFocusableEl.id,focusableEls.length);

      element.addEventListener("keydown", onTabKeyDown);
    }

    function onTabKeyDown(e) {
      var KEYCODE_TAB = 9;
      var isActiveElementTriggered = false;
      var tabCounter = modelCls.cPropObj.tabCounter;
      var isTabPressed = e.key === "Tab" || e.keyCode === KEYCODE_TAB;

      if (!isTabPressed) {
        return;
      } // console.log('11',document.activeElement.tagName,tabCounter);
      // if(document.activeElement.tagName === 'CANVAS') {
      //   tabCounter = e.shiftKey ? --tabCounter : ++tabCounter;
      //   onModelUpdateCls.trigger('setCProp', {
      //     tabCounter: tabCounter
      //   }, '')
      //   console.log('22',tabCounter);
      //   if(tabCounter >= modelCls.cPropObj.indexingArr.length || tabCounter < 0) {
      //     isActiveElementTriggered = false;
      //     tabCounter = -1;
      //     onModelUpdateCls.trigger('setCProp', {
      //       tabCounter: tabCounter
      //     }, '')
      //     console.log('@@',tabCounter);
      //     hideAllTabFocus();
      //   }
      //   else {
      //     isActiveElementTriggered = true;
      //     e.preventDefault();
      //   }
      //   // return;
      // }
      // else {
      // tabCounter = e.shiftKey ? modelCls.cPropObj.indexingArr.length : -1;
      // onModelUpdateCls.trigger('setCProp', {
      //   tabCounter: tabCounter
      // }, '')
      // hideAllTabFocus();
      // console.log('33',tabCounter);
      // }
      // console.log('**#',document.activeElement.id,document.activeElement === lastFocusableEl,document.activeElement.id === lastFocusableEl.id);


      if (e.shiftKey) {
        /* shift + tab */
        if (document.activeElement === firstFocusableEl && tabCounter <= -1) {
          // console.log('**LE',lastFocusableEl.id);
          if (lastFocusableEl.id) {
            document.getElementById(lastFocusableEl.id).focus();
          } else {
            lastFocusableEl.focus();
          }

          e.preventDefault();
        }
      }
      /* tab */
      else {
          // console.info(
          //   document.activeElement,
          //   lastFocusableEl,
          //   document.activeElement.id,
          //   lastFocusableEl.id,
          //   document.activeElement.id.length,
          //   document.activeElement === lastFocusableEl,
          //   firstFocusableEl
          // );
          if (document.activeElement === lastFocusableEl || document.activeElement.id === lastFocusableEl.id && document.activeElement.id.length) {
            // console.log('**FE',firstFocusableEl.id);
            if (firstFocusableEl.id) {
              document.getElementById(firstFocusableEl.id).focus();
            } else {
              firstFocusableEl.focus();
            }

            e.preventDefault();
          }
        }

      if (isActiveElementTriggered) {
        console.log("44", tabCounter); // window.ref.showBorder();

        modelCls.cPropObj.indexingArr.forEach(function (_el, _i) {
          modelCls.cPropObj.compListObj[modelCls.cPropObj.indexingArr[_i].id].obj.hideBorder();
        });
        modelCls.cPropObj.compListObj[modelCls.cPropObj.indexingArr[tabCounter].id].obj.showBorder();
        onViewUpdateCls.trigger("onGlobalUpdate", {
          type: "rendererUpdate"
        });
      }
    }

    function hideAllTabFocus() {
      modelCls.cPropObj.indexingArr.forEach(function (_el, _i) {
        modelCls.cPropObj.compListObj[modelCls.cPropObj.indexingArr[_i].id].obj.hideBorder();
      });
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "rendererUpdate"
      });
    } // ---------------------------------


    function onGlobalUpdate(_dataObj) {
      switch (_dataObj.type) {
        case "addMouseEvent":
          modelCls.cPropObj.mouseHandleCls.addMouseEvent(_dataObj.data);
          break;

        case "addKeyEvent":
          modelCls.cPropObj.keyHandlerCls.addKeyEvents(_dataObj.data);
          break;

        case "removeMouseEvent":
          modelCls.cPropObj.mouseHandleCls.removeMouseEvent(_dataObj.data);
          break;

        case "removeKeyEvent":
          modelCls.cPropObj.keyHandlerCls.removeKeyEvents(_dataObj.data);
          break;

        case "updateTrapFocus":
          // console.log('TF',eval(_dataObj.data.element).tagName,_dataObj.data.id);
          // eval(_dataObj.data.element).removeEventListener('keydown',onTabKeyDown);
          trapFocus(eval(_dataObj.data.element));
          break;

        case "rendererUpdate":
          requestAnimationFrame(drawFn);
          break;

        case "onNavStageResize":
          drawBg();
          drawFn();
          break;

        default:
          break;
      }
    } // ---------------------------------


    function createDropDowntMenu(buttonType) {
      var buttonWrapper = modelCls.vPropObj["header".concat(buttonType, "ObjWrapper")];
      var button = modelCls.vPropObj["header".concat(buttonType, "Obj")];
      var buttonMenu = modelCls.vPropObj["header".concat(buttonType, "ObjMenu")];
      var globalTextObj = modelCls.cPropObj.globalTextObj;
      LabComClass.globalTextObj = globalTextObj;
      var dataKey = "".concat(buttonType[0].toLowerCase() + buttonType.slice(1), "Data");
      var menuItems = Object.keys(globalTextObj[dataKey]);
      var menuItemsAltText = globalTextObj[dataKey + "AltText"];
      var menuHolder = buttonMenu;
      menuHolder.setAttribute("class", "menuHolder");
      menuHolder.style.display = "none";
      buttonWrapper.appendChild(menuHolder);
      buttonWrapper.menuHolder = menuHolder;
      button.menuHolder = menuHolder;
      menuItems.forEach(function (item) {
        var menuItem = document.createElement("button");
        var menuItemHeading = document.createElement("h2");
        menuItemHeading.innerHTML = item; // menuItem.setAttribute("disabled", true);

        menuItem.setAttribute("class", "menuItem");
        menuItem.setAttribute("tabindex", 0);
        menuItem.setAttribute("aria-label", menuItemsAltText[item]); // menuItem.setAttribute('aria-hidden',true);
        // menuItem.setAttribute('tabindex',buttonType === 'Help' ? 1 : 2)

        menuItem.appendChild(menuItemHeading);
        menuItem.addEventListener("click", function (e) {
          return openPopup(e, item, dataKey);
        });
        menuHolder.appendChild(menuItem);
      });
      button.addEventListener("click", function () {
        return openMenu(button);
      });

      if (!LabComClass.BrowserDetect.isDevice()) {
        button.addEventListener("mouseenter", function () {
          return button.classList.add("hover");
        });
        button.addEventListener("mouseleave", function () {
          return button.classList.remove("hover");
        });
      }
    }

    function createPopup() {
      var infoPopupObj = modelCls.vPropObj.infoPopupObj;
      var popupOverlay = document.createElement("div");
      popupOverlay.setAttribute("class", "popupOverlay"); // popupOverlay.setAttribute("tabindex", 0);

      infoPopupObj.appendChild(popupOverlay);
      var popupHolder = document.createElement("div");
      popupHolder.setAttribute("class", "popupHolder");
      popupHolder.setAttribute("id", "popupHolder"); // popupHolder.setAttribute("tabindex", 0);

      infoPopupObj.appendChild(popupHolder);
      var popupTile = document.createElement("div");
      popupTile.setAttribute("class", "popupTitle");
      popupHolder.appendChild(popupTile);
      var titleText = document.createElement("div");
      titleText.innerHTML = "title";
      popupTile.appendChild(titleText); // popupTile.setAttribute("tabindex", 0);

      infoPopupObj.titleDiv = titleText;
      var closeButton = document.createElement("button");
      closeButton.setAttribute("class", "closePopup");
      closeButton.setAttribute("tabindex", 0);
      closeButton.setAttribute("disabled", true);
      closeButton.innerHTML = "X";
      popupTile.appendChild(closeButton);
      var popupContent = document.createElement("div");
      popupContent.setAttribute("class", "popupContent");
      popupContent.setAttribute("tabindex", 0);
      popupHolder.appendChild(popupContent);
      infoPopupObj.contentDiv = popupContent; // infoPopupObj.contentDiv.setAttribute("tabindex", 0);

      closeButton.addEventListener("click", closePopup);
      popupOverlay.addEventListener("click", closePopup);
    }

    function openMenu(button) {
      button.menuHolder.style.display = "block";
      var buttonSelected = document.querySelector(".headerButton.selected");
      closeMenu();

      if (button !== buttonSelected) {
        button.classList.add("selected");
        button.menuHolder.classList.add("show"); // Removing Disable

        document.querySelectorAll(".headerButton  > .show > button").forEach(function (el) {
          el.removeAttribute("disabled");
        });
        document.body.removeEventListener("keydown", onTabKeyDown);
        trapFocus(document.body);
        onViewUpdateCls.trigger("onGlobalUpdate", {
          type: "menuOpened",
          data: {}
        });
      }
    }

    function closeMenu() {
      var button = document.querySelector(".headerButton.selected");

      if (!button) {
        return;
      }

      document.body.removeEventListener("keydown", onTabKeyDown);
      button.classList.remove("selected");
      button.menuHolder.style.display = "none"; // Adding Disable

      document.querySelectorAll(".headerButton  > .show > button").forEach(function (el) {
        el.setAttribute("disabled", true);
      });
      document.body.removeEventListener("keydown", onTabKeyDown);
      trapFocus(document.body);
      button.menuHolder.classList.remove("show");
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "menuClosed",
        data: {}
      });
    }

    function openPopup(e, title, contentKey) {
      closeMenu();
      e.stopPropagation();
      document.body.removeEventListener("keydown", onTabKeyDown);
      modelCls.vPropObj.infoPopupObj.classList.add("show");
      modelCls.cPropObj.mouseHandleCls.toggleMouseEvents(false);
      modelCls.vPropObj.infoPopupObj.contentDiv.scrollTop = 0;
      document.querySelectorAll(".closePopup")[0].removeAttribute("disabled");
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "popupOpened",
        data: {
          title: title,
          contentKey: contentKey
        }
      });
      trapFocus(document.getElementsByClassName("popupHolder")[0]);
    }

    function closePopup() {
      modelCls.vPropObj.infoPopupObj.classList.remove("show");
      modelCls.cPropObj.mouseHandleCls.toggleMouseEvents(true);
      document.querySelectorAll(".closePopup")[0].setAttribute("disabled", true);
      trapFocus(document.body);
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "popupClosed",
        data: {}
      });
    } // ---------------------------------


    function drawFn() {
      var _contCnvObj = modelCls.vPropObj.contCanvasObj;
      var _contCtxObj = modelCls.vPropObj.contContextObj;
      var _scaledDataObj = modelCls.vPropObj.scaledDataObj; // ---------------------

      _contCtxObj.clearRect(0, 0, _contCnvObj.width, _contCnvObj.height);

      _contCtxObj.save();

      _contCtxObj.scale(_scaledDataObj.scale * _scaledDataObj.devScaleRatioInt, _scaledDataObj.scale * _scaledDataObj.devScaleRatioInt); // modelCls.cPropObj.activityObj.draw();
      // ---------------------


      var _compListObj = modelCls.cPropObj.compListObj;
      var components = modelCls.cPropObj.labObj.components;
      components.forEach(function (elem) {
        if (_compListObj[elem.id].obj.draw) {
          _compListObj[elem.id].obj.draw();
        }
      });

      _contCtxObj.restore();
    } // ---------------------------------


    function drawBg() {
      var _bgCnvObj = modelCls.vPropObj.bgCanvasObj;
      var _bgCtxObj = modelCls.vPropObj.bgContextObj; // ---------------------

      _bgCtxObj.clearRect(0, 0, _bgCnvObj.width, _bgCnvObj.height);

      _bgCnvObj.strokeColor = "red"; // _bgCtxObj.drawImage(modelCls.vPropObj.bgImageObj, 0, 0, _bgCnvObj.width, _bgCnvObj.height);
    } // ---------------------------------
    // ---------------------------------


    onModelUpdateCls.on("onChange", onChange); // ----------------------------
    // onViewUpdateCls.on('updateView', onUpdateView);
    // onViewUpdateCls.on('getImageSlide', onGetImageSlide);

    onViewUpdateCls.on("onGlobalUpdate", onGlobalUpdate); // ---------------------------------
    // ---------------------------------
  } // ===================================================================================


  function ControllerClass() {
    var hasOProp = Object.prototype.hasOwnProperty; // ----------------------------

    function init() {
      loadGlobalText();
      modelCls.cPropObj.keyHandlerCls.init(); // =====================================================

      var inputFieldDummyDiv = document.createElement("div");
      inputFieldDummyDiv.setAttribute("id", "inputFieldDummyDiv");
      inputFieldDummyDiv.setAttribute("contenteditable", true);
      inputFieldDummyDiv.setAttribute("tabindex", -1);
      inputFieldDummyDiv.setAttribute("aria-hidden", true);
      inputFieldDummyDiv.style.position = "absolute";
      inputFieldDummyDiv.style.width = "0px";
      inputFieldDummyDiv.style.height = "0px";
      inputFieldDummyDiv.style.top = "-100px";
      inputFieldDummyDiv.style.left = "-100px";
      inputFieldDummyDiv.addEventListener("keydown", function () {
        this.innerHTML = "";
      });
      document.body.appendChild(inputFieldDummyDiv);
    } // ---------------------------------
    // ---------------------------------


    function onChange(_dataObj) {
      // console.log('Controller onChange', _dataObj.type);
      switch (_dataObj.type) {
        case "onGlobalTextLoad":
          setUpPlayer();
          break;

        case "onPlayerConfigLoad":
          LabComClass.childPreloadProgress(30); // Set browser and platform type

          if (LabComClass.BrowserDetect.isDevice()) {
            onModelUpdateCls.trigger("setCProp", {
              deviceTypeBool: true
            }, "onDeviceSelected");
          } else {
            onModelUpdateCls.trigger("setCProp", {
              deviceTypeBool: false
            }, "onDeviceSelected");
          }

          break;

        case "onDeviceSelected":
          setPlayerScale();
          break;

        case "onScaleSet":
          // Load lesson structure file
          LabComClass.childPreloadProgress(48);
          var toolsUsedArr,
              toolArray = [],
              toolArrayNoDuplicate;
          httpRequest("labstructure.json", "json", function (_httpData) {
            onModelUpdateCls.trigger("setCProp", _httpData, "onLessonStructureLoad"); // toolsUsedArr = _httpData.labObj.components.filter(el=>(el.ref === 'ToolPanelCompClass'))[0].initdata.buttons; // Extracting Tools Object from Geo Tools.
            // toolArrayNoDuplicate = Object.keys(toolsUsedArr).filter(tool => toolsUsedArr[tool].visible); // Extracting only visible tools.
            // let count = 0; // If more than one brush only single brush is shown.
            // toolArrayNoDuplicate.forEach((el,i) => {
            //   if(el.includes('brush')) {
            //     if(count === 0){
            //       toolArray.push(el);
            //       count++;
            //     }
            //   }
            //   else {
            //     toolArray.push(el);
            //   }
            // });
            // onModelUpdateCls.trigger('setCProp', {toolsUsed:toolArray}, 'toolsUsed');
          });
          break;

        case "onLessonStructureLoad":
          httpRequest(modelCls.cPropObj.labObj.lang + "/labtext.json", "json", function (_httpData) {
            LabComClass.globalLangText = _httpData;

            try {
              LabComClass.urlParams = JSON.parse('{"' + location.search.substring(1).replace(/&/g, '","').replace(/=/g, '":"') + '"}');
            } catch (e) {
              LabComClass.urlParams = {};
            }

            LabComClass.klettFontRegular = modelCls.cPropObj.playerConfigObj["klettFontRegular-" + modelCls.cPropObj.labObj.lang]; // This concatenation is done to support various languauges with their respective font variation.

            LabComClass.polo22KlettRegular = modelCls.cPropObj.playerConfigObj["polo22KlettRegular-" + modelCls.cPropObj.labObj.lang]; // This concatenation is done to support various languauges with their respective font variation.

            LabComClass.bold = modelCls.cPropObj.playerConfigObj.bold;
            LabComClass.italic = modelCls.cPropObj.playerConfigObj.italic;
            LabComClass.italicbold = modelCls.cPropObj.playerConfigObj.italicbold;
            LabComClass.italicDistance = modelCls.cPropObj.playerConfigObj.italicDistance;
            LabComClass.subscript = modelCls.cPropObj.playerConfigObj.subscript;
            LabComClass.superscript = modelCls.cPropObj.playerConfigObj.superscript;
            LabComClass.end = modelCls.cPropObj.playerConfigObj.end;
            LabComClass.requestLocalImage(["background.png"], function (_bgObj) {
              onModelUpdateCls.trigger("setVProp", {
                bgImageObj: _bgObj["background.png"]
              }, "onLocaliseTextLoad");
            });
          });
          break;

        case "onLocaliseTextLoad":
          // Load BGs
          LabComClass.childPreloadProgress(60);
          loadSFXAudio();
          break;

        case "onSFXLoad":
          createCompList();
          break;

        case "onCompListAdd":
          sendInstanceToAct();
          break;

        case "onActivityInited":
          break;

        default:
          break;
      }
    } // ----------------------
    // ----------------------


    function onGlobalUpdate(_dataObj) {
      // console.log('Controller onGlobalUpdate', _dataObj.type);
      switch (_dataObj.type) {
        case "onCheckForSubway":
          break;

        case "componentLoaded":
          var _compCountInt = modelCls.cPropObj.compCountInt;
          var _totalCompCountInt = modelCls.cPropObj.labObj.components.length;

          if (_compCountInt < _totalCompCountInt) {
            allCompLoaded(_dataObj.data);
          }

          break;

        case "manageIndex":
          onModelUpdateCls.trigger("setCProp", {
            indexingArr: [].concat(_toConsumableArray(modelCls.cPropObj.indexingArr), [_dataObj.data])
          }, ""); // console.log('AAA',modelCls.cPropObj.indexingArr);

          break;

        case "playSFX":
          modelCls.cPropObj.audioContextCls.sfxObj.play(_dataObj.data);
          break;

        case "popupOpened":
          updatePopupContent(_dataObj.data);
          break;

        default:
          break;
      }
    } // ===================================================================================


    function setUpPlayer() {
      LabComClass.localImagePath = "assets/images/";
      LabComClass.globalImagePath = "assets/images/"; // var _obj = JSON.parse('{"' + location.search.substring(1).replace(/&/g, '","').replace(/=/g, '":"') + '"}');
      // console.log('setUpPlayer', _obj);

      httpRequest(modelCls.cPropObj.playerPath + "playerconfig.json", "json", function (_dataObj) {
        LabComClass.childPreloadProgress(18);
        onModelUpdateCls.trigger("setCProp", _dataObj, "onPlayerConfigLoad");
      });
    }

    function loadGlobalText() {
      httpRequest(modelCls.cPropObj.playerPath + "globalTextV2.js", "js", function (_dataObj) {
        var globalText;
        eval(_dataObj);
        onModelUpdateCls.trigger("setCProp", {
          globalTextObj: globalText
        }, "onGlobalTextLoad");
      });
    } // ===================================================================================
    // Common function for loading JSON, JS
    // ===================================================================================


    function httpRequest(_urlStr, _typeStr, _callBackFn, _errorCallBackFn, _cnt) {
      var cnt = 1;
      var maxRetries = 3;

      if (typeof _cnt !== "undefined") {
        cnt = _cnt;
      }

      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (_callBackFn) {
            if (_typeStr.toLowerCase() === "json") {
              _callBackFn(JSON.parse(this.responseText));
            } else {
              _callBackFn(this.responseText);
            }
          }
        }
      };

      xhttp.open("GET", _urlStr, true);
      xhttp.send();
    } // ===================================================================================


    function setPlayerScale() {
      // Following timeout is given to keep some buffer for device calculation because on android app activity looks in double size because stage not rendered fully. This condition is applied only for devices.
      var _time = 0;

      if (modelCls.cPropObj.deviceTypeBool) {
        _time = 1500;
      }

      setTimeout(function () {
        window.onresize = function () {
          setStageSize();
        };

        setStageSize(true);
      }, _time);
    } // ===================================================================================


    function setStageSize(_bool) {
      clearTimeout(modelCls.vPropObj.resizeTimeoutObj);

      var _resizeTimeoutObj = setTimeout(function () {
        var _retStr = "";

        var _scaleVal = calculateScaleVal({
          w: modelCls.cPropObj.playerConfigObj.baseWidth,
          h: modelCls.cPropObj.playerConfigObj.baseHeight
        });

        _scaleVal.devScaleRatioInt = calculateDevicePixelRatio(modelCls.vPropObj.contCanvasObj);

        var _trace = _scaleVal.w + " : " + _scaleVal.h + " : " + _scaleVal.devScaleRatioInt; // alert(_trace);


        if (_bool) {
          // ----------------------------
          modelCls.vPropObj.mTextWrapperObj.className = "mStage mTextWrapper";
          document.body.appendChild(modelCls.vPropObj.mTextWrapperObj); // ----------------------------

          modelCls.vPropObj.bgCanvasObj.className = "mStage mStagebgCanvas";
          document.body.appendChild(modelCls.vPropObj.bgCanvasObj); // ----------------------------

          modelCls.vPropObj.contCanvasObj.className = "mStage mStagecontCanvas";
          modelCls.vPropObj.contCanvasObj.setAttribute("tabindex", -1);
          modelCls.vPropObj.contCanvasObj.setAttribute("role", "canvas");
          document.body.appendChild(modelCls.vPropObj.contCanvasObj); // ----------------------------

          modelCls.vPropObj.virtualCanvasObj.className = "mStage mVirtualStagecontCanvas"; // ----------------------------

          modelCls.vPropObj.domLayerObj.className = "mStage mDomLayer";
          document.body.appendChild(modelCls.vPropObj.domLayerObj);
          modelCls.vPropObj.headerObj.className = "mStage header";
          modelCls.vPropObj.helpObj.className = "mStage header header__buttons";
          modelCls.vPropObj.domLayerObj.appendChild(modelCls.vPropObj.headerObj);
          modelCls.vPropObj.domLayerObj.appendChild(modelCls.vPropObj.helpObj);
          modelCls.vPropObj.headerLogoItemObj.className = "logoItem";
          modelCls.vPropObj.headerObj.appendChild(modelCls.vPropObj.headerLogoItemObj);
          modelCls.vPropObj.headerLogoObj.className = "logo";
          modelCls.vPropObj.headerLogoItemObj.appendChild(modelCls.vPropObj.headerLogoObj);
          modelCls.vPropObj.headerLogoObj.setAttribute("alt", modelCls.cPropObj.globalTextObj.ariaLabel["logo"]);
          modelCls.vPropObj.headerTextObj.className = "header__title";
          modelCls.vPropObj.headerTextObj.innerHTML = "header"; // modelCls.vPropObj.headerTextObj.setAttribute("tabIndex", 0);

          modelCls.vPropObj.headerObj.appendChild(modelCls.vPropObj.headerTextObj);
          modelCls.vPropObj.headerHelpObj.className = "helpScreenButton headerButton";
          modelCls.vPropObj.headerHelpObj.setAttribute("tabindex", 0);
          modelCls.vPropObj.headerHelpObj.setAttribute("aria-label", modelCls.cPropObj.globalTextObj.ariaLabel["helpScreenBtn"]);
          modelCls.vPropObj.helpObj.appendChild(modelCls.vPropObj.headerHelpObjWrapper);
          modelCls.vPropObj.headerHelpObjWrapper.appendChild(modelCls.vPropObj.headerHelpObj);
          modelCls.vPropObj.headerHelpObjWrapper.appendChild(modelCls.vPropObj.headerHelpObjMenu); // modelCls.vPropObj.helpObj.setAttribute("tabIndex", 0);

          modelCls.vPropObj.headerHelpIconObj.className = "helpIcon";
          modelCls.vPropObj.headerHelpObj.appendChild(modelCls.vPropObj.headerHelpIconObj);
          modelCls.vPropObj.headerCopyRightObj.className = "copyrightButton headerButton";
          modelCls.vPropObj.headerCopyRightObj.setAttribute("tabindex", 0);
          modelCls.vPropObj.headerCopyRightObj.setAttribute("aria-label", modelCls.cPropObj.globalTextObj.ariaLabel["copyrightBtn"]); // modelCls.vPropObj.headerObj.appendChild(

          modelCls.vPropObj.helpObj.appendChild(modelCls.vPropObj.headerCopyRightObjWrapper);
          modelCls.vPropObj.headerCopyRightObjWrapper.appendChild(modelCls.vPropObj.headerCopyRightObj);
          modelCls.vPropObj.headerCopyRightObjWrapper.appendChild(modelCls.vPropObj.headerCopyRightObjMenu);
          modelCls.vPropObj.mainWrapper.className = "mainWrapper";
          modelCls.vPropObj.mainWrapper.setAttribute("id", "mainWrapper");
          modelCls.vPropObj.domLayerObj.appendChild(modelCls.vPropObj.mainWrapper);
          modelCls.vPropObj.infoPopupObj.className = "infoPopup";
          modelCls.vPropObj.mainWrapper.appendChild(modelCls.vPropObj.infoPopupObj);
          modelCls.vPropObj.headerCopyRightIconObj.className = "verticalDotsIcon";
          modelCls.vPropObj.headerCopyRightObj.appendChild(modelCls.vPropObj.headerCopyRightIconObj); //----------------------------

          modelCls.vPropObj.questionWrapper.className = "questionWrapper mStage";
          modelCls.vPropObj.mainWrapper.appendChild(modelCls.vPropObj.questionWrapper); //-------------------------------

          modelCls.vPropObj.taskTableWrapper.className = "taskTableWrapper mStage";
          modelCls.vPropObj.mainWrapper.appendChild(modelCls.vPropObj.taskTableWrapper); //----------------------------

          modelCls.vPropObj.toolPanelWrapper.className = "toolPanelWrapper mStage header";
          modelCls.vPropObj.mainWrapper.appendChild(modelCls.vPropObj.toolPanelWrapper); // ----------------------------

          modelCls.vPropObj.preloadObj.className = "mStage preloadDiv";
          document.body.appendChild(modelCls.vPropObj.preloadObj); // ----------------------------
          // modelCls.vPropObj.mouseCanvasObj.className = 'mStage mStageMouseCanvas';
          // document.body.appendChild(modelCls.vPropObj.mouseCanvasObj);
          // ----------------------------

          CanvasRenderingContext2D.prototype.textWrapperClass = LabComClass.TextImgClass;
          CanvasRenderingContext2D.prototype.textWrapperV2Class = LabComClass.TextImgV2Class;
          CanvasRenderingContext2D.prototype.textWrapperNewClass = LabComClass.TextImgNewClass;
          CanvasRenderingContext2D.prototype.tweenClass = LabComClass.TweenClass;
          CanvasRenderingContext2D.prototype.drawCurveRect = LabComClass.drawCurveRect;
          CanvasRenderingContext2D.prototype.drawStyledText = LabComClass.drawStyledText;
          var drawImage = CanvasRenderingContext2D.prototype.drawImage;

          CanvasRenderingContext2D.prototype.drawImage = function () {
            try {
              drawImage.apply(this, arguments);
            } catch (e) {
              var stack = e.stack || "";
              stack = stack.split("\n").map(function (line) {
                return line.trim();
              });
              var printError = "Failed to draw error, ";
              printError += "trace === " + stack.join(",") + ", ";
              printError += "arguments === " + JSON.stringify(arguments);

              if (typeof trackJs !== "undefined") {
                trackJs.console.error(printError);
              }
            }
          }; // ----------------------------


          _retStr = "onScaleSet"; // trapFocus(document.body)
        }

        var _cnvObj = {};
        _cnvObj.bgContextObj = modelCls.vPropObj.bgCanvasObj.getContext("2d"); // Context to show the background

        _cnvObj.contContextObj = modelCls.vPropObj.contCanvasObj.getContext("2d"); // Context to show the content
        // -----------

        onModelUpdateCls.trigger("setVProp", _cnvObj, ""); // ---------

        modelCls.vPropObj.bgCanvasObj.style.left = _scaleVal.x + "px";
        modelCls.vPropObj.bgCanvasObj.style.top = _scaleVal.y + "px";
        modelCls.vPropObj.bgCanvasObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.bgCanvasObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.bgCanvasObj.style.width = _scaleVal.w + "px";
        modelCls.vPropObj.bgCanvasObj.style.height = _scaleVal.h + "px"; // ---------

        modelCls.vPropObj.contCanvasObj.style.left = _scaleVal.x + "px";
        modelCls.vPropObj.contCanvasObj.style.top = _scaleVal.y + "px";
        modelCls.vPropObj.contCanvasObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.contCanvasObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.contCanvasObj.style.width = _scaleVal.w + "px";
        modelCls.vPropObj.contCanvasObj.style.height = _scaleVal.h + "px"; // ---------

        modelCls.vPropObj.virtualCanvasObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.virtualCanvasObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.virtualCanvasObj.style.width = _scaleVal.w + "px";
        modelCls.vPropObj.virtualCanvasObj.style.height = _scaleVal.h + "px"; // ---------

        modelCls.vPropObj.domLayerObj.style.left = _scaleVal.x + "px";
        modelCls.vPropObj.domLayerObj.style.top = _scaleVal.y + "px";
        modelCls.vPropObj.domLayerObj.style.width = modelCls.cPropObj.playerConfigObj.baseWidth + "px";
        modelCls.vPropObj.domLayerObj.style.height = modelCls.cPropObj.playerConfigObj.baseHeight + "px";
        modelCls.vPropObj.domLayerObj.style.transform = "scale(" + _scaleVal.scale + ")"; // ---------

        modelCls.vPropObj.snapshotCnvObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.snapshotCnvObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt; // ---------
        // modelCls.vPropObj.mouseCanvasObj.style.left = _scaleVal.x + 'px';
        // modelCls.vPropObj.mouseCanvasObj.style.top = _scaleVal.y + 'px';

        modelCls.vPropObj.mouseCanvasObj.width = _scaleVal.w;
        modelCls.vPropObj.mouseCanvasObj.height = _scaleVal.h; // modelCls.vPropObj.mouseCanvasObj.style.width = _scaleVal.w + 'px';
        // modelCls.vPropObj.mouseCanvasObj.style.height = _scaleVal.h + 'px';
        // ---------

        modelCls.vPropObj.mTextWrapperObj.style.display = "none";
        modelCls.vPropObj.mTextWrapperObj.setAttribute("data-scale", _scaleVal.scale); // ----------------------------

        modelCls.vPropObj.preloadObj.style.left = _scaleVal.x + "px";
        modelCls.vPropObj.preloadObj.style.top = _scaleVal.y + "px";
        modelCls.vPropObj.preloadObj.style.width = _scaleVal.w + "px";
        modelCls.vPropObj.preloadObj.style.height = _scaleVal.h + "px"; // ----------------------------

        modelCls.cPropObj.mouseHandleCls.updateOnResize(_scaleVal); // ----------------------------

        LabComClass.setVirtualCnv(modelCls.vPropObj.virtualCanvasObj); // ----------------------------

        LabComClass.setSnapshotCnv({
          snapshotCnvObj: modelCls.vPropObj.snapshotCnvObj,
          bgCanvasObj: modelCls.vPropObj.bgCanvasObj,
          contCanvasObj: modelCls.vPropObj.contCanvasObj,
          devScaleRatioInt: _scaleVal.devScaleRatioInt,
          scale: _scaleVal.scale
        }); // ----------------------------

        onModelUpdateCls.trigger("setVProp", {
          scaledDataObj: _scaleVal
        }, _retStr); // ----------------------------

        LabComClass.setCnvScale(modelCls.vPropObj.scaledDataObj); // ----------------------------

        if (!_bool) {
          onViewUpdateCls.trigger("onGlobalUpdate", {
            type: "onNavStageResize",
            data: {}
          });
        }
      }, 300);

      onModelUpdateCls.trigger("setVProp", {
        resizeTimeoutObj: _resizeTimeoutObj
      }, "");
    } // ===================================================================================


    function calculateScaleVal(_dataObj) {
      var _obj = {};

      try {
        _obj = JSON.parse('{"' + location.search.substring(1).replace(/&/g, '","').replace(/=/g, '":"') + '"}');
      } catch (e) {
        console.log("To switch off the scale: ?noscale=true");
      }

      if (_obj.noscale !== "true") {
        var _shellWidth = _dataObj.w;
        var _shellHeight = _dataObj.h;

        var _newShellHeight;

        var _newShellWidth;

        var _actWid = window.innerWidth;
        var _actHgt = window.innerHeight;
        var _scale = 1;
        var _nscale = 1;

        if (_actHgt < _actWid) {
          _newShellHeight = _actHgt;
          _scale = Number(_shellHeight / _newShellHeight); // .toFixed(2);

          _newShellWidth = _shellWidth / _shellHeight * _newShellHeight;

          var _aleft = _actWid / 2 - Number(_newShellWidth) / 2;

          if (_aleft < 0) {
            _newShellWidth = _actWid;
            _scale = Number(_shellWidth / _newShellWidth); // .toFixed(2);

            _newShellHeight = _shellHeight / _shellWidth * _newShellWidth;
          }

          _nscale = 1 / _scale;

          if (_nscale < 0.1) {
            _nscale = 0.1;
          }
        } else {
          _newShellWidth = _actWid;
          _scale = Number(_shellWidth / _newShellWidth); // .toFixed(2);

          _newShellHeight = _shellHeight / _shellWidth * _newShellWidth;
          _nscale = 1 / _scale;

          if (_nscale < 0.1) {
            _nscale = 0.1;
          }
        }

        return {
          w: Math.round(_shellWidth * _nscale),
          h: Math.round(_shellHeight * _nscale),
          scale: _nscale,
          x: Math.round(window.innerWidth / 2 - Number(_newShellWidth) / 2),
          y: Math.round(window.innerHeight / 2 - Number(_newShellHeight) / 2)
        };
      }

      document.body.style.overflow = "auto";
      return {
        w: _dataObj.w,
        h: _dataObj.h,
        scale: 1,
        x: 0,
        y: 0
      };
    } // ===================================================================================


    function calculateDevicePixelRatio(_cnvObj) {
      var _ctxObj = _cnvObj.getContext("2d");

      var devicePixelRatio = window.devicePixelRatio || 1;
      var backingStoreRatio = _ctxObj.webkitBackingStorePixelRatio || _ctxObj.mozBackingStorePixelRatio || _ctxObj.msBackingStorePixelRatio || _ctxObj.oBackingStorePixelRatio || _ctxObj.backingStorePixelRatio || 1;
      var ratio = devicePixelRatio / backingStoreRatio;
      return ratio;
    } // ===================================================================================


    function loadUIFonts(_callback) {
      // load font divs
      var _uiFonts = modelCls.cPropObj.labObj.fonts; // remmove deprecated fonts

      var fontArr = [];

      if (_uiFonts.length > 0) {
        for (var i = 0; i < _uiFonts.length; i += 1) {
          fontArr.push(_uiFonts[i]);
        }
      }

      LabComClass.fontLoader({
        timeout: 15000,
        // error callback will be executed after timeout if one/all fonts failed to load.
        fontArr: fontArr,
        callback: _callback,
        error: function error(_fontFailureArr) {
          console.log("List of fonts failed to load === ", JSON.stringify(_fontFailureArr));

          if (typeof trackJs !== "undefined") {
            trackJs.console.error("List of fonts failed to load === ", JSON.stringify(_fontFailureArr)); // t2
          }
        }
      });
    } // ===================================================================================
    // function loadCompScript() {
    //   var _gScrObj = {};
    //   var _gScrStrArr = [];
    //   var _iInt = 0;
    //   // Loading local CJSs.
    //   var _locCjs = modelCls.cPropObj.labObj.localCJS;
    //   if (typeof (_locCjs) !== 'undefined') {
    //     for (_iInt = 0; _iInt < _locCjs.length; _iInt++) {
    //       _gScrStrArr.push(_locCjs[_iInt].path + '.js');
    //     }
    //   }
    //   // Loading global component classes.
    //   var _httpData = modelCls.cPropObj.labObj.components;
    //   for (_iInt = 0; _iInt < _httpData.length; _iInt++) {
    //     if (_httpData[_iInt].type === 'global') {
    //       _gScrStrArr.push(modelCls.cPropObj.playerPath + 'component/' + _httpData[_iInt].ref + '.js');
    //     } else {
    //       _gScrStrArr.push(modelCls.cPropObj.playerPath + 'localcomponent/' + _httpData[_iInt].ref + '.js');
    //     }
    //   }
    //   // Start
    //   onModelUpdateCls.trigger('setCProp', {
    //     totalCompCountInt: _gScrStrArr.length
    //   }, '');
    //   // Loading local script
    //   // var _localBrain = modelCls.cPropObj.labObj.brainClass;
    //   _gScrStrArr.push(modelCls.cPropObj.playerPath + 'localcomponent/' + _localBrain.ref + '.js');
    //   // Start Loading all scripts
    //   scriptLoader(_gScrObj, _gScrStrArr, function () {
    //     // loadCompAssets();
    //     loadSFXAudio();
    //   });
    // }
    // ===================================================================================


    function loadSFXAudio() {
      LabComClass.childPreloadProgress(78); // Audio SFX loading

      var _totalSfxList = [];
      var _sfxList = modelCls.cPropObj.labObj.globalSfx;
      Object.keys(_sfxList).forEach(function (i) {
        var _sfxTemList = _sfxList[i];
        _sfxList[i].source = modelCls.cPropObj.playerPath + "assets/audio/" + _sfxTemList.source;

        _totalSfxList.push(_sfxList[i]);
      });

      if (_sfxList.length > 0) {
        var _aPlayer = modelCls.cPropObj.audioContextCls;

        _aPlayer.sfxObj.add(_totalSfxList, function () {
          onModelUpdateCls.trigger("setCProp", {}, "onSFXLoad");
        });
      } else {
        onModelUpdateCls.trigger("setCProp", {}, "onSFXLoad");
      }
    } // ===================================================================================


    function scriptLoader(_dataObj, _scriptArr, _callBackFn) {
      var _cnt = 0;

      for (var i = 0; i < _scriptArr.length; i++) {
        _cnt++;
        addScript(_scriptArr[i], onloaded, 0);
      } // ----------------------------


      function onloaded() {
        _cnt--;

        if (_cnt <= 0) {
          _callBackFn();
        }
      }
    } // ===================================================================================


    function addScript(src, callback, loadCnt) {
      var s = document.createElement("script");
      s.setAttribute("data-load-cnt", loadCnt);
      s.onload = callback;

      s.onerror = function (e) {
        if (loadCnt <= 2) {
          setTimeout(function () {
            addScript(src, callback, loadCnt + 1);
          }, 500);
        } else if (typeof trackJs !== "undefined") {
          trackJs.console.error("script onload error URL : " + src);
          window.alert("There was an error loading a critical file for this lesson. The lesson needs to close");
          onViewUpdateCls.trigger("onGlobalUpdate", {
            type: "onClosePlayerWindow"
          });
        }
      };

      s.setAttribute("src", src);
      document.getElementsByTagName("head")[0].appendChild(s);
    } // ===================================================================================


    function componentInit(_ref) {
      var _globalData$_iInt;

      var _iInt = _ref._iInt;
      var _compListObj = {};
      var _globalData = modelCls.cPropObj.labObj.components;
      var _interactiveLayerArr = modelCls.cPropObj.interactiveLayerArr;

      var _idObj = ((_globalData$_iInt = _globalData[_iInt]) === null || _globalData$_iInt === void 0 ? void 0 : _globalData$_iInt.initdata) || {};

      _idObj.id = _globalData[_iInt].id;
      _idObj.domLayer = modelCls.vPropObj.domLayerObj;
      _idObj.canvas = modelCls.vPropObj.contCanvasObj;
      _idObj.context = modelCls.vPropObj.contContextObj;
      _idObj.deviceTypeBool = modelCls.cPropObj.deviceTypeBool;
      _idObj.devScaleRatioInt = modelCls.vPropObj.scaledDataObj.devScaleRatioInt;
      _idObj.playerConfigObj = modelCls.cPropObj.playerConfigObj;
      _idObj.LabComClass = LabComClass;

      var _func = eval(_globalData[_iInt].ref);

      _compListObj[_globalData[_iInt].id] = {};
      _compListObj[_globalData[_iInt].id].obj = new _func(_idObj);

      _interactiveLayerArr.push(_globalData[_iInt].id);

      onModelUpdateCls.trigger("setCProp", {
        compListObj: _objectSpread(_objectSpread({}, modelCls.cPropObj.compListObj), _compListObj),
        interactiveLayerArr: _interactiveLayerArr
      }, "");
    }

    function createCompList() {
      // Checking if tasktable is there ,if not then removing the tasktableWrapper
      var isTaskTablePresent = false; // ------------------------

      var _globalData = modelCls.cPropObj.labObj.components;

      if (_globalData.length > 0) {
        componentInit({
          _iInt: 0
        });
      }

      if (_globalData.find(function (elem) {
        return elem.ref == "TaskTableCompClass";
      })) {
        isTaskTablePresent = true;
      } // Removing for the All Gamar Activity


      if (!isTaskTablePresent) {
        var _wrapper = document.querySelectorAll(".taskTableWrapper")[0];

        _wrapper.remove();
      } // ----------------------------

    } // ===================================================================================


    function allCompLoaded(e) {
      var _returnStr = "";
      var _compCountInt = modelCls.cPropObj.compCountInt;
      var _totalCompCountInt = modelCls.cPropObj.labObj.components.length;
      _compCountInt++;

      if (_compCountInt >= _totalCompCountInt) {
        _returnStr = "onCompListAdd";
        setTimeout(function () {
          onModelUpdateCls.trigger("setCProp", {
            compCountInt: _compCountInt
          }, _returnStr);
        }, 100);
      } else {
        onModelUpdateCls.trigger("setCProp", {
          compCountInt: _compCountInt
        }, _returnStr);

        if (_compCountInt < _totalCompCountInt) {
          componentInit({
            _iInt: _compCountInt
          });
        }
      }
    } // ===================================================================================


    function sendInstanceToAct() {
      var _compListObj = modelCls.cPropObj.compListObj;
      var _obj = {};

      if (Object.keys(_compListObj).length <= 0) {
        requestAnimationFrame(sendInstanceToAct);
      } else {
        Object.keys(_compListObj).forEach(function (j) {
          _obj[j] = _compListObj[j].obj;
        });
        var _idObj = {};
        _idObj.spineObj = _obj;
        _idObj.spineObj.LabComClass = LabComClass;

        var _brainClassObj = eval("BrainClass");

        var _brainObj = new _brainClassObj(_idObj);

        onModelUpdateCls.trigger("setCProp", {
          brainObj: _brainObj
        }, "onActivityInited");
      }
    }

    function getTableData(toolArray, infoObj) {
      var content = '<table aria-label="table" style = "border:1px solid black;border-collapse: collapse">\
        <tr role="' + modelCls.cPropObj.globalTextObj.ariaLabel["row"] + '" style = "border:1px solid black">\
          <th aria-label="' + modelCls.cPropObj.globalTextObj.ariaLabel["col"] + "" + 1 + '" style = "padding: 5px 10px;border:1px solid black">Werkzeug</th>\
          <th aria-label="' + modelCls.cPropObj.globalTextObj.ariaLabel["col"] + "" + 2 + '" style = "padding: 5px 20px;border:1px solid black">Symbol</th>\
          <th aria-label="' + modelCls.cPropObj.globalTextObj.ariaLabel["col"] + "" + 3 + '" style = "padding: 5px 50px;border:1px solid black">Funktionsweise</th>\
        </tr>';
      toolArray.forEach(function (tool, index) {
        tool = tool.includes("brush") ? "color" : tool;
        var height = tool === "point" ? "20px" : "70px";
        content += '<tr role="row" aria-label="' + modelCls.cPropObj.globalTextObj.ariaLabel["row"] + "" + (index + 2) + '"  style = "border:1px solid black">\
            <td role="cell" aria-label="' + modelCls.cPropObj.globalTextObj.ariaLabel["row"] + (index + 2) + modelCls.cPropObj.globalTextObj.ariaLabel["col"] + 1 + '" style = "padding: 5px 10px;border:1px solid black">' + infoObj.toolGerman[tool] + '</td>\
            <td role="cell" aria-label="' + modelCls.cPropObj.globalTextObj.ariaLabel["row"] + (index + 2) + modelCls.cPropObj.globalTextObj.ariaLabel["col"] + 2 + ' style = "padding: 5px 20px;vertical-align:middle;border:1px solid black"><img alt="' + infoObj.toolImgAltText[tool] + '" src="assets/images/' + tool + '.svg" style = "height:' + height + ';width:70px;vertical-align:text-top"/></td>\
            <td role="cell" aria-label="' + modelCls.cPropObj.globalTextObj.ariaLabel["row"] + index + modelCls.cPropObj.globalTextObj.ariaLabel["col"] + 3 + '" style = "padding: 5px 50px;border:1px solid black">' + infoObj[tool] + "</td>\
          </tr>";
      });
      content += "</table>";
      return content;
    } // ===================================================================================


    function updatePopupContent(_ref2) {
      var title = _ref2.title,
          contentKey = _ref2.contentKey;
      var _modelCls$vPropObj$in = modelCls.vPropObj.infoPopupObj,
          titleDiv = _modelCls$vPropObj$in.titleDiv,
          contentDiv = _modelCls$vPropObj$in.contentDiv;
      var content = LabComClass.globalLangText[title] || modelCls.cPropObj.globalTextObj[contentKey][title];
      titleDiv.innerHTML = title;

      if (title !== "Werkzeugliste") {
        contentDiv.innerHTML = content;
      } else {
        // const toolsUsed = LabComClass.globalLangText['toolsUsed'];
        // const toolArray = toolsUsed.split(",");
        var toolArray = ["move", "select", "color", "point", "segment", "segmentDash", "segSize", "ray", "line", "angleRay", "angleSize", "angle", "perpendicularLine", "parallelLine", "circle", "circleSize", "circle_3", "compass", "length", "mirrorOnLine", "midPoint", "mirrorOnPoint", "perpendicularBisector", "angleB", "triangle", "square", "labelTool", "delete"];
        contentDiv.innerHTML = getTableData(toolArray, modelCls.cPropObj.globalTextObj[contentKey][title]); // contentDiv.innerHTML = getTableData(modelCls.cPropObj.toolsUsed,modelCls.cPropObj.globalTextObj[contentKey][title]);
      }

      var a = document.getElementsByTagName("a");

      function navigateAnchor(event) {
        if (!event) var event = window.event;

        if (event.keyCode === 32) {
          window.open(event.target.href, "_blank");
        }

        return true;
      }

      for (var idx = 0; idx < a.length; ++idx) {
        a[idx].addEventListener("keyup", navigateAnchor);
      }
    } // ===================================================================================
    // ----------------------
    // ----------------------


    onModelUpdateCls.on("controllerInit", init);
    onModelUpdateCls.on("onChange", onChange); // ----------------------------

    onViewUpdateCls.on("onGlobalUpdate", onGlobalUpdate);
  } // ===================================================================================
  // ===================================================================================

  /*
   * Audio player
   */


  function AudioContextClass() {
    var thisObj = this;
    var context;
    var bufferLoader;
    var support;
    var hasOProp = Object.prototype.hasOwnProperty;
    var audioObj = new AudioNativeClass();
    var audioList;
    var audioListArr;
    var previosAudio = "";
    var currentAudioCnt = 0;
    var audioContextFallbackArr = [];
    var loadCnt = 0;
    var desiredSampleRate = 44100;
    var mediaErrorCls = new MediaErrorHandlingClass({
      refObj: thisObj,
      element: null,
      type: "audioContext"
    });

    if (isAudioContextSupported()) {
      support = true;
      context = new window.AudioContext();
    } else {
      support = false;
    }

    support = false;

    function SFXClass() {
      var audios = {};

      this.add = function (_audioListArr, _callBackFn) {
        mediaErrorCls.registerRequest({
          action: "add",
          audioListArr: _audioListArr,
          callBackFn: _callBackFn
        });
        audioListArr = _audioListArr;

        if (support === true) {
          var finishedLoading = function finishedLoading(_list) {
            Object.keys(_list).forEach(function (i) {
              audios[_list[i].key] = {};
              audios[_list[i].key] = _list[i];
            });

            _callBackFn();
          };

          bufferLoader = new BufferLoaderClass(context, _audioListArr, finishedLoading);
          bufferLoader.load();
        } else {
          Object.keys(_audioListArr).forEach(function (k) {
            if (thisObj.mp3Support() === false) {
              _audioListArr[k].source = _audioListArr[k].source.replace(".mp3", ".ogg");
            }

            audios[_audioListArr[k].key] = new Howl({
              src: [_audioListArr[k].source]
            });

            audios[_audioListArr[k].key].once("load", loadComplete);

            audios[_audioListArr[k].key].once("loaderror", loaderror);
          });
          /* var i = 0;
           for (i = 0; i < 10; i += 1) {
           audioContextFallbackArr[i] = new AudioNativeClass();
           if (typeof _audioListArr[i] !== 'undefined') {
           audioContextFallbackArr[i].addAudio({
           src: _audioListArr[i].source
           });
           }
           } */
          // _callBackFn();
        }

        function loaderror(error) {
          console.log("loaderror", error);
          mediaErrorCls.pushError(JSON.stringify(error));
        }

        function loadComplete() {
          loadCnt += 1;

          if (_audioListArr.length === loadCnt) {
            _callBackFn();
          }
        }
      };

      this.play = function (_keyNum, _callBackFn) {
        if (support === true && audios[_keyNum]) {
          audios[_keyNum].context = context.createBufferSource();

          if (audios[_keyNum].context.context.sampleRate !== desiredSampleRate) {
            // console.log(audios[_keyNum].context.context.sampleRate, 'sampleRate');
            var buffer = context.createBuffer(1, 1, desiredSampleRate);
            audios[_keyNum].context = context.createBufferSource();
            audios[_keyNum].context.buffer = buffer;

            audios[_keyNum].context.connect(context.destination);

            audios[_keyNum].context.start(0);

            audios[_keyNum].context.disconnect();

            context.close();
            context = new window.AudioContext();
            audios[_keyNum].context = context.createBufferSource();
          }

          if (_callBackFn) {
            audios[_keyNum].context.onended = _callBackFn;
          }

          audios[_keyNum].context.buffer = audios[_keyNum].buffer;

          audios[_keyNum].context.connect(context.destination);

          audios[_keyNum].context.start(0);
        } else if (audios[_keyNum]) {
          audios[_keyNum].play(); // console.log('play sfx without audio API', _keyNum);

        }
      };

      this.setAudioList = function (_audioListArr) {
        audioList = _audioListArr;
      };
    }

    this.sfxObj = new SFXClass();

    this.mp3Support = function () {
      var audioObj = document.createElement("audio");
      var temp = !!(audioObj.canPlayType && audioObj.canPlayType("audio/mpeg;").replace(/no/, ""));
      return temp;
    }; // ----------------------------

    /*
     *  audio loading system for audio context
     */


    function BufferLoaderClass(_contextObj, _urlListArr, _callBackFn) {
      this.context = _contextObj;
      this.urlList = _urlListArr;
      this.onload = _callBackFn;
      this.bufferList = [];
      this.loadCount = 0;
    }

    BufferLoaderClass.prototype.loadBuffer = function (_urlStr, _indexNum) {
      // Load buffer asynchronously
      // console.log(thisObj.mp3Support(), 'mp3 support');
      if (thisObj.mp3Support() === false) {
        _urlStr = _urlStr.replace(".mp3", ".ogg");
      }

      var request = new XMLHttpRequest();
      request.open("GET", _urlStr, true);
      request.responseType = "arraybuffer";
      var loader = this;

      request.onload = function () {
        // Asynchronously decode the audio file data in request.response
        loader.context.decodeAudioData(request.response, function (buffer) {
          /* if (!buffer) {
           console.log('error decoding file data: ' + _urlStr);
           return;
           } */
          // loader.bufferList[_indexNum] = buffer;
          loader.bufferList[_indexNum] = _indexNum;
          loader.urlList[_indexNum].buffer = buffer;

          if (++loader.loadCount === loader.urlList.length) {
            loader.onload(loader.urlList);
          }
        }, function (error) {
          console.log("decodeAudioData error", error);

          if (typeof trackJs !== "undefined") {
            trackJs.console.error("Audio load error " + JSON.stringify(error)); // t4
          }

          window.alert("There was an error loading a critical file for this lesson. The lesson needs to close");
          onViewUpdateCls.trigger("onGlobalUpdate", {
            type: "onClosePlayerWindow"
          });
        });
      };

      request.onerror = function (error) {
        console.log("onerror", error);

        if (typeof trackJs !== "undefined") {
          trackJs.console.error("Audio load error"); // t5
        }

        window.alert("There was an error loading a critical file for this lesson. The lesson needs to close");
        onViewUpdateCls.trigger("onGlobalUpdate", {
          type: "onClosePlayerWindow"
        });
      };

      request.send();
    };

    BufferLoaderClass.prototype.load = function () {
      for (var i = 0; i < this.urlList.length; ++i) {
        this.loadBuffer(this.urlList[i].source, i);
      }
    };
  }

  function AudioNativeClass() {
    var audioObj = new Audio();
    var hasOProp = Object.prototype.hasOwnProperty;
    var thisObj = this;

    var ended = function ended() {};

    var onerror = function onerror() {};

    var started = function started() {};

    var stopOnLoad = false;
    var playStartedIntervalInt;
    var latestAction;
    var instantiateBool = false;
    var mediaErrorCls = new MediaErrorHandlingClass({
      refObj: thisObj,
      element: audioObj,
      type: "audio"
    });
    audioObj.addEventListener("ended", function () {
      ended(); // ended = function () {};
    }, false);
    audioObj.addEventListener("error", function (error) {
      mediaErrorCls.pushError(error); // onerror();
      // onerror = function () {};
    }, false); // audioObj.addEventListener('canplaythrough', function () {
    // }, false);

    this.addAudio = function (_dataObj) {
      latestAction = "add";
      mediaErrorCls.registerRequest({
        action: "add",
        dataObj: _dataObj
      });
      audioObj.src = "";

      if (hasOProp.call(_dataObj, "callback")) {
        ended = function ended() {
          _dataObj.callback();
        };
      } else {
        ended = function ended() {};
      }

      if (hasOProp.call(_dataObj, "startCallback")) {
        started = function started() {
          _dataObj.startCallback();
        };
      } else {
        started = function started() {};
      }

      if (hasOProp.call(_dataObj, "errorCallback")) {
        onerror = function onerror() {
          _dataObj.errorCallback();
        };
      } else {
        onerror = function onerror() {};
      }

      if (hasOProp.call(_dataObj, "stopOnLoad")) {
        stopOnLoad = _dataObj.stopOnLoad;
      } else {
        stopOnLoad = false;
      }

      if (this.mp3Support() === false) {
        _dataObj.src = _dataObj.src.replace(".mp3", ".ogg");
      }

      mediaErrorCls.setFilePath(_dataObj.src);
      audioObj.src = _dataObj.src;
      audioObj.load();
      checkForPlayStart();
    };

    this.mp3Support = function () {
      var audioObj = document.createElement("audio");
      var temp = !!(audioObj.canPlayType && audioObj.canPlayType("audio/mpeg;").replace(/no/, ""));
      return temp;
    };

    this.removeAudio = function () {
      trace("remove audio...");
      latestAction = "remove";
      audioObj.src = "";
    };

    this.callEnded = function () {
      trace("call ended...");
      /* ended();
       ended = function () {}; */
    };

    this.playAudio = function (_timeNum) {
      latestAction = "play";
      mediaErrorCls.registerRequest({
        action: "playAudio",
        dataObj: _timeNum
      });

      if (typeof _timeNum !== "undefined") {
        audioObj.currentTime = _timeNum;
      }

      if (audioObj.src !== "") {
        var playPromise = audioObj.play();

        if (playPromise !== undefined) {
          playPromise.then(function () {
            // Automatic playback started!
            instantiateBool = true;
          })["catch"](function (error) {
            // Automatic playback failed.
            // Show a UI element to let the user manually start playback.
            if (audioObj.error === null) {
              if (instantiateBool === false) {
                onModelUpdateCls.trigger("setCProp", {
                  mediaPromiseErrorTypeStr: "audio"
                });
                console.log("playPromise error audio", error);
                started();

                started = function started() {};

                onViewUpdateCls.trigger("onGlobalUpdate", {
                  type: "navPauseBtnClick"
                });
              }
            } else {
              mediaErrorCls.pushError(error); // retry();
            }
          });
        }
      }
    };

    this.pauseAudio = function () {
      trace("pause audio...");
      latestAction = "pause";

      if (audioObj.src !== "" && audioObj.currentTime > 0) {
        audioObj.pause();
      }
    };

    this.getCurrentTime = function () {
      trace("Get current Time ...");
      return audioObj.currentTime;
    };

    this.reload = function () {
      latestAction = "reload";
      var _tempSrc = audioObj.src;
      audioObj.src = "";
      audioObj.src = _tempSrc;
    }; // --------


    function checkForPlayStart() {
      clearInterval(playStartedIntervalInt);

      if (audioObj.src.indexOf("blank.") === -1) {
        playStartedIntervalInt = setInterval(function () {
          if (audioObj.currentTime > 0) {
            clearInterval(playStartedIntervalInt);
            started();

            started = function started() {};

            if (stopOnLoad === true) {
              stopOnLoad = false;
              thisObj.pauseAudio();
            }

            if (latestAction === "pause") {
              thisObj.pauseAudio();
            }
          }
        }, 5);
      }
    }
  }

  function trace(msg) {// console.log(msg);
  }

  function isAudioContextSupported() {
    // This feature is still prefixed in Safari
    window.AudioContext = window.AudioContext || window.webkitAudioContext;

    if (window.AudioContext) {
      return true;
    }

    return false;
  } // ===================================================================================
  // DETECT BROWSER TO IDENTIFY THE PLATFORM
  // ===================================================================================


  function MediaErrorHandlingClass(_obj) {
    var errorCnt = 0;
    var maxRetries = 3;
    var mediaCls = _obj.refObj;
    var mediaElement = _obj.element;
    var type = _obj.type;
    var thisObj = this;
    var previousRequestObj = {
      action: null,
      dataObj: null
    };
    var filePathStr = "No file source";

    this.registerRequest = function (_previousRequestObj) {
      previousRequestObj = _previousRequestObj;
    };

    this.setFilePath = function (_filePathStr) {
      if (typeof _filePathStr !== "undefined") {
        filePathStr = _filePathStr;
      }
    };

    this.pushError = function (_error, _bool) {
      errorCnt += 1; // video playback failed - show a message saying why

      var errorMsg;

      switch (type) {
        case "audio":
        case "video":
          switch (mediaElement.error.code) {
            case mediaElement.error.MEDIA_ERR_ABORTED:
              errorMsg = "You aborted the audio/video playback.";
              break;

            case mediaElement.error.MEDIA_ERR_NETWORK:
              errorMsg = "A network error caused the audio/video download to fail part-way.";
              break;

            case mediaElement.error.MEDIA_ERR_DECODE:
              errorMsg = "The video/Audio playback was aborted due to a corruption problem or because the audio/video used features your browser did not support.";
              break;

            case mediaElement.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
              errorMsg = "The video/Audio could not be loaded, either because the server or network failed or because the format is not supported.";
              break;

            default:
              errorMsg = "An unknown error occurred.";
              break;
          }

          break;

        case "audioContext":
          errorMsg = "audio sfx missing";
          break;

        default:
          break;
      }

      if (errorCnt <= maxRetries) {
        // thisObj.playVideo();
        console.log("media error retry delay started");
        setTimeout(function () {
          console.log("media error retry delay end");

          switch (type) {
            case "video":
              if (previousRequestObj.action === "add") {
                mediaCls.add(previousRequestObj.dataObj);
              } else {
                mediaCls.reload();
                mediaCls.playVideo(previousRequestObj.dataObj);
              }

              break;

            case "audio":
              if (previousRequestObj.action === "add") {
                mediaCls.addAudio(previousRequestObj.dataObj);
              } else {
                mediaCls.reload();
                mediaCls.playAudio(previousRequestObj.dataObj);
              }

              break;

            case "audioContext":
              if (previousRequestObj.action === "add") {
                mediaCls.sfxObj.add(previousRequestObj.audioListArr, previousRequestObj.callBackFn);
              }

              break;

            default:
              break;
          }
        }, 500);
      } else if (errorCnt === maxRetries + 1) {
        console.log(errorMsg + "file path = " + filePathStr);

        if (typeof trackJs !== "undefined") {
          if (filePathStr !== "No file source") {
            trackJs.console.error(errorMsg + "; file path = " + filePathStr); // t6
          } else {
            trackJs.console.error(errorMsg); // t6
          }
        }

        thisObj.backToDashboard();
      }
    };

    this.backToDashboard = function () {
      window.alert("There was an error loading a critical file for this lesson. The lesson needs to close");
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "onClosePlayerWindow"
      });
    };
  } // ===================================================================================


  function KeyHandlerClass() {
    var eventListeners = {};

    this.init = function () {
      window.addEventListener("keyup", onKeyEvent);
      window.addEventListener("keydown", onKeyEvent);
      window.addEventListener("keypress", onKeyEvent);
    };

    this.addKeyEvents = function (_ref3) {
      var id = _ref3.id,
          callback = _ref3.callback;

      if (!eventListeners[id]) {
        eventListeners[id] = [];
      }

      eventListeners[id].push(callback);
    };

    this.removeKeyEvents = function (_ref4) {
      var id = _ref4.id,
          callback = _ref4.callback;

      if (isListenerRegister(id)) {
        var index = eventListeners[id].indexOf(callback);
        eventListeners[id].splice(index, 1);

        if (eventListeners[id].length === 0) {
          delete eventListeners[id];
        }
      }
    };

    function onKeyEvent(e) {
      Object.keys(eventListeners).forEach(function (id) {
        eventListeners[id].forEach(function (callback) {
          callback({
            nativeEvent: e,
            compId: id
          });
        });
      });
    }

    function isListenerRegister(id) {
      return eventListeners[id] && eventListeners[id].length > 0;
    }
  } // ===================================================================================
  // ===================================================================================


  function MouseHandlerClass() {
    var dataObj = {};
    var scaledDataObj = {};
    var mouseRegionObj = {};
    var lastPageX = 0;
    var lastPageY = 0;
    var mouseEvents = {};
    var mousePoniterStyle = "default";
    var activeElement = null;
    var newMouseEnterElement = null;
    var mouseContextObj;
    var hitAreaArr;
    var enableMouseEvents = true; // ============================================

    this.init = function (_obj) {
      dataObj = _obj;
      var _mousObj = {
        down: "mousedown",
        move: "mousemove",
        up: "mouseup",
        click: "click"
      };
      mouseEvents = dataObj.deviceTypeBool ? {
        down: "touchstart",
        move: "touchmove",
        up: "touchend",
        click: "click"
      } : _mousObj;
      mouseContextObj = dataObj.mouseCanvasObj.getContext("2d"); // // ----------------------------

      applyMouseEvents(true); // // ----------------------------

      onViewUpdateCls.on("onGlobalUpdate", onGlobalUpdate);
    }; // ============================================


    this.updateOnResize = function (_obj) {
      scaledDataObj = _obj;
      upadteHitAreas();
    }; // ============================================


    this.updateInteractiveLayer = function (_obj) {
      dataObj.interactiveLayerArr = _obj;
      upadteHitAreas();
    };

    this.toggleMouseEvents = function (_bool) {
      enableMouseEvents = _bool;
    }; // ============================================
    // mouseenter, mouseout, mousedown, mouseup, mouseover


    this.addMouseEvent = function (_dataObj) {
      if (!mouseRegionObj[_dataObj.id]) {
        mouseRegionObj[_dataObj.id] = [];
      } // -----


      for (var i = 0; i < _dataObj.r.length; i++) {
        var _flagBool = false;

        for (var j = 0; j < mouseRegionObj[_dataObj.id].length; j++) {
          if (mouseRegionObj[_dataObj.id][j].id === _dataObj.r[i].id) {
            _flagBool = true;
            Object.keys(_dataObj.r[i]).forEach(function (k) {
              mouseRegionObj[_dataObj.id][j][k] = _dataObj.r[i][k];
            });
          }
        }

        if (!_flagBool) {
          mouseRegionObj[_dataObj.id].push(_dataObj.r[i]);
        }
      }

      upadteHitAreas();
    };

    this.setCursor = function (_dataObj) {
      for (var j = 0; j < mouseRegionObj[_dataObj.id].length; j++) {
        if (mouseRegionObj[_dataObj.id][j].id === _dataObj.subId) {
          if (_dataObj.cursor) {
            mouseRegionObj[_dataObj.id][j].cursor = _dataObj.cursor;
          }

          if (_dataObj.downCursor) {
            mouseRegionObj[_dataObj.id][j].downCursor = _dataObj.downCursor;
          }

          break;
        }
      }
    }; // ============================================


    this.removeMouseEvent = function (_dataObj) {
      if (_dataObj.r && mouseRegionObj[_dataObj.id]) {
        for (var i = 0; i < _dataObj.r.length; i++) {
          for (var j = 0; j < mouseRegionObj[_dataObj.id].length; j++) {
            if (mouseRegionObj[_dataObj.id][j].id === _dataObj.r[i]) {
              mouseRegionObj[_dataObj.id].splice(j, 1);
            }
          }
        }
      } else if (mouseRegionObj[_dataObj.id]) {
        delete mouseRegionObj[_dataObj.id];
      }

      upadteHitAreas();
    };

    this.getCursor = function () {
      return mousePoniterStyle;
    }; // ============================================
    // PRIVATE AREA
    // ============================================


    function onGlobalUpdate(_dataObj) {
      switch (_dataObj.type) {
        case "resumeGlobalMouseEvent":
          applyMouseEvents(true);
          break;

        case "stopGlobalMouseEvent":
          applyMouseEvents(false);
          break;

        default:
          break;
      }
    }

    function upadteHitAreas() {
      var _intArr = dataObj.interactiveLayerArr;

      if (_intArr) {
        hitAreaArr = [];

        for (var i = _intArr.length - 1; i >= 0; i--) {
          var _elem = mouseRegionObj[_intArr[i]];

          if (typeof _elem !== "undefined") {
            for (var _nni = _elem.length - 1; _nni >= 0; _nni--) {
              var _obj = {
                id: _intArr[i],
                subId: _elem[_nni].id,
                color: getRandomColor(),
                rect: _elem[_nni].rect,
                arc: _elem[_nni].arc,
                shape: _elem[_nni].shape
              };
              hitAreaArr.push(_obj);
            }
          }
        }

        drawNav();
      }
    } // ============================================


    function drawNav() {
      if (typeof scaledDataObj.scale !== "undefined") {
        mouseContextObj.clearRect(0, 0, dataObj.mouseCanvasObj.width, dataObj.mouseCanvasObj.height);
        mouseContextObj.save();
        mouseContextObj.scale(scaledDataObj.scale, scaledDataObj.scale);

        for (var _ni = hitAreaArr.length - 1; _ni >= 0; _ni--) {
          var _el = hitAreaArr[_ni];
          mouseContextObj.beginPath();
          mouseContextObj.fillStyle = _el.color;

          if (typeof _el.rect !== "undefined") {
            mouseContextObj.fillRect(_el.rect.x, _el.rect.y, _el.rect.w, _el.rect.h);
          } else if (typeof _el.arc !== "undefined") {
            mouseContextObj.arc(_el.arc.x, _el.arc.y, _el.arc.r, 0, 2 * Math.PI);
            mouseContextObj.fill();
          } else if (typeof _el.shape !== "undefined") {
            for (var _sh = 0; _sh < _el.shape.length; _sh++) {
              eval("mouseContextObj." + _el.shape[_sh]);
            }

            mouseContextObj.fill();
          }

          mouseContextObj.closePath();
        }

        mouseContextObj.restore();
      }
    } // ============================================


    function mouseEventHandler(e) {
      if (!enableMouseEvents) {
        return;
      }

      var pageX, pageY;

      if (LabComClass.BrowserDetect.isDevice()) {
        if (typeof e.targetTouches[0] !== "undefined") {
          lastPageX = e.targetTouches[0].pageX;
          lastPageY = e.targetTouches[0].pageY;
          pageX = lastPageX;
          pageY = lastPageY;
        } else {
          pageX = lastPageX;
          pageY = lastPageY;
        }
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      } // ----------------------------


      var typeStr = "";

      switch (e.type) {
        case "touchstart":
        case "mousedown":
          typeStr = "mousedown";

          if (e.button && e.button === 2) {
            typeStr = "rightmousedown";
          }

          break;

        case "touchmove":
        case "mousemove":
          typeStr = "mousemove";
          break;

        case "touchend":
        case "mouseup":
          typeStr = "mouseup";

          if (e.button && e.button === 2) {
            typeStr = "rightmouseup";
          }

          break;

        case "click":
          // typeStr = 'mouseup';
          break;

        default:
          break;
      }

      pageX -= scaledDataObj.x;
      pageY -= scaledDataObj.y;

      if (typeStr !== "") {
        isMouseInRegion({
          pageX: pageX,
          pageY: pageY,
          typeStr: typeStr
        });
      } // if (!LabComClass.BrowserDetect.isDevice()) {
      //   e.preventDefault();
      // }

    } // ============================================


    function isMouseInRegion(_obj) {
      var _mouseType = "default";

      var _activeElement = checkMouseIn(_obj.pageX, _obj.pageY); // ------------------


      if (_obj.typeStr === "mousemove") {
        if (activeElement === null) {
          if (_activeElement !== null) {
            if (newMouseEnterElement === null || newMouseEnterElement.id !== _activeElement.id || newMouseEnterElement.subIndex !== _activeElement.subIndex) {
              if (newMouseEnterElement !== null) {
                // leaves the interactive area to another interactive area.
                dispatchMouseEvent("mouseout", _obj, newMouseEnterElement);
              } // Enters the interactive area for the first time.


              dispatchMouseEvent("mouseenter", _obj, _activeElement);
              newMouseEnterElement = _activeElement;
            } else {
              // Mve dispatch once entered.
              dispatchMouseEvent("mousemove", _obj, newMouseEnterElement);
            }
          } else if (newMouseEnterElement !== null) {
            // Leaves the interactive area to the stage. called once
            dispatchMouseEvent("mouseout", _obj, newMouseEnterElement);
            newMouseEnterElement = _activeElement;
          }
        } else {
          // Move dispatch once clicked.
          dispatchMouseEvent("pressmove", _obj, activeElement);
        }
      } // ------------------


      if (_obj.typeStr === "mousedown") {
        if (activeElement === null && _activeElement !== null) {
          activeElement = _activeElement;
          dispatchMouseEvent(_obj.typeStr, _obj, activeElement);
          dispatchStageEvent(activeElement);
        } else {
          dispatchStageEvent(activeElement);
        }
      }

      if (_obj.typeStr === "rightmousedown") {
        if (activeElement === null && _activeElement !== null) {
          console.log("**FRINF.");
          dispatchMouseEvent(_obj.typeStr, _obj, _activeElement);
        } // dispatchStageEvent(_activeElement);

      } // ------------------


      if ((_obj.typeStr === "mouseup" || _obj.typeStr === "rightmouseup") && activeElement !== null) {
        if (_activeElement !== null && activeElement.id === _activeElement.id && activeElement.subId === _activeElement.subId) {
          // If released on the same pressed element.
          dispatchMouseEvent(_obj.typeStr, _obj, activeElement);
        } else {
          // If released outside of the pressed element.
          dispatchMouseEvent(_obj.typeStr === "mouseup" ? "mouseupout" : "rightmouseupout", _obj, activeElement);
        }

        newMouseEnterElement = null;
        activeElement = null;
      } // ------------------


      if (activeElement !== null) {
        _mouseType = typeof activeElement.cursor === "undefined" ? "pointer" : activeElement.cursor;

        if ((_obj.typeStr === "mousemove" || _obj.typeStr === "mousedown") && activeElement.downCursor) {
          _mouseType = activeElement.downCursor;
        }
      } else {
        var _overElement = checkMouseIn(_obj.pageX, _obj.pageY);

        if (_overElement !== null) {
          _mouseType = typeof _overElement.cursor === "undefined" ? "pointer" : _overElement.cursor;
        }
      } // ------------------


      if (mousePoniterStyle !== _mouseType) {
        // dataObj.mouseCanvasObj.style.cursor = _mouseType;
        document.body.style.cursor = _mouseType;
      }

      mousePoniterStyle = _mouseType;
    } // mouseenter, mouseout, mousedown, mouseup, mouseover
    // ============================================


    function dispatchMouseEvent(_typeStr, _obj, _elem) {
      var _actElem = mouseRegionObj[_elem.id] ? mouseRegionObj[_elem.id][_elem.subIndex] : undefined;

      if (typeof _actElem !== "undefined" && typeof _actElem.eventListener !== "undefined") {
        var _e = {
          id: _elem.id,
          subId: _actElem.id,
          type: _typeStr,
          pageX: _obj.pageX / scaledDataObj.scale,
          pageY: _obj.pageY / scaledDataObj.scale
        }; // _actElem.eventListener(_e);

        setTimeout(function () {
          _actElem.eventListener(_e);

          onViewUpdateCls.trigger("onGlobalUpdate", {
            type: "rendererUpdate"
          });
        }, 0);
      } // onViewUpdateCls.trigger('onGlobalUpdate', {
      //   type: 'rendererUpdate'
      // });

    } // ============================================


    function dispatchStageEvent(_obj) {
      if (_obj === null) {
        _obj = {
          id: null,
          subId: null
        };
      }

      Object.keys(mouseRegionObj).forEach(function (_key) {
        for (var i = 0; i < mouseRegionObj[_key].length; i++) {
          var _actElem = mouseRegionObj[_key][i];

          if (typeof _actElem.eventListener !== "undefined") {
            var _e = {
              id: _obj.id,
              subId: _obj.id,
              type: "stageevent",
              pageX: _obj.pageX / scaledDataObj.scale,
              pageY: _obj.pageY / scaledDataObj.scale
            }; // _actElem.eventListener(_e);

            setTimeout(function () {
              _actElem.eventListener(_e);
            }, 0);
          }
        }
      });
    } // ============================================


    function checkMouseIn(_pageXNum, _pageYNum) {
      var _imgData = mouseContextObj.getImageData(_pageXNum, _pageYNum, 1, 1);

      var _colStr = LabComClass.rgba2hex(_imgData.data[0], _imgData.data[1], _imgData.data[2], _imgData.data[3]).substring(0, 6);

      if (_colStr !== "000000") {
        for (var i = 0; i < hitAreaArr.length; i++) {
          var _comStr = hitAreaArr[i].color.replace("#", "");

          if (_comStr === _colStr) {
            var _ittem = mouseRegionObj[hitAreaArr[i].id];

            for (var j = 0; j < _ittem.length; j++) {
              if (_ittem[j].id === hitAreaArr[i].subId) {
                return {
                  id: hitAreaArr[i].id,
                  subIndex: j,
                  cursor: _ittem[j].cursor,
                  downCursor: _ittem[j].downCursor
                };
              }
            }

            break;
          }
        }
      }

      return null;
    } // ============================================


    function getRandomColor() {
      // var letters = '0123456789ABCDEF'.split('');
      var letters = "0123456789".split("");
      var color = "#";

      for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * letters.length)];
      }

      return color;
    } // ============================================


    function applyMouseEvents(_bool) {
      document.body.style.cursor = "default";
      document.body.removeEventListener(mouseEvents.down, mouseEventHandler);
      document.body.removeEventListener(mouseEvents.move, mouseEventHandler);
      document.body.removeEventListener(mouseEvents.up, mouseEventHandler);

      if (_bool) {
        document.body.addEventListener(mouseEvents.down, mouseEventHandler, {
          passive: false
        });
        document.body.addEventListener(mouseEvents.move, mouseEventHandler, {
          passive: false
        });
        document.body.addEventListener(mouseEvents.up, mouseEventHandler, {
          passive: false
        });
      }
    }
  } // ===================================================================================


  var LabComClass = {
    // ================================================================================
    //  STATIC CONTENT SIZE CONSTANTS
    // ================================================================================
    contentAreaObj: {},
    globalLangText: "",
    snapshotCnvObj: {},
    html2CanvasQueueArr: [],
    html2CanvasQueueStarted: false,
    // ===================================================================================
    // Used to set scale of Virtual Canvas globally
    // ===================================================================================
    setCnvScale: function setCnvScale(_scale) {
      LabComClass.scale = _scale;
    },
    // ===================================================================================
    // Used to set reference of Virtual Canvas globally
    // ===================================================================================
    setVirtualCnv: function setVirtualCnv(_can) {
      LabComClass.virtualCnv = _can;
    },
    // To set a cursor on perticular event area from activity or component.
    setCursor: function setCursor(data) {
      if (modelCls.cPropObj.mouseHandleCls.getCursor() !== data.cursor) {
        document.body.style.cursor = data.cursor;
        modelCls.cPropObj.mouseHandleCls.setCursor(data);
      }
    },
    setHeader: function setHeader() {
      var _text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "header";

      modelCls.vPropObj.headerTextObj.innerHTML = _text;
      modelCls.vPropObj.headerTextObj.setAttribute("aria-label", _text);
    },
    // ===================================================================================
    // Used to take snapshot globally
    // ===================================================================================
    setSnapshotCnv: function setSnapshotCnv(_obj) {
      LabComClass.snapshotCnvObj = _obj;
    },
    globalSnapShot: function globalSnapShot(_obj) {
      var _bgImg = new Image();

      _bgImg.onload = function () {
        var _contImg = new Image();

        _contImg.onload = function () {
          var _cnv = LabComClass.snapshotCnvObj.snapshotCnvObj;
          _cnv.width = LabComClass.snapshotCnvObj.contCanvasObj.width;
          _cnv.height = LabComClass.snapshotCnvObj.contCanvasObj.height;
          var _x = 0;
          var _y = 0;

          if (typeof _obj.areaObj !== "undefined") {
            _cnv.width = _obj.areaObj.width * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt;
            _cnv.height = _obj.areaObj.height * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt;
            _x = -1 * (_obj.areaObj.x * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt);
            _y = -1 * (_obj.areaObj.y * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt);
          }

          var _ctx = _cnv.getContext("2d");

          _ctx.drawImage(_bgImg, _x, _y);

          _ctx.drawImage(_contImg, _x, _y);

          var _ssImg = new Image();

          _ssImg.onload = function () {
            if (typeof _obj.callback !== "undefined") {
              var _retImg = new Image();

              _retImg.src = _cnv.toDataURL("image/png");

              _obj.callback(_retImg);
            }
          };

          _ssImg.src = _cnv.toDataURL("image/png");
        };

        _contImg.src = LabComClass.snapshotCnvObj.contCanvasObj.toDataURL("image/png");
      };

      _bgImg.src = LabComClass.snapshotCnvObj.bgCanvasObj.toDataURL("image/png");
    },
    // ===================================================================================
    //  GLOBAL EVENT CLASS FOR INTER FUNCTION COMMUNICATION
    // ===================================================================================
    EventClass: function EventClass(_isLocalBool) {
      var channels = {};
      var eventNumber = 0;
      var hasOProp = Object.prototype.hasOwnProperty; //  Used to publish to subscribers that an event of their interest happened

      this.trigger = function (_eventStr, _dataObj, _typeStr) {
        // _typeStr === 'onGlobalTextLoad' && console.log('........',channels);
        Object.keys(channels).forEach(function (_topic) {
          _typeStr === "onGlobalTextLoad" && _topic === _eventStr && console.log("Here", _dataObj, _typeStr, _topic === _eventStr, _topic, _eventStr, hasOProp.call(channels, _topic));

          if (_topic === _eventStr && hasOProp.call(channels, _topic)) {
            if (_isLocalBool === true) {
              callBackAll(_topic, _dataObj, _typeStr);
            } else {
              requestAnimationFrame(function () {
                callBackAll(_topic, _dataObj, _typeStr);
              });
            }
          }
        });
      }; //  Used to register for the event to listen


      this.on = function (_eventStr, _callBackFn) {
        // requestAnimationFrame(function() {
        if (typeof channels[_eventStr] === "undefined") {
          channels[_eventStr] = [];
        }

        channels[_eventStr].push(_callBackFn); // });

      }; //  Used to unsubscribe/stop listening to the event


      this.off = function (_eventStr, _callBackFn) {
        requestAnimationFrame(function () {
          // delete channels[_eventStr]
          if (typeof channels[_eventStr] !== "undefined") {
            for (var i = 0; i < channels[_eventStr].length; i++) {
              if (channels[_eventStr][i] === _callBackFn) {
                channels[_eventStr].splice(i, 1);
              }
            }
          }
        });
      }; // aa


      function callBackAll(_topic, _dataObj, _typeStr) {
        if (typeof channels[_topic] !== "undefined") {
          for (var j = 0; j < channels[_topic].length; j++) {
            if (typeof channels[_topic][j] === "function") {
              channels[_topic][j](_dataObj, _typeStr);
            }
          }
        }
      }
    },
    // ===================================================================================
    //  GLOBAL DEFINE FUNCTION
    // ===================================================================================
    defineObject: function defineObject(_obj, _key, _value) {
      Object.defineProperty(_obj, _key, {
        value: _value,
        writable: false,
        configurable: true,
        enumerable: true
      });
    },
    global_line_intersect: function global_line_intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      var ua;
      var ub;
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

      if (denom === 0) {
        return null;
      }

      ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
      ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
      return {
        x: x1 + ua * (x2 - x1),
        y: y1 + ub * (y2 - y1),
        seg1: ua >= 0 && ua <= 1,
        seg2: ub >= 0 && ub <= 1
      };
    },
    // ===================================================================================
    //  REQUEST IMAGE LOAD
    // ===================================================================================
    localImagePath: "",
    globalImagePath: "",
    requestLocalImage: function requestLocalImage(_imgArr, _callBackFn, _errorCnt) {
      var _imgObj = {};

      for (var i = 0; i < _imgArr.length; i++) {
        _imgObj[_imgArr[i]] = LabComClass.localImagePath + _imgArr[i];
      }

      LabComClass.imageLoader(_imgObj, _callBackFn, _errorCnt);
    },
    requestGlobalImage: function requestGlobalImage(_imgArr, _callBackFn, _errorCnt) {
      var _imgObj = {};

      for (var i = 0; i < _imgArr.length; i++) {
        _imgObj[_imgArr[i]] = LabComClass.globalImagePath + _imgArr[i];
      }

      LabComClass.imageLoader(_imgObj, _callBackFn, _errorCnt);
    },
    // ===================================================================================
    //  RGBA to Hexa
    // ===================================================================================
    rgba2hex: function rgba2hex(r, g, b, a) {
      if (r > 255 || g > 255 || b > 255 || a > 255) {
        throw "Invalid color component";
      }

      return (256 + r).toString(16).substr(1) + ((1 << 24) + (g << 16) | b << 8 | a).toString(16).substr(1);
    },
    // ===================================================================================
    //  IMAGE LOADER CLASS
    // ===================================================================================
    imageLoader: function imageLoader(_imgObj, _callBackFn, _errorCnt) {
      var _dataObj = {};
      var _cnt = 0;
      var _arr = [];
      var _keys = [];
      var errorCnt = 0;

      if (typeof _errorCnt !== "undefined") {
        errorCnt = _errorCnt;
      }

      var _maxRetries = 3;
      Object.keys(_imgObj).forEach(function (i) {
        _arr.push(_imgObj[i]);

        _keys.push(i);
      });

      function loadImage() {
        var key = _keys[_cnt];
        _dataObj[key] = new Image();
        _dataObj[key].onerror = onerror;
        _dataObj[key].onload = onloaded;
        _dataObj[key].src = _arr[_cnt];
      }

      loadImage();

      function onerror() {
        errorCnt += 1;

        if (errorCnt <= _maxRetries) {
          loadImage();
        } else {
          window.alert("There was an error loading a critical file for this lesson. The lesson needs to close"); // onViewUpdateCls.trigger('onGlobalUpdate', {
          //   type: 'onClosePlayerWindow'
          // });
        }
      } // ----------------------------


      function onloaded() {
        _cnt += 1;
        errorCnt = 0;

        if (_cnt === _arr.length) {
          _callBackFn(_dataObj);
        } else {
          loadImage();
        }
      }
    },
    // ===================================================================================
    //  GLOBAL EVENT CLASS FOR INTER FUNCTION COMMUNICATION
    // ===================================================================================
    BrowserDetect: {
      platformAndroid: function platformAndroid() {
        return !!navigator.userAgent.match(/Android/i);
      },
      platformBlackBerry: function platformBlackBerry() {
        return !!navigator.userAgent.match(/BlackBerry/i);
      },
      platformIOS: function platformIOS() {
        return navigator.userAgent.match(/iPhone|iPad|iPod|caireadymobile/i) ? true : navigator.maxTouchPoints > 0 && typeof window.orientation !== "undefined";
      },
      platformWindows: function platformWindows() {
        return !!navigator.userAgent.match(/IEMobile/i);
      },
      isDevice: function isDevice() {
        return LabComClass.BrowserDetect.platformAndroid() || LabComClass.BrowserDetect.platformBlackBerry() || LabComClass.BrowserDetect.platformIOS() || LabComClass.BrowserDetect.platformWindows();
      },
      browserUserAgentName: function browserUserAgentName() {
        return navigator.userAgent;
      },
      ie9: function ie9() {
        return !!navigator.userAgent.match(/MSIE 9.0/i);
      },
      ie10: function ie10() {
        return !!navigator.userAgent.match(/MSIE 10.0/i);
      },
      ie: function ie() {
        return navigator.appName === "Microsoft Internet Explorer" || !!(navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/rv:11/)) || navigator.userAgent.indexOf("MSIE") > 0 || !!navigator.userAgent.match(/Edge\/\d./i) || !!navigator.userAgent.match(/MSIE 9.0/i) || !!navigator.userAgent.match(/MSIE 10.0/i);
      }
    },
    // ================================================================================
    // GlobalAnimClass is accepts objects
    // id: Required to stop the particular animation.
    // fps (optional): Frame per second.
    // delay (optional): if delay given then fps will not work.
    // start (optional): Callback when the animation starts.
    // frame (optional): Callback when the animation is playing.
    // stop (optional): Callback when the animation stops.
    // ================================================================================
    GlobalAnimClass: function GlobalAnimClass() {
      var animObjects = {};

      var _thisObj = this;

      var animPlaying = false;
      var requestId; // ================================================================

      this.start = function (_obj) {
        if (_obj.id) {
          animObjects[_obj.id] = _obj;

          if (!_obj.immediate) {
            animObjects[_obj.id].oldDate = new Date();
          }

          animObjects[_obj.id].lastFrame = null;

          if (animObjects[_obj.id].start) {
            animObjects[_obj.id].start();
          }
        }

        if (!animPlaying) {
          animPlaying = true;
          enterFrame();
        }
      }; // ================================================================


      this.stop = function (_id) {
        if (_id) {
          if (animObjects[_id]) {
            if (animObjects[_id].stop) {
              animObjects[_id].stop();
            }

            if (animObjects[_id] !== undefined) {
              delete animObjects[_id];
            }
          }
        }

        if (objectSize(animObjects) === 0) {
          animPlaying = false;
          cancelAnimationFrame(requestId);
        }
      }; // ================================================================


      this.reset = function (_id) {
        animObjects[_id].resetVal = true;
      }; // ================================================================


      function enterFrame() {
        var _newDate = new Date(); // --------------------------


        Object.keys(animObjects).forEach(function (i) {
          if (animObjects[i].delay !== undefined) {
            if (typeof animObjects[i].oldDate === "undefined" || _newDate - animObjects[i].oldDate >= animObjects[i].delay) {
              animObjects[i].oldDate = _newDate;

              if (animObjects[i].frame) {
                animObjects[i].frame(i);
              }
            }
          } else if (animObjects[i].fps !== undefined) {
            var _curFrame = Math.ceil((_newDate - animObjects[i].oldDate) / (1 / animObjects[i].fps * 1000));

            if (animObjects[i].lastFrame !== _curFrame) {
              if (animObjects[i].resetVal) {
                animObjects[i].oldDate = new Date();
                _curFrame = 1;
                animObjects[i].resetVal = null;
              }

              animObjects[i].lastFrame = _curFrame;

              if (animObjects[i].frame) {
                animObjects[i].frame({
                  id: i,
                  frame: _curFrame
                });
              }
            }
          }
        }); // --------------------------

        if (animPlaying) {
          requestId = requestAnimationFrame(enterFrame);
        }
      } // ================================================================


      function objectSize(obj) {
        var size = 0;
        var key;
        Object.keys(obj).forEach(function (key) {
          if (obj.hasOwnProperty(key)) {
            size++;
          }
        });
        return size;
      } // ================================================================
      // ================================================================


      (function () {
        var lastTime = 0;
        var vendors = ["webkit", "moz"];

        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
          window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
          window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        }

        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function () {
              callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
          };
        }

        if (!window.cancelAnimationFrame) {
          window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
          };
        }
      })();
    },
    // ================================================================================
    // ================================================================================
    //  STATIC MATH CONSTANTS
    // ================================================================================
    Maths: {
      // ================================================================================
      TO_DEGREES: 180 / Math.PI,
      TO_RADIANS: Math.PI / 180,
      // ================================================================================
      //  Returns a random number from a range.
      getRandomIntInclusive: function getRandomIntInclusive(min, max) {
        var minVal = Math.ceil(min);
        var maxVal = Math.floor(max);
        return Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal; // The maximum is inclusive and the minimum is inclusive
      },
      // Return random number with steps.
      getRandomNumber: function getRandomNumber(min, max, numOfDes, step) {
        var newRand = Math.random() * (max - min) + min;
        if (!step) return Number(newRand.toFixed(numOfDes));
        var temp = newRand + 0;
        newRand -= temp % step;
        return Number(newRand.toFixed(numOfDes));
      },
      // ================================================================================
      //  Returns distance between given points
      getDistance: function getDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      },
      approximatelyEqual: function approximatelyEqual(v1, v2) {
        var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.001;
        return Math.abs(v1 - v2) < epsilon;
      },
      getPointLineDistance: function getPointLineDistance(_pt, p1, p2) {
        var _dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        var _ans = 0;

        if (_dist > 0) {
          var _num = (p2.x - p1.x) * (p1.y - _pt.y) - (p2.y - p1.y) * (p1.x - _pt.x);

          _ans = _num / _dist;
        }

        return _ans;
      },
      // ================================================================================
      //  Returns angle between given points with optional parameter isRad.
      getAngle: function getAngle(_x1, _y1, _x2, _y2) {
        return Math.atan2(_y2 - _y1, _x2 - _x1);
      },
      // ================================================================================
      //  return Point Object with given angle and radius
      getPoint: function getPoint(p, angle, rad) {
        var temp = {};
        temp.x = parseFloat((p.x + rad * Math.cos(angle)).toFixed(5));
        temp.y = parseFloat((p.y + rad * Math.sin(angle)).toFixed(5));
        return temp;
      },
      getLineintersect2: function getLineintersect2(x1, y1, x2, y2, x3, y3, x4, y4) {
        var ua, ub;
        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

        if (denom === 0) {
          return null;
        }

        ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
        console.info("denom", denom);
        console.info("ua", ua);
        console.info("ub", ub);
        console.info("(x2 - x1)", x2 - x1);
        console.info("(y2 - y1)", x2 - x1);
        return {
          x: x1 + ua * (x2 - x1),
          y: y1 + ub * (y2 - y1),
          seg1: ua >= 0 && ua <= 1,
          seg2: ub >= 0 && ub <= 1
        };
      },
      getLinePointIntersection: function getLinePointIntersection(lineStart, lineEnd, point) {
        var lineAngle = LabComClass.Maths.getAngle(lineStart.x, lineStart.y, lineEnd.x, lineEnd.y);
        var perpandicularAngle = lineAngle + Math.PI / 2;
        var perpandicularPoint = LabComClass.Maths.getPoint(point, perpandicularAngle, 10);
        var intersectionPoint = LabComClass.Maths.getLineintersect(lineStart.x, lineStart.y, lineEnd.x, lineEnd.y, point.x, point.y, perpandicularPoint.x, perpandicularPoint.y);
        return intersectionPoint;
      },
      getLineintersect: function getLineintersect(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
        // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
        var denominator,
            a,
            b,
            numerator1,
            numerator2,
            result = {
          x: null,
          y: null,
          onLine1: false,
          onLine2: false
        };
        denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);

        if (denominator === 0) {
          return result;
        }

        a = line1StartY - line2StartY;
        b = line1StartX - line2StartX;
        numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
        numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
        a = numerator1 / denominator;
        b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:

        result.x = line1StartX + a * (line1EndX - line1StartX);
        result.y = line1StartY + a * (line1EndY - line1StartY);
        /*
                // it is worth noting that this should be the same as:
                x = line2StartX + (b * (line2EndX - line2StartX));
                y = line2StartX + (b * (line2EndY - line2StartY));
                */
        // if line1 is a segment and line2 is infinite, they intersect if:

        if (a > 0 && a < 1) {
          result.onLine1 = true;
        } // if line2 is a segment and line1 is infinite, they intersect if:


        if (b > 0 && b < 1) {
          result.onLine2 = true;
        } // if line1 and line2 are segments, they intersect if both of the above are true


        return result;
      },
      //
      getIntersectOfTwoCircles: function getIntersectOfTwoCircles(_x1, _y1, _r1, _x2, _y2, _r2) {
        // var rLX1,
        //   rLY1,
        //   gLX1,
        //   gLY1;
        // var radArr = [];
        // // ---------------------------
        // for (var i = 0; i <= (2 * Math.PI); i += 0.1) {
        //   var _rX1 = _x1 + (_r1 * Math.cos(i));
        //   var _rY1 = _y1 + (_r1 * Math.sin(i));
        //   for (var j = 0; j <= (2 * Math.PI); j += 0.1) {
        //     var _gX1 = _x2 + (_r2 * Math.cos(j));
        //     var _gY1 = _y2 + (_r2 * Math.sin(j));
        //     // ---------------------------
        //     if (gLX1 && gLY1 && rLX1 && rLY1) {
        //       var _inter = LabComClass.Maths.getLineintersect(_rX1, _rY1, rLX1, rLY1, _gX1, _gY1, gLX1, gLY1);
        //       if (_inter && _inter.seg1 && _inter.seg2) {
        //         radArr.push({
        //           t1: parseFloat((i * LabComClass.Maths.TO_DEGREES).toFixed(2), 10),
        //           t2: parseFloat((j * LabComClass.Maths.TO_DEGREES).toFixed(2), 10)
        //         });
        //       }
        //     }
        //     // ---------------------------
        //     gLX1 = _gX1;
        //     gLY1 = _gY1;
        //   }
        //   rLX1 = _rX1;
        //   rLY1 = _rY1;
        // }
        var _r = LabComClass.Maths.getDistance({
          x: _x1,
          y: _y1
        }, {
          x: _x2,
          y: _y2
        });

        var _cal = 0.5 * Math.sqrt(2 * (Math.pow(_r1, 2) + Math.pow(_r2, 2)) / Math.pow(_r, 2) - Math.pow(Math.pow(_r1, 2) - Math.pow(_r2, 2), 2) / Math.pow(_r, 4) - 1);

        var _p1X = 0.5 * (_x1 + _x2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_x2 - _x1) / (2 * Math.pow(_r, 2)) + _cal * (_y2 - _y1);

        var _p1Y = 0.5 * (_y1 + _y2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_y2 - _y1) / (2 * Math.pow(_r, 2)) + _cal * (_x1 - _x2);

        var _p2X = 0.5 * (_x1 + _x2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_x2 - _x1) / (2 * Math.pow(_r, 2)) - _cal * (_y2 - _y1);

        var _p2Y = 0.5 * (_y1 + _y2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_y2 - _y1) / (2 * Math.pow(_r, 2)) - _cal * (_x1 - _x2);

        return [{
          x: _p1X,
          y: _p1Y
        }, {
          x: _p2X,
          y: _p2Y
        }]; // return radArr;
      },
      findCirclesIntersect: function findCirclesIntersect(c1, c2) {
        var midPoint = {
          x: (c1.x + c2.x) / 2,
          y: (c1.y + c2.y) / 2
        };
        var distance = Math.abs(LabComClass.Maths.getDistance(c1, c2));
        var lengthHalf = distance / 2;
        var midPointAngle = LabComClass.Maths.getAngle(c1.x, c1.y, midPoint.x, midPoint.y);
        var axis = Math.sqrt(c1.r * c1.r - lengthHalf * lengthHalf);
        var point1 = LabComClass.Maths.getPoint(midPoint, Math.PI / 2 + midPointAngle, axis);
        var point2 = LabComClass.Maths.getPoint(midPoint, Math.PI / 2 + midPointAngle, -1 * axis);
        point1.type = "point";
        point2.type = "point";
        var intersections = [];

        if (!isNaN(point1.x)) {
          intersections.push(point1);
        }

        if (!isNaN(point2.x)) {
          intersections.push(point2);
        }

        return intersections;
      },
      pointInSegment: function pointInSegment(point, segmentStart, segmentEnd) {
        if (point) {
          var segmentDist = LabComClass.Maths.getDistance(segmentStart, segmentEnd);
          var distFromStart = LabComClass.Maths.getDistance(point, segmentStart);
          var distFromEnd = LabComClass.Maths.getDistance(point, segmentEnd);

          if (distFromStart <= segmentDist && distFromEnd <= segmentDist) {
            return true;
          }
        }

        return false;
      },
      findCircleLineIntersect: function findCircleLineIntersect(circle, lineStart, lineEnd) {
        var m = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x); //====================================

        var theta = Math.atan(m) * 180 / Math.PI; // rads to degs

        if (theta == -90 || theta == 90) {
          m = 50; // max value of slope
        } //====================================


        var c1 = lineStart.y - m * lineStart.x;
        var a = Math.pow(m, 2) + 1;
        var b = -2 * circle.x + 2 * m * c1 - 2 * m * circle.y;
        var c = Math.pow(circle.x, 2) + Math.pow(c1, 2) + Math.pow(circle.y, 2) - 2 * c1 * circle.y - Math.pow(circle.r, 2);
        var x1 = (-1 * b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
        var x2 = (-1 * b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
        var p1;
        var p2; //=============

        if (theta == -90 || theta == 90) {
          //  p2 = {
          //   type: 'point',
          //   x:  x1 ,
          //   y: m * x1 + c1
          // };
          //  p1 = {
          //   type: 'point',
          //   x: x2 ,
          //   y:  m * x2 + c1
          // };
          p1 = {
            type: "point",
            x: lineEnd.x,
            y: circle.y - Math.sqrt(Math.pow(circle.r, 2) - Math.pow(lineEnd.x - circle.x, 2))
          };
          p2 = {
            type: "point",
            x: lineEnd.x,
            y: circle.y + Math.sqrt(Math.pow(circle.r, 2) - Math.pow(lineEnd.x - circle.x, 2))
          };
        } else {
          p1 = {
            type: "point",
            x: x1,
            y: m * x1 + c1
          };
          p2 = {
            type: "point",
            x: x2,
            y: m * x2 + c1
          };
        } //==============


        function checkInSegment(point, lineS, lineE) {
          if (point) {
            var segmentDist = LabComClass.Maths.getDistance(lineS, lineE);
            var distFromStart = LabComClass.Maths.getDistance(point, lineS);
            var distFromEnd = LabComClass.Maths.getDistance(point, lineE);

            if (distFromStart <= segmentDist && distFromEnd <= segmentDist) {
              point.isInSegment = true;
            } else {
              point.isInSegment = false;
            }
          }
        }

        checkInSegment(p1, lineStart, lineEnd);
        checkInSegment(p2, lineStart, lineEnd);
        return {
          p1: p1,
          p2: p2
        };
      }
    },
    // eslint-disable-next-line object-shorthand
    Vector: function Vector(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;

      this.reset = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      };

      this.toString = function (decPlaces) {
        decPlaces = decPlaces || 3;
        var scalar = Math.pow(10, decPlaces);
        return "[" + Math.round(this.x * scalar) / scalar + ", " + Math.round(this.y * scalar) / scalar + ", " + Math.round(this.z * scalar) / scalar + "]";
      };

      this.clone = function () {
        return new LabComClass.Vector(this.x, this.y, this.z);
      };

      this.copyTo = function (v) {
        v.x = this.x;
        v.y = this.y;
        v.z = this.z;
      };

      this.copyFrom = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
      };

      this.magnitude = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      };

      this.normalise = function () {
        var m = this.magnitude();
        this.x = this.x / m;
        this.y = this.y / m;
        this.z = this.z / m;
        return this;
      };

      this.reverse = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      };

      this.plusEq = function (v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      };

      this.plusNew = function (v) {
        return new LabComClass.Vector(this.x + v.x, this.y + v.y, this.z + v.z);
      };

      this.minusEq = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      };

      this.getNormal = function () {
        return new LabComClass.Vector(-this.y, this.x, this.z);
      };

      this.minusNew = function (v) {
        return new LabComClass.Vector(this.x - v.x, this.y - v.y, this.z - v.z);
      };

      this.multiplyEq = function (scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      };

      this.multiplyNew = function (scalar) {
        var returnvec = this.clone();
        return returnvec.multiplyEq(scalar);
      };

      this.divideEq = function (scalar) {
        this.x /= scalar;
        this.y /= scalar;
        this.z /= scalar;
        return this;
      };

      this.divideNew = function (scalar) {
        var returnvec = this.clone();
        return returnvec.divideEq(scalar);
      };

      this.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      };

      this.angle = function (useRadians) {
        return Math.atan2(this.y, this.x) * (useRadians ? 1 : LabComClass.Maths.TO_DEGREES);
      };

      this.rotate = function (angle, useRadians) {
        var cosRY = Math.cos(angle * (useRadians ? 1 : LabComClass.Maths.TO_RADIANS));
        var sinRY = Math.sin(angle * (useRadians ? 1 : LabComClass.Maths.TO_RADIANS));
        var VectorConst = {
          clone: new LabComClass.Vector()
        };
        VectorConst.clone.copyFrom(this);
        this.x = VectorConst.clone.x * cosRY - VectorConst.clone.y * sinRY;
        this.y = VectorConst.clone.x * sinRY + VectorConst.clone.y * cosRY;
        return this;
      };

      this.equals = function (v) {
        return this.x === v.x && this.y === v.x;
      };

      this.length = function () {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));
      };

      this.angleBetween = function (v) {
        this.z = this.z === undefined ? 0 : this.z;
        v.z = v.z === undefined ? 0 : v.z;
        return Math.acos((this.x * v.x + this.y * v.y + this.z * v.z) / (Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2)) * Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2) + Math.pow(v.z, 2))));
      };

      this.crossProduct = function (v) {
        var x = this.y * v.z - this.z * v.y;
        var y = this.x * v.z - this.z * v.x;
        var z = this.x * v.y - this.y * v.x;
        return new LabComClass.Vector(x, y, z);
      };

      return this;
    },
    // eslint-disable-next-line object-shorthand
    Matrix: function Matrix(arr, m, n) {
      // Private variables
      var _thisRef = this; // Public variables


      this.elements = []; // ===================================================
      // Private Functions
      // ===================================================

      function init(arg) {
        if (arg) {
          _thisRef.setElements(arg);
        }
      } // ===================================================
      // Public Functions
      // ===================================================
      //++++++++++++++++++++++++++++++++++++++++++++++++++++


      this.setElements = function (a) {
        var i,
            elements = a.elements || a;

        if (typeof elements[0][0] !== "undefined") {
          var b = elements.length,
              ki = b,
              nj,
              kj,
              j;
          this.elements = [];

          do {
            i = ki - b;
            nj = elements[i].length;
            kj = nj;
            this.elements[i] = [];

            do {
              j = kj - nj;
              this.elements[i][j] = elements[i][j];
            } while (--nj);
          } while (--b);

          return this;
        }

        var n = elements.length,
            k = n;
        this.elements = [];

        do {
          i = k - n;
          this.elements.push([elements[i]]);
        } while (--n);

        return this;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return element of given index


      this.elem = function (i, j) {
        if (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) {
          return null;
        }

        return this.elements[i - 1][j - 1];
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return whole row of given number


      this.row = function (i) {
        if (i > this.elements.length) {
          return null;
        }

        return this.elements[i - 1];
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return whole column of given number


      this.col = function (j) {
        if (j > this.elements[0].length) {
          return null;
        }

        var a = [],
            n = this.elements.length,
            k = n * 1,
            i;

        do {
          i = k - n;
          a.push(this.elements[i][j - 1]);
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns number of Rows and columns in array


      this.dimensions = function () {
        return {
          rows: this.elements.length,
          cols: this.elements[0].length
        };
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns number of Rows


      this.rows = function () {
        return this.elements.length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns number of Columns


      this.cols = function () {
        return this.elements[0].length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Check if given matrix is equal with current matrix


      this.eql = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === "undefined") {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (this.elements.length !== M.length || this.elements[0].length !== M[0].length) {
          return false;
        }

        var b = this.elements.length,
            ki = b,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - b;
          nj = kj;

          do {
            j = kj - nj;

            if (Math.abs(this.elements[i][j] - M[i][j]) > 0) {
              return false;
            }
          } while (--nj);
        } while (--b);

        return true;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return duplicate matrix


      this.dup = function () {
        return new LabComClass.Matrix().setElements(this.elements);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Maps the receiver to another matrix by calling iterator on each element of the receiver in turn. iterator receives the row and column index of each element as second and third arguments. Some examples:


      this.map = function (a) {
        var b = [],
            ni = this.elements.length,
            ki = ni,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - ni;
          nj = kj;
          b[i] = [];

          do {
            j = kj - nj;
            b[i][j] = a(this.elements[i][j], i + 1, j + 1);
          } while (--nj);
        } while (--ni);

        return new LabComClass.Matrix().setElements(b);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Check if number of rows and columns are same of given matrix with respect to current matrix


      this.isSameSizeAs = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === "undefined") {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        return this.elements.length === M.length && this.elements[0].length === M[0].length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Add Matrix


      this.add = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === "undefined") {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (!this.isSameSizeAs(M)) {
          return null;
        }

        return this.map(function (x, i, j) {
          return x + M[i - 1][j - 1];
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Subtract Matrix


      this.subtract = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === "undefined") {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (!this.isSameSizeAs(M)) {
          return null;
        }

        return this.map(function (x, i, j) {
          return x - M[i - 1][j - 1];
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // A.canMultiplyFromLeft(B) returns true if AB is a mathematically valid expression.
      // This is the case if A has the same number of columns as B has rows.
      // Matrix can also be a Vector, as long as it has the same number of elements as the receiver has rows.


      this.canMultiplyFromLeft = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === "undefined") {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        return this.elements[0].length === M.length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return Multiplication of Matrix


      this.multiply = function (a) {
        if (!a.elements) {
          return this.map(function (x) {
            return x * a;
          });
        }

        var b = !!a.modulus;
        var M = a.elements || a;

        if (typeof M[0][0] === "undefined") {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (!this.canMultiplyFromLeft(M)) {
          return null;
        }

        var d = this.elements.length,
            ki = d,
            i,
            nj,
            kj = M[0].length,
            j;
        var e = this.elements[0].length,
            elements = [],
            sum,
            nc,
            c;

        do {
          i = ki - d;
          elements[i] = [];
          nj = kj;

          do {
            j = kj - nj;
            sum = 0;
            nc = e;

            do {
              c = e - nc;
              sum += this.elements[i][c] * M[c][j];
            } while (--nc);

            elements[i][j] = sum;
          } while (--nj);
        } while (--d);

        M = new LabComClass.Matrix().setElements(elements);
        return b ? M.col(1) : M;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for multiply


      this.x = function (a) {
        return this.multiply(a);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // This method returns a matrix formed from a subset of the receiver’s elements. It selects elements beginning at row i and column j of the receiver, and returns a matrix with n rows and m columns. The selection wraps to the other side of the receiver if n or m is large enough.


      this.minor = function (a, b, c, d) {
        var e = [],
            ni = c,
            i,
            nj,
            j;
        var f = this.elements.length,
            cols = this.elements[0].length;

        do {
          i = c - ni;
          e[i] = [];
          nj = d;

          do {
            j = d - nj;
            e[i][j] = this.elements[(a + i - 1) % f][(b + j - 1) % cols];
          } while (--nj);
        } while (--ni);

        return new LabComClass.Matrix().setElements(e);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the matrix transpose of the receiver.


      this.transpose = function () {
        var a = this.elements.length,
            cols = this.elements[0].length;
        var b = [],
            ni = cols,
            i,
            nj,
            j;

        do {
          i = cols - ni;
          b[i] = [];
          nj = a;

          do {
            j = a - nj;
            b[i][j] = this.elements[j][i];
          } while (--nj);
        } while (--ni);

        return new LabComClass.Matrix().setElements(b);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns true if the receiver is square.


      this.isSquare = function () {
        return this.elements.length === this.elements[0].length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the value of the element of the receiver with the largest absolute value.


      this.max = function () {
        var m = 0,
            ni = this.elements.length,
            ki = ni,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - ni;
          nj = kj;

          do {
            j = kj - nj;

            if (Math.abs(this.elements[i][j]) > Math.abs(m)) {
              m = this.elements[i][j];
            }
          } while (--nj);
        } while (--ni);

        return m;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Reads the receiver’s elements row by row from left to right and returns an object containing the indexes of the first exact match. Returns null if no match is found.


      this.indexOf = function (x) {
        var a = null,
            ni = this.elements.length,
            ki = ni,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - ni;
          nj = kj;

          do {
            j = kj - nj;

            if (this.elements[i][j] === x) {
              return {
                i: i + 1,
                j: j + 1
              };
            }
          } while (--nj);
        } while (--ni);

        return null;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // If the receiver is square, returns its leading-diagonal elements as a Array. Otherwise, returns null.


      this.diagonal = function () {
        if (!this.isSquare) {
          return null;
        }

        var a = [],
            n = this.elements.length,
            k = n,
            i;

        do {
          i = k - n;
          a.push(this.elements[i][i]);
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a copy of the receiver converted to right triangular form. The conversion is done only by adding multiples of rows to other rows, so the determinant (if the matrix is square) is unchanged. This method can be used on non-square matrices, which lets you use it to solve sets of simultaneous equations.


      this.toRightTriangular = function () {
        var M = this.dup(),
            els;
        var n = this.elements.length,
            k = n,
            i,
            np,
            kp = this.elements[0].length,
            p;

        do {
          i = k - n;

          if (M.elements[i][i] === 0) {
            for (var j = i + 1; j < k; j++) {
              if (M.elements[j][i] !== 0) {
                els = [];
                np = kp;

                do {
                  p = kp - np;
                  els.push(M.elements[i][p] + M.elements[j][p]);
                } while (--np);

                M.elements[i] = els;
                break;
              }
            }
          }

          if (M.elements[i][i] !== 0) {
            for (j = i + 1; j < k; j++) {
              var a = M.elements[j][i] / M.elements[i][i];
              els = [];
              np = kp;

              do {
                p = kp - np;
                els.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * a);
              } while (--np);

              M.elements[j] = els;
            }
          }
        } while (--n);

        return M;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for toRightTriangular.


      this.toUpperTriangular = function () {
        return this.toRightTriangular();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // If the receiver is square, returns its determinant, otherwise returns null. Note that if the receiver is singular, this method will return exactly zero, with no rounding errors.


      this.determinant = function () {
        if (!this.isSquare()) {
          return null;
        }

        var M = this.toRightTriangular();
        var a = M.elements[0][0],
            n = M.elements.length - 1,
            k = n,
            i;

        do {
          i = k - n + 1;
          a *= M.elements[i][i];
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      //  Alias for determinant.


      this.det = function () {
        return this.determinant();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns true if the receiver is square and has zero determinant.


      this.isSingular = function () {
        return this.isSquare() && this.determinant() === 0;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the trace for square matrices, which is the sum of their leading-diagonal elements.


      this.trace = function () {
        if (!this.isSquare()) {
          return null;
        }

        var a = this.elements[0][0],
            n = this.elements.length - 1,
            k = n,
            i;

        do {
          i = k - n + 1;
          a += this.elements[i][i];
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for trace.


      this.tr = function () {
        return this.trace();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the receiver’s rank, which is the number of linearly independent rows/columns it contains.


      this.rank = function () {
        var M = this.toRightTriangular(),
            rank = 0;
        var a = this.elements.length,
            ki = a,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - a;
          nj = kj;

          do {
            j = kj - nj;

            if (Math.abs(M.elements[i][j]) > 0) {
              rank++;
              break;
            }
          } while (--nj);
        } while (--a);

        return rank;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for rank.


      this.rk = function () {
        return this.rank();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the result of augmenting the receiver with matrix, that is, appending matrix to the right hand side of the receiver. Both matrices must have the same number of rows for this to work.


      this.augment = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === "undefined") {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        var T = this.dup(),
            cols = T.elements[0].length;
        var b = T.elements.length,
            ki = b,
            i,
            nj,
            kj = M[0].length,
            j;

        if (b !== M.length) {
          return null;
        }

        do {
          i = ki - b;
          nj = kj;

          do {
            j = kj - nj;
            T.elements[i][cols + j] = M[i][j];
          } while (--nj);
        } while (--b);

        return T;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the matrix inverse of the receiver, if one exists. If the matrix is singular or not square, then null is returned. The inverse is computed using Gauss-Jordan elimination.


      this.inverse = function () {
        if (!this.isSquare() || this.isSingular()) {
          return null;
        }

        var a = this.elements.length,
            ki = a,
            i,
            j;
        var M = this.augment(LabComClass.Matrix.I(a)).toRightTriangular();
        var b,
            kp = M.elements[0].length,
            p,
            els,
            divisor;
        var c = [],
            new_element;

        do {
          i = a - 1;
          els = [];
          b = kp;
          c[i] = [];
          divisor = M.elements[i][i];

          do {
            p = kp - b;
            new_element = M.elements[i][p] / divisor;
            els.push(new_element);

            if (p >= ki) {
              c[i].push(new_element);
            }
          } while (--b);

          M.elements[i] = els;

          for (j = 0; j < i; j++) {
            els = [];
            b = kp;

            do {
              p = kp - b;
              els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);
            } while (--b);

            M.elements[j] = els;
          }
        } while (--a);

        return new LabComClass.Matrix().setElements(c);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for inverse.


      this.inv = function () {
        return this.inverse();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a copy of the receiver with all its elements rounded to the nearest integer.


      this.round = function () {
        return this.map(function (x) {
          return Math.round(x);
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a copy of the receiver in which any elements that differ from x by less than the value of 0 are set exactly equal to x.


      this.snapTo = function (x) {
        return this.map(function (p) {
          return Math.abs(p - x) <= 0 ? x : p;
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a string representation of the receiver, useful for debugging.


      this.inspect = function () {
        var a = [];
        var n = this.elements.length,
            k = n,
            i;

        do {
          i = k - n;
          a.push("[" + this.elements[i].join(", ") + "]");
        } while (--n);

        return a.join("\n");
      };

      this.RotationZ = function (t) {
        var c = Math.cos(t),
            s = Math.sin(t);
        return new LabComClass.Matrix().setElements([[c, -s, 0], [s, c, 0], [0, 0, 1]]);
      }; //


      init(arr);
    },
    // ================================================================================
    //  Calculate Senetence Highlight
    // ================================================================================
    calculateSentenceHighlight: function calculateSentenceHighlight(_charArr, _lineHeightInt, _data) {
      // console.log(_charArr, _lineHeightInt, _data);
      var _tempArr = [];
      var _lineObj = {};
      var _leftArr = [];
      var rightArr = [];
      var _maxFontSize = 0;

      _charArr.forEach(function (e, i) {
        if (i >= _data.s && i <= _data.e) {
          if (typeof e.lineIndex === "number") {
            if (!_lineObj.hasOwnProperty(e.lineIndex)) {
              if (_maxFontSize < e.maxFontSize) {
                _maxFontSize = e.maxFontSize;
              }

              _lineObj[e.lineIndex] = [];
            }

            _lineObj[e.lineIndex].push(e);
          }
        }
      });

      var _lastWordIndex;

      var _len = Object.keys(_lineObj).length - 1;

      Object.keys(_lineObj).forEach(function (i) {
        _lastWordIndex = _lineObj[i].length - 1;

        if (_lineObj[i][_lastWordIndex].value === " ") {
          _lastWordIndex -= 1;
        }

        var tempYint = 0;

        if (_lineObj[i][0].fontSizeNum < _maxFontSize) {
          tempYint = (_maxFontSize - _lineObj[i][0].fontSizeNum) / 2;
        }

        _leftArr.push({
          xInt: _lineObj[i][0].x,
          yInt: _lineObj[i][0].y - _lineHeightInt / 2 - tempYint
        }, {
          xInt: _lineObj[i][0].x,
          // yInt: _lineObj[i][0].y + _maxFontSize + (_lineHeightInt / 2) - tempYint
          yInt: _lineObj[i][0].y + _lineObj[i][0].fontSizeNum + _lineHeightInt / 2 + tempYint
        });

        rightArr.push({
          xInt: _lineObj[i][_lastWordIndex].x + _lineObj[i][_lastWordIndex].w,
          yInt: _lineObj[i][_lastWordIndex].y - _lineHeightInt / 2 - tempYint
        }, {
          xInt: _lineObj[i][_lastWordIndex].x + _lineObj[i][_lastWordIndex].w,
          // yInt: _lineObj[i][_lastWordIndex].y + _maxFontSize + (_lineHeightInt / 2) - tempYint
          yInt: _lineObj[i][_lastWordIndex].y + _lineObj[i][_lastWordIndex].fontSizeNum + _lineHeightInt / 2 + tempYint
        });
      });

      if (_leftArr.length > 0 && rightArr.length > 0) {
        _leftArr.forEach(function (e, i) {
          rightArr.push(_leftArr[_leftArr.length - 1 - i]);
        });
      }

      return rightArr;
    },
    // ================================================================================
    //  get underline points
    // ================================================================================
    getUnderline: function getUnderline(_charArr, _data) {
      // console.log(_charArr, _data);
      var s = _data.s;
      var e = _data.e;
      var pointArr = [s];
      var breakPointArr = [];

      for (var i = 0; i < _charArr.length; i += 1) {
        if (i >= s && i <= e) {
          if (typeof _charArr[i + 1] !== "undefined") {
            if (_charArr[i].lineIndex !== _charArr[i + 1].lineIndex) {
              pointArr.push(i);

              if (i + 1 <= e) {
                pointArr.push(i + 1);
              }
            }
          }
        }
      }

      if (pointArr.indexOf(e) === -1) {
        pointArr.push(e);
      }

      if (pointArr.length % 2 !== 0) {
        pointArr.push(e);
      }

      return pointArr;
    },
    // ================================================================================
    //  Text Wrapper New Class
    // ================================================================================
    TextImgNewClass: function TextImgNewClass(obj) {
      var canvas = document.createElement("canvas");
      var context = canvas.getContext("2d"); // ============================

      var devicePixelRatio = window.devicePixelRatio || 1;
      var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
      var ratio = devicePixelRatio / backingStoreRatio; // ===========================

      var modelObj = {
        textStr: "",
        style: {},
        callback: function callback() {}
      };
      Object.keys(obj).forEach(function (key) {
        modelObj[key] = obj[key];
      }); // Stylemarker modification

      modelObj.textStr = modelObj.textStr.replace(/§b/g, '<span style="font-family: OpenSans-Bold;">');
      modelObj.textStr = modelObj.textStr.replace(/§i/g, '<span style="font-family: OpenSans-Italic;">');
      modelObj.textStr = modelObj.textStr.replace(/§t/g, '<span style="font-family: OpenSans-BoldItalic;">');
      modelObj.textStr = modelObj.textStr.replace(/§l/g, '<span style="font-family: Alef-Light;">');
      modelObj.textStr = modelObj.textStr.replace(/§r/g, "</span>");

      var _div = document.createElement("div");

      _div.style.position = "absolute";
      _div.style.left = "0px";
      _div.style.top = "0px";
      _div.style.visibility = "hidden";
      Object.keys(modelObj.style).forEach(function (key) {
        _div.style[key] = modelObj.style[key];
      });
      _div.innerHTML = modelObj.textStr;
      document.body.appendChild(_div);
      _div.style.height = "".concat(_div.offsetHeight + 5, "px");
      LabComClass.html2CanvasQueueArr.push({
        div: _div,
        callback: modelObj.callback
      });
      LabComClass.executeHtml2canvas();
    },
    executeHtml2canvas: function executeHtml2canvas() {
      if (!LabComClass.html2CanvasQueueStarted) {
        LabComClass.html2CanvasQueueStarted = true; // console.log('executeHtml2canvas started');

        var _obj = LabComClass.html2CanvasQueueArr[0];
        html2canvas(_obj.div, {
          pixelRatio: 2,
          onrendered: function onrendered(canvas) {
            function loadOrErr() {
              LabComClass.html2CanvasQueueArr.splice(0, 1); // console.log('executeHtml2canvas completed', LabComClass.html2CanvasQueueArr.length);

              LabComClass.html2CanvasQueueStarted = false;

              if (LabComClass.html2CanvasQueueArr.length > 0) {
                LabComClass.executeHtml2canvas();
              }
            }

            var _width = _obj.div.offsetWidth;
            var _height = _obj.div.offsetHeight;
            document.body.removeChild(_obj.div);
            _obj.div = null;
            var img = new Image();

            img.onload = function () {
              _obj.callback({
                imageObj: {
                  imageObj: img,
                  widthInt: _width,
                  heightInt: _height
                }
              });

              loadOrErr();
            };

            img.onerror = function () {
              loadOrErr();
            };

            img.src = canvas.toDataURL();
          }
        });
      }
    },
    // ================================================================================
    //  Text Wrapper Class
    // ================================================================================
    TextImgClass: function TextImgClass(style, message, callback) {
      var scaleVal = 4;

      var pre = document.createElement("pre"),
          canvas = document.createElement("canvas"),
          context = canvas.getContext("2d"),
          _style = {
        fontFamilyStr: "Polo22Klett-Regular",
        align: "left",
        color: "#000000",
        fontSizeNum: 16,
        background: "rgba(0, 0, 0, 0)",
        stroke: 0,
        fontFormat: "px ",
        strokeColor: "#FFFFFF",
        lineHeight: "1.5em",
        bold: false,
        italic: false
      },
          thisObj = this,
          _str,
          _tempArr,
          preStyle = ";padding: 0; display: block; position: fixed; top: 100%; overflow: hidden;";

      message = message || style.textStr || "";
      context.save();
      style = style || {};
      Object.keys(_style).forEach(function (key) {
        if (!style[key]) {
          style[key] = _style[key];
        }
      });
      _style = "font: ";

      if (style.italic || message.indexOf(LabComClass.italic) >= 0 || message.indexOf(LabComClass.italicbold) >= 0 || message.indexOf(LabComClass.italicDistance) >= 0) {
        _style += "italic ";
      }

      if (style.bold || message.indexOf(LabComClass.bold) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
        _style += "bold ";
      }

      _style += style.fontSizeNum + style.fontFormat + style.fontFamilyStr + ";";
      _style += "line-height:" + style.lineHeight + ";";
      _style += "text-align: " + style.align + ";";
      _style += "color: " + style.color + ";";
      _style += "background-color: " + style.background + ";";
      _style += preStyle;
      _str = String(message);

      if (_str.indexOf(LabComClass.subscript) >= 0) {
        style.yNum += Math.round(style.fontSizeNum / 5);
      }

      pre.innerText = _str;

      if (style.maxWidthNum) {
        _style += "max-width: " + style.maxWidthNum + "px; word-spacing: normal;word-break: keep-all; white-space: pre-wrap; white-space: -moz-pre-wrap;white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word";
      }

      pre.setAttribute("style", _style);
      document.body.appendChild(pre);
      var lines = [],
          _tempLine = [];
      var context_font = "";

      if (style.italic) {
        context_font += "italic ";
      }

      if (style.bold) {
        context_font += "bold ";
      }

      if (style.italic && style.bold) {
        message = LabComClass.italicbold + message + LabComClass.end;
      } else if (style.italic) {
        message = LabComClass.italic + message + LabComClass.end;
      } else if (style.bold) {
        message = LabComClass.bold + message + LabComClass.end;
      }

      context_font += style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = style.align;
      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;
      var width = style.maxWidthNum;

      if (style.maxWidthNum && message.indexOf("\n") === -1) {
        var result = message.split(" "); // console.log('RESULT', result);

        var _lineText = "";

        while (result.length > 0) {
          if (context.measureText(_lineText).width + context.measureText(result[0]).width >= style.maxWidthNum) {
            // _bool = false;
            lines.push(_lineText);
            _lineText = "";
          }

          if (_lineText === "") {
            _lineText = "".concat(result[0]);
          } else {
            _lineText = "".concat(_lineText, " ").concat(result[0]);
          }

          result.splice(0, 1);
        }

        lines.push(_lineText); // while (message.length) {
        //   for (var i = message.length; context.measureText(message.substr(0, i)).width > style.maxWidthNum; i--);
        //   var result = message.substr(0, i);
        //   if (i !== message.length) {
        //     for (var j = 0; result.indexOf(' ', j) !== -1; j = result.indexOf(' ', j) + 1);
        //   }
        //   lines.push(result.substr(0, j || result.length));
        //   var width = Math.max(width, context.measureText(lines[lines.length - 1]).width);
        //   message = message.substr(lines[lines.length - 1].length, message.length);
        // }
      } else {
        lines = message.split("\n");
      }

      lines.forEach(function (val, i) {
        _tempLine[i] = val;
        _tempLine[i] = _tempLine[i].replace(LabComClass.bold, "");
        _tempLine[i] = _tempLine[i].replace(LabComClass.italic, "");
        _tempLine[i] = _tempLine[i].replace(LabComClass.italicbold, "");
        _tempLine[i] = _tempLine[i].replace(LabComClass.italicDistance, "");
        _tempLine[i] = _tempLine[i].replace(LabComClass.end, "");
      });
      var x = style.stroke,
          y = pre.offsetHeight / lines.length,
          base = y * 0.25;
      canvas.width = (width + style.xNum * 2) * scaleVal;
      canvas.height = (pre.offsetHeight + style.yNum * 2) * scaleVal;
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = style.background;
      context.beginPath();
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.fill();
      context_font = ""; // add bold/italic

      if (style.italic) {
        context_font += "italic ";
      }

      if (style.bold) {
        context_font += "bold ";
      } // append size, font


      context_font = style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = "left"; // style.align;

      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;

      switch (style.align) {
        case "center":
          x = canvas.width / scaleVal / 2;
          break;

        case "right":
          x = canvas.width / scaleVal;
          break;

        default:
          break;
      }

      var _x, width;

      context.scale(scaleVal, scaleVal);
      lines.forEach(function (line, i) {
        if (style.align === "center") {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width / 2;
        } else if (style.align === "right") {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width;
        } else {
          _x = x;
        } // width = context.measureText(_tempLine[i]).width;
        // switch (style.align) {
        //   case 'center':
        //     _x = x - width / 2;
        //     break;
        //   case 'right':
        //     _x = x - width;
        //     break;
        //   default:
        //     _x = x;
        //     break;
        // }
        // _x = x;


        var text;

        if (style.bold) {
          text = LabComClass.bold + _tempLine[i] + LabComClass.end;
        } else {
          text = line;
        }

        if (style.stroke) {
          context.strokeText(text, _x + style.xNum, y * (i + 1) + style.yNum);
        } // context.fillText()


        context.drawStyledText(text, _x + style.xNum, y * (i + 1) - base + style.yNum, style.fontFamilyStr, style.fontSizeNum); // context.fillText(line, x + style.xNum, y * (i + 1) - base + style.yNum);
      });
      context.restore();
      setTimeout(function () {
        document.body.removeChild(pre);
      }, 100);
      var img = new Image();

      if (callback) {
        img.onload = callback;
      }

      img.src = canvas.toDataURL();
      return {
        imageObj: {
          imageObj: img,
          widthInt: canvas.width / scaleVal,
          heightInt: canvas.height / scaleVal
        }
      };
    },
    TextImgV2Class: function TextImgV2Class(style, message, callback) {
      var scaleVal = 4;
      /* Define function for escaping user input to be treated as
      a literal string within a regular expression */

      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      /* Define functin to find and replace specified term with replacement string */


      function replaceAll(str, term, replacement) {
        return str.replace(new RegExp(escapeRegExp(term), "g"), replacement);
      }

      var pre = document.createElement("pre"),
          canvas = document.createElement("canvas"),
          context = canvas.getContext("2d"),
          _style = {
        fontFamilyStr: LabComClass.AlefFontRegular,
        align: "left",
        color: "#000000",
        fontSizeNum: 16,
        background: "rgba(0, 0, 0, 0)",
        stroke: 0,
        fontFormat: "px ",
        strokeColor: "#FFFFFF",
        lineHeight: "1.5em",
        bold: false,
        italic: false
      },
          thisObj = this,
          _str,
          _tempArr,
          preStyle = ";padding: 0; display: block; position: fixed; top: 100%; overflow: hidden;";

      message = message || style.textStr || "";
      style = style || {};
      Object.keys(_style).forEach(function (key) {
        if (!style[key]) {
          style[key] = _style[key];
        }
      });
      _style = "font: "; // if (style.italic || message.indexOf(LabComClass.italic) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
      //   _style += 'italic ';
      // }
      // if (style.bold || message.indexOf(LabComClass.bold) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
      //   _style += 'bold ';
      // }

      if (style.italic || message.indexOf(LabComClass.italic) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
        _style += " ";
      }

      if (style.bold || message.indexOf(LabComClass.bold) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
        _style += " ";
      }

      _style += style.fontSizeNum + style.fontFormat + style.fontFamilyStr + ";";
      _style += "line-height:" + style.lineHeight + ";";
      _style += "text-align: " + style.align + ";";
      _style += "color: " + style.color + ";";
      _style += "background-color: " + style.background + ";";
      _style += preStyle;
      _str = String(message);

      if (_str.indexOf(LabComClass.subscript) >= 0) {
        style.yNum += Math.round(style.fontSizeNum / 5);
      }

      var support = function () {
        if (!window.DOMParser) return false;
        var parser = new DOMParser();

        try {
          parser.parseFromString("x", "text/html");
        } catch (err) {
          return false;
        }

        return true;
      }();

      var textToHTML = function textToHTML(str) {
        // check for DOMParser support
        // if (support) {
        //   var parser = new DOMParser();
        //   var doc = parser.parseFromString(str, 'text/html');
        //   return doc.body.innerHTML;
        // }
        // Otherwise, create div and append HTML
        var dom = document.createElement("pre");
        dom.innerHTML = str;
        return dom;
      };

      _str = replaceAll(_str, "</d>", "");
      _str = replaceAll(_str, "<d>", "");
      _str = replaceAll(_str, "§p", "");
      _str = replaceAll(_str, "§q", "");
      _str = replaceAll(_str, "§Q", "");
      _str = replaceAll(_str, "§d", "");

      while (_str.includes("<c>")) {
        var index = _str.indexOf("<c>");

        var index2 = _str.indexOf("</c>");

        _str = _str.substring(0, index) + _str.substring(index + 9, index2) + _str.substring(index2 + 4);
      }

      pre = textToHTML(_str);
      pre.innerHTML = _str;

      if (style.maxWidthNum) {
        _style += "max-width: " + style.maxWidthNum + "px; word-spacing: normal;word-break: keep-all; white-space: pre-wrap; white-space: -moz-pre-wrap;white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word";
      }

      pre.setAttribute("style", _style);
      document.body.appendChild(pre);
      var lines = [],
          _tempLine = [];
      var context_font = ""; // if (style.italic) {
      //   context_font += 'italic ';
      // }
      // if (style.bold) {
      //   context_font += 'bold ';
      // }

      if (style.italic) {
        context_font += " ";
      }

      if (style.bold) {
        context_font += " ";
      }
      /* Testing our replaceAll() function  */


      message = replaceAll(message, "</b>", "§r");
      message = replaceAll(message, "<b>", "§b");
      message = replaceAll(message, "</i>", "§r");
      message = replaceAll(message, "<i>", "§i");
      message = replaceAll(message, "</d>", "§r");
      message = replaceAll(message, "<d>", "§d");
      message = replaceAll(message, "</c>", "§c");
      message = replaceAll(message, "<c>", "§c");

      if (style.italic && style.bold) {
        message = LabComClass.italicbold + message + LabComClass.end;
      } else if (style.italic) {
        message = LabComClass.italic + message + LabComClass.end;
      } else if (style.bold) {
        message = LabComClass.bold + message + LabComClass.end;
      }

      context_font += style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = style.align;
      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;

      var msg = _str.split("\n");

      var text = message;
      var newlines = [];

      if (style.maxWidthNum && _str.indexOf("\n") === -1) {
        for (var k = 0; k < msg.length; k++) {
          _str = msg[k];

          while (_str.length) {
            var condition = context.measureText(_str.substr(0, i)).width > style.maxWidthNum;

            for (var i = _str.length; context.measureText(_str.substr(0, i)).width > style.maxWidthNum; i--) {
              ;
            }

            var result = _str.substr(0, i); // console.info(condition, _str);
            // console.info(result);


            if (i !== _str.length) {
              for (var j = 0; result.indexOf(" ", j) !== -1; j = result.indexOf(" ", j) + 1) {
                ;
              }
            }

            lines.push(result.substr(0, j || result.length));
            var newText = result.substr(0, j || result.length);
            var _k = 0;
            var _index = 0;

            for (var _i2 = 0; _i2 < text.length; _i2++) {
              if (newText[_k] === text[_i2]) {
                _k++;
              }

              if (_k === newText.length) {
                _index = _i2;
                break;
              }
            }

            if (_index) {
              _index++;
            }

            newText = text.substring(0, _index);
            newlines.push(newText);
            text = text.substring(_index);
            var width = Math.max(width, context.measureText(lines[lines.length - 1]).width);
            _str = _str.substr(lines[lines.length - 1].length, _str.length);
          }
        }
      } else {
        newlines = msg;
        lines = msg;
      }

      lines = newlines;
      lines.forEach(function (val, i) {
        _tempLine[i] = val;
        _tempLine[i] = _tempLine[i].replace(LabComClass.bold, "");
        _tempLine[i] = _tempLine[i].replace(LabComClass.italic, "");
        _tempLine[i] = _tempLine[i].replace(LabComClass.italicbold, "");
        _tempLine[i] = _tempLine[i].replace(LabComClass.end, "");
      });
      var x = style.stroke,
          y = pre.offsetHeight / lines.length,
          base = y * 0.25;
      canvas.width = (pre.offsetWidth + style.xNum * 2) * scaleVal;
      canvas.height = (pre.offsetHeight + style.yNum * 2) * scaleVal;
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = style.background;
      context.beginPath();
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.fill();
      context_font = ""; // add bold/italic
      // if (style.italic) {
      //   context_font += 'italic ';
      // }
      // if (style.bold) {
      //   context_font += 'bold ';
      // }

      if (style.italic) {
        context_font += " ";
      }

      if (style.bold) {
        context_font += " ";
      } // append size, font


      context_font = style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = "left"; // style.align;

      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;

      switch (style.align) {
        case "center":
          x = canvas.width / scaleVal / 2;
          break;

        case "right":
          x = canvas.width / scaleVal;
          break;

        default:
          break;
      }

      var _x;

      context.scale(scaleVal, scaleVal);
      lines.forEach(function (line, i) {
        if (style.align === "center") {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width / 2;
        } else if (style.align === "right") {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width;
        } else {
          _x = x;
        } // width = context.measureText(_tempLine[i]).width;
        // switch (style.align) {
        //   case 'center':
        //     _x = x - width / 2;
        //     break;
        //   case 'right':
        //     _x = x - width;
        //     break;
        //   default:
        //     _x = x;
        //     break;
        // }
        // _x = x;


        if (style.stroke) {
          context.strokeText(line, _x + style.xNum, y * (i + 1) + style.yNum);
        } // context.fillText()


        context.drawStyledText(line, _x + style.xNum, y * (i + 1) - base + style.yNum, style.fontFamilyStr, style.fontSizeNum); // context.fillText(line, x + style.xNum, y * (i + 1) - base + style.yNum);
      }); // document.body.removeChild(pre);

      var img = new Image();

      if (callback) {
        img.onload = callback;
      }

      img.src = canvas.toDataURL();
      return {
        imageObj: {
          imageObj: img,
          widthInt: canvas.width / scaleVal,
          heightInt: canvas.height / scaleVal
        }
      };
    },
    // ================================================================================
    //  Text Style Class
    // ================================================================================
    drawCurveRect: function drawCurveRect(_xNum, _yNum, _wNum, _hNum, _rInt) {
      var _waNum = _xNum + _wNum;

      var _haNum = _yNum + _hNum;

      this.beginPath();
      this.moveTo(_xNum + _rInt, _yNum);
      this.lineTo(_waNum - _rInt, _yNum);
      this.arcTo(_waNum, _yNum, _waNum, _yNum + _rInt, _rInt);
      this.lineTo(_waNum, _haNum - _rInt);
      this.arcTo(_waNum, _haNum, _waNum - _rInt, _haNum, _rInt);
      this.lineTo(_xNum + _rInt, _haNum);
      this.arcTo(_xNum, _haNum, _xNum, _haNum - _rInt, _rInt);
      this.lineTo(_xNum, _yNum + _rInt);
      this.arcTo(_xNum, _yNum, _xNum + _rInt, _yNum, _rInt);
      this.lineTo(_xNum + _rInt, _yNum);
      this.fill();
      this.closePath();
    },
    // ================================================================================
    //  Text Style Class
    // ================================================================================
    TextStyleClass: {
      s1Obj: {
        fontColor: "#FFCC00"
      }
    },
    // ================================================================================
    //  Text Styling Class
    // ================================================================================
    drawStyledText: function drawStyledText(_text, x, y, font, fontSize) {
      var _styleCodeToStyle;

      var styleMarker = "§",
          styleCodeToStyle = (_styleCodeToStyle = {
        r: "",
        i: "italic",
        b: "bold",
        t: "italic bold",
        l: "lighter",
        p: "supscript",
        q: "subscript",
        Q: "",
        //subscript with distance bar on it.
        d: "",
        c: "color",
        a: "",
        s: "",
        //lessthan sign <
        g: "",
        //greaterthan sign >
        h: "",
        //Hypen long
        w: ""
      }, _defineProperty(_styleCodeToStyle, "b", ""), _defineProperty(_styleCodeToStyle, "t", ""), _styleCodeToStyle); // start with regular style

      var _ctx = this;

      var _width = 0;
      var _scaleFont = 0.66;
      var _supMux = 0.25;
      var _subMux = 0.2;
      var distanceBar = 1.1;
      var fontCodeStyle = "r";
      var fontColor = "";
      var mainFontColor = _ctx.fillStyle;

      if (typeof _text !== "string") {
        _text = _text.toString();
      }

      var textForWidth = _text;
      var textWidth = 0;
      var originalTextAlign = _ctx.textAlign;
      calculateTextWidth(textForWidth, font, fontSize, fontCodeStyle);

      if (originalTextAlign === "right") {
        x -= textWidth;
      }

      if (originalTextAlign === "center") {
        x -= textWidth / 2;
      }

      _ctx.save();

      _ctx.beginPath();

      _ctx.textBaseline = "bottom";

      do {
        // set context font
        _ctx.font = buildFont(font, fontSize, fontCodeStyle); // find longest run of text for current style

        var ind = _text.indexOf(styleMarker); // take all text if no more marker


        if (ind === -1) ind = _text.length; // fillText current run

        var run = _text.substring(0, ind);

        var _y = y;

        if (fontCodeStyle === "p") {
          _y = y - fontSize * _supMux * 1.5; // y = y - (fontSize * _supMux);

          x -= _ctx.measureText(run).width * 0.01; // x -= _ctx.measureText(run).width * (_supMux);
        }

        if (fontCodeStyle === "q" || fontCodeStyle === "Q") {
          _y = y + fontSize * _subMux;
          x -= _ctx.measureText(run).width * (fontCodeStyle === "Q" ? _subMux : 0.01); // x -= _ctx.measureText(run).width
        }

        if (fontColor !== "" || fontColor.includes(" ")) {
          _ctx.fillStyle = fontColor;
          _ctx.strokeStyle = fontColor;
        } // if ((originalTextAlign === 'right' || originalTextAlign === 'center')) _ctx.textAlign = 'left';


        if (_ctx.textAlign === "right") {
          x += _ctx.measureText(run).width;
        } else if (_ctx.textAlign === "center") {
          x += _ctx.measureText(run).width / 2;
        } // _ctx.save();
        // _ctx.beginPath();
        // _ctx.lineWidth = 0.1;
        // _ctx.strokeText(run, x, _y);


        _ctx.fillText(run, x, _y); // _ctx.closePath();
        // _ctx.restore();


        if (_ctx.textAlign === "right") {
          x -= _ctx.measureText(run).width;
        } else if (_ctx.textAlign === "center") {
          x -= _ctx.measureText(run).width / 2;
        }

        if (fontCodeStyle === "w") {
          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;
          _ctx.lineJoin = "round"; // _ctx.moveTo(x, _y - (fontSize * distanceBar));
          // _ctx.lineTo(x + _ctx.measureText(run).width - 0.25, _y - (fontSize * distanceBar));

          _ctx.moveTo(x, _y - fontSize / 2 * distanceBar);

          _ctx.lineTo(x + fontSize * 0.15, _y - fontSize / 2 * distanceBar);

          _ctx.lineTo(x + fontSize * 0.25, _y);

          _ctx.lineTo(x + fontSize * 0.35, _y - fontSize * distanceBar);

          _ctx.lineTo(x + _ctx.measureText(run).width, _y - fontSize * distanceBar); // _ctx.lineTo(x + _ctx.measureText(run).width/2 ,  _y - (fontSize * distanceBar))


          _ctx.stroke();

          _ctx.closePath();
        }

        if (fontCodeStyle === "d") {
          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;
          _ctx.lineJoin = "round";

          _ctx.moveTo(x, _y - fontSize * distanceBar);

          _ctx.lineTo(x + _ctx.measureText(run).width - 0.25, _y - fontSize * distanceBar);

          _ctx.stroke();

          _ctx.closePath();
        }

        if (fontCodeStyle === "Q") {
          _y = _y - fontSize * _subMux;

          _ctx.beginPath();

          _ctx.lineJoin = "bevel";
          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x + 0.6, _y - fontSize * distanceBar);

          _ctx.lineTo(x + _ctx.measureText(run).width - 0.25, _y - fontSize * distanceBar);

          _ctx.stroke();

          _ctx.closePath();
        }

        if (fontCodeStyle === "a") {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x, _y - fontSize / 3);

          _ctx.lineTo(x + fontSize / 2, _y - fontSize / 3);

          _ctx.stroke();

          _ctx.closePath(); //Slant Line


          _ctx.beginPath();

          _ctx.moveTo(x, _y - fontSize / 3);

          _ctx.lineTo(x + fontSize / 2.5, _y - fontSize / 1.1);

          _ctx.stroke();

          _ctx.closePath(); //Arc of Angle


          _ctx.beginPath();

          _ctx.arc(x, _y - fontSize / 3, fontSize / 3, 30 * Math.PI / 180, -85 * Math.PI / 180, 1);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        }

        if (fontCodeStyle === "s") {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x, _y - fontSize / 1.5);

          _ctx.lineTo(x + fontSize / 2, _y - fontSize / 2.5);

          _ctx.stroke();

          _ctx.closePath(); //Slant Line


          _ctx.beginPath();

          _ctx.moveTo(x, _y - fontSize / 1.5);

          _ctx.lineTo(x + fontSize / 2, _y - fontSize / 1.1);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        }

        if (fontCodeStyle === "h") {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x, _y - fontSize);

          _ctx.lineTo(x + textWidth / 2 * (fontSize / 2), _y - fontSize);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        }

        if (fontCodeStyle === "g") {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x + fontSize / 2, _y - fontSize / 2.5);

          _ctx.lineTo(x + fontSize / 2 * 2, _y - fontSize / 1.5);

          _ctx.stroke();

          _ctx.closePath(); //Slant Line


          _ctx.beginPath();

          _ctx.moveTo(x + fontSize / 2, _y - fontSize / 1.1);

          _ctx.lineTo(x + fontSize / 2 * 2, _y - fontSize / 1.5);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        } // return if ended


        if (ind === _text.length) break; // move forward

        x += _ctx.measureText(run).width; // update current style

        fontCodeStyle = _text[ind + 1];

        if (fontCodeStyle === "c") {
          if (_text[ind + 2] === " " || _text.substring(ind + 2, ind + 8).includes(" ")) {
            fontColor = mainFontColor;
            _text = _text.substring(ind + 2);
          } else {
            fontColor = "#".concat(_text.substring(ind + 2, ind + 8));
            _text = _text.substring(ind + 8);
          } // keep only remaining part of text

        } else {
          // keep only remaining part of text
          _text = _text.substring(ind + 2);
        }
      } while (_text.length > 0);

      function calculateTextWidth(text, font, fontSize, fontCodeStyle) {
        var tempSting = "";

        do {
          _ctx.save();

          _ctx.font = buildFont(font, fontSize, fontCodeStyle); // find longest run of text for current style

          var ind = text.indexOf(styleMarker); // take all text if no more marker

          if (ind === -1) ind = text.length; // fillText current run

          var run = text.substring(0, ind);
          tempSting += run;

          if (fontCodeStyle === "p") {
            textWidth += _ctx.measureText(run).width * _supMux;
          } else if (fontCodeStyle === "q") {
            textWidth += _ctx.measureText(run).width * _subMux;
          } else {
            textWidth += _ctx.measureText(run).width;
          } // update current style


          fontCodeStyle = text[ind + 1]; // keep only remaining part of text

          text = text.substring(ind + 2);

          _ctx.restore();
        } while (text.length > 0); // console.log(textWidth, _ctx.measureText(tempSting).width, _text)

      }

      function buildFont(font, fontSize, fontCodeStyle) {
        var style = styleCodeToStyle[fontCodeStyle];

        if (fontCodeStyle === "p" || fontCodeStyle === "q" || fontCodeStyle === "Q") {
          return " " + fontSize * _scaleFont + "px " + font;
        }

        return style + " " + fontSize + "px " + font;
      }

      _ctx.closePath();

      _ctx.restore();
    },
    // ================================================================================
    //  Text Styling Class For DOM
    // ================================================================================
    drawStyledTextDOM: function drawStyledTextDOM(_text) {
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function replaceAll(str, term, replacement) {
        return str.replace(new RegExp(escapeRegExp(term), "g"), replacement);
      }

      var newText = []; // First array and then performing join operation

      var _textStr = String(_text);

      if (_textStr.includes("<c>")) {
        _textStr = replaceAll(_textStr, "<c>", "§c");
        _textStr = replaceAll(_textStr, "</c>", "§r");
      }

      if (_textStr.includes("§")) {
        _textStr.split("§").forEach(function (part, i) {
          var y = ""; // First iteration is ignored

          var _style = i === 0 ? false : part[0]; // part[0] to get the fontCodeStyle -> §d,§r


          switch (_style) {
            case "d":
              // Distance bar
              y = part.replace(_style, '<span class ="dash">');
              break;

            case "q":
            case "Q":
              // subscript
              y = part.replace(_style, '<span class ="subscript">');
              break;

            case "p":
            case "P":
              // supscript
              y = part.replace(_style, '<span class ="supscript">');
              break;

            case "a":
              // angle icon
              y = part.replace(_style, "∡");
              break;

            case "w":
              // sqaure Root icon
              y = part.replace(_style, "<span class =\"squareRoot\"><math display=\"block\"><msqrt><mi>");
              break;

            case "c":
              // colored text.
              var color = part.slice(1, 7);
              y = part.replace(color, "");
              y = y.replace(_style, "<span style = \"color : #".concat(color, "\">"));
              break;

            case "h":
              //hypen
              y = part.replace(_style, '<span class ="hypen"></span>');
              break;

            case "r":
              // end
              // special case for 'w'- square root as it has special math tag.
              if (_textStr.split("§")[i - 1][0] === "w") {
                y = part.replace(_style, "</mi></msqrt></math></span>");
              } else {
                y = part.replace(_style, "</span>");
              }

              break;

            default:
              y = part;
              break;
          }

          newText.push(y);
        });

        _textStr.includes("Seitenlänge des") && console.log("NT", newText, newText.join(""));
        return newText.join("");
      } else {
        return _textStr;
      }
    },
    // ================================================================================
    //  Tween Class
    // ================================================================================
    // _tObj.duration: End frame number till what frame the tween will get calculated.
    // _tObj.startValue: initial value from which the calculation will start.
    // _tObj.endValue: Destination values for the calculation.
    // _tObj.type: Tween type.
    TweenClass: function TweenClass(_tObj) {
      var hasOProp = Object.prototype.hasOwnProperty; // t: Current time
      // b: Begin value
      // c: Total change in the value
      // d: Total motion duration

      var tweenFunctions = {
        plain: function plain(t, b, c, d) {
          var _t = t / d;

          return b + c * _t;
        },
        back: function back(t, b, c, d) {
          var ts = (t /= d) * t;
          var tc = ts * t;
          return b + c * (1.77635683940025e-15 * tc * ts + 4 * tc + -9 * ts + 6 * t);
        },
        cubic: function cubic(t, b, c, d) {
          var ts = (t /= d) * t;
          var tc = ts * t;
          return b + c * (1.77635683940025e-15 * tc * ts + 0.999999999999998 * tc + -3 * ts + 3 * t);
        }
      }; // ------------------------------------------------------

      var _arr = [];

      if (tweenFunctions[_tObj.type]) {
        var _valueDiff = _tObj.endValue - _tObj.startValue;

        for (var i = 0; i <= _tObj.duration; i += 1000 / 24) {
          // _arr.push(Math.round(tweenFunctions[_tObj.type](i, _tObj.startValue, _valueDiff, _tObj.duration)));
          _arr.push(tweenFunctions[_tObj.type](i, _tObj.startValue, _valueDiff, _tObj.duration));
        }
      }

      return _arr;
    },
    // ================================================================================
    //  Jump to for QA
    // ================================================================================
    jumpToSlide: function jumpToSlide(_pInt) {
      onViewUpdateCls.trigger("onGlobalUpdate", {
        type: "onJumpToSlide",
        data: {
          curSlideInt: _pInt
        }
      });
    },
    // ================================================================================
    //  RGB to Hex
    // ================================================================================
    rgbToHex: function rgbToHex(_r, _g, _b) {
      if (_r > 255 || _g > 255 || _b > 255) {
        throw "Invalid color component";
      }

      return (_r << 16 | _g << 8 | _b).toString(16);
    },
    childPreloadProgress: function childPreloadProgress(_no) {
      var _cpNo = _no;

      if (window !== window.parent && typeof window.parent.childPreloadProgress !== "undefined") {
        window.parent.childPreloadProgress(_cpNo);
      }
    },

    /**
     * Class to create shadow of an image using create JS
     *
     * @public
     */
    createShadow: function createShadow(_Obj) {
      var _canvas = document.createElement("canvas");

      var _context = _canvas.getContext("2d");

      _canvas.width = 800;
      _canvas.height = 600;

      var _stage;

      var _shape;

      var _glowFilter;

      _stage = new createjs.Stage(_canvas);
      _shape = new createjs.Bitmap(_Obj.imgObj[_Obj.imgNameStr]);
      _shape.x = _Obj.xInt;
      _shape.y = _Obj.yInt;
      _shape.scaleX = _Obj.widthInt / _Obj.imgObj[_Obj.imgNameStr].naturalWidth;
      _shape.scaleY = _Obj.heightInt / _Obj.imgObj[_Obj.imgNameStr].naturalHeight;
      var color = _Obj.hasOwnProperty("colorStr") ? _Obj.colorStr.replace("#", "0x") : "0xffff00";
      var alpha = _Obj.hasOwnProperty("alphaInt") ? _Obj.alphaInt : 1;
      var blurX = _Obj.hasOwnProperty("blurXInt") ? _Obj.blurXInt : 20;
      var blurY = _Obj.hasOwnProperty("blurYInt") ? _Obj.blurYInt : 20;
      var strength = _Obj.hasOwnProperty("strengthInt") ? _Obj.strengthInt : 3;
      var quality = _Obj.hasOwnProperty("qualityInt") ? _Obj.qualityInt : 1;
      var inner = _Obj.hasOwnProperty("innerBool") ? _Obj.innerBool : false;
      var knockout = _Obj.hasOwnProperty("knockoutBool") ? _Obj.knockoutBool : false;
      _glowFilter = new createjs.GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout);
      _shape.filters = [_glowFilter];

      _shape.cache(0, 0, 800, 600);

      _stage.addChild(_shape);

      _stage.update();

      var dataURL = _canvas.toDataURL();

      var _tempImg = new Image();

      _tempImg.src = dataURL;
      return _tempImg;
    },

    /**
     * Returns the hostname.
     * @private
     * @param {!object} [windowObject=window] - browser window object by default, or a
     *                                          custom window object to use for testing purposes.
     * @returns {!string} hostname
     */
    getHostName: function getHostName() {
      var windowObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var inIframe;
      var hostname;

      try {
        inIframe = windowObject.self !== windowObject.top;

        if (inIframe) {
          hostname = windowObject.parent.location.hostname; // Host name, no port e.g. mack.i-ready.com
        } else {
          hostname = windowObject.location.hostname;
        }
      } catch (e) {
        hostname = "defaultHostName";
      }

      return hostname;
    },

    /*
     * preload fonts
     */
    fontLoader: function fontLoader() {
      var _Obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _fontArr = _Obj.fontArr;
      var _fontElementArr = [];
      var _bodyElement = document.getElementsByTagName("body")[0];
      var _loadedCnt = 0;
      var _fontFailureArr = [];
      var _exitBool = false;

      var _callback = function _callback() {
        if (typeof _Obj.callback !== "undefined") {
          _Obj.callback();
        }
      };

      if (_fontArr.length > 0) {
        for (var i = 0; i < _fontArr.length; i += 1) {
          _fontElementArr[i] = document.createElement("span");
          _fontElementArr[i].innerHTML = "preloadFont";
          _fontElementArr[i].style.color = "rgba(0,0,0,0)";
          _fontElementArr[i].style.fontSize = "24px";

          _bodyElement.appendChild(_fontElementArr[i]);

          _fontElementArr[i].setAttribute("data-fontsizebefore", _fontElementArr[i].offsetWidth);

          _fontElementArr[i].setAttribute("data-fontloaded", "false");

          _fontElementArr[i].style.fontFamily = _fontArr[i];
        }
      }

      function isFontLoader() {
        _fontFailureArr = [];

        if (_loadedCnt < _fontElementArr.length) {
          for (var i = 0; i < _fontElementArr.length; i += 1) {
            if (_fontElementArr[i].getAttribute("data-fontloaded") === "false" && Number(_fontElementArr[i].offsetWidth) !== Number(_fontElementArr[i].getAttribute("data-fontsizebefore"))) {
              _fontElementArr[i].setAttribute("data-fontsizeafter", _fontElementArr[i].offsetWidth);

              _fontElementArr[i].setAttribute("data-fontloaded", "true"); // console.log('font familty ' + _fontArr[i] + ' loaded.');


              _loadedCnt += 1;
            } else if (_fontElementArr[i].getAttribute("data-fontloaded") === "false") {
              // to update refresh font request
              _fontElementArr[i].innerHTML = "preloadFont";
              _fontElementArr[i].style.color = "rgba(0,0,0,0)";
              _fontElementArr[i].style.fontSize = "24px";

              _fontFailureArr.push(_fontArr[i]);
            }
          }

          if (_exitBool === false) {
            requestAnimationFrame(isFontLoader);
          }
        } else {
          console.log("total " + _loadedCnt + " fonts loaded out of " + _fontArr.length); // remove elements from document

          for (var k = 0; k < _fontElementArr.length; k += 1) {
            document.body.removeChild(_fontElementArr[k]);
          }

          _callback();

          _callback = function _callback() {}; // reset callback after execution

        }
      }

      isFontLoader();
      setTimeout(function () {
        if (_loadedCnt < _fontArr.length) {
          _exitBool = true; // remove elements from document

          for (var k = 0; k < _fontElementArr.length; k += 1) {
            document.body.removeChild(_fontElementArr[k]);
          }

          if (typeof _Obj.error !== "undefined") {
            _Obj.error(_fontFailureArr);
          }

          _callback();

          _callback = function _callback() {}; // reset callback after execution

        }
      }, _Obj.timeout ? _Obj.timeout : 30000);
    },

    /*
     * preload fonts
     */
    tracer: function tracer() {
      var _obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // eval('console.log(arguments)');
      eval("console.log(_obj)");
    }
  }; // ===================================================================================
  //  Global event class

  window.onViewUpdateCls = new LabComClass.EventClass(true); //  LOCAL event class

  var onModelUpdateCls = new LabComClass.EventClass(true); // ===================================================================================

  var controllerCls = new ControllerClass();
  var viewCls = new ViewClass();
  var modelCls = new ModelClass();
  onModelUpdateCls.trigger("controllerInit"); // ===================================================================================
}
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// ////////////////////////////////////////////////////////////////////////////////////
// Developed By: Mitr Learning & Media
// Name: BrainClass
// Description: The Brain Class act as an intermediate where all the class update data.
// And the updated data is passed to all other classes requiring it
// Date Created: 14/05/2019
// Date Modified: 24/05/2019
// Version: 1.0
// ////////////////////////////////////////////////////////////////////////////////////
function BrainClass(_obj) {
  var modelObj = {
    questionNumbers: [],
    initialquestionNumbers: [],
    pointLabels: [],
    tangentPointsLabel: [],
    currentQuestionNumber: 0,
    finalColor: "rgb(65,180,5)",
    currentQuestion: null,
    constructionShapes: [],
    taskData: [],
    clickedOnQuestionMark: false,
    totalSteps: 0,
    currentStep: 1,
    showSolution: false,
    tutorialCompleted: false,
    totalCorrectShapes: 0,
    isLastQuestion: false,
    solved: false,
    angleSizeData: null,
    lastCenterAngleState: {},
    stepsToPerformInCurrentStep: 1,
    zoomOffsetValue: 4,
    graphSize: {
      x: 300,
      y: 114,
      width: 1280 - 40 - 261
    },
    tangentMidPointData: {
      A: ["F", "J"],
      B: ["F", "G"],
      C: ["G", "H"],
      D: ["I", "H"],
      E: ["J", "I"]
    },
    isA11y_visible: false,
    a11yMode: true,
    a11y_tool_inputs: ["a11y_tool_Input_1", "a11y_tool_Input_2", "a11y_tool_Input_3"],
    a11y_tool_Labels: ["a11y_tool_Label1", "a11y_tool_Label2", "a11y_tool_Label3"],
    tools: {
      point: {
        title1: "pointPatchAriaText1",
        title2: "pointPatchAriaText2",
        title3: "pointPatchAriaText3",
        inputs: {
          a11y_tool_Input_1: true,
          a11y_tool_Input_2: false
        },
        labels: {
          a11y_tool_Label1: true,
          a11y_tool_Label2: false
        }
      },
      ray: {
        title1: "rayPatchAriaText1",
        title2: "rayPatchAriaText2",
        inputs: {
          a11y_tool_Input_1: true,
          a11y_tool_Input_2: true
        },
        labels: {
          a11y_tool_Label1: true,
          a11y_tool_Label2: true
        }
      },
      segment: {
        title1: "segmentPatchAriaText1",
        title2: "segmentPatchAriaText2",
        inputs: {
          a11y_tool_Input_1: true,
          a11y_tool_Input_2: true
        },
        labels: {
          a11y_tool_Label1: true,
          a11y_tool_Label2: true
        }
      },
      // perpendicularLine: {
      //   title: "perpendicularLineInfo",
      //   inputs: { a11y_tool_Input_1: true, a11y_tool_Input_2: true },
      // },
      circle: {
        title1: "circlePatchAriaText1",
        title2: "circlePatchAriaText2",
        inputs: {
          a11y_tool_Input_1: true,
          a11y_tool_Input_2: true
        },
        labels: {
          a11y_tool_Label1: true,
          a11y_tool_Label2: true
        }
      },
      compass: {
        title1: "commpassPatchAriaText1",
        title2: "commpassPatchAriaText2",
        title3: "commpassPatchAriaText3",
        inputs: {
          a11y_tool_Input_1: true,
          a11y_tool_Input_2: true,
          a11y_tool_Input_3: true
        },
        labels: {
          a11y_tool_Label1: true,
          a11y_tool_Label2: true,
          a11y_tool_Label3: true
        }
      },
      angleSize: {
        title1: "angleSizeInfo",
        title2: "angleSizeInfo",
        inputs: {
          a11y_tool_Input_1: true,
          a11y_tool_Input_2: true
        },
        labels: {
          a11y_tool_Label1: true,
          a11y_tool_Label2: true
        }
      }
    }
  };
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });
  var spineObj = modelObj.spineObj;

  window.showGraph = function (flag) {
    spineObj.graphComp.graphLines({
      axis: flag,
      grid: flag
    });
  };

  window.showGraph(false);
  document.addEventListener("keydown", function (e) {
    var _e$key;

    if ((e === null || e === void 0 ? void 0 : (_e$key = e.key) === null || _e$key === void 0 ? void 0 : _e$key.toLowerCase()) === "s" && (e === null || e === void 0 ? void 0 : e.ctrlKey)) {
      e.preventDefault(); // Add your code here

      modelObj.a11yMode = !modelObj.a11yMode;

      if (!modelObj.a11yMode) {
        modelObj.isA11y_visible = false;
        update_a11y_step1_MA(modelObj.isA11y_visible);
      }

      alert("Accessability mode is ".concat(modelObj.a11yMode ? "active" : "deactive", ". Press ctrl + s to ").concat(modelObj.a11yMode ? "deactivate" : "activate", " it."));
    }
  });
  modelObj.questionNumbers = shuffleArray(_toConsumableArray(Array(spineObj.timeLine.getTotalTasks()).keys()));
  modelObj.questionNumbers = [2, 1, 3, 4, 0];
  modelObj.initialquestionNumbers = _toConsumableArray(modelObj.questionNumbers); // spineObj.geoDrawObjAns.disable();

  spineObj.logicObj.setMathObj(spineObj.mathObj, spineObj.LabComClass.Maths);
  spineObj.mathObj.setMathObj(spineObj.LabComClass.Maths);
  spineObj.mathObj.populateDefaultQuestions();
  spineObj.graphComp.graphLines({
    axis: false,
    grid: false
  });
  spineObj.geoDrawObjHelp.snapToGrid(false);
  spineObj.geoDrawObjHelp.show();
  addListener();
  nextQuestion();
  update_a11y_step1_MA();
  updateRender();
  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: _obj.id
    }
  });

  function addListener() {
    var clickEvents = ["geoTools", "nextTaskBtn", "showSolutionBtn", "stepsTable", "zoomControls", "submitBtn"];
    var inputs = ["angleInput", "centerAngleInput"].concat(_toConsumableArray(modelObj.a11y_tool_inputs)); //Events to be added on input Box

    var eventsToListen = ["focusOut", "keyup"];
    inputs.forEach(function (elem) {
      spineObj[elem].enable();
      spineObj[elem].on(eventsToListen[1], onKeyUp);
    });
    modelObj.a11y_tool_inputs.forEach(function (elem) {
      // spineObj[elem].on(eventsToListen[0], checkAndPlot);
      spineObj[elem].on(eventsToListen[1], checkAndPlot);
    });

    for (var i = 0; i < clickEvents.length; i++) {
      spineObj[clickEvents[i]].addEventListener("click", onButtonEvent);
    } //Submit Btn and Radio is selected bydefault


    spineObj.submitBtn.disable();
    spineObj.radio.setValue(0);
    spineObj.draggable.addEventListener("change", updatePos); //

    spineObj.centerAngleDraggable.addEventListener("change", updateCenterAnglePanelPos);
    spineObj.a11y_tool_Draggable.addEventListener("change", update_a11y_step1_MA);
    var drawEvents = ["geoInteraction", "move", "moveGraph", "select", "angleSize"];

    for (var _i = 0; _i < drawEvents.length; _i++) {
      // spineObj.geoDrawHelpObj.addEventListener(drawEvents[i], onGraphEvent);
      spineObj.geoDrawObjHelp.addEventListener(drawEvents[_i], onGraphEvent);
    }

    spineObj.graphComp.addEventListener("scaleUpdate", onChange);
    spineObj.wrongAlertBox.addEventListener("popupClose", onPopupClose);
  }

  function onPopupClose() {
    spineObj.geoTools.setFocus();
  }

  function nextQuestion() {
    modelObj.currentQuestionNumber = modelObj.questionNumbers.shift();
    modelObj.currentQuestion = spineObj.mathObj.getQuestion(modelObj.currentQuestionNumber);
    modelObj.tutorialCompleted = false;
    modelObj.clickedOnQuestionMark = false;
    modelObj.showSolution = false;
    modelObj.totalCorrectShapes = 0;
    modelObj.solved = false;
    spineObj.showSolutionBtn.setToggleState(false);
    spineObj.geoDrawObjAns.clearAll();
    reset();
    setQuestionText();
    setQuestion();
    setSolution(true);
    renderCenterAnglePanel(true);
  }

  function reset() {
    spineObj.geoTools.reset();
    spineObj.zoomControls.reset();
    spineObj.logicObj.reset();
    modelObj.currentStep = 1;
    spineObj.stepsTable.resetStates();
    spineObj.stepsTable.setStep(0);
    spineObj.geoDrawObjHelp.clearAll();
    spineObj.geoTools.enable();
    spineObj.completeAlertBox.hide();
    spineObj.showSolutionBtn.enable();
    resetCenterAnglePanel();
  }

  function setQuestionText() {
    var _spineObj$LabComClass = spineObj.LabComClass.globalLangText,
        questions = _spineObj$LabComClass.questions,
        questionNumberAriaLabel = _spineObj$LabComClass.questionNumberAriaLabel,
        questionNumberInitialShapeAriaLabel = _spineObj$LabComClass.questionNumberInitialShapeAriaLabel;
    var _questions$modelObj$c = questions[modelObj.currentQuestionNumber],
        steps = _questions$modelObj$c.steps,
        task = _questions$modelObj$c.task;
    var _modelObj$currentQues = modelObj.currentQuestion,
        points = _modelObj$currentQues.points,
        type = _modelObj$currentQues.type;
    modelObj.totalSteps = steps.length;
    spineObj.stepsTable.clearData();
    modelObj.pointLabels = [];
    modelObj.tangentPointsLabel = [];
    points.forEach(function (point, i) {
      modelObj.pointLabels.push(String.fromCharCode(65 + i));

      if (type === 3) {
        modelObj.tangentPointsLabel.push(String.fromCharCode(65 + points.length + i));
      }
    });
    steps.forEach(function (step, i) {
      spineObj.stepsTable.addData({
        text: step
      });
    });
    spineObj.questionLabel.setValue(task);
    var currentQuestionNumber = modelObj.initialquestionNumbers.findIndex(function (e) {
      return e == modelObj.currentQuestionNumber;
    }) + 1;
    spineObj.questionLabelStart.setValue(questionNumberAriaLabel + currentQuestionNumber + questionNumberInitialShapeAriaLabel);
    spineObj.questionLabel.setAriaLabel(questionNumberAriaLabel + currentQuestionNumber + questionNumberInitialShapeAriaLabel + task);
    spineObj.questionLabelStart.setFocus();
  }

  function setQuestion(onlyGeoDrawObjAns) {
    var _modelObj$currentQues2 = modelObj.currentQuestion,
        circle = _modelObj$currentQues2.circle,
        point = _modelObj$currentQues2.point,
        centerPoint = _modelObj$currentQues2.centerPoint;
    [centerPoint, circle, point].forEach(function (data) {
      data = _objectSpread(_objectSpread({}, data), {}, {
        strokeColor: "rgba(10,190,220,1)",
        isDraggable: false,
        isDeletable: false
      });

      if (!onlyGeoDrawObjAns) {
        spineObj.geoDrawObjHelp.addShape(data);
      }

      spineObj.geoDrawObjAns.addShape(data);
    });

    if (!onlyGeoDrawObjAns) {
      spineObj.geoDrawObjHelp.setStep(1);
    }
  }

  function setSolution() {
    var ignoreStep1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var questions = spineObj.LabComClass.globalLangText.questions;
    var steps = questions[modelObj.currentQuestionNumber].steps;
    var previousStep = modelObj.currentStep;
    modelObj.currentStep = 1;

    for (var i = +ignoreStep1; i < steps.length; i++) {
      modelObj.currentStep++;
      autoCompleteStep(i, spineObj.geoDrawObjAns);
    }

    highlightFinalAnswer(spineObj.geoDrawObjAns);
    modelObj.currentStep = previousStep;
  } //To show and hide the Angle Panel


  function renderCenterAnglePanel(_bool) {
    var centerAngles = ["centerAngleDraggable", "centerAngleLabel", "centerAngleLHS", "centerAngleLHSDivideSign", "centerAngleEqualSign", "centerAngleRHS", "centerAngleInput"];

    if (_bool) {
      updateCenterAnglePanelPos();
      centerAngles.forEach(function (elem) {
        spineObj[elem].show();
      });
      spineObj.centerAngleInput.setValue("");
    } else {
      centerAngles.forEach(function (elem) {
        spineObj[elem].hide();
      });
      spineObj.centerAngleInput.setValue("");
    }
  }

  function update_a11y_step1_MA() {
    var _modelObj$tools$tool3, _modelObj$tools$tool4, _modelObj$tools$tool5;

    var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var visible = status;

    if (!modelObj.a11yMode) {
      visible = false;
    }

    var diff = 30;
    var inputHeight = 30;
    var textHeight = 90;
    var items = [{
      id: "a11y_tool_Label1",
      x: 10,
      y: 10
    }, {
      id: "a11y_tool_Input_1",
      x: 10,
      y: 10 + textHeight
    }, {
      id: "a11y_tool_Label2",
      x: 10,
      y: 10 + textHeight + inputHeight + diff
    }, {
      id: "a11y_tool_Input_2",
      x: 10,
      y: 10 + textHeight * 2 + diff + inputHeight
    }, {
      id: "a11y_tool_Label3",
      x: 10,
      y: 10 + textHeight * 2 + diff * 2 + inputHeight * 2
    }, {
      id: "a11y_tool_Input_3",
      x: 10,
      y: 10 + textHeight * 3 + diff * 2 + inputHeight * 2
    }];
    var tool = spineObj.geoTools.getSelected();
    var set = [{
      id: "a11y_tool_Draggable",
      x: 0,
      y: 0
    }].concat(items);

    if (visible == true || visible == false) {
      set.forEach(function (elem) {
        spineObj[elem.id][visible ? "show" : "hide"]();

        if (visible && modelObj.a11y_tool_inputs.includes(elem.id)) {
          var _modelObj$tools$tool;

          if (modelObj.tools[tool] && !(modelObj === null || modelObj === void 0 ? void 0 : (_modelObj$tools$tool = modelObj.tools[tool]) === null || _modelObj$tools$tool === void 0 ? void 0 : _modelObj$tools$tool.inputs[elem === null || elem === void 0 ? void 0 : elem.id])) {
            spineObj[elem.id].hide();
          }
        }

        if (visible && modelObj.a11y_tool_Labels.includes(elem.id)) {
          var _modelObj$tools$tool2;

          if (modelObj.tools[tool] && !(modelObj === null || modelObj === void 0 ? void 0 : (_modelObj$tools$tool2 = modelObj.tools[tool]) === null || _modelObj$tools$tool2 === void 0 ? void 0 : _modelObj$tools$tool2.labels[elem === null || elem === void 0 ? void 0 : elem.id])) {
            spineObj[elem.id].hide();
          }
        }
      });
    } //Setting Positions


    var oPos = spineObj.a11y_tool_Draggable.getPos();
    items.forEach(function (elem) {
      spineObj[elem.id].setPos(oPos.x + elem.x, oPos.bodyY + elem.y);
    });
    var label1 = spineObj.LabComClass.globalLangText[(modelObj === null || modelObj === void 0 ? void 0 : (_modelObj$tools$tool3 = modelObj.tools[tool]) === null || _modelObj$tools$tool3 === void 0 ? void 0 : _modelObj$tools$tool3.title1) || ""];
    var label2 = spineObj.LabComClass.globalLangText[(modelObj === null || modelObj === void 0 ? void 0 : (_modelObj$tools$tool4 = modelObj.tools[tool]) === null || _modelObj$tools$tool4 === void 0 ? void 0 : _modelObj$tools$tool4.title2) || ""];
    var label3 = spineObj.LabComClass.globalLangText[(modelObj === null || modelObj === void 0 ? void 0 : (_modelObj$tools$tool5 = modelObj.tools[tool]) === null || _modelObj$tools$tool5 === void 0 ? void 0 : _modelObj$tools$tool5.title3) || ""];
    spineObj.a11y_tool_Label1.setValue(label1);
    spineObj.a11y_tool_Label2.setValue(label2);
    spineObj.a11y_tool_Label3.setValue(label3);

    if (modelObj.currentStep !== 1 && tool === "point") {
      spineObj.a11y_tool_Label1.setValue(label2);
    }

    if (modelObj.currentQuestion.type === 2 && modelObj.currentStep > 2 && tool === "point") {
      spineObj.a11y_tool_Label1.setValue(label3);
    }
  }

  function updateCenterAnglePanelPos() {
    //Setting Positions
    var oPos = spineObj.centerAngleDraggable.getPos();
    spineObj.centerAngleLabel.setPos(oPos.x + 10, oPos.bodyY + 10);
    spineObj.centerAngleLHS.setPos(oPos.x + 14, oPos.bodyY + 40);
    spineObj.centerAngleLHSDivideSign.setPos(oPos.x + 10, oPos.bodyY + 43);
    spineObj.centerAngleInput.setPos(oPos.x + 10, oPos.bodyY + 70);
    spineObj.centerAngleEqualSign.setPos(oPos.x + 70, oPos.bodyY + 54);
    spineObj.centerAngleRHS.setPos(oPos.x + 90, oPos.bodyY + 54);
  }

  function updatePos() {
    //Setting Positions
    var oPos = spineObj.draggable.getPos();
    spineObj.angleLabel.setPos(oPos.x + 200, oPos.bodyY + 40);
    spineObj.angleInput.setPos(oPos.x + 200, oPos.bodyY + 70);
    spineObj.radio.setPos(oPos.x + 200, oPos.bodyY + 110);
    spineObj.submitBtn.setPos({
      x: oPos.x + 200,
      y: oPos.bodyY + 190
    });
  }

  function highlightFinalAnswer(geoDrawObjInst) {
    var strokeColor = modelObj.finalColor;
    var fillColor = modelObj.finalColor;

    var _geoDrawObjInst$getDa = geoDrawObjInst.getData(),
        visible = _geoDrawObjInst$getDa.visible;

    var type = modelObj.currentQuestion.type;
    var shapes = visible.filter(function (shape) {
      return shape.type === "segment";
    });
    shapes.forEach(function (shape) {
      var common = {
        x: shape.x,
        y: shape.y,
        type: "point",
        strokeColor: strokeColor,
        fillColor: fillColor
      };
      geoDrawObjInst.addShape(_objectSpread(_objectSpread({}, common), {}, {
        xTo: shape.xTo,
        yTo: shape.yTo,
        type: "segment"
      }));
      geoDrawObjInst.addShape(_objectSpread({}, common));
      geoDrawObjInst.addShape(_objectSpread(_objectSpread({}, common), {}, {
        x: shape.xTo,
        y: shape.yTo
      }));
    });
  }

  function onChange(_obj) {
    switch (_obj.type) {
      case "scaleUpdate":
        spineObj.geoDrawObjHelp.setScreenData(spineObj.graphComp.getScreenData());
        spineObj.geoDrawObjAns.setScreenData(spineObj.graphComp.getScreenData());
        break;

      default:
        console.info("Brain No event Added for " + _obj.type);
        break;
    }

    updateRender();
  }

  function onGraphEvent(e) {
    switch (e.type) {
      case "geoInteraction":
        var _spineObj$logicObj$ch = spineObj.logicObj.checkStep(modelObj.currentStep, e.data, modelObj.currentQuestion, spineObj.geoDrawObjHelp.getData),
            _spineObj$logicObj$ch2 = _slicedToArray(_spineObj$logicObj$ch, 2),
            match = _spineObj$logicObj$ch2[0],
            completed = _spineObj$logicObj$ch2[1];

        if (match) {
          if (e.mode !== "auto") {
            addLabel(e.data, spineObj.geoDrawObjHelp);
          }

          if (completed) {
            if (e.mode !== "auto") {
              modelObj.totalCorrectShapes++;
            }

            if (modelObj.currentStep <= modelObj.totalSteps - 1) {
              spineObj.stepsTable.setStep(modelObj.currentStep);
              spineObj.geoDrawObjHelp.setStep(modelObj.currentStep + 1);
              spineObj.logicObj.reset();
            }

            modelObj.currentStep++;

            if (modelObj.currentStep > modelObj.totalSteps) {
              if (e.mode !== "auto" && !modelObj.clickedOnQuestionMark) {
                modelObj.solved = true;
              }

              modelObj.tutorialCompleted = true;
              spineObj.completeAlertBox.show();
              updateConstructionHelperStyle(e);
              highlightFinalAnswer(spineObj.geoDrawObjHelp);
              spineObj.stepsTable.setStep(modelObj.totalSteps);
            } else {
              updateConstructionHelperStyle(e);
            }
          } else {
            updateConstructionHelperStyle(e);

            if (e.mode !== "auto" && modelObj.currentStep == 1) {
              spineObj.centerAngleLabel.setFocus();
            }
          }
        } else {
          spineObj.geoDrawObjHelp.removeRecentShapes(e.data.newPlottedShapes);
          spineObj.wrongAlertBox.show(true);
          modelObj.isA11y_visible = false;
          update_a11y_step1_MA(modelObj.isA11y_visible);
        }

        adjustPointLabel(spineObj.geoDrawObjHelp);
        break;

      case "moveGraph":
        spineObj.graphComp.setPanValues(e.data);
        break;

      case "angleSize":
        //Angle Size Event called from Geodraw
        renderAnglePanel(e.visible); //PAnel is shown.

        if (e.visible) {
          modelObj.angleSizeData = e.data; //Data is stored in variable

          updatePos(); //To set Pos of all comps in patch i.e, input Box,label,radio and Submit Btn
          //If Manual Setting
          // e.data.degree=45;
          // e.data.clockwise=true;

          spineObj.angleLabel.setFocus();
        }

        break;
    }

    updateRender();
  }

  function onKeyUp(e) {
    switch (e.id) {
      case "angleInput":
        spineObj.submitBtn[spineObj.angleInput.getValue() !== "" ? "enable" : "disable"]();
        break;

      case "centerAngleInput":
        var angle = spineObj[e.id].getValue();

        if (angle && modelObj.currentQuestion.points.length === +angle) {
          angle = +angle;
          spineObj.centerAngleRHS.setValue(+(360 / angle).toFixed(2) + "°");
        } else {
          spineObj.centerAngleRHS.setValue("");
        }

        break;

      case "a11y_tool_Input_1":
      case "a11y_tool_Input_2":
        break;
    }

    if (e.id === "centerAngleInput" && spineObj[e.id].getValue() !== "" && e.enterPressed) {
      var status = modelObj.currentQuestion.points.length === +spineObj.centerAngleInput.getValue();
      spineObj.centerAngleInput.setState(status ? "correct" : "incorrect");

      if (status) {
        spineObj.centerAngleInput.disable();
        onGraphEvent({
          id: "geoDrawObjHelp",
          type: "geoInteraction",
          data: {
            type: "centerAngleInput",
            correct: status
          },
          mode: "auto"
        });
      }
    }
  } //To show and hide the Angle Panel


  function renderAnglePanel(_bool) {
    var showHide = ["draggable", "angleInput", "submitBtn", "angleLabel", "radio"];

    if (_bool) {
      showHide.forEach(function (elem) {
        spineObj[elem].show();
      });
      spineObj.submitBtn.disable();
    } else {
      showHide.forEach(function (elem) {
        spineObj[elem].hide();
      });
      spineObj.angleInput.setValue("");
    }
  }

  function addLabel(data, geoDrawObjInst) {
    if (data.type === "point") {
      var label;

      if ([1, 3].includes(modelObj.currentQuestion.type) && [2, 3].includes(modelObj.currentStep) || modelObj.currentQuestion.type === 2 && [2, 3, 4].includes(modelObj.currentStep)) {
        var shapes = geoDrawObjInst.getData().visible;
        var points = shapes.filter(function (shape) {
          return shape.type === "point" && shape.uniqueId !== data.uniqueId;
        });
        label = modelObj.pointLabels[points.length - 1];
      } else if (modelObj.currentQuestion.type === 3 && [4, 5].includes(modelObj.currentStep)) {
        var _shapes = geoDrawObjInst.getData().visible;

        var clockwise = _shapes.find(function (shape) {
          return shape.type === "angleSize";
        }).clockwise;

        var labelIndex = modelObj.currentQuestion.tangentIntersectionPoints.findIndex(function (point) {
          return spineObj.logicObj.checkPoints(point, data);
        });
        label = (clockwise ? modelObj.tangentPointsLabel.slice(0).reverse() : modelObj.tangentPointsLabel)[labelIndex];
      }

      if (label) {
        geoDrawObjInst.updateShape(data.uniqueId, {
          label: label,
          labelDiffX: 6,
          labelDiffY: -9,
          labelX: data.x,
          labelY: data.y
        });
      }
    }
  }

  function labelManager(data) {
    var variant = modelObj.taskData.length;
    data.forEach(function (el) {
      if (el.type === "line") {
        var point = {};
        var expression = variant < 3 ? el.firstPointId > el.secondPointId : el.firstPointId < el.secondPointId;
        var displacement = variant == 1 ? 3.5 : 3;

        if (expression) {
          var _slope = spineObj.LabComClass.Maths.getAngle(el.xTo, el.yTo, el.x, el.y);

          point = spineObj.LabComClass.Maths.getPoint({
            x: el.x,
            y: el.y
          }, _slope, displacement);
        } else {
          var _slope2 = spineObj.LabComClass.Maths.getAngle(el.x, el.y, el.xTo, el.yTo);

          point = spineObj.LabComClass.Maths.getPoint({
            x: el.xTo,
            y: el.yTo
          }, _slope2, displacement);
        }

        el.labelX = point.x;
        el.labelY = point.y; // el.labelDiffX=variant!==1?10:5;
      }
    });
    return data;
  }

  function getDataByStep(type, stepNumber, _geoDrawObj) {
    var drawNewShape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var data;

    switch (type) {
      case 1:
        switch (stepNumber) {
          case 0:
            data = step1(drawNewShape);
            break;

          case 1:
            data = step2({
              _geoDrawObj: _geoDrawObj,
              prevPoint: modelObj.currentQuestion.point,
              drawNewShape: drawNewShape
            });
            break;

          case 2:
            data = type1Step3(_geoDrawObj, drawNewShape);
            break;

          case 3:
            data = joinPoints();
            break;
        }

        break;

      case 2:
        switch (stepNumber) {
          case 0:
            data = step1(drawNewShape);
            break;

          case 1:
            data = step2({
              _geoDrawObj: _geoDrawObj,
              prevPoint: modelObj.currentQuestion.point,
              drawNewShape: drawNewShape
            });
            break;

          case 2:
          case 3:
            {
              var points = modelObj.currentQuestion.points;
              var pointLabels = modelObj.pointLabels;

              var shapes = _geoDrawObj.getData().visible;

              var clockwise = shapes.find(function (shape) {
                return shape.type === "angleSize";
              }).clockwise;

              if (!clockwise) {
                points = _toConsumableArray(points).reverse();
              }

              var r = spineObj.LabComClass.Maths.getDistance(points[0], points[1]);
              data = [];
              var startIndex = clockwise ? 0 : stepNumber === 2 ? 1 : 2;

              for (var i = startIndex; i < points.length - (2 - startIndex); i++) {
                if (stepNumber === 3 && i === (clockwise ? startIndex : points.length - 1)) {
                  continue;
                }

                var point = points[i];
                var nextIndex = i + 1;
                data = [].concat(_toConsumableArray(data), [{
                  x: point.x,
                  y: point.y,
                  r: r,
                  type: "circle"
                }, {
                  x: points[nextIndex].x,
                  y: points[nextIndex].y,
                  type: "point",
                  label: pointLabels[nextIndex + Number(clockwise)]
                }]);

                if (stepNumber === 2 && i === startIndex || stepNumber === 3 && i === (clockwise ? startIndex : points.length - 1)) {
                  break;
                }
              }
            }
            break;

          case 4:
            data = joinPoints();
            break;
        }

        break;

      case 3:
        switch (stepNumber) {
          case 0:
            data = step1(drawNewShape);
            break;

          case 1:
            data = step2({
              _geoDrawObj: _geoDrawObj,
              prevPoint: modelObj.currentQuestion.point,
              drawNewShape: drawNewShape
            });
            break;

          case 2:
            data = type1Step3(_geoDrawObj, drawNewShape);
            break;

          case 3:
            {
              var tangentIntersectionPoints = modelObj.currentQuestion.tangentIntersectionPoints;

              var _shapes2 = _geoDrawObj.getData().visible;

              var _clockwise = _shapes2.find(function (shape) {
                return shape.type === "angleSize";
              }).clockwise;

              var tangentPoint = _clockwise ? tangentIntersectionPoints[tangentIntersectionPoints.length - 1] : tangentIntersectionPoints[0];
              data = tangentPoint.forLinesPoints.map(function (point) {
                return {
                  x: point.x,
                  y: point.y,
                  xTo: tangentPoint.x,
                  yTo: tangentPoint.y,
                  type: "line"
                };
              });
              data.push({
                x: tangentPoint.x,
                y: tangentPoint.y,
                label: modelObj.tangentPointsLabel[0],
                type: "point"
              });
            }
            break;

          case 4:
            {
              var _tangentIntersectionPoints = modelObj.currentQuestion.tangentIntersectionPoints;

              var _shapes3 = _geoDrawObj.getData().visible;

              var _clockwise2 = _shapes3.find(function (shape) {
                return shape.type === "angleSize";
              }).clockwise;

              var remainingTangentPoints;

              if (_clockwise2) {
                remainingTangentPoints = _tangentIntersectionPoints.slice(0, -1).reverse();
              } else {
                remainingTangentPoints = _tangentIntersectionPoints.slice(1);
              }

              var tangentPointsData = [];
              remainingTangentPoints.forEach(function (point, i) {
                tangentPointsData.push({
                  x: point.x,
                  y: point.y,
                  label: modelObj.tangentPointsLabel[i + 1],
                  type: "point"
                });
              }); // remaining Tangent Lines

              if (_clockwise2) {
                remainingTangentPoints.shift();
              } else {
                remainingTangentPoints.pop();
              }

              data = remainingTangentPoints.map(function (tangentPoint, i) {
                var point = tangentPoint.forLinesPoints[1];
                return {
                  x: point.x,
                  y: point.y,
                  xTo: tangentPoint.x,
                  yTo: tangentPoint.y,
                  type: "line"
                };
              });
              data = [].concat(_toConsumableArray(data), tangentPointsData);
            }
            break;

          case 5:
            data = joinPoints(modelObj.currentQuestion.tangentIntersectionPoints);
            break;
        }

        break;
    }

    return data;
  }

  function autoCompleteStep(stepNumber, geoDrawObjAnsInst) {
    var _geoDrawObj = geoDrawObjAnsInst || spineObj.geoDrawObjHelp;

    spineObj.geoDrawObjHelp === _geoDrawObj && spineObj.stepsTable.setStep(modelObj.currentStep);
    var type = modelObj.currentQuestion.type;
    var data = getDataByStep(type, stepNumber, _geoDrawObj, true);
    plotShapes({
      data: data,
      geoDrawObjAnsInst: geoDrawObjAnsInst,
      _geoDrawObj: _geoDrawObj,
      startChecking: false
    });
    adjustPointLabel(_geoDrawObj);
  }

  function plotShapes(_ref) {
    var data = _ref.data,
        geoDrawObjAnsInst = _ref.geoDrawObjAnsInst,
        _geoDrawObj = _ref._geoDrawObj,
        _ref$startChecking = _ref.startChecking,
        startChecking = _ref$startChecking === void 0 ? false : _ref$startChecking;

    if (data) {
      var action = function action(d) {
        geoDrawObjAnsInst && (d.step = modelObj.currentStep - 1);

        if (!d.ignoreAddingShape) {
          d.uniqueId = _geoDrawObj.addShape(d);
        }

        if (geoDrawObjAnsInst) {
          updateConstructionHelperStyle({
            data: d
          }, geoDrawObjAnsInst);
        } else if (!d.ignoreAddingShape || d.ignoreAddingShape && d.type === "angleSize" || startChecking) {
          onGraphEvent({
            id: "geoDrawObjHelp",
            type: "geoInteraction",
            data: d,
            mode: "auto"
          });
        }
      };

      Array.isArray(data) ? data.forEach(action) : action(data);
    }
  }

  function adjustPointLabel(_geoDrawObj) {
    var data = _geoDrawObj.getData().visible;

    var variant = modelObj.taskData.length;
    var lx1, ly1;
    var lx2, ly2;
    data.forEach(function (val, i) {
      if (val.label == "S") {
        switch (variant) {
          case 2:
            lx1 = 4.5919282511210895;
            ly1 = -16.299049666468022;
            break;

          case 3:
            lx1 = -26.403587443946208;
            ly1 = 10.89686098654704;
            break;

          case 4:
            lx1 = 6;
            ly1 = -9;
            break;
        }

        data[i].labelDiffX = lx1;
        data[i].labelDiffY = ly1;
      }

      if (val.label == "S'") {
        switch (variant) {
          case 2:
            lx2 = 10.331838565022508;
            ly2 = 16.568107962432236;
            break;

          case 3:
            lx2 = -8.437668161434885;
            ly2 = -18.89327354260101;
            break;

          case 4:
            lx2 = -12.919337086972746;
            ly2 = -16.409566517189887;
            break;
        }

        data[i].labelDiffX = lx2;
        data[i].labelDiffY = ly2;
      }
    });

    _geoDrawObj.setData({
      visible: data
    });
  }

  function updateConstructionHelperStyle(e, geoDrawObjInst) {
    var _shapes4;

    if (e.data.type === "segment") {
      return;
    }

    var _geoDrawObj = geoDrawObjInst || spineObj.geoDrawObjHelp;

    var pointLabels = modelObj.pointLabels;
    var _modelObj$currentQues3 = modelObj.currentQuestion,
        pointsOnCircle = _modelObj$currentQues3.points,
        type = _modelObj$currentQues3.type,
        tangentIntersectionPoints = _modelObj$currentQues3.tangentIntersectionPoints;

    var allShapes = _geoDrawObj.getData().visible;

    var shapes = allShapes.filter(function (shape) {
      return shape.step !== 0;
    });

    var shapeToBeMarkedAsBlue = _toConsumableArray(shapes);

    var shapeToBeMarkedAsGrey = [];
    var lastStep = (_shapes4 = shapes[shapes.length - 1]) === null || _shapes4 === void 0 ? void 0 : _shapes4.step;

    if (lastStep !== undefined) {
      if (type === 3) {
        // grey out the angle on step2 & step3
        var tempShapeToBeMarkedAsGrey = shapeToBeMarkedAsBlue.splice(0, shapeToBeMarkedAsBlue.findLastIndex(function (shape) {
          return shape.type === "point" && shape.step <= 3;
        }));
        tempShapeToBeMarkedAsGrey.forEach(function (shape) {
          if (shape.type === "angleSize") {
            shapeToBeMarkedAsGrey.push(shape);
          } else {
            shapeToBeMarkedAsBlue.push(shape);
          }
        });

        if (lastStep >= 4) {
          // grey out the rays perpendicular to the tangents drawn
          var perpendicularLines = shapeToBeMarkedAsBlue.filter(function (shape) {
            return shape.type === "perpendicularLine" || shape.type === "line";
          });
          perpendicularLines.forEach(function (line) {
            var perpendicularRayIndex = shapeToBeMarkedAsBlue.findIndex(function (shape) {
              return shape.type === "ray" && spineObj.logicObj.angleBetweenLines(line.x, line.y, line.xTo, line.yTo, shape.x, shape.y, shape.xTo, shape.yTo) === 90;
            });

            if (perpendicularRayIndex > -1) {
              shapeToBeMarkedAsGrey.push(shapeToBeMarkedAsBlue.splice(perpendicularRayIndex, 1)[0]);
            }
          }); // grey out the tangents when their intersection point is drawn.

          Object.keys(modelObj.tangentMidPointData).forEach(function (midePointLabel, i) {
            var tangentsLabel = modelObj.tangentMidPointData[midePointLabel];
            var pointshapes = shapeToBeMarkedAsBlue.filter(function (shape) {
              return shape.type === "point" && (shape.label === tangentsLabel[0] || shape.label === tangentsLabel[1]);
            });

            if (pointshapes.length == 2) {
              var midPoint = allShapes.find(function (shape) {
                return shape.type === "point" && shape.label === midePointLabel;
              });

              if (midPoint) {
                var lineIndex = shapeToBeMarkedAsBlue.findIndex(function (shape) {
                  return (shape.type === "perpendicularLine" || shape.type === "line") && (spineObj.logicObj.checkPoints(midPoint, shape) || spineObj.logicObj.checkPoints(midPoint, {
                    x: shape.xTo,
                    y: shape.yTo
                  }));
                });

                if (lineIndex > -1) {
                  shapeToBeMarkedAsGrey.push(shapeToBeMarkedAsBlue.splice(lineIndex, 1)[0]);
                }
              }
            }
          });
        }
      } else {
        // handles grey out shapes on step2, step3
        var inclue2ndLastShape;

        if (type === 2 && lastStep >= 3) {
          inclue2ndLastShape = true;
        } else {
          inclue2ndLastShape = shapes.filter(function (shape) {
            return shape.type === "point" && pointLabels.includes(shape.label);
          }).length === pointsOnCircle.length - 1;
        }

        shapeToBeMarkedAsGrey = shapeToBeMarkedAsBlue.splice(0, shapeToBeMarkedAsBlue.findLastIndex(function (shape) {
          return shape.type === "point";
        }) - (inclue2ndLastShape ? 0 : 1));
      }
    }

    shapeToBeMarkedAsGrey.forEach(function (shape) {
      if (shape.type !== "point") _geoDrawObj.setStyle(shape.uniqueId, {
        strokeColor: "#828282",
        //"#CFCFCF",
        fillColor: "#828282" //"#CFCFCF",

      });
    });
    shapeToBeMarkedAsBlue.forEach(function (shape) {
      if (shape.type !== "point") _geoDrawObj.setStyle(shape.uniqueId, {
        strokeColor: "rgba(10,190,220,0.8)",
        fillColor: "rgba(10,190,220,1)"
      });
    });
  }

  function changeSolLabels() {
    var drawData = spineObj.geoDrawObjHelp.getData().visible;
    var diffArray = [];
    drawData.forEach(function (el) {
      if (el.type !== "circle") {
        diffArray.push({
          label: el.label,
          labelDiffX: el.labelDiffX,
          labelDiffY: el.labelDiffY,
          type: el.type
        });
      }
    });
    diffArray.forEach(function (el) {
      if (el.label !== undefined) {
        var solShape = findShapeByLabelForSol(el.label, "geoDrawObjAns")[0];

        if (solShape !== undefined && el.label === solShape.label && el.type === solShape.type) {
          spineObj.geoDrawObjAns.updateShape(solShape.uniqueId, {
            labelDiffX: el.labelDiffX,
            labelDiffY: el.labelDiffY
          });
        }
      }
    });
  }

  function findShapeByLabelForSol(label, geoDrawObj) {
    var _spineObj$geoDrawObj$ = spineObj[geoDrawObj].getData(),
        visible = _spineObj$geoDrawObj$.visible; // const visible=modelObj.mathData;


    var index;
    var shape;
    var shapes = [];
    visible.forEach(function (el, i) {
      if ((el.label === label || el.oglabel === label) && el.type !== "circle") {
        index = i;
        shape = el;
        shapes.push(el);
      }
    });
    return shapes;
  }

  function updateRender() {
    var selectedGeoTool = spineObj.geoTools.getSelected();
    changeSolLabels();

    if (modelObj.showSolution) {
      spineObj.geoDrawObjHelp.hide();
      spineObj.geoDrawObjAns.show();
    } else {
      spineObj.geoDrawObjAns.hide();
      spineObj.geoDrawObjHelp.show();
    }

    spineObj.geoTools.enable();
    spineObj.showSolutionBtn.enable();

    if (modelObj.tutorialCompleted) {
      spineObj.geoTools.disable();
      spineObj.showSolutionBtn.disable();
    }

    spineObj.geoDrawObjHelp.setTransperent(modelObj.showSolution);
    spineObj.showSolutionBtn.setValue(spineObj.LabComClass.globalLangText[modelObj.showSolution ? "hideSolution" : "showSolution"]);

    if (modelObj.taskData.length >= spineObj.timeLine.getTotalTasks() - 1) {
      spineObj.nextTaskBtn.setValue(spineObj.LabComClass.globalLangText.submit);
      modelObj.isLastQuestion = true;
    }

    if (modelObj.taskData.length >= spineObj.timeLine.getTotalTasks()) {
      spineObj.nextTaskBtn.disable();
      spineObj.stepsTable.disable();
      spineObj.showSolutionBtn.disable();
      spineObj.geoTools.disable();
    }

    spineObj.geoDrawObjHelp.setInteractionType(selectedGeoTool);

    if (modelObj.tutorialCompleted) {
      spineObj.geoDrawObjHelp.setInteractionType("move");
    }

    if (spineObj.completeAlertBox.isVisible()) {
      spineObj.wrongAlertBox.hide();
    }

    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "rendererUpdate"
    });
  }

  function resetCenterAnglePanel() {
    spineObj.centerAngleInput.setState("normal");
    spineObj.centerAngleInput.setValue("");
    spineObj.centerAngleInput.enable();
    onKeyUp({
      id: "centerAngleInput"
    });
  }

  function onButtonEvent(e) {
    switch (e.id) {
      case "nextTaskBtn":
        storeData();

        if (!modelObj.isLastQuestion) {
          nextQuestion();
        } else {
          modelObj.tutorialCompleted = true;
          spineObj.submitBox.show();
        }

        modelObj.isA11y_visible = false;
        update_a11y_step1_MA(modelObj.isA11y_visible);
        break;

      case "showSolutionBtn":
        modelObj.showSolution = !modelObj.showSolution;

        if (modelObj.showSolution) {
          spineObj.geoDrawObjAns.clearAll(); // Store the previous center angle panel state

          modelObj.lastCenterAngleState = {
            centerAngleRHS: spineObj.centerAngleRHS.getValue(),
            centerAngleInputState: spineObj.centerAngleInput.getCorrect(),
            centerAngleInputValue: spineObj.centerAngleInput.getValue(),
            centerAngleInputEnable: spineObj.centerAngleInput.isEnabled()
          };
          setQuestion(true);
          setSolution();
        } else {
          // retain last state
          var _modelObj$lastCenterA = modelObj.lastCenterAngleState,
              centerAngleRHS = _modelObj$lastCenterA.centerAngleRHS,
              centerAngleInputState = _modelObj$lastCenterA.centerAngleInputState,
              centerAngleInputValue = _modelObj$lastCenterA.centerAngleInputValue,
              centerAngleInputEnable = _modelObj$lastCenterA.centerAngleInputEnable;
          spineObj.centerAngleRHS.setValue(centerAngleRHS);
          centerAngleInputState === null ? spineObj.centerAngleInput.setState("normal") : spineObj.centerAngleInput.setState(centerAngleInputState);
          spineObj.centerAngleInput.setValue(centerAngleInputValue);
          centerAngleInputEnable ? spineObj.centerAngleInput.enable() : spineObj.centerAngleInput.disable();
        }

        break;

      case "stepsTable":
        switch (e.type) {
          case "help":
            // spineObj.geoDrawObjHelp.removeIncompleteShape();
            modelObj.clickedOnQuestionMark = true;
            spineObj.geoDrawObjHelp.setStep(e.value);
            spineObj.geoDrawObjHelp.setStep(e.value + 1);
            modelObj.currentStep = e.value + 1;
            spineObj.logicObj.reset();
            autoCompleteStep(e.value);
            break;

          case "reset":
            // spineObj.geoDrawObjHelp.removeIncompleteShape();
            modelObj.tutorialCompleted = false;
            spineObj.geoDrawObjHelp.setStep(e.value);
            spineObj.geoDrawObjHelp.setStep(e.value + 1);
            modelObj.currentStep = e.value + 1;

            if (modelObj.currentStep === 1) {
              resetCenterAnglePanel();
            }

            spineObj.logicObj.reset();
            updateConstructionHelperStyle({
              id: "geoDrawObjHelp",
              data: {}
            });
            break;
        }

        break;

      case "zoomControls":
        if (e.value.includes("zoom")) {
          updateValues(e);
          var aData = spineObj.geoDrawObjHelp.getData().visible;
          var data = labelManager(aData);
          spineObj.geoDrawObjHelp.setData({
            visible: data
          });
        } else {
          spineObj.graphComp.setPanValues(e.data);
        }

        if (e.value === "zoomReset") {
          setGraphSize(true);
          spineObj.zoomControls.setValue(spineObj.zoomControls.getValue().resetVal + modelObj.zoomOffsetValue);
        }

        break;

      case "centerAngleInput":
        // Used enter to Submit instead of focus out.
        // if (e.type === 'focusOut') {
        //   const status = modelObj.currentQuestion.points.length === +spineObj.centerAngleInput.getValue();
        //   spineObj.centerAngleInput.setState(status ? 'correct' : 'incorrect');
        //   if (status) {
        //     spineObj.centerAngleInput.disable();
        //     onGraphEvent({
        //       id: "geoDrawObjHelp",
        //       type: "geoInteraction",
        //       data: { type: 'centerAngleInput', correct: status },
        //       mode: "auto",
        //     });
        //   }
        //   break;
        // }
        break;

      case "submitBtn":
        //Calling setAngle Size Function with data taken from user
        var angleSizeData = modelObj.angleSizeData;
        angleSizeData.degree = +spineObj.angleInput.getValue();
        angleSizeData.clockwise = !Boolean(spineObj.radio.getValue()); // angleSizeData.fillColor = modelObj.finalColor;

        spineObj.geoDrawObjHelp.setAngleSize(angleSizeData);
        renderAnglePanel(false); //Panel is hidden

        break;

      case "geoTools":
        renderAnglePanel(false);
        modelObj.isA11y_visible = !!modelObj.tools[spineObj.geoTools.getSelected()];
        update_a11y_step1_MA(modelObj.isA11y_visible);

        if (modelObj.tools[spineObj.geoTools.getSelected()]) {
          spineObj.a11y_tool_Label1.setFocus();
        }

        break;
    }

    updateRender();
  }

  function checkAndPlot(e) {
    if (!spineObj.a11y_tool_Input_1.getVisble()) {
      return;
    } else if (!e.enterPressed) {
      return;
    }

    var type = modelObj.currentQuestion.type;
    var tool = spineObj.geoTools.getSelected();
    var data = getDataByStep(type, modelObj.currentStep - 1, spineObj.geoDrawObjHelp, false);
    var a11y_firstInput = spineObj.a11y_tool_Input_1.getVisble() ? spineObj.a11y_tool_Input_1.getValue() : "";
    var a11y_secondInput = spineObj.a11y_tool_Input_2.getVisble() ? spineObj.a11y_tool_Input_2.getValue() : "";
    var a11y_thirdInput = spineObj.a11y_tool_Input_3.getVisble() ? spineObj.a11y_tool_Input_3.getValue() : "";

    if (!spineObj.a11y_tool_Input_1.getVisble() && !spineObj.a11y_tool_Input_2.getVisble() && !spineObj.a11y_tool_Input_3.getVisble() || spineObj.a11y_tool_Input_1.getVisble() && a11y_firstInput == "" || spineObj.a11y_tool_Input_2.getVisble() && a11y_secondInput == "" || spineObj.a11y_tool_Input_3.getVisble() && a11y_thirdInput == "") {
      return false;
    } else {
      var _obj2 = {
        type: tool
      };
      var shapes = spineObj.geoDrawObjHelp.getData().visible;

      if (tool == "angleSize" && a11y_firstInput && a11y_secondInput) {
        var start = shapes.find(function (elem) {
          return elem.type === "point" && elem.label.toLowerCase() === a11y_firstInput.toLowerCase();
        }) || null;
        var end = shapes.find(function (elem) {
          return elem.type === "point" && elem.label.toLowerCase() === a11y_secondInput.toLowerCase();
        }) || null;

        if (start && end) {
          _obj2 = {
            id: "geoDrawObjHelp",
            type: "angleSize",
            visible: true,
            data: {
              type: "angleSize",
              step: modelObj.currentStep,
              visible: true,
              degree: 0,
              clockwise: true,
              x: start === null || start === void 0 ? void 0 : start.x,
              y: start === null || start === void 0 ? void 0 : start.y,
              mode: "point",
              isSelected: false,
              xTo: end === null || end === void 0 ? void 0 : end.x,
              yTo: end === null || end === void 0 ? void 0 : end.y
            }
          };
          spineObj.a11y_tool_Input_1.setValue("");
          spineObj.a11y_tool_Input_2.setValue("");
          spineObj.a11y_tool_Input_3.setValue("");
          onGraphEvent(_obj2);
          modelObj.isA11y_visible = false;
          update_a11y_step1_MA(modelObj.isA11y_visible);
          spineObj.angleLabel.setFocus();
        } else {
          spineObj.wrongAlertBox.show(true);
          clearInputs();
        }
      } else {
        fullShapeReady({
          _obj: _obj2,
          shapes: shapes,
          type: type,
          tool: tool,
          data: data,
          a11y_firstInput: a11y_firstInput,
          a11y_secondInput: a11y_secondInput,
          a11y_thirdInput: a11y_thirdInput
        });
      }
    }
  }

  function clearInputs() {
    spineObj.a11y_tool_Input_1.setValue("");
    spineObj.a11y_tool_Input_2.setValue("");
    spineObj.a11y_tool_Input_3.setValue("");
    modelObj.isA11y_visible = false;
    update_a11y_step1_MA(modelObj.isA11y_visible);
  }

  function fullShapeReady(_ref2) {
    var _obj = _ref2._obj,
        shapes = _ref2.shapes,
        type = _ref2.type,
        tool = _ref2.tool,
        data = _ref2.data,
        a11y_firstInput = _ref2.a11y_firstInput,
        a11y_secondInput = _ref2.a11y_secondInput,
        a11y_thirdInput = _ref2.a11y_thirdInput;
    var addData = null;
    var firstPoint, secondPoint, thirdPoint;
    data.forEach(function (shape) {
      if (shape.type === tool || shape.type === "circle" && tool === "compass") {
        var accepted = false;

        switch (tool) {
          case "point":
            if (a11y_firstInput && shape.label.toLowerCase() === a11y_firstInput.toLowerCase()) {
              accepted = true;
            }

            break;

          case "ray":
          case "segment":
            if (a11y_firstInput && a11y_secondInput) {
              firstPoint = shapes.find(function (elem) {
                return elem.type === "point" && shape.x === elem.x && shape.y === elem.y;
              });
              secondPoint = shapes.find(function (elem) {
                return elem.type === "point" && shape.xTo === elem.x && shape.yTo === elem.y;
              });

              if (firstPoint && secondPoint && firstPoint.label.toLowerCase() === a11y_firstInput.toLowerCase() && secondPoint.label.toLowerCase() === a11y_secondInput.toLowerCase()) {
                accepted = true;
              }

              if (tool === "segment" && firstPoint && secondPoint && firstPoint.label.toLowerCase() === a11y_secondInput.toLowerCase() && secondPoint.label.toLowerCase() === a11y_firstInput.toLowerCase()) {
                accepted = true;
              }
            }

            break;

          case "circle":
            if (a11y_firstInput) {
              firstPoint = shapes.find(function (elem) {
                return elem.type === "point" && elem.label.toLowerCase() === a11y_firstInput.toLowerCase();
              });
              secondPoint = shapes.find(function (elem) {
                return elem.type === "point" && elem.label.toLowerCase() === a11y_secondInput.toLowerCase();
              });

              if (firstPoint.x === shape.x && firstPoint.y === shape.y && spineObj.LabComClass.Maths.approximatelyEqual(spineObj.LabComClass.Maths.getDistance(firstPoint, secondPoint), shape.r)) {
                accepted = true;
              }
            }

            break;

          case "compass":
            if (a11y_firstInput && a11y_secondInput && a11y_thirdInput) {
              firstPoint = shapes.find(function (elem) {
                return elem.type === "point" && elem.label.toLowerCase() === a11y_firstInput.toLowerCase();
              });
              secondPoint = shapes.find(function (elem) {
                return elem.type === "point" && elem.label.toLowerCase() === a11y_secondInput.toLowerCase();
              });
              thirdPoint = shapes.find(function (elem) {
                return elem.type === "point" && elem.label.toLowerCase() === a11y_thirdInput.toLowerCase();
              });

              if (thirdPoint.x === shape.x && thirdPoint.y === shape.y && spineObj.LabComClass.Maths.approximatelyEqual(spineObj.LabComClass.Maths.getDistance(firstPoint, secondPoint), shape.r)) {
                accepted = true;
              }
            }

            break;
        }

        if (accepted) {
          addData = shape;
        }
      }
    });

    if (addData) {
      plotShapes({
        data: addData,
        geoDrawObjAnsInst: null,
        _geoDrawObj: spineObj.geoDrawObjHelp,
        startChecking: true
      });
    } else {
      spineObj.wrongAlertBox.show(true);
    }

    clearInputs();

    if (modelObj.currentStep === modelObj.totalSteps && tool === "segment") {
      modelObj.isA11y_visible = true;

      if (addData) {
        spineObj.a11y_tool_Label1.setFocus();
      }
    }

    update_a11y_step1_MA(modelObj.isA11y_visible);
  }

  function updateValues(e) {
    spineObj.graphComp.setZoom(e);
  }

  function setGraphSize() {
    var currentGraphSize = modelObj.graphSize;
    spineObj.graphComp.setParams(currentGraphSize);
    var _modelObj$currentQues4 = modelObj.currentQuestion,
        centerPoint = _modelObj$currentQues4.centerPoint,
        point = _modelObj$currentQues4.point,
        type = _modelObj$currentQues4.type;
    var graphPoint = type === 1 ? centerPoint : {
      x: (centerPoint.x + point.x) / 2,
      y: (centerPoint.y + point.y) / 2
    };
    spineObj.graphComp.setPointToScreenCenter(graphPoint.x, graphPoint.y, 800, 350);
  }

  function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }

    return array;
  }

  function step1() {
    var drawNewShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var _modelObj$currentQues5 = modelObj.currentQuestion,
        centerPoint = _modelObj$currentQues5.centerPoint,
        point = _modelObj$currentQues5.point;

    if (drawNewShape) {
      spineObj.centerAngleInput.setState("correct");
      spineObj.centerAngleInput.setValue(modelObj.currentQuestion.points.length);
      spineObj.centerAngleInput.disable();
      onKeyUp({
        id: "centerAngleInput"
      });
    }

    return [{
      x: centerPoint.x,
      y: centerPoint.y,
      xTo: point.x,
      yTo: point.y,
      type: "ray",
      startLabel: "M",
      endLabel: "A"
    }, {
      correct: true,
      type: "centerAngleInput"
    }];
  }

  function step2(_ref3) {
    var _shapes$find$clockwis, _shapes$find;

    var _geoDrawObj = _ref3._geoDrawObj,
        prevPoint = _ref3.prevPoint,
        point = _ref3.point,
        _ref3$labelIndex = _ref3.labelIndex,
        labelIndex = _ref3$labelIndex === void 0 ? 1 : _ref3$labelIndex,
        _ref3$drawNewShape = _ref3.drawNewShape,
        drawNewShape = _ref3$drawNewShape === void 0 ? true : _ref3$drawNewShape;
    var _modelObj$currentQues6 = modelObj.currentQuestion,
        centerPoint = _modelObj$currentQues6.centerPoint,
        points = _modelObj$currentQues6.points;
    var shapes = spineObj.geoDrawObjHelp.getData().visible;
    var clockwise = (_shapes$find$clockwis = (_shapes$find = shapes.find(function (shape) {
      return shape.type === "angleSize";
    })) === null || _shapes$find === void 0 ? void 0 : _shapes$find.clockwise) !== null && _shapes$find$clockwis !== void 0 ? _shapes$find$clockwis : true;
    point = point ? point : clockwise ? points[0] : points[points.length - 2];
    var label = modelObj.pointLabels[labelIndex];

    var angleSizeData = _geoDrawObj.plotAngleSize({
      x: centerPoint.x,
      y: centerPoint.y,
      xTo: prevPoint.x,
      yTo: prevPoint.y,
      degree: parseInt(spineObj.centerAngleRHS.getValue()),
      clockwise: clockwise
    }, drawNewShape);

    angleSizeData.angleSize.ignoreAddingShape = true;
    angleSizeData.ray.ignoreAddingShape = true;
    return [angleSizeData.angleSize, angleSizeData.ray, {
      x: point.x,
      y: point.y,
      label: label,
      type: "point"
    }];
  }

  function type1Step3(_geoDrawObj, drawNewShape) {
    var data = [];
    var points = modelObj.currentQuestion.points;

    var clockwise = _geoDrawObj.getData().visible.find(function (shape) {
      return shape.type === "angleSize";
    }).clockwise;

    points = _toConsumableArray(points);

    if (!clockwise) {
      points.reverse();
      points.shift();
    }

    var startIndex = clockwise ? 1 : 0;
    var endIndex = points.length - startIndex * 1;

    for (var i = 1; i < endIndex; i++) {
      var prevIndex = i - 1;
      var prevPoint = points[prevIndex];
      var labelIndex = i + 1;
      data = [].concat(_toConsumableArray(data), _toConsumableArray(step2({
        _geoDrawObj: _geoDrawObj,
        prevPoint: prevPoint,
        point: points[i],
        labelIndex: labelIndex,
        drawNewShape: drawNewShape
      })));
    }

    return data;
  }

  function joinPoints(source) {
    var totalPoint = source ? source : [modelObj.currentQuestion.point].concat(_toConsumableArray(modelObj.currentQuestion.points));
    return totalPoint.map(function (point, i) {
      i = i + 1;

      if (i > totalPoint.length - 1) {
        i = 0;
      }

      return {
        x: point.x,
        y: point.y,
        xTo: totalPoint[i].x,
        yTo: totalPoint[i].y,
        type: "segment"
      };
    });
  }

  function storeData() {
    var data = {
      visited: true,
      solved: modelObj.solved,
      totalCorrectShapes: modelObj.totalCorrectShapes
    };
    modelObj.taskData.push(data);
    var taskStatus = [];

    for (var i = 0; i < modelObj.taskData.length; i++) {
      taskStatus.push(JSON.parse(JSON.stringify(modelObj.taskData[i])));
    }

    spineObj.timeLine.setTaskStatus(taskStatus);
  }
}