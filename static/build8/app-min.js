/* eslint-disable object-shorthand */
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
      || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function () { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }
  if(!Array.prototype.findIndex) {
    'use strict';

    Array.prototype.findIndex = Array.prototype.findIndex || function(callback) {
      if (this === null) {
        throw new TypeError('Array.prototype.findIndex called on null or undefined');
      } else if (typeof callback !== 'function') {
        throw new TypeError('callback must be a function');
      }
      var list = Object(this);
      // Makes sures is always has an positive integer as length.
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      for (var i = 0; i < length; i++) {
        if ( callback.call(thisArg, list[i], i, list) ) {
          return i;
        }
      }
      return -1;
    };
  }
  if(!Array.prototype.findLastIndex) {
    'use strict';

    Array.prototype.findLastIndex = Array.prototype.findLastIndex || function(callback) {
      if (this === null) {
        throw new TypeError('Array.prototype.findIndex called on null or undefined');
      } else if (typeof callback !== 'function') {
        throw new TypeError('callback must be a function');
      }
      var list = Object(this);
      // Makes sures is always has an positive integer as length.
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      for (var i = length - 1; i > 0; i--) {
        if ( callback.call(thisArg, list[i], i, list) ) {
          return i;
        }
      }
      return -1;
    };
  }
  if (!Math.trunc) {
    Math.trunc = function (v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
  }
  if (!Array.prototype.keys) {
    Array.prototype.keys = function() {
        var k, a = [], nextIndex = 0, ary = this;
        k = ary.length;
        while (k > 0) a[--k] = k;
        a.next = function(){
            return nextIndex < ary.length ?
                {value: nextIndex++, done: false} :
                {done: true};
        };
    return a;
    };
  }
 
  if (!Array.prototype.values) {
    Array.prototype.values = function() {
      var k, a = [], nextIndex = 0, ary = this;
      k = ary.length;
      while (k > 0) a[--k] = ary[k];
      a.next = function(){
          return nextIndex < ary.length ?
              {value: ary[nextIndex++], done: false} :
              {done: true};
      };
    return a;
    };
  }
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    };
  }
  if (!Object.keys) {
    Object.keys = function(obj) {
      var keys = [];
  
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          keys.push(i);
        }
      }
  
      return keys;
    };
  }
  if (!Object.values) {
    Object.prototype.values = function(object) {
      var values = [];
      var keys = Object.keys(object);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        values.push(object[k]);
      }
      return values;
    }
  }
  if (!String.prototype.replaceAll) {
    String.prototype.replaceAll = function(str, newStr){
  
      // If a regex pattern
      if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {
        return this.replace(str, newStr);
      }
  
      // If a string
      return this.replace(new RegExp(str, 'g'), newStr);
  
    };
  }
  if (!Math.hypot) 
  {
    Math.hypot = function () {
    var max = 0;
    var s = 0;
    var containsInfinity = false;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = Math.abs(Number(arguments[i]));
      if (arg === Infinity)
        containsInfinity = true
      if (arg > max) {
        s *= (max / arg) * (max / arg);
        max = arg;
      }
      s += arg === 0 && max === 0 ? 0 : (arg / max) * (arg / max);
    }
    return containsInfinity ? Infinity : (max === 1 / 0 ? 1 / 0 : max * Math.sqrt(s));
    };
  }


  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      value: function(predicate) {
        // 1. Let O be ? ToObject(this value).
        if (this == null) {
          throw TypeError('"this" is null or not defined');
        }

        var o = Object(this);

        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = o.length >>> 0;

        // 3. If IsCallable(predicate) is false, throw a TypeError exception.
        if (typeof predicate !== 'function') {
          throw TypeError('predicate must be a function');
        }

        // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
        var thisArg = arguments[1];

        // 5. Let k be 0.
        var k = 0;

        // 6. Repeat, while k < len
        while (k < len) {
          // a. Let Pk be ! ToString(k).
          // b. Let kValue be ? Get(O, Pk).
          // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
          // d. If testResult is true, return kValue.
          var kValue = o[k];
          if (predicate.call(thisArg, kValue, k, o)) {
            return kValue;
          }
          // e. Increase k by 1.
          k++;
        }

        // 7. Return undefined.
        return undefined;
      },
      configurable: true,
      writable: true
    });
  }
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (search instanceof RegExp) {
        throw TypeError('first argument must not be a RegExp');
      }
      if (start === undefined) { start = 0; }
      return this.indexOf(search, start) !== -1;
    };
  }
  if (!Array.prototype.includes) {
    Object.defineProperty(Array.prototype, 'includes', {
      enumerable: false,
      value: function (obj) {
        var newArr = this.filter(function (el) {
          return el === obj;
        });
        return newArr.length > 0;
      }
    });
  }
}());

/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function A(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||"-"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+" "+(a.f+"00")+" 300px "+I(a.c)}function I(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function J(a){return a.a+a.f}function H(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);K(a,"loading")}function L(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}K(a,"inactive")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function N(a){u(a.c,"body",a.a)}function O(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+I(a.c)+";"+("font-style:"+H(a)+";font-weight:"+(a.f+"00")+";")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+",serif",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+",sans-serif",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G("serif",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G("sans-serif",J(this.a));a=
O(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:"serif",C:"sans-serif"},S=null;function T(){if(null===S){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.m.a.offsetWidth;this.A=q();U(this)};
function la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,J(a).toString(),"active")],[b.a.c("wf",a.c,J(a).toString(),"loading"),b.a.c("wf",a.c,J(a).toString(),"inactive")]);K(b,"fontactive",a);this.m=!0;na(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,J(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,J(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,J(a).toString(),"inactive"));w(b.f,d,e)}K(b,"fontinactive",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),K(a,"active")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};
function qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c("wf",x.c,J(x).toString(),"loading")]);K(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);
X=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}
ra.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||"https://fast.fonts.net/jsapi")+"/"+d+".js"+(e?"?v="+e:""),function(e){e?a([]):(f["__MonotypeConfiguration__"+
d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||""}var ua="https://fonts.googleapis.com/css";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function wa(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}
var za={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Aa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ba={i:"i",italic:"i",n:"n",normal:"n"},
Ca=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(","),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k="";else{k=n[2];k=null==k||""==k?"n":Ba[k];n=n[1];if(null==n||""==n)n="4";else var r=Aa[n],n=r?r:isNaN(n)?"4":n.substr(0,1);k=[k,n].join("")}}else k="";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},A(this.c,(this.f.api||"https://f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());

"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// ////////////////////////////////////////////////////////////////////////////////////
// Developed By: Mitr Learning & Media
// Name: DemoActClass
// Description: The View Class Controls the Lab by interacting with BrainClass and updates the lab accordingly
// Date Created: 08/04/2019
// Date Modified: 03/06/2019
// Version: 1.0
// canvas arrow : http://www.dbp-consulting.com/tutorials/canvas/CanvasArrow.html
// ////////////////////////////////////////////////////////////////////////////////////
// Please read below info for more info about variables.
//= ================================

/*
--------- Quadrant Info ---------------
    Quadrant 4 |  Quadrant 1
      --------------------------
      Quadrant 3 |  Quadrant 2
      ---------------------------------------

    While defining qudrants. Pass array. For ex. If you want to show only quadrant 1 then pass string as.
    quadrant:'1'
    quadrant:'2'
    quadrant:'3'
    quadrant:'4'
    If you want to display qudrants 1 and 2 then pass below code.
    for qudrants 1 and 2 => '12' or '21'
    for qudrants 2 and 3 => '23' or '32'
    for qudrants 3 and 4 => '34' or '43'
    for qudrants 1 and 4 => '14' or '41'

    for all pass => '1234';

    ----------------------------------------------------

    How to define Graph Center --------

    // ====== possible values ===============
    graphCenter = 'center';
    graphCenter = 'center-left';
    graphCenter = 'center-right';
    graphCenter = 'left-top';
    graphCenter = 'left-bottom';
    graphCenter = 'right-top';
    graphCenter = 'right-bottom';
    //=======================================

*/
// ////////////////////////////////////////////////////////////////////////////////////
function graphPluginAdvClass(_obj) {
  var modelObj = {
    x: 0,
    y: 0,
    width: 1280,
    height: 720,
    imageList: [],
    fontsize: 16,
    lineWidth: 1,
    minX: -10,
    minY: -10,
    maxX: 10,
    maxY: 10,
    unitsPerTick: 5,
    XunitsPerTick: 5,
    XunitsPerTickToFixed: 0,
    YunitsPerTick: 5,
    YunitsPerTickToFixed: 0,
    unitsPerGrid: 5,
    XunitsPerGrid: 5,
    YunitsPerGrid: 5,
    panX: true,
    panY: true,
    gridLightColor: '#cde6f1',
    gridDarkColor: '#98c8db',
    // gridLightColor: '#0000ff',
    // gridDarkColor: '#ff0000',
    axisColor: '#000',
    numberFontSize: 16,
    labelFontSize: 18,
    tickSize: 10,
    showQuadrants: '1234',
    graphCenter: 'center',
    margin: 0,
    topMargin: 1,
    rightMargin: 1,
    bottomMargin: 1,
    leftMargin: 1,
    gridMargin: [0, 0, 0, 0],
    // L R T B
    numbersMinX: null,
    numbersMaxX: null,
    numbersMinY: null,
    numbersMaxY: null,
    numTextFontSize: 12,
    xLabelText: 'X',
    xLabelTextOffsetX: 15,
    xLabelTextOffsetY: 11,
    yLabelText: 'Y',
    yLabelTextOffsetX: 15,
    yLabelTextOffsetY: 18,
    lineThickness: 1,
    lineColor: '#ff0000',
    pointColor: '#ff0000',
    borderColor: 'rgba(73,124,190,1)',
    bgColor: 'rgba(255,255,255,1)',
    borderThickness: 1,
    majorThickness: 1,
    cacheGraph: true,
    showPointText: true,
    showAxisLabels: true,
    limitNumberDisplay: 'true',
    visible: true,
    pointRadius: 5,
    pixelValuePerX: 35,
    pixelValuePerY: 35,
    alignXLine: 'center',
    // left center right
    alignYLine: 'center',
    // top center bottom,
    regX: null,
    regY: null,
    clickable: false,
    showGrid: true,
    sections: {
      graph: {
        index: 0,
        visible: true,
        // required for cache graph drawing
        horizontalGrid: true,
        verticalGrid: true
      },
      axis: {
        index: 1,
        visible: true,
        origin: {
          visible: true
        },
        xAxis: {
          visible: true,
          ticks: true,
          arrowHead: true,
          numbers: true,
          minPanInPixel: null,
          maxPanInPixel: null,
          restrictPadding: 35,
          restrictToBoundry: true,
          values: [] // provide an array of text id from labText.json. default is number

        },
        yAxis: {
          visible: true,
          ticks: true,
          arrowHead: true,
          numbers: true,
          minPanInPixel: null,
          maxPanInPixel: null,
          restrictPadding: 35,
          restrictToBoundry: true,
          values: [] // provide an array of text id from labText.json default is number

        }
      },
      shape: {
        index: 2,
        visible: true
      },
      line: {
        index: 3,
        visible: true
      },
      point: {
        index: 4,
        visible: true
      }
    },
    minPanX: -10000000,
    // top left    this values only to restrict dragging area
    maxPanX: 10000000,
    // bottom right
    minPanY: -10000000,
    // top left
    maxPanY: 10000000,
    // bottom right,
    decimalPoint: 2,
    centerPoint: null,
    arrowOnly: false
  }; // context.lineWidth = modelObj.borderThickness;
  // context.strokeStyle = modelObj.borderColor;
  // ====================== Local Variables =====================================

  var brainObj = {};
  var imgObj;
  var resetObj;
  var events = {};
  var localObj = {};
  var context;
  var rangeX;
  var rangeY;
  var unitX;
  var unitY;
  var centerX;
  var centerY;
  var iteration;
  var scaleX;
  var scaleY;
  var vertex_X;
  var vertex_Y;
  var xShift = 0;
  var yShift = 0;
  var trangleWidth = 5;
  var trangleHeight = 10;
  var graphCanvas = document.createElement('canvas');
  var graphContext = graphCanvas.getContext('2d');
  graphCanvas.style.position = 'absolute';
  var axisCanvas = document.createElement('canvas');
  var axisContext = axisCanvas.getContext('2d');
  axisCanvas.style.position = 'absolute'; // document.body.appendChild(graphCanvas);

  var lineCanvas = document.createElement('canvas');
  var lineContext = lineCanvas.getContext('2d');
  lineCanvas.style.position = 'absolute'; // document.body.appendChild(lineCanvas);

  var pointCanvas = document.createElement('canvas');
  var pointContext = pointCanvas.getContext('2d');
  pointCanvas.style.position = 'absolute'; // document.body.appendChild(pointCanvas);

  var shapeCanvas = document.createElement('canvas');
  var shapeContext = shapeCanvas.getContext('2d');
  shapeCanvas.style.position = 'absolute'; // document.body.appendChild(shapeCanvas);

  var pointsArr = [];
  var coeffObj;
  var _counter = 0;
  var mouseDown = false;

  var _mouseDownPageX;

  var _mouseDownPageY;

  var renderGraph = false;
  var arrow1 = true;
  var arrow2 = true;
  var arrow3 = true;
  var arrow4 = true;
  var graphLineArr = [];
  var graphPointArr = [];
  var shapePointArr = [];

  var _this = this;

  var originalX;
  var originalY;
  var canvasImages; //= ==================================================================
  // --------------------

  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === 'object' && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === 'object' && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  }

  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass(); // --------------------

  if (modelObj.imageList.length > 0) {
    modelObj.LabComClass.requestLocalImage(modelObj.imageList, onImageLoaded);
  } else {
    onImageLoaded({});
  } // =================================================
  // PUBLIC SECTION
  // =================================================

  /*
     * This function is a initialization function and used to initialize the values.
     * @param _obj is of type object. It has all the data from the brainObj.
     */


  this.init = function () {
    correctModelObj(); //= =======================================
    // modelObj.height = modelObj.height

    /*
    resetObj = JSON.parse(JSON.stringify(brainObj));
    onActValueUpdate();
    addEvents();
    */

    originalX = modelObj.x;
    originalY = modelObj.y;

    if (modelObj.cacheGraph) {
      modelObj.x = 0;
      modelObj.y = 0;
    }

    context = modelObj.context;
    graphCanvas.width = modelObj.width;
    graphCanvas.height = modelObj.height;
    axisCanvas.width = modelObj.width;
    axisCanvas.height = modelObj.height;
    lineCanvas.width = modelObj.width;
    lineCanvas.height = modelObj.height;
    pointCanvas.width = modelObj.width;
    pointCanvas.height = modelObj.height;
    shapeCanvas.width = modelObj.width;
    shapeCanvas.height = modelObj.height;
    canvasImages = [{
      img: graphCanvas,
      sectionId: 'graph',
      changeImageSmoothing: false
    }, {
      img: axisCanvas,
      sectionId: 'axis',
      changeImageSmoothing: false
    }, {
      img: lineCanvas,
      sectionId: 'line',
      changeImageSmoothing: false
    }, {
      img: pointCanvas,
      sectionId: 'point',
      changeImageSmoothing: false
    }, {
      img: shapeCanvas,
      sectionId: 'shape',
      changeImageSmoothing: false
    }];
    updateZoomValues();
    addEvents();
  }; // =================================================


  function correctModelObj() {
    // =========== Convert +ve & -ve Range to numbers ==================
    modelObj.minX = Number(modelObj.minX);
    modelObj.minY = Number(modelObj.minY);
    modelObj.maxX = Number(modelObj.maxX);
    modelObj.maxY = Number(modelObj.maxY); //= ==================================================

    modelObj.numbersMinX = Number(modelObj.numbersMinX);
    modelObj.numbersMaxX = Number(modelObj.numbersMaxX);
    modelObj.numbersMinY = Number(modelObj.numbersMinY);
    modelObj.numbersMaxY = Number(modelObj.numbersMaxY); //= ==================================================

    modelObj.xLabelTextOffsetX = Number(modelObj.xLabelTextOffsetX);
    modelObj.xLabelTextOffsetY = Number(modelObj.xLabelTextOffsetY);
    modelObj.yLabelTextOffsetX = Number(modelObj.yLabelTextOffsetX);
    modelObj.yLabelTextOffsetY = Number(modelObj.yLabelTextOffsetY); //= ==================================================
  }

  this.getGraphMinMax = function () {
    var _screenMin = _this.getPointByPixel(originalX, originalY);

    var _screenMax = _this.getPointByPixel(originalX + modelObj.width, originalY + modelObj.height);

    var _screenCenter = _this.getPointByPixel(originalX + modelObj.width / 2, originalY + modelObj.height / 2);

    return {
      min: {
        x: _screenMin.x,
        y: _screenMin.y
      },
      max: {
        x: _screenMax.x,
        y: _screenMax.y
      },
      center: {
        x: _screenCenter.x,
        y: _screenCenter.y
      },
      unit: {
        x: modelObj.unitsPerTick,
        pxValX: modelObj.pixelValuePerX,
        pxValY: modelObj.pixelValuePerX
      }
    };
  };

  this.getScreenData = function () {
    var data = {
      x: originalX,
      y: originalY,
      width: modelObj.width,
      height: modelObj.height,
      screen: {
        x: originalX,
        y: originalY,
        w: modelObj.width,
        h: modelObj.height
      },
      originX: _this.getPixelByPoint(0, 0).x,
      originY: _this.getPixelByPoint(0, 0).y,
      centerX: centerX,
      centerY: centerY,
      unitX: unitX,
      unitY: unitY,
      XunitsPerGrid: modelObj.XunitsPerGrid,
      YunitsPerGrid: modelObj.YunitsPerGrid,
      showQuadrants: modelObj.showQuadrants
    };

    if (modelObj.showQuadrants === '1') {
      data.x = originalX + restrictAxisX(axisContext);
      data.width = modelObj.width - (data.x - originalX);
      data.height = restrictAxisY();
    }

    return data;
  };

  this.getPointByPixel = function (_x, _y) {
    var pointX;
    var pointY;
    pointX = (_x - originalX - centerX) / unitX;
    pointY = -1 * (_y - originalY - centerY) / unitY;
    return {
      x: pointX,
      y: pointY
    };
  };

  this.getPixelByPoint = function (valueX, valueY) {
    var pointX;
    var pointY;
    pointX = valueX * unitX + centerX + originalX;
    pointY = valueY * unitY / -1 + centerY + originalY;
    return {
      x: pointX,
      y: pointY
    };
  };

  this.setPointToScreenCenter = function (valueX, valueY) {
    var pixelX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1280 / 2;
    var pixelY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 720 / 2;
    updateGraphPos(valueX, valueY, pixelX, pixelY);
    validateValues();
  };

  function updateGraphPos(valueX, valueY, pixelX, pixelY) {
    var point = _this.getPixelByPoint(valueX, valueY);

    var screenCenter = {
      x: pixelX,
      y: pixelY
    };

    var origin = _this.getPixelByPoint(0, 0);

    var diff = {
      x: point.x - screenCenter.x,
      y: point.y - screenCenter.y
    };
    modelObj.regX = origin.x - diff.x - originalX;
    modelObj.regY = origin.y - diff.y - originalY;
    centerX = modelObj.regX;
    centerY = modelObj.regY;
  }

  this.getPointUnitByPixelUnit = function (_pixelUnit) {
    return _pixelUnit / unitX;
  };

  this.getPixelUnitByPointUnit = function (_pointUnit) {
    return _pointUnit * unitX;
  };

  this.graphLines = function (_obj) {
    if (_obj.axis !== undefined) {
      modelObj.sections.axis.visible = _obj.axis;
    }

    if (_obj.grid !== undefined) {
      modelObj.sections.graph.visible = _obj.grid;
    }
  };

  this.setZoom = function (_obj) {
    // modelObj.centerPoint = _this.getPointByPixel(originalX + modelObj.width / 2, originalY + modelObj.height / 2);
    if (_obj.value === 'zoomReset') {
      _this.setParams({
        regX: '',
        regY: ''
      });
    }

    var currentZoomData = _obj.data;
    modelObj.pixelValuePerX = currentZoomData.pixelQube;
    modelObj.pixelValuePerY = currentZoomData.pixelQube; // eslint-disable-next-line no-multi-assign

    modelObj.unitsPerTick = modelObj.XunitsPerTick = modelObj.YunitsPerTick = currentZoomData.tick;
    modelObj.XunitsPerTickToFixed = currentZoomData.toFixed;
    modelObj.YunitsPerTickToFixed = currentZoomData.toFixed;
    modelObj.unitsPerGrid = modelObj.unitsPerTick / 5;
    modelObj.XunitsPerGrid = modelObj.XunitsPerTick / 5;
    modelObj.YunitsPerGrid = modelObj.YunitsPerTick / 5;
    validateValues(true);
  };

  this.setParams = function (_obj) {
    var keys = ['x', 'y', 'width', 'height', 'unitsPerTick', 'XunitsPerTick', 'YunitsPerTick', 'unitsPerGrid', 'XunitsPerGrid', 'YunitsPerGrid', 'panX', 'panY', 'pixelValuePerX', 'pixelValuePerY', 'regX', 'regY', 'clickable', 'sections', 'minPanX', 'maxPanX', 'minPanY', 'maxPanY', 'decimalPoint'];
    updateValues.apply(void 0, [_obj].concat(keys));
    validateValues(false);
  };

  function updateValues(_data) {
    var temp = {};
    var needToInitialize = false;

    for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      keys[_key - 1] = arguments[_key];
    }

    keys.forEach(function (i) {
      if (_data.hasOwnProperty(i)) {
        temp[i] = _data[i];

        if (i === 'x' || i === 'y' || i === 'width' || i === 'height') {
          needToInitialize = true;
        }
      }
    });
    setData(modelObj, temp);

    if (needToInitialize) {
      _this.init();
    }

    drawGraph();
  }

  function validateValues(_flag) {
    checkPanRestrictions();
    var dataSetters = {
      restrictions: {
        tickRange: {
          min: 0.000000001,
          max: 1000000,
          toFixed: 10
        },
        gridRange: {
          min: 0.000000001,
          max: 1000000,
          toFixed: 10
        }
      },
      property: {
        unitsPerTick: 'tickRange',
        XunitsPerTick: 'tickRange',
        YunitsPerTick: 'tickRange',
        unitsPerGrid: 'gridRange',
        XunitsPerGrid: 'gridRange',
        YunitsPerGrid: 'gridRange'
      }
    };
    Object.keys(dataSetters.property).forEach(function (i) {
      if (modelObj[i] < dataSetters.restrictions[dataSetters.property[i]].min) {
        modelObj[i] = dataSetters.restrictions[dataSetters.property[i]].min;
      }

      if (modelObj[i] > dataSetters.restrictions[dataSetters.property[i]].max) {
        modelObj[i] = dataSetters.restrictions[dataSetters.property[i]].max;
      }

      if (dataSetters.restrictions[dataSetters.property[i]].toFixed >= 0 && modelObj[dataSetters.property[i]] !== '') {
        modelObj[i] = Number(Number(modelObj[i]).toFixed(dataSetters.restrictions[dataSetters.property[i]].toFixed));
      }
    });
    updateZoomValues(_flag);
  }

  this.updateBarChart = function (_obj) {
    for (var i = 0; i < _obj.length; i++) {
      modelObj.bardata[i].value = _obj[i].value;
    }

    drawGraph();
  };

  function updateZoomValues(_flag) {
    rangeX = modelObj.maxX - modelObj.minX;
    rangeY = modelObj.maxY - modelObj.minY;
    unitX = modelObj.pixelValuePerX;
    unitY = modelObj.pixelValuePerY;

    if (modelObj.regX === '') {
      switch (modelObj.alignXLine) {
        case 'left':
          modelObj.regX = modelObj.x + modelObj.leftMargin + unitX;
          break;

        case 'right':
          modelObj.regX = modelObj.x + modelObj.width - modelObj.rightMargin - unitX;
          break;

        case 'center':
          modelObj.regX = modelObj.x + modelObj.width / 2;
          break;

        default:
          modelObj.regX = modelObj.x + modelObj.leftMargin + unitX;
      }

      switch (modelObj.alignYLine) {
        case 'top':
          modelObj.regY = modelObj.y + modelObj.topMargin + unitY;
          break;

        case 'bottom':
          modelObj.regY = modelObj.y + modelObj.height - modelObj.bottomMargin - unitY;

          if (modelObj.showQuadrants === '1') {
            if (modelObj.sections.axis.yAxis.maxPanInPixel !== null) {
              modelObj.regY = modelObj.height - modelObj.sections.axis.yAxis.maxPanInPixel;
            }
          }

          break;

        case 'center':
          modelObj.regY = modelObj.y + modelObj.height / 2;
          break;

        default:
          modelObj.regY = modelObj.y + modelObj.topMargin + unitY;
      }
    }

    centerX = modelObj.regX;
    centerY = modelObj.regY;
    restrictAxisX(axisContext); // if (_flag && modelObj.showQuadrants !== '1') {
    // updateGraphPos(modelObj.centerPoint.x, modelObj.centerPoint.y, originalX + modelObj.width / 2, originalY + modelObj.height / 2);
    // }

    if (typeof events.scaleUpdate !== 'undefined') {
      events.scaleUpdate({
        type: 'scaleUpdate'
      }, true);
    }

    drawGraph();
  }

  this.enablePan = function (bool) {
    if (bool) {
      modelObj.panX = true;
      modelObj.panY = true;
    } else {
      modelObj.panX = false;
      modelObj.panY = false;
    }

    addEvents();
  }; // =================================================
  // var graphImage;


  function drawGraph() {
    // DRAWING BUG FIXED: 1-6-2020 WHILE DOING POC
    graphContext.clearRect(0, 0, modelObj.width, modelObj.height);
    axisContext.clearRect(0, 0, modelObj.width, modelObj.height);
    lineContext.clearRect(0, 0, modelObj.width, modelObj.height);
    pointContext.clearRect(0, 0, modelObj.width, modelObj.height);
    shapeContext.clearRect(0, 0, modelObj.width, modelObj.height);

    if (modelObj.maxY < 0) {
      centerY = -centerY;
    }

    if (modelObj.minX > 0) {
      centerX = -centerX;
    }

    iteration = (modelObj.maxX - modelObj.minX) / 1000;
    scaleX = (modelObj.width - 2 * modelObj.margin) / rangeX;
    scaleY = (modelObj.height - 2 * modelObj.margin) / rangeY; // ===== Sample Rect =================

    if (modelObj.showQuadrants === '2') {
      centerY += modelObj.margin;
    }

    if (modelObj.showQuadrants === '3') {
      centerX -= modelObj.margin;
      centerY += modelObj.margin;
    }

    if (modelObj.showQuadrants === '4') {
      centerX -= modelObj.margin;
    }

    if (modelObj.graphCenter === 'center-left') {
      centerX = modelObj.x + modelObj.leftMargin;
    }

    if (modelObj.graphCenter === 'center-right') {
      centerX = modelObj.x + modelObj.width - modelObj.rightMargin;
    }

    if (modelObj.graphCenter === 'left-bottom') {
      centerX = modelObj.x + modelObj.leftMargin;
      centerY = modelObj.height + modelObj.y - modelObj.bottomMargin;
    }

    if (modelObj.cacheGraph) {
      drawAllParts({
        graphContext: graphContext,
        axisContext: axisContext,
        lineContext: lineContext,
        pointContext: pointContext,
        shapeContext: shapeContext
      });
    } else {
      drawAllParts({
        graphContext: context,
        axisContext: context,
        lineContext: context,
        pointContext: context,
        shapeContext: context
      });
    } //= ================================

  }

  function drawAllParts(_obj) {
    _obj.graphContext.save();

    clipGraphRegion(_obj.graphContext);
    drawGridLines(_obj.graphContext);

    _obj.graphContext.restore();

    axisContext.save();
    clipGraphRegion(_obj.axisContext); // barchart-pyramid

    if (modelObj.graphType === 'barchart') {
      drawBarChart(_obj.axisContext);
    }

    if (modelObj.graphType === 'barchart-pyramid') {
      drawBarChartPyramid(_obj.axisContext);
    }

    if (modelObj.sections.axis.yAxis.visible) {
      drawYAxis(_obj.axisContext);
    }

    if (modelObj.sections.axis.xAxis.visible) {
      drawXAxis(_obj.axisContext);
    }

    axisContext.restore();

    _this.plotLineArr(_obj.lineContext);

    _this.plotPointArr(_obj.pointContext);

    _this.plotShapeArr(_obj.shapeContext);
  }

  function clipGraphRegion(ctx) {
    ctx.beginPath();
    ctx.rect(modelObj.x, modelObj.y, modelObj.width - 1, modelObj.height);
    ctx.strokeStyle = 'transparent';
    ctx.lineWidth = '1';
    ctx.stroke();
    ctx.closePath();
    ctx.clip();
  } // =================================================

  /*
     * This function is used to Add custom events.
     * @param _evt is of type string. It is the name of the events to be saved.
     * @param _func is of type function. It is the code which is to be exectued on the event fire
     */


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================

  /*
     * This function is used to Update the Lab.
     * @param _obj is of type object. It has all the data from the brainObj.
     */


  this.updateRender = function (_obj) {
    if (_obj) {
      Object.keys(_obj).forEach(function (i) {
        brainObj[i] = _obj[i];
      });
    }

    onActValueUpdate();
  };

  this.updateGraph = function () {
    drawGraph();
  }; // =================================================

  /*
     * This function is used to reset the lab.
     */


  this.resetLab = function () {}; // =================================================
  // =================================================

  /*
     * This function is used to draw the Lab.
     */
  //= =========================


  this.draw = function () {
    if (modelObj.visible) {
      context.save();

      if (modelObj.cacheGraph) {
        drawGraphBorder(originalX, originalY, modelObj.width, modelObj.height);

        for (var i = 0; i < canvasImages.length; i++) {
          for (var j = 0; j < canvasImages.length; j++) {
            if (modelObj.sections[canvasImages[j].sectionId].index === i && modelObj.sections[canvasImages[j].sectionId].visible) {
              context.save();
              context.beginPath();

              if (canvasImages[j].changeImageSmoothing) {
                context.imageSmoothingEnabled = false;
                context.mozImageSmoothingEnabled = false;
                context.webkitImageSmoothingEnabled = false;
                context.msImageSmoothingEnabled = false;
              }

              context.drawImage(canvasImages[j].img, originalX, originalY);
              context.closePath();
              context.restore();
            }
          }
        }
      } else {
        drawGraphBorder(modelObj.x, modelObj.y, modelObj.width, modelObj.height);
        drawGraph();
      }

      context.restore();
    }
  };

  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  };

  this.getVisible = function () {
    return modelObj.visible;
  }; //= =========================


  function drawGraphBorder(x, y, w, h) {
    context.save();
    context.fillStyle = modelObj.bgColor;
    context.fillRect(x, y, w, h);
    context.beginPath();
    context.lineWidth = modelObj.borderThickness;
    context.strokeStyle = modelObj.borderColor;
    context.rect(x, y, w - 1, h);
    context.stroke();
    context.closePath();
    context.restore();
  } //= =========================


  this.getTotalPoints = function () {
    return pointsArr.length;
  };

  this.updateGraphRange = function () {
    xShift += 0.1;
    yShift += 0.1;
    modelObj.minX += xShift;
    modelObj.maxX += xShift;
  };

  this.drawCustomGraph = function () {
    centerY = Math.round(Math.abs(modelObj.maxY / rangeY) * modelObj.height);
    centerX = Math.round(Math.abs(modelObj.minX / rangeX) * modelObj.width);

    if (modelObj.maxY < 0) {
      centerY = -centerY;
    }

    if (modelObj.minX > 0) {
      centerX = -centerX;
    }

    centerX += modelObj.x;
    centerY += modelObj.y;
    iteration = (modelObj.maxX - modelObj.minX) / 1000;
    scaleX = modelObj.width / rangeX;
    scaleY = modelObj.height / rangeY;
    drawGridLines();

    if (modelObj.minX <= 0 && modelObj.maxX >= 0) {
      drawYAxis();
    }

    if (modelObj.maxY >= 0 && modelObj.minY <= 0) {
      drawXAxis();
    }

    context.save();
    context.rect(modelObj.x + 5, modelObj.y + 3, modelObj.width - 8, modelObj.height - 10);
    context.strokeStyle = 'transparent';
    context.stroke();
    context.clip();

    for (var i = 0; i < pointsArr.length; i++) {
      this.plotPoint(pointsArr[i].x, pointsArr[i].y, pointsArr[i].color, pointsArr[i].type, true);
    }

    context.restore(); //= ============================= DRAW EQUATIONS ==================
  };

  function drawEqTriangle(ctx, side, cx, cy, type) {
    // type
    // type 0 ( Y-Upside):
    // type 1 ( X-Rightside) :
    // type 2  ( Y-Downside):
    // type 3 ( X-Leftside) :
    var h = side * (Math.sqrt(3) / 2);
    ctx.strokeStyle = '#000';
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();

    if (type === 0) {
      ctx.moveTo(0, -h / 2);
      ctx.lineTo(-side / 2, h / 2);
      ctx.lineTo(side / 2, h / 2);
      ctx.lineTo(0, -h / 2);
    }

    if (type === 1) {
      ctx.moveTo(0, h / 2);
      ctx.lineTo(-side / 2, -h / 2);
      ctx.lineTo(side / 2, -h / 2);
      ctx.lineTo(0, h / 2);
    }

    if (type === 2) {
      ctx.moveTo(h / 2, 0);
      ctx.lineTo(-h / 2, -side / 2);
      ctx.lineTo(-h / 2, side / 2);
      ctx.lineTo(h / 2, 0);
    }

    if (type === 3) {
      ctx.moveTo(-h / 2, 0);
      ctx.lineTo(side / 2, h / 2);
      ctx.lineTo(side / 2, -h / 2);
      ctx.lineTo(-h / 2, 0);
    }

    ctx.stroke();
    ctx.fill();
    ctx.closePath();
    ctx.restore();
  } //= ==================================================


  function canvas_arrow(context, fromx, fromy, tox, toy) {
    var headlen = 0.3; // length of head in pixels

    var dx = tox - fromx;
    var dy = toy - fromy;
    var angle = Math.atan2(dy, dx);
    context.moveTo(tox, toy);
    context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
    context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
    context.lineTo(tox, toy);
    context.fill();
  } //= ==================================================


  function drawGridLines(ctx) {
    var lineCounter;

    var _drawGridBool; // return;
    // draw tick marks


    var minorLineWidth = 1;
    var xPosIncrement = modelObj.XunitsPerGrid * unitX;
    var xPosIncrementMajor = modelObj.XunitsPerTick * unitX;
    var xPos, unit;
    ctx.font = modelObj.numberFontSize + 'px ' + modelObj.LabComClass.klettFontRegular;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top'; // ctx.strokeStyle = '#b5f3d0';

    ctx.strokeStyle = modelObj.gridLightColor; //= =================================
    // draw left tick marks

    xPos = centerX - xPosIncrement;
    unit = -1 * modelObj.XunitsPerGrid; //= =================================

    var leftVerticalLines = true;

    if (modelObj.showQuadrants === '1') {
      leftVerticalLines = false;
    }

    if (modelObj.sections.graph.verticalGrid) {
      if (leftVerticalLines) {
        lineCounter = 0;

        while (xPos > modelObj.x + modelObj.gridMargin[0]) {
          if (xPos < modelObj.x + modelObj.width - modelObj.gridMargin[1]) {
            lineCounter++;
            _drawGridBool = lineCounter % (modelObj.XunitsPerTick / modelObj.XunitsPerGrid);
            ctx.beginPath();
            ctx.moveTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.gridMargin[2]) + 0.5);
            ctx.lineTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.gridMargin[3]) + 0.5);

            if (_drawGridBool === 0) {
              ctx.lineWidth = modelObj.majorThickness;
              ctx.strokeStyle = modelObj.gridDarkColor;
            } else {
              ctx.lineWidth = minorLineWidth;
              ctx.strokeStyle = modelObj.gridLightColor;
            }

            ctx.stroke();
            ctx.closePath();
          }

          unit -= modelObj.XunitsPerGrid;
          xPos -= xPosIncrement;
        }
      } //= =================================
      // draw right tick marks


      xPos = centerX;
      unit = modelObj.XunitsPerGrid; //= ====================================

      var rightVerticalLines = true;
      var axisX = restrictAxisX(ctx);

      if (rightVerticalLines) {
        lineCounter = 0;

        while (xPos < modelObj.x + modelObj.width) {
          var drawLines = true;

          if (modelObj.showQuadrants === '1' && xPos < axisX) {
            drawLines = false;
          }

          if (drawLines) {
            _drawGridBool = lineCounter % (modelObj.XunitsPerTick / modelObj.XunitsPerGrid);
            ctx.beginPath();
            ctx.moveTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.gridMargin[2]) + 0.5);

            if (modelObj.showQuadrants === '1') {
              var end = restrictAxisY();

              if (modelObj.gridMargin[3] && end > modelObj.y + modelObj.height - modelObj.gridMargin[3]) {
                end = modelObj.y + modelObj.height - modelObj.gridMargin[3];
              }

              ctx.lineTo(Math.round(xPos) + 0.5, Math.round(end) + 0.5);
            } else {
              ctx.lineTo(Math.round(xPos) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.gridMargin[3]) + 0.5);
            }

            if (_drawGridBool === 0) {
              ctx.lineWidth = modelObj.majorThickness;
              ctx.strokeStyle = modelObj.gridDarkColor;
            } else {
              ctx.lineWidth = minorLineWidth;
              ctx.strokeStyle = modelObj.gridLightColor;
            }

            ctx.stroke();
            ctx.closePath();
          }

          lineCounter++;
          unit += modelObj.XunitsPerGrid;
          xPos += xPosIncrement;
        }
      }
    } //= ====================================
    //= =================================
    // draw tick marks


    var yPosIncrement = modelObj.YunitsPerGrid * unitY;
    var yPos;
    ctx.font = modelObj.numberFontSize + 'px ' + modelObj.LabComClass.klettFontRegular;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = modelObj.gridLightColor; //= =================================
    // draw top tick marks

    yPos = centerY;
    unit = modelObj.YunitsPerGrid;
    var _counter = 0; // while(yPos > modelObj.y)
    // modelObj.y

    var startX = modelObj.x + modelObj.gridMargin[0];
    var endX = modelObj.x + modelObj.width - modelObj.gridMargin[1];

    if (modelObj.showQuadrants === '1') {
      startX = restrictAxisX(ctx);
    }

    var axisY = restrictAxisY();

    if (modelObj.sections.graph.horizontalGrid) {
      lineCounter = 0;

      while (yPos > modelObj.y + modelObj.gridMargin[2]) {
        _counter++;
        _drawGridBool = lineCounter % (modelObj.YunitsPerTick / modelObj.YunitsPerGrid);
        lineCounter++;
        var _drawLines = true;

        if (modelObj.showQuadrants === '1') {
          if (yPos > axisY) {
            _drawLines = false;
          }
        }

        if (_drawLines && yPos < modelObj.height + modelObj.y - modelObj.gridMargin[3]) {
          ctx.beginPath();
          ctx.moveTo(Math.round(startX) + 0.5, Math.round(yPos) + 0.5);
          ctx.lineTo(Math.round(endX) + 0.5, Math.round(yPos) + 0.5);

          if (_drawGridBool === 0) {
            ctx.lineWidth = modelObj.majorThickness;
            ctx.strokeStyle = modelObj.gridDarkColor;
          } else {
            ctx.lineWidth = minorLineWidth;
            ctx.strokeStyle = modelObj.gridLightColor;
          }

          ctx.stroke();
          ctx.closePath();
        }

        unit += modelObj.YunitsPerGrid; // yPos = Math.round(yPos - yPosIncrement);

        yPos -= yPosIncrement;
      } //= =================================
      // draw bottom tick marks


      yPos = centerY + yPosIncrement;
      unit = -1 * modelObj.YunitsPerGrid;
      var bottomHorizontalLines = true;

      if (modelObj.showQuadrants === '1') {
        bottomHorizontalLines = false;
      }

      if (bottomHorizontalLines) {
        lineCounter = 0;

        while (yPos < modelObj.height + modelObj.y - modelObj.gridMargin[3]) {
          if (yPos > modelObj.y + modelObj.gridMargin[2]) {
            lineCounter++;
            _drawGridBool = lineCounter % (modelObj.YunitsPerTick / modelObj.YunitsPerGrid);
            ctx.beginPath();
            ctx.moveTo(Math.round(modelObj.x + modelObj.gridMargin[0]) + 0.5, Math.round(yPos) + 0.5);
            ctx.lineTo(Math.round(modelObj.x + modelObj.width - modelObj.gridMargin[1]) + 0.5, Math.round(yPos) + 0.5);

            if (_drawGridBool === 0) {
              ctx.lineWidth = modelObj.majorThickness;
              ctx.strokeStyle = modelObj.gridDarkColor;
            } else {
              ctx.lineWidth = minorLineWidth;
              ctx.strokeStyle = modelObj.gridLightColor;
            }

            ctx.stroke();
            ctx.closePath();
          }

          unit -= modelObj.YunitsPerGrid;
          yPos += yPosIncrement;
        }
      }
    }
  }

  function drawBar(ctx, upperLeftCornerX, upperLeftCornerY, width, height, color) {
    if (color === '') {
      color = '#000000';
    }

    ctx.save();
    ctx.fillStyle = color;
    ctx.fillRect(upperLeftCornerX, upperLeftCornerY, width, height);
    ctx.restore();
  }

  function drawBarChart(ctx) {
    var barIndex = 0;

    for (var i = 0; i < modelObj.bardata.length; i++) {
      var _barWidth = modelObj.barSize;
      var _barValArr = modelObj.bardata[i].value;
      var _barColorArr = modelObj.bardata[i].color;
      var _barGroupStartX = 0;
      var _barGroupWidth = 0;

      for (var j = 0; j < _barValArr.length; j++) {
        var _barHeight = Number(_barValArr[j]) * unitY;

        var _barColor = _barColorArr[j];

        var _barX = centerX + modelObj.barChartPadding + modelObj.barChartLeftMargin + barIndex * (modelObj.barSize + modelObj.barsGapWidth) + j * modelObj.barSize;

        var _barY = centerY - _barHeight - modelObj.barChartPadding;

        if (j === 0) {
          _barGroupStartX = _barX;
        }

        _barGroupWidth += modelObj.barSize;
        drawBar(ctx, _barX, _barY, _barWidth, _barHeight, _barColor);
      }

      ctx.fillStyle = '#000000';
      ctx.textAlign = 'center';
      ctx.font = modelObj.barLabelFontSize + 'px ' + modelObj.LabComClass.klettFontRegular; // start text from the center of the graph

      var _textX = _barGroupStartX + _barGroupWidth / 2;

      ctx.fillText(modelObj.LabComClass.globalLangText[modelObj.bardata[i].name], _textX, centerY + 15);
      barIndex++;
    }
  }

  function drawBarChartPyramid(ctx) {
    var barIndex = 0;

    for (var i = 0; i < modelObj.bardata.length; i++) {
      //= ========================================
      var _xPtVal = centerX + modelObj.shiftCenterX * unitX;

      var _yPtVal = centerY - barIndex * 5 * unitY;

      var _barX = _xPtVal;
      var _barY = _yPtVal; //= ========= DRAW LEFT BAR CHART ====================

      var _barWidth = modelObj.bardata[i].value[0] * unitX;

      var _barHeight = 4 * unitY;

      var _barColor = '#00aeef';
      _barY -= 4 * unitY;
      drawBar(ctx, _barX, _barY, _barWidth, _barHeight, _barColor); //= ========= DRAW RIGHT BAR CHART ====================

      _barWidth = modelObj.bardata[i].value[1] * unitX;
      _barHeight = 4 * unitY;
      _barColor = '#fb7e83';
      drawBar(ctx, _barX, _barY, _barWidth, _barHeight, _barColor); //= =======================================

      barIndex++;
    }
  }

  function drawAxisLabels(ctx) {
    if (modelObj.showAxisLabels) {
      ctx.textAlign = 'left';
      var textXpos = centerX;
      var textYpos = modelObj.y;

      if (modelObj.LabComClass.globalLangText[modelObj.yLabelText] !== undefined) {
        var _textX = textXpos + modelObj.yLabelTextOffsetX;

        var _textY = modelObj.y + modelObj.height / 2 + modelObj.yLabelTextOffsetY;

        ctx.save();
        ctx.translate(_textX, _textY);
        ctx.rotate(0 * Math.PI / 180);
        ctx.drawStyledText(modelObj.LabComClass.globalLangText[modelObj.yLabelText], 0, 0, modelObj.font, modelObj.labelFontSize);
        ctx.restore();
      }
    }
  } //= ==================================================


  function restrictAxisY() {
    var diff = modelObj.sections.axis.yAxis.restrictPadding;
    var arrowY = centerY;

    if (modelObj.sections.axis.yAxis.restrictToBoundry) {
      if (centerY < diff) {
        arrowY = diff;
      } else if (centerY >= modelObj.height - diff) {
        arrowY = modelObj.height - diff;
      }
    }

    return arrowY;
  }

  function restrictAxisX(ctx) {
    var diff = modelObj.sections.axis.xAxis.restrictPadding;
    var arrowX = centerX;

    if (modelObj.sections.axis.xAxis.restrictToBoundry) {
      if (centerX < diff) {
        arrowX = diff;
      } else if (centerX > modelObj.width - diff) {
        arrowX = modelObj.width - diff;
      }
    }

    var topLeft = _this.getPointByPixel(originalX, originalY).y.toFixed(modelObj.YunitsPerTickToFixed);

    var bottomLeft = _this.getPointByPixel(originalX, originalY + modelObj.height).y.toFixed(modelObj.YunitsPerTickToFixed);

    ctx.save();
    ctx.font = modelObj.numberFontSize + 'px ' + modelObj.LabComClass.klettFontRegular;
    var topLeftSize = ctx.measureText(topLeft).width;
    var bottomLeftSize = ctx.measureText(bottomLeft).width;
    var maxWidth = topLeftSize > bottomLeftSize ? topLeftSize : bottomLeftSize;
    maxWidth += 14;

    if (arrowX < maxWidth) {
      arrowX = maxWidth;
    } else if (modelObj.showQuadrants === '1' && modelObj.regX > maxWidth) {
      arrowX = maxWidth;
      modelObj.regX = arrowX;
      centerX = arrowX;
    }

    ctx.restore();
    return arrowX;
  }

  function drawXAxis(ctx) {
    arrow1 = false;
    arrow3 = false;
    var arrowY = restrictAxisY();
    var arrowX = restrictAxisX(ctx);

    if (modelObj.showQuadrants === '1' || modelObj.showQuadrants === '2' || modelObj.showQuadrants === '12' || modelObj.showQuadrants === '23' || modelObj.showQuadrants === '41' || modelObj.showQuadrants === '1234') {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.lineTo(Math.round(modelObj.x + modelObj.width - modelObj.rightMargin - trangleWidth / 2) + 0.5, Math.round(arrowY) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow1 = true;
    }

    if (modelObj.showQuadrants === '3' || modelObj.showQuadrants === '4' || modelObj.showQuadrants === '23' || modelObj.showQuadrants === '34' || modelObj.showQuadrants === '41' || modelObj.showQuadrants === '1234') {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.lineTo(Math.round(modelObj.x + modelObj.leftMargin) + 0.5, Math.round(arrowY) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow3 = true;
    } // draw tick marks


    if (modelObj.sections.axis.xAxis.ticks || modelObj.sections.axis.xAxis.numbers) {
      var xPosIncrement = modelObj.XunitsPerTick * unitX;
      var xPos;
      ctx.font = modelObj.numberFontSize + 'px ' + modelObj.LabComClass.klettFontRegular;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top'; // draw left tick marks

      xPos = centerX;

      if (arrow3) {
        var _obj2 = {
          ctx: ctx,
          type: 1,
          min: modelObj.x + modelObj.leftMargin + trangleHeight,
          start: xPos,
          max: modelObj.x + modelObj.width - trangleHeight,
          incrDecrFactor: -xPosIncrement,
          y: arrowY
        };
        drawTicksX(_obj2);
      } // draw right tick marks


      xPos = centerX;
      var lecftMostPos = modelObj.x + modelObj.leftMargin + trangleHeight;

      if (modelObj.showQuadrants === '1') {
        lecftMostPos = modelObj.x + modelObj.leftMargin;
      }

      if (arrow1) {
        var _obj3 = {
          ctx: ctx,
          type: 2,
          min: modelObj.x + modelObj.width - modelObj.rightMargin - trangleHeight,
          start: xPos,
          max: lecftMostPos,
          incrDecrFactor: xPosIncrement,
          y: arrowY
        };
        drawTicksX(_obj3);
      }
    }

    if (modelObj.sections.axis.xAxis.arrowHead) {
      if (arrow1 && centerX < modelObj.x + modelObj.width - modelObj.rightMargin - trangleHeight) {
        drawEqTriangle(ctx, trangleHeight, Math.round(modelObj.x + modelObj.width - modelObj.rightMargin - trangleWidth - 50) + 0.5, Math.round(arrowY) + 0.5, 2);
      }

      if (arrow3 && centerX > modelObj.x + modelObj.leftMargin + trangleHeight) {// drawEqTriangle(ctx, trangleHeight, Math.round(modelObj.x + modelObj.leftMargin + trangleWidth) + 0.5, Math.round(arrowY) + 0.5, 3);
      }
    }

    var textXpos = modelObj.x + modelObj.width - modelObj.rightMargin;
    var textYpos = centerY;

    if (modelObj.graphCenter === 'center-right') {
      textXpos = modelObj.x;
    }

    if (textYpos > arrowY) {
      textYpos = arrowY;
    }

    if (modelObj.showAxisLabels) {
      ctx.textAlign = 'left';

      if (modelObj.LabComClass.globalLangText[modelObj.xLabelText] !== undefined) {
        var yPos = textYpos - modelObj.xLabelTextOffsetY;

        if (modelObj.y + modelObj.labelFontSize + modelObj.xLabelTextOffsetY >= textYpos - modelObj.xLabelTextOffsetY) {
          yPos = modelObj.y + modelObj.labelFontSize + modelObj.xLabelTextOffsetY;
        }

        ctx.drawStyledText(modelObj.LabComClass.globalLangText[modelObj.xLabelText], textXpos - modelObj.xLabelTextOffsetX, yPos, modelObj.LabComClass.klettFontRegular, modelObj.labelFontSize);
      }
    }
  }

  function drawTicksX(_obj) {
    var unit,
        xPos = _obj.start;
    var y = _obj.y;
    var ctx = _obj.ctx;
    unit = Number(_this.getPointByPixel(xPos + originalX, y).x.toFixed(2));
    var arrowX = restrictAxisX(ctx);

    while (_obj.type === 1 ? xPos > _obj.min : xPos < _obj.min) {
      if (_obj.type === 1 ? xPos < _obj.max : xPos > _obj.max) {
        var _showNumbers = true;

        if (modelObj.showQuadrants === '1' && xPos < arrowX) {
          _showNumbers = false;
        }

        if (_showNumbers) {
          if (modelObj.sections.axis.xAxis.ticks && unit !== 0) {
            ctx.beginPath();
            ctx.moveTo(Math.round(xPos), Math.round(y - modelObj.tickSize / 2));
            ctx.lineTo(Math.round(xPos), Math.round(y + modelObj.tickSize / 2));
            ctx.stroke();
            ctx.closePath();
          }

          var txt = unit.toString();

          if (modelObj.sections.axis.xAxis.postTxt && modelObj.LabComClass.globalLangText[modelObj.sections.axis.xAxis.postTxt]) {
            txt += modelObj.LabComClass.globalLangText[modelObj.sections.axis.xAxis.postTxt];
          }

          if (modelObj.sections.axis.xAxis.numbers) {
            if (unit === 0) {
              if (_obj.incrDecrFactor > 0 && modelObj.sections.axis.origin.visible) {
                var unitTxtX = Math.round(xPos - modelObj.tickSize / 2 - 3);
                var unitTxtY = Math.round(centerY + modelObj.tickSize / 2);

                if (!modelObj.sections.axis.yAxis.visible) {
                  unitTxtX = Math.round(xPos);
                  unitTxtY = Math.round(centerY + modelObj.tickSize / 2 + 3);
                }

                ctx.fillText('O', unitTxtX, unitTxtY);
              }
            } else {
              ctx.fillText(txt, Math.round(xPos), Math.round(y + modelObj.tickSize / 2 + modelObj.numberFontSize / 2));
            }
          }
        }
      }

      xPos += _obj.incrDecrFactor;
      unit = Number(_this.getPointByPixel(xPos + originalX, y).x.toFixed(modelObj.XunitsPerTickToFixed));
    }
  }

  function drawTicksY(_obj) {
    var unit,
        yPos = _obj.start;
    var arrowY = restrictAxisY();
    var x = _obj.x;
    var ctx = _obj.ctx;
    unit = Number(_this.getPointByPixel(x, yPos + originalY).y.toFixed(2));

    while (_obj.type === 1 ? yPos > _obj.min : yPos < _obj.min) {
      _counter++;

      if (_obj.type === 1 ? yPos < _obj.max : yPos > _obj.max) {
        var _showNumbers = true;

        if (modelObj.numbersMaxY) {
          if (unit > modelObj.numbersMaxY) {
            _showNumbers = false;
          }
        }

        if (modelObj.showQuadrants === '1' && yPos > arrowY) {
          _showNumbers = false;
        } // if (unit <= modelObj.numbersMaxY)


        if (_showNumbers) {
          // ============= Draw Ticks ====================
          if (modelObj.sections.axis.yAxis.ticks) {
            ctx.beginPath();
            ctx.moveTo(Math.round(x - modelObj.tickSize / 2) + 0.5, Math.round(yPos) + 0.5);
            ctx.lineTo(Math.round(x + modelObj.tickSize / 2) + 0.5, Math.round(yPos) + 0.5);
            ctx.stroke();
            ctx.closePath();
          } //= =======================================


          if (modelObj.sections.axis.yAxis.numbers) {
            ctx.fillStyle = modelObj.axisColor;
            ctx.fillText(unit, x - modelObj.tickSize / 2 - modelObj.numberFontSize / 2, yPos);
          }
        }
      }

      yPos += _obj.incrDecrFactor;
      unit = Number(_this.getPointByPixel(x, yPos + originalY).y.toFixed(modelObj.YunitsPerTickToFixed));
    }
  }

  function drawYAxis(ctx) {
    arrow4 = false;
    arrow2 = false;
    var arrowX = restrictAxisX(ctx);
    var arrowY = restrictAxisY(ctx);

    if (modelObj.showQuadrants === '1' || modelObj.showQuadrants === '4' || modelObj.showQuadrants === '12' || modelObj.showQuadrants === '34' || modelObj.showQuadrants === '41' || modelObj.showQuadrants === '1234') {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.topMargin + trangleHeight / 2) + 0.5);
      ctx.lineTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow4 = true;
    }

    if (modelObj.showQuadrants === '2' || modelObj.showQuadrants === '3' || modelObj.showQuadrants === '12' || modelObj.showQuadrants === '23' || modelObj.showQuadrants === '34' || modelObj.showQuadrants === '1234') {
      ctx.beginPath();
      ctx.moveTo(Math.round(arrowX) + 0.5, Math.round(arrowY) + 0.5);
      ctx.lineTo(Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.bottomMargin) + 0.5);
      ctx.strokeStyle = modelObj.axisColor;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.closePath();
      arrow2 = true;
    } // draw tick marks


    if (modelObj.sections.axis.yAxis.ticks || modelObj.sections.axis.yAxis.numbers) {
      var yPosIncrement = modelObj.YunitsPerTick * unitY;
      var yPos, unit;
      ctx.font = modelObj.numberFontSize + 'px ' + modelObj.LabComClass.klettFontRegular;
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle'; // draw top tick marks

      yPos = centerY - yPosIncrement;
      unit = modelObj.YunitsPerTick;
      var _counter = 0;

      if (arrow4) {
        var _obj4 = {
          ctx: ctx,
          type: 1,
          min: modelObj.y + modelObj.topMargin + trangleHeight,
          start: yPos,
          max: modelObj.y + modelObj.height - modelObj.bottomMargin - trangleHeight,
          incrDecrFactor: -yPosIncrement,
          x: arrowX
        };
        drawTicksY(_obj4);
      } // draw bottom tick marks


      yPos = centerY + yPosIncrement;
      unit = -1 * modelObj.YunitsPerTick; // while(yPos < modelObj.height+modelObj.y)

      var _showNumbers;

      if (arrow2) {
        var _obj5 = {
          ctx: ctx,
          type: 2,
          min: modelObj.y + modelObj.height - modelObj.bottomMargin - trangleHeight,
          start: yPos,
          max: modelObj.y + modelObj.topMargin + trangleHeight,
          incrDecrFactor: yPosIncrement,
          x: arrowX
        };
        drawTicksY(_obj5);
      }
    }

    if (modelObj.sections.axis.yAxis.arrowHead) {
      if (arrow4 && centerY > modelObj.y + modelObj.topMargin + trangleHeight) {
        drawEqTriangle(ctx, trangleHeight, Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.topMargin + trangleWidth) + 0.5, 0);
      }

      if (arrow2 && centerY < modelObj.y + modelObj.height - modelObj.bottomMargin - trangleHeight) {// drawEqTriangle(ctx, trangleHeight, Math.round(arrowX) + 0.5, Math.round(modelObj.y + modelObj.height - modelObj.bottomMargin - trangleWidth) + 0.5, 1);
      }
    }

    var textXpos = centerX;
    var textYpos = modelObj.y + modelObj.topMargin;

    if (modelObj.graphCenter === 'center-right') {
      textXpos = centerX;
    }

    if (textXpos < arrowX) {
      textXpos = arrowX;
    }

    if (modelObj.showAxisLabels) {
      ctx.textAlign = 'left';

      if (modelObj.LabComClass.globalLangText[modelObj.yLabelText] !== undefined) {
        var xPos = textXpos + modelObj.yLabelTextOffsetX;

        if (modelObj.width - modelObj.labelFontSize - modelObj.yLabelTextOffsetX * 2 < textXpos - modelObj.yLabelTextOffsetX) {
          xPos = modelObj.width - modelObj.labelFontSize * 2 - modelObj.yLabelTextOffsetX * 2;
        }

        ctx.drawStyledText(modelObj.LabComClass.globalLangText[modelObj.yLabelText], xPos, textYpos + modelObj.yLabelTextOffsetY, modelObj.LabComClass.klettFontRegular, modelObj.labelFontSize);
      }
    }
  }

  this.updateLineArr = function (_arr) {
    lineCanvas.width = lineCanvas.width;
    graphLineArr = _arr;

    if (modelObj.cacheGraph) {
      drawGraph();
    }
  };

  this.updatePointsArr = function (_arr) {
    pointCanvas.width = pointCanvas.width;
    graphPointArr = _arr;

    if (modelObj.cacheGraph) {
      drawGraph();
    }

    addEvents();
  };

  this.updateShapesArr = function (_arr) {
    shapeCanvas.width = shapeCanvas.width;
    shapePointArr = _arr;

    if (modelObj.cacheGraph) {
      drawGraph();
    }

    addEvents();
  };

  this.plotPointArr = function (ctx) {
    if (graphPointArr.length === 0) {
      return false;
    }

    for (var i = 0; i < graphPointArr.length; i++) {
      for (var j = 0; j < graphPointArr[i].length; j++) {
        _this.plotPoint(ctx, graphPointArr[i][j].x, graphPointArr[i][j].y, graphPointArr[i][j].color, '', true);
      }
    }

    return true;
  };

  this.plotShapeArr = function (ctx) {
    if (shapePointArr.length === 0) {
      return false;
    } // sample
    // [
    //   [
    //     [
    // 'moveTo(', { val: 20, axis: 'x' }, ',', { val: 50, axis: 'y' }, ')'
    // 'arc(', { val: 20, axis: 'x' }, ',', { val: 50, axis: 'y' }, ',5', ',0', ',6.28)'
    //     ]
    //   ]
    // ]


    for (var i = 0; i < shapePointArr.length; i++) {
      // multiple shapes in different arrays
      ctx.beginPath();

      for (var j = 0; j < shapePointArr[i].length; j++) {
        // single shape
        eval('ctx.' + generateShapeString(shapePointArr[i][j]));
      }

      ctx.closePath();
    }

    return true;
  };

  function generateShapeString(data) {
    var shapeMethodString = ''; // arc(0,0,5,0,Math.PI * 2)

    for (var i = 0; i < data.length; i++) {
      // single shape
      var text = '';

      if (_typeof(data[i]) === 'object') {
        if (data[i].val !== undefined && data[i].axis !== undefined) {
          if (data[i].axis === 'x') {
            text = _this.getPixelByPoint(data[i].val, 0).x;
          } else {
            text = _this.getPixelByPoint(0, data[i].val).y;
          }
        }
      } else {
        text = data[i];
      }

      shapeMethodString += text;
    }

    return shapeMethodString;
  }

  this.plotLineArr = function (ctx) {
    if (graphLineArr.length === 0) {
      return false;
    }

    for (var i = 0; i < graphLineArr.length; i++) {
      if (graphLineArr[i].length > 1) {
        ctx.save();

        for (var j = 1; j < graphLineArr[i].length; j++) {
          var _startXPtVal = centerX + graphLineArr[i][j - 1].x * unitX;

          var _startYPtVal = centerY - graphLineArr[i][j - 1].y * unitY;

          var _endXPtVal = centerX + graphLineArr[i][j].x * unitX;

          var _endYPtVal = centerY - graphLineArr[i][j].y * unitY;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(_startXPtVal, _startYPtVal); //= ================

          ctx.lineTo(_endXPtVal, _endYPtVal); //= =============

          ctx.restore();

          if (graphLineArr[i][j].stroke === 'dash') {
            ctx.setLineDash([5, 15]);
          } else {
            ctx.setLineDash([0, 0]);
          }

          ctx.strokeStyle = graphLineArr[i][0].color;
          ctx.closePath();
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    return true;
  };

  this.resetParams = function () {
    pointsArr = [];
    coeffObj = null;
  };

  this.updateGraphParams = function (obj) {
    Object.keys(_obj).forEach(function (i) {
      modelObj[i] = _obj[i];
    });
    correctModelObj();
  };

  this.changeGraphScale = function (maxVal) {
    if (maxVal < 10) {
      modelObj.minX = -10;
      modelObj.maxX = 10;
      modelObj.minY = -10;
      modelObj.maxY = 10;
      modelObj.unitsPerTick = 1;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }

    if (maxVal >= 10 && maxVal <= 25) {
      modelObj.minX = -25;
      modelObj.maxX = 25;
      modelObj.minY = -25;
      modelObj.maxY = 25;
      modelObj.unitsPerTick = 5;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }

    if (maxVal >= 25 && maxVal <= 50) {
      modelObj.minX = -50;
      modelObj.maxX = 50;
      modelObj.minY = -50;
      modelObj.maxY = 50;
      modelObj.unitsPerTick = 10;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }

    if (maxVal >= 50 && maxVal <= 100) {
      modelObj.minX = -100;
      modelObj.maxX = 100;
      modelObj.minY = -100;
      modelObj.maxY = 100;
      modelObj.unitsPerTick = 10;
      modelObj.unitsPerGrid = modelObj.unitsPerTick / 2;
      this.updateRender();
    }
  };

  this.getVertex = function (coeffObj) {
    return [vertex_X, vertex_Y];
  };

  this.getXintercept = function (coeffObj) {
    if (coeffObj) {
      var interceptX1 = (-coeffObj.b + Math.sqrt(coeffObj.b * coeffObj.b - 4 * coeffObj.a * coeffObj.c)) / (2 * coeffObj.a);
      var interceptX2 = (-coeffObj.b - Math.sqrt(coeffObj.b * coeffObj.b - 4 * coeffObj.a * coeffObj.c)) / (2 * coeffObj.a);
      interceptX1 = interceptX1.toFixed(2);
      interceptX2 = interceptX2.toFixed(2);
      interceptX1 = Number(interceptX1);
      interceptX2 = Number(interceptX2);
      return [interceptX1, interceptX2];
    }

    return true;
  };

  function plotEquation(equation, color, thickness) {
    var _y = equation(modelObj.minX);

    context.moveTo(modelObj.minX, _y);
    var _lineArr = [];

    for (var _x = modelObj.minX + iteration; _x <= modelObj.maxX; _x += iteration) {
      _y = equation(_x);

      _lineArr.push({
        x: _x,
        y: _y
      });

      context.lineTo(_x, _y);
    }
  }

  this.addPoint = function (_x, _y, _color, _type) {
    var _exist = false;

    for (var i = 0; i < pointsArr.length; i++) {
      if (pointsArr[i].x === _x && pointsArr[i].y === _y && pointsArr[i].color === _color) {
        _exist = true;
      }
    }

    if (!_exist) {
      pointsArr.push({
        x: _x,
        y: _y,
        color: _color,
        type: _type
      });
      this.updateRender();
    }
  };

  this.plotPoint = function (ctx, _x, _y, color, type, visible) {
    ctx.save();
    _x = Number(_x);
    _y = Number(_y);
    ctx.beginPath();

    var point = _this.getPixelByPoint(_x, _y);

    point.x -= originalX;
    point.y -= originalY;
    var boolX = point.x > modelObj.x && point.x < modelObj.x + modelObj.width;
    var boolY = point.y > modelObj.y && point.y < modelObj.y + modelObj.height;

    if (boolX && boolY) {
      ctx.arc(point.x, point.y, modelObj.pointRadius, 0, 2 * Math.PI, false);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.font = modelObj.numberFontSize + 'px ' + modelObj.LabComClass.klettFontRegular;

      if (visible) {
        var xVal = Number(_x.toFixed(modelObj.decimalPoint)) === 0 ? 0 : Number(_x.toFixed(modelObj.decimalPoint));
        var yVal = Number(_y.toFixed(modelObj.decimalPoint)) === 0 ? 0 : Number(_y.toFixed(modelObj.decimalPoint));

        var _txt = '( ' + xVal + ', ' + yVal + ' )';

        var _txtLen = ctx.measureText(_txt).width;
        point.x += 10;

        if (_x !== 0) {
          point.x -= _txtLen / 2 + 12;
        }

        if (_x === 0) {
          point.y += 10;
        }

        if (_y === 0 || _y > 0) {
          point.y -= 15;
        }

        if (_y < 0 && _x !== 0) {
          point.y += 20;
        }

        if (modelObj.showPointText) {
          ctx.beginPath();
          var gap = 5;
          ctx.fillStyle = 'rgba(255,255,255,1)';
          ctx.rect(point.x - gap, point.y - (modelObj.fontsize - 2), _txtLen + gap * 2, modelObj.fontsize + 3);
          ctx.fill();
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fillText(_txt, point.x, point.y);
        }
      }
    }

    ctx.closePath();
    ctx.restore();
  };

  function transformContext(_ctx) {
    _ctx.translate(centerX, centerY);

    _ctx.scale(scaleX, -scaleY);
  } // =================================================


  this.setPanValues = function (_obj) {
    if (modelObj.panX) {
      modelObj.regX += _obj.x;
    }

    if (modelObj.panY) {
      modelObj.regY += _obj.y;
    }

    checkPanRestrictions();
  }; // =================================================
  // PRIVATE SECTION
  // =================================================

  /*
     * This function is used to save the Loaded Images.
     * @param _obj is of type Object. It contains all the image that are to be used.
     */


  function onImageLoaded(_obj) {
    imgObj = _obj;
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'componentLoaded',
      data: {
        id: modelObj.id
      }
    });
  } // =================================================

  /*
     * This function is used to add mouse events to the lab
     */


  function addEvents() {
    removeEvents();

    if (modelObj.visible) {
      var _eventDataObj = {};
      _eventDataObj.id = modelObj.id;
      _eventDataObj.r = [];

      if (modelObj.panX || modelObj.panY || modelObj.clickable || modelObj.arrowOnly) {
        _eventDataObj.r.push({
          id: 'graphCnv',
          rect: {
            x: originalX,
            y: originalY,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: modelObj.clickable ? 'pointer' : modelObj.arrowOnly ? 'arrow' : 'grab',
          downCursor: modelObj.clickable ? 'pointer' : modelObj.arrowOnly ? 'arrow' : 'grabbing',
          eventListener: mouseHandle.bind(this)
        });
      }

      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'addMouseEvent',
        data: _eventDataObj
      });
    }
  } // =================================================

  /*
     * This function is used to remove the mouse events.
     */


  function removeEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  } // =================================================

  /*
     * This function is used to handle the mouse events of the Lab.
     * @param e is of type Object.It usually has 2 properties type and subId.
     */


  var mouseDownAt = {};

  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        mouseDown = true;
        _mouseDownPageX = e.pageX;
        _mouseDownPageY = e.pageY;
        mouseDownAt.x = e.pageX;
        mouseDownAt.y = e.pageY;
        mouseDownAt.mousemove = false;
        break;

      case 'pressmove':
        if (mouseDown) {
          if (modelObj.panX || modelObj.panY) {
            changeGraphRange(e);
          }

          if (e.pageX !== mouseDownAt.x || e.pageY !== mouseDownAt.y) {
            mouseDownAt.mousemove = true;
          }
        }

        break;

      case 'mouseup':
      case 'mouseupout':
        mouseDown = false;
        addEvents();

        if (modelObj.clickable && mouseDownAt && typeof events.mouseDown !== 'undefined' && modelObj.visible) {
          events.mouseDown({
            type: 'mouseDown',
            x: mouseDownAt.x,
            y: mouseDownAt.y,
            mousemove: mouseDownAt.mousemove,
            val: _this.getPointByPixel(mouseDownAt.x, mouseDownAt.y)
          }, true);
        }

        break;

      default:
        break;
    } // event.preventDefault()

  } // =================================================


  function changeGraphRange(e) {
    if (modelObj.panX) {
      var _diffX = e.pageX - _mouseDownPageX;

      modelObj.regX += _diffX;
    }

    if (modelObj.panY) {
      var _diffY = e.pageY - _mouseDownPageY;

      modelObj.regY += _diffY;
    }

    _mouseDownPageX = e.pageX;
    _mouseDownPageY = e.pageY;
    checkPanRestrictions();
  }

  function checkPanRestrictions() {
    if (modelObj.panX) {
      var minPixelX = modelObj.minPanX * -1 * unitX;

      if (modelObj.sections.axis.xAxis.minPanInPixel !== null) {
        minPixelX = modelObj.sections.axis.xAxis.minPanInPixel;
      }

      var maxPixelX = modelObj.width - modelObj.maxPanX * unitX;

      if (modelObj.sections.axis.xAxis.maxPanInPixel !== null) {
        maxPixelX = modelObj.sections.axis.xAxis.maxPanInPixel;
      }

      if (modelObj.regX > minPixelX) {
        modelObj.regX = minPixelX;
      }

      if (modelObj.regX < maxPixelX) {
        modelObj.regX = maxPixelX;
      }
    }

    if (modelObj.panY) {
      var minPixelY = modelObj.minPanY * -1 * unitY;

      if (modelObj.sections.axis.yAxis.minPanInPixel !== null) {
        minPixelY = modelObj.sections.axis.yAxis.minPanInPixel;
      }

      var maxPixelY = modelObj.height - modelObj.maxPanY * unitY;

      if (modelObj.sections.axis.yAxis.maxPanInPixel !== null) {
        maxPixelY = modelObj.height - modelObj.sections.axis.yAxis.maxPanInPixel;
      }

      if (modelObj.regY > minPixelY) {
        modelObj.regY = minPixelY;
      }

      if (modelObj.regY < maxPixelY) {
        modelObj.regY = maxPixelY;
      }
    }

    updateZoomValues();
  } // =================================================

  /*
     * This function is used to update the Lab with the Updated Value
     */


  function onActValueUpdate() {
    if (typeof events.change !== 'undefined') {
      events.change({
        type: 'change'
      }, true);
    }
  }

  this.init();
}
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
// interactionType can be either of "point", "segment", "line", "circle".
function FreeGeoDrawClass(_obj) {
  var events = {};
  var scaleObj = {
    x: 0,
    y: 0,
    xTo: 200,
    yTo: 200,
    pointColor: 'rgba(10,190,220,1)',
    pointRadius: 7,
    segmentColor: 'rgba(10,190,220,1)',
    segmentWidth: 3,
    visible: false
  };
  var modelObj = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    bgColor: 'rgba(255, 255, 255, 0.5)',
    state: true,
    visible: true,
    interactionType: '',
    interactionElements: [],
    pointColor: 'rgba(10,190,220,1)',
    pointLabelColor: 'rgba(51,51,51,1)',
    lengthLabelColor: 'rgba(51,51,51,1)',
    pointRadius: 5,
    segmentColor: 'rgba(10,190,220,1)',
    segmentWidth: 2,
    tempElements: [],
    transperent: false,
    eventsEnable: true,
    fontSize: 20,
    currentStep: 0,
    snapToGrid: false,
    snappingDiff: 10,
    // in pixel,
    deviceSnappingDiff: 25,
    shapesEditable: false,
    undoRedo: false,
    pointSnapping: true,
    finalColor: 'rgba(65,180,5,1)',
    screen: {},
    labelBGRatio: 1,
    waiting: false,
    shapes: {
      length: {
        digit: 1,
        onlyDistance: false,
        label: {
          visible: true
        }
      },
      point: {
        label: {
          visible: true
        }
      },
      square: {
        label: {
          visible: false
        },
        fill: true
      },
      circle: {
        digit: 0,
        circleDistanceLabel: true
      },
      line: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        }
      },
      brush1: {
        color: {
          stroke: 'rgba(0,0,0)'
        }
      },
      brush2: {
        color: {
          stroke: 'rgba(222,108,225)'
        }
      },
      brush3: {
        color: {
          stroke: 'rgba(255,204,0)'
        }
      },
      brush4: {
        color: {
          stroke: 'rgba(50,205,50)'
        }
      },
      brush5: {
        color: {
          stroke: 'rgba(10,190,220)'
        }
      },
      brush6: {
        color: {
          stroke: 'rgba(255,0,0)'
        }
      },
      brush7: {
        color: {
          stroke: 'rgba(207,207,207)'
        }
      },
      segment: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        },
        label: {
          visible: false
        },
        segDistanceLabel: false,
        digit: 1
      },
      angle: {
        dotOn90: true
      },
      angleSize: {
        dotOn90: true
      },
      defBgFill: 'rgba(112,146,190,0.5)'
    }
  };
  var localObj = {
    mouseDown: {
      isMouseDown: false,
      lastShapeCompleted: true
    },
    uniqueId: 0,
    currentUniqueId: 0,
    allShapesData: [],
    tempData: [],
    mouseDownData: null,
    isDevice: false,
    newPlottedShapes: [],
    lineTypes: ['line', 'ray', 'perpendicularLine', 'parallelLine', 'segment', 'segmentDash'],
    isLableSelected: false,
    arbitaryX: 1,
    selectedItemsCount: 0,
    itemCount: 0,
    plotPointOnExistingPoint: false,
    selectFlag: true,
    selectAll: false
  };

  var _this = this;

  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === 'object' && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === 'object' && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  }

  modelObj.centerX = modelObj.x + modelObj.width / 2;
  modelObj.centerY = modelObj.y + modelObj.height / 2;
  setScaleValues();
  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass();
  localObj.isDevice = modelObj.LabComClass.BrowserDetect.isDevice();

  if (localObj.isDevice) {
    modelObj.snappingDiff = modelObj.deviceSnappingDiff;
  } // addEvents();


  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.alpha = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.setTransperent = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.setLengthLabelColor = function (_color) {
    modelObj.lengthLabelColor = _color;
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  }; // =================================================


  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    addEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  };

  this.editable = function (flag) {
    modelObj.shapesEditable = flag;
    return modelObj.shapesEditable;
  };

  this.selectAll = function (_flag) {
    modelObj.interactionElements.forEach(function (item) {
      item.isSelected = _flag;
    });
    localObj.selectAll = modelObj.interactionType === 'move'; // modelObj.interactionType = 'select';
    // addEvents();
  };

  this.snapToGrid = function (_flag) {
    modelObj.snapToGrid = _flag;
  };

  this.redoPossible = function () {
    return localObj.tempData.length !== 0;
  };

  this.undoPossible = function () {
    return localObj.allShapesData.length !== 0;
  };

  this.setFinalView = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.finalView = _flag;
  };

  this.setPointSnapping = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.pointSnapping = _flag;
  };

  this.setStyle = function (uniqueId, _obj) {
    var styleApproved = {
      strokeColor: true,
      fillColor: true
    };
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        if (styleApproved[i]) {
          shape.shape[i] = _obj[i];
        }
      });
    }
  };

  this.deleteSelected = function () {
    if (modelObj.shapesEditable) {
      var selectedIds = [];
      modelObj.interactionElements.forEach(function (item) {
        if (item.isSelected && (item.isDeletable === undefined || item.isDeletable)) {
          selectedIds.push(item.uniqueId);
        }
      });
      removeShapesV2(selectedIds);
    }
  };

  this.setScaleDefaultPos = function (x1, y1, x2, y2) {
    var updateScalePos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    scaleObj.originPos = {
      x: x1,
      y: y1,
      xTo: x2,
      yTo: y2
    };

    if (updateScalePos) {
      scaleObj.x = scaleObj.originPos.x;
      scaleObj.y = scaleObj.originPos.y;
      scaleObj.xTo = scaleObj.originPos.xTo;
      scaleObj.yTo = scaleObj.originPos.yTo;
    }
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  };

  this.getStep = function () {
    return modelObj.currentStep;
  }; // =================================================


  this.showDrawing = function (_arr, _bool) {
    if (typeof _arr !== 'undefined' && _arr !== null) {
      _arr.forEach(function (item) {
        if (typeof item !== 'undefined') {
          item.visible = _bool;
        }
      });
    }
  }; // =================================================


  this.setInteractionType = function (_type) {
    if (typeof _type !== 'undefined') {
      if (modelObj.interactionType !== _type) {
        modelObj.interactionType = _type;
        clearCache();
        addEvents();
      }
    }
  };

  this.getInteractionType = function () {
    return modelObj.interactionType;
  };

  this.setStep = function (_step) {
    if (modelObj.currentStep > _step) {
      removeShapes(modelObj.interactionElements.filter(function (e) {
        return e.step > _step;
      }).map(function (e) {
        return e.uniqueId;
      }));
    }

    modelObj.currentStep = _step;
  };

  this.setSegmentDistanceLabel = function (_flag) {
    modelObj.shapes.segment.segDistanceLabel = _flag;
  };

  this.getCount = function () {
    return modelObj.interactionElements.length;
  };

  this.getData = function () {
    return {
      visible: JSON.parse(JSON.stringify(modelObj.interactionElements)),
      nonVisible: modelObj.tempElements
    };
  };

  this.setWaiting = function (_bool) {
    modelObj.waiting = _bool;
  };

  this.getWaiting = function () {
    return modelObj.waiting;
  };

  this.setScreenData = function (_obj) {
    modelObj.graphValues = _obj;
    modelObj.x = _obj.x;
    modelObj.y = _obj.y;
    modelObj.width = _obj.width;
    modelObj.height = _obj.height;
    modelObj.screen = _obj.screen;
    modelObj.centerX = _obj.originX;
    modelObj.centerY = _obj.originY;
    modelObj.showQuadrants = _obj.showQuadrants; // for (let i = 0; i < modelObj.interactionElements.length; i++) {
    //   const shape = modelObj.interactionElements[i];
    // if ((shape.type === 'line' || shape.type === 'ray') && shape.label) {
    //   const pos = findLableByLine(shape, { x: shape.xTo, y: shape.yTo });
    //   shape.labelX = pos.x;
    //   shape.labelY = pos.y;
    // }
    // }

    setScaleValues();
    updateAllShapes();
    addEvents();
  };

  this.plotAngleSize = function (_obj) {
    if (!modelObj.waiting) {
      var angleSize = {
        type: 'angleSize',
        uniqueId: ++localObj.uniqueId,
        x: 0,
        y: 0,
        xTo: 0,
        yTo: 0,
        degree: 0,
        clockwise: true,
        connectionId: []
      };
      var rayId = ++localObj.uniqueId;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var angle = modelObj.LabComClass.Maths.getAngle(angleSize.x, angleSize.y, angleSize.xTo, angleSize.yTo);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(angleSize, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + '°';
      }

      if (angleSize.labelX === undefined) {
        var angleTextPos = modelObj.LabComClass.Maths.getPoint(angleSize, angle + _obj.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleTextPos.x;
        angleSize.labelY = angleTextPos.y;
        angleSize.labelDiffX = angleSize.labelDiffX !== undefined ? angleSize.labelDiffX : 0;
        angleSize.labelDiffY = angleSize.labelDiffY !== undefined ? angleSize.labelDiffY : 0;
      }

      var newAngleSize = addNewShape(angleSize); // localObj.newPlottedShapes.push(angleSize.uniqueId);

      var ray = addNewShape({
        type: 'ray',
        uniqueId: rayId,
        x: angleSize.x,
        y: angleSize.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        dontDrag: true,
        connectionId: []
      }); // localObj.newPlottedShapes.push(rayId);

      updateLinePoints(ray);
      angleSize.connectionId.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;

      _this.updateShape(ray.uniqueId, {
        dontDrag: true
      });

      return {
        angleSize: newAngleSize,
        ray: ray
      };
    }
  };

  this.setAngleSize = function (_obj) {
    if (modelObj.waiting) {
      var rayId = ++localObj.uniqueId;
      var angleSize = findShape(_obj.uniqueId).shape;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var firstPoint = findShape(_obj.firstPointId).shape;
      var angle = modelObj.LabComClass.Maths.getAngle(_obj.x, _obj.y, firstPoint.x, firstPoint.y);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));
      angleSize.angleSign = _obj.degree;

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + '°';
      }

      if (angleSize.labelX === undefined) {
        var angleText = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleText.x;
        angleSize.labelY = angleText.y;
        angleSize.labelDiffX = 0;
        angleSize.labelDiffY = 0;
      }

      var newShape = addNewShape({
        type: 'ray',
        uniqueId: rayId,
        firstPointId: _obj.secondPointId,
        x: _obj.x,
        y: _obj.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        slope: angle + _obj.degree * Math.PI / 180,
        dontDrag: true,
        connectionId: [_obj.secondPointId, angleSize.uniqueId]
      });
      updateLinePoints(newShape);
      var fpShape = findShape(angleSize.firstPointId).shape;
      fpShape.isSelected = false;
      var spShape = findShape(angleSize.secondPointId).shape;
      angleSize.angleStart = spineObj.LabComClass.Maths.getAngle(spShape.x, spShape.y, fpShape.x, fpShape.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(spShape.x, spShape.y, fpShape.x, fpShape.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(spShape.x, spShape.y, fpShape.x, fpShape.y) * 180 / Math.PI;
      angleSize.angleEnd = spineObj.LabComClass.Maths.getAngle(spShape.x, spShape.y, rayEnd.x, rayEnd.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(spShape.x, spShape.y, rayEnd.x, rayEnd.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(spShape.x, spShape.y, rayEnd.x, rayEnd.y) * 180 / Math.PI;
      angleSize.angleEntered = true;
      angleSize.rayId = rayId;
      angleSize.connectionId.push(rayId);
      localObj.newPlottedShapes.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };

      if (spShape) {
        spShape.isSelected = false;
      }

      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  this.setLabel = function (_obj) {
    if (modelObj.waiting) {
      var labelDiff = getDefLabelDiff(_obj);
      var label;

      if (_obj.newLabel !== undefined && !_obj.type.includes('angle')) {
        label = _obj.newLabel;
      } else if (_obj.newLabel !== undefined && _obj.type.includes('angle')) {
        if (_obj.newLabel.includes('∡')) {
          label = _obj.newLabel.replace('∡', '§a  ');
        } else {
          label = _obj.newLabel;
        }

        if (_obj.type === 'angle' || _obj.type === 'angleSize') {
          _this.updateShape(_obj.uniqueId, {
            newLabel: label
          });
        }
      }

      if (_obj.type.includes('segment') && _obj.onlyLength && _obj.newLabel !== '') {
        label = _obj.newLabel + ' = ' + _obj.label;
        this.updateShape(_obj.uniqueId, {
          onlyLength: false
        });
      } else if (_obj.type.includes('segment') && !_obj.onlyLength && _obj.newLabel == '') {
        label = modelObj.shapes.length.digit !== undefined ? _obj.distance.toFixed(modelObj.shapes.length.digit) : _obj.distance.toFixed(2);
        this.updateShape(_obj.uniqueId, {
          onlyLength: true
        });
      }

      if (!labelDiff) {
        // If the object has label Diff set prior to setting new label.
        _this.updateShape(_obj.uniqueId, {
          label: label,
          isSelectedForLabel: false
        });
      } else {
        _this.updateShape(_obj.uniqueId, {
          label: label,
          labelDiffX: labelDiff.x,
          labelDiffY: labelDiff.y,
          isSelectedForLabel: false
        });
      }

      modelObj.waiting = false;
      localObj.mouseDown.lastShapeCompleted = true;
      dispatchEventCustom({});
    }
  };

  function getDefLabelDiff(_obj) {
    if (_obj.newLabel !== undefined && _obj.labelDiffX !== 0 && _obj.labelDiffX !== undefined && _obj.labelDiffY !== 0 && _obj.labelDiffY !== undefined) {
      return false;
    }

    var labelDiff = {};

    switch (_obj.type) {
      case 'point':
        labelDiff.x = 6;
        labelDiff.y = -9;
        break;

      case 'segment':
      case 'segmentDash':
      case 'ray':
      case 'line':
        // const angle = modelObj.LabComClass.Maths.getAngle(_obj.x,_obj.y,_obj.xTo,_obj.yTo) + Math.PI/2;
        var angle = modelObj.LabComClass.Maths.getAngle(0, 0, _obj.labelX, _obj.labelY) + Math.PI;
        var newDiff = modelObj.LabComClass.Maths.getPoint({
          x: _obj.labelX,
          y: _obj.labelY
        }, angle, getPointUnitByPixelUnit(20));
        labelDiff.x = getPixelUnitByPointUnit(_obj.labelX - newDiff.x);
        labelDiff.y = getPixelUnitByPointUnit(_obj.labelY - newDiff.y);
        break;
    }

    return labelDiff;
  }

  this.setSegSize = function (_obj) {
    if (modelObj.waiting) {
      var segmentId = ++localObj.uniqueId;
      var secondPointId = ++localObj.uniqueId;
      var segSize = findShape(_obj.uniqueId).shape;
      var firstPoint = findShape(segSize.firstPointId).shape;
      addNewShape({
        type: 'segment',
        firstPointId: segSize.firstPointId,
        secondPointId: secondPointId,
        uniqueId: segmentId,
        x: _obj.x,
        y: _obj.y,
        xTo: _obj.x + _obj.distance,
        yTo: _obj.y,
        labelX: (_obj.x * 2 + _obj.distance) / 2,
        labelY: _obj.y,
        segSize: true.valueOf,
        connectionId: [_obj.firstPointId, secondPointId, segSize.uniqueId]
      });
      addNewShape({
        type: 'point',
        uniqueId: secondPointId,
        x: _obj.x + _obj.distance,
        y: _obj.y,
        isIntersection: false,
        isParameter: false,
        // updateValue: false,
        segDistance: _obj.distance,
        firstPointId: _obj.firstPointId,
        connectionId: [segmentId]
      });
      segSize.connectionId.push(segmentId);
      segSize.connectionId.push(secondPointId);
      segSize.secondPointId = secondPointId;
      segSize.slope = 0;
      localObj.newPlottedShapes.push(segmentId);
      localObj.newPlottedShapes.push(secondPointId);
      segSize.segmentId = segmentId;
      segSize.distance = _obj.distance;
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fp = findShape(segSize.firstPointId).shape;
      fp.isSelected = false;
      fp.secondSegmentPoint = secondPointId;

      if (fp.connectionId === undefined) {
        fp.connectionId = [segmentId];
      } else {
        fp.connectionId.push(segmentId);
      }

      var sp = findShape(segSize.secondPointId).shape;
      sp.connectionId.push(segSize.uniqueId);
      fp.segPlotted = true;
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  this.setCircleSize = function (_obj) {
    if (modelObj.waiting) {
      var circleId = ++localObj.uniqueId;
      var circleSize = findShape(_obj.uniqueId).shape;
      var firstPoint = findShape(circleSize.firstPointId).shape;
      addNewShape({
        type: 'circle',
        uniqueId: circleId,
        x: _obj.x,
        y: _obj.y,
        r: _obj.distance,
        circleSize: true,
        firstPointId: _obj.firstPointId,
        connectionId: [_obj.firstPointId, circleSize.uniqueId]
      });
      var fpConnId = firstPoint.connectionId; // _this.updateShape(firstPoint.uniqueId,{connectionId :  fpConnId !== undefined  ? fpConnId.push(circleId) : [circleId]});

      firstPoint.connectionId.push(circleId);
      circleSize.connectionId.push(circleId);
      localObj.newPlottedShapes.push(circleId);
      circleSize.circleId = circleId;
      circleSize.r = _obj.distance;
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fp = findShape(circleSize.firstPointId).shape;
      fp.isSelected = false;
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  function getPointByPixel(_x, _y) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = (_x - _g.originX) / _g.unitX;
    pointY = -1 * (_y - _g.originY) / _g.unitY;
    return {
      x: pointX,
      y: pointY
    };
  }

  function getPixelByPoint(valueX, valueY) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = valueX * _g.unitX + _g.originX;
    pointY = valueY * _g.unitY / -1 + _g.originY;
    return {
      x: pointX,
      y: pointY
    };
  }

  function getPointUnitByPixelUnit(_pixelUnit) {
    return _pixelUnit / modelObj.graphValues.unitX;
  }

  function getPixelUnitByPointUnit(_pointUnit) {
    return _pointUnit * modelObj.graphValues.unitX;
  }

  this.setData = function (_data) {
    if (_data.visible !== undefined) {
      modelObj.interactionElements = JSON.parse(JSON.stringify(_data.visible));
    }

    if (_data.nonVisible !== undefined) {
      modelObj.tempElements = JSON.parse(JSON.stringify(_data.nonVisible));
    }

    clearCache();
  };

  this.getCurrentStepIndex = function (_num) {
    var arr = [];

    var _loop = typeof _num === 'undefined' ? 1 : _num;

    if (modelObj.interactionType !== 'scale') {
      for (var i = _loop; i > 0; i--) {
        arr.push(modelObj.interactionElements.length - i);
      }
    }

    return arr;
  };

  this.removeRecentShapes = function () {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (data.length) {
      removeShapes(data);
    } else {
      removeShapes(localObj.newPlottedShapes);
    }
  }; // =================================================


  this.clearAll = function () {
    modelObj.interactionElements = [];
    localObj.uniqueId = 0;
    modelObj.currentStep = 0;
    modelObj.finalView = false;
    localObj.selectAll = false;

    _this.clearTemp();
  };

  this.clearTemp = function () {
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
    modelObj.tempElements = [];
    localObj.allShapesData = [];
    localObj.tempData = [];
    clearCache();
  };

  this.undo = function () {
    if (modelObj.waiting) {
      this.removeUnplotedShapes();
      clearScreen();
    } else if (localObj.allShapesData.length) {
      localObj.tempData.push(localObj.allShapesData.pop());
      clearScreen(true);

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
        updateAllShapes();
      } else {
        modelObj.interactionElements = [];
      }
    } // else {
    //   // If circlesize or segment size is plotted first and if undo is pressed when window is open, then all shapes are cleared.
    //   clearScreen(true);
    //   modelObj.interactionElements = [];
    // }

  };

  this.redo = function () {
    if (localObj.tempData.length) {
      localObj.allShapesData.push(localObj.tempData.pop());
      clearScreen(true);

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
      } else {
        modelObj.interactionElements = [];
      }
    }
  };

  function saveData() {
    if (modelObj.interactionElements) {
      modelObj.interactionElements.forEach(function (shape) {
        if (shape.isMoved === true) {
          shape.isMoved = false;
        }
      });
    }

    if (modelObj.undoRedo) {
      var currentData = JSON.stringify(modelObj.interactionElements);
      var addData = false;

      if (localObj.allShapesData.length) {
        var lastData = JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]);

        if (currentData !== lastData) {
          addData = true;
        }
      } else {
        addData = true;
      }

      if (addData) {
        localObj.allShapesData.push(JSON.parse(JSON.stringify(modelObj.interactionElements)));
        localObj.tempData = [];
        localObj.selectAll = false;
      }
    }
  }

  this.addShape = function (_objData) {
    clearCache();

    var _obj = JSON.parse(JSON.stringify(_objData));

    _obj.uniqueId = ++localObj.uniqueId;

    if (!modelObj.shapesEditable) {
      _obj.isDraggable = false;
      _obj.isDeletable = false;
    }

    if (_obj.label) {
      if (_obj.labelX === undefined) {
        _obj.labelX = _obj.x;
        _obj.labelY = _obj.y;
      }

      if (_obj.labelDiffX === undefined) {
        _obj.labelDiffX = 0;
        _obj.labelDiffY = 0;
      }
    }

    _obj.connectionId = [];

    switch (_obj.type) {
      case 'point':
        updatePoints(addNewShape(_obj));
        break;

      case 'circle':
        updatePoints(addNewShape(_obj));
        break;

      case 'circle_3':
        updatePoints(addNewShape(_obj));
        break;

      case 'line':
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case 'triangle':
        addNewShape(_obj);
        break;

      case 'segment':
      case 'segmentDash':
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case 'ray':
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case 'perpendicularLine':
        updatePLinePoints(addNewShape(_obj));
        break;

      case 'parallelLine':
        updatePLinePoints(addNewShape(_obj));
        break;

      case 'length':
        _obj.labelAlign = 'center';
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case 'polygonShape':
        addNewShape(_obj);
        break;

      case 'angle':
      case 'angleRay':
      case 'angleB':
        addNewShape(_obj);
        break;

      case 'mirrorOnLine':
      case 'semiCircle':
      case 'square':
        addNewShape(_obj);

      default:
        break;
    }

    updateAllShapes();
    saveData();
    return _obj.uniqueId;
  };

  function checkForConnection(_obj) {
    if (_obj.type === 'line' || _obj.type === 'ray' || _obj.type === 'length') {
      modelObj.interactionElements.forEach(function (shape) {
        if (shape.type === 'point') {
          if (shape.x === _obj.x && shape.y === _obj.y) {
            _obj.firstPointId = shape.uniqueId;

            _obj.connectionId.push(_obj.firstPointId);
          }

          if (shape.x === _obj.xTo && shape.y === _obj.yTo) {
            _obj.secondPointId = shape.uniqueId;

            _obj.connectionId.push(_obj.secondPointId);
          }
        }
      });
    }
  }

  this.removeIncompleteShape = function () {
    if (!localObj.mouseDown.lastShapeCompleted) {
      _this.removeUnplotedShapes();
    } else {
      clearScreen(false);
    }
  };

  this.removeUnplotedShapes = function () {
    var saveData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    removeShapes(localObj.newPlottedShapes, saveData);
    clearScreen(true);
  };

  function clearScreen(closeThePanel) {
    localObj.newPlottedShapes = [];
    localObj.mouseDown.lastShapeCompleted = true;
    modelObj.waiting = false;

    if (closeThePanel) {
      if (typeof events.angleSize !== 'undefined') {
        events.angleSize({
          id: modelObj.id,
          type: 'angleSize',
          visible: false
        }, true);
      }

      if (typeof events.segSize !== 'undefined') {
        events.segSize({
          id: modelObj.id,
          type: 'segSize',
          visible: false
        }, true);
      }

      if (typeof events.circleSize !== 'undefined') {
        events.circleSize({
          id: modelObj.id,
          type: 'circleSize',
          visible: false
        }, true);
      }

      if (typeof events.labelTool !== 'undefined') {
        events.labelTool({
          id: modelObj.id,
          type: 'labelTool',
          visible: false
        }, true);
        switchSelectedShapeForLabel();
      }
    }
  }

  function switchSelectedShapeForLabel() {
    var shapes = modelObj.interactionElements;
    shapes.forEach(function (shape) {
      if (shape.isSelectedForLabel !== undefined && shape.isSelectedForLabel) {
        shape.isSelectedForLabel = false;
      }
    });
  }

  function clearCache() {
    modelObj.waiting = false;

    _this.removeIncompleteShape();

    localObj.newPlottedShapes = [];

    if (modelObj.interactionType !== 'select') {
      for (var i = 0; i < modelObj.interactionElements.length; i++) {
        modelObj.interactionElements[i].isSelected = false;
        localObj.selectedItemsCount = 0;
        localObj.selectFlag = true;
      }
    }

    localObj.itemCount = 0;
    scaleObj.visible = modelObj.interactionType === 'scale';
  }

  function removeShapesV2(data) {
    var _loop2 = function _loop2(i) {
      var _shape$shape$connecti;

      var shape = findShape(data[i]);

      if (shape && shape.index !== undefined) {
        removeShapeV2(data[i]);
      }

      if (shape && ((_shape$shape$connecti = shape.shape.connectionId) === null || _shape$shape$connecti === void 0 ? void 0 : _shape$shape$connecti.length) > 0) {
        shape.shape.connectionId.forEach(function (id) {
          var connectedShape = findShape(id).shape;

          if (connectedShape && (connectedShape.type !== 'point' || connectedShape.type === 'point' && (connectedShape === null || connectedShape === void 0 ? void 0 : connectedShape.dontDrag) && (shape.shape.midPointId !== undefined || shape.shape.mirrorOnPointId !== undefined || shape.shape.mirrorOnLineId !== undefined))) {// removeShapes([id]);
            // removeShape(id);
          }
        });
      }
    };

    for (var i = 0; i < data.length; i++) {
      _loop2(i);
    }

    clearCache();
    saveData();
  }

  function removeShapes(data) {
    var saveData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var _loop3 = function _loop3(i) {
      var _shape$shape$connecti2;

      var shape = findShape(data[i]);

      if (shape && shape.index !== undefined) {
        removeShape(data[i]);
      }

      if (shape && ((_shape$shape$connecti2 = shape.shape.connectionId) === null || _shape$shape$connecti2 === void 0 ? void 0 : _shape$shape$connecti2.length) > 0) {
        shape.shape.connectionId.forEach(function (id) {
          var connectedShape = findShape(id).shape;

          if (connectedShape && (connectedShape.type !== 'point' || connectedShape.type === 'point' && (connectedShape === null || connectedShape === void 0 ? void 0 : connectedShape.dontDrag) && (shape.shape.midPointId !== undefined || shape.shape.mirrorOnPointId !== undefined || shape.shape.mirrorOnLineId !== undefined))) {
            // removeShapes([id]);
            removeShape(id);
          }
        });
      }
    };

    for (var i = 0; i < data.length; i++) {
      _loop3(i);
    }

    if (saveData) {
      saveData();
    }
  }

  function callerName() {
    try {
      throw new Error();
    } catch (e) {
      try {
        return e.stack.split('at ')[3].split(' ')[0]; // return e.stack;
      } catch (e) {
        return '';
      }
    }
  }

  function removeShapeV2(id) {
    var shapeData = modelObj.interactionElements;
    var data = findShape(id);
    var shape = data.shape;
    var index = data.index;

    if (shape) {
      shapeData[index] = null;
      modelObj.interactionElements = shapeData.filter(function (e) {
        return e !== null;
      });
    }

    if (shape) {
      var connectionId = shape.connectionId;

      if (connectionId) {
        connectionId.forEach(function (conId, conIndex) {
          var connectedShape = findShape(conId).shape;

          if (connectedShape && (connectedShape.type !== 'point' || connectedShape.type === 'point' && (connectedShape === null || connectedShape === void 0 ? void 0 : connectedShape.dontDrag) && (shape.midPointId !== undefined || shape.mirrorOnPointId !== undefined || shape.mirrorOnLineId !== undefined || shape.squareId !== undefined) || connectedShape.type === 'point' && connectedShape.firstPointId !== undefined && connectedShape.segDistance !== undefined)) {
            removeShapeV2(conId);
          }
        });
      }
    } //removing related items like having parameter,intersection.


    modelObj.interactionElements.forEach(function (shape, index) {
      if (shape !== null && shape.isParameter) {
        if (shape.line !== undefined) {
          removeParamInterShape(shape, 'line');
        } else if (shape.circle !== undefined) {
          removeParamInterShape(shape, 'circle');
        }
      } else if (shape !== null && shape.isIntersection) {
        if (shape.l1 !== undefined || shape.l2 !== undefined) {
          removeParamInterShape(shape, 'l1');
          removeParamInterShape(shape, 'l2');
        } else if (shape.line !== undefined || shape.circle !== undefined) {
          removeParamInterShape(shape, 'line');
          removeParamInterShape(shape, 'circle');
        } else if (shape.circle1 !== undefined || shape.circle2 !== undefined) {
          removeParamInterShape(shape, 'circle1');
          removeParamInterShape(shape, 'circle2');
        }
      }
    }); // updateAllPointsSplCase();
    // modelObj.interactionElements.forEach((_shape,index)=> {
    //   // console.log('->->',_shape,'<-<-',shape);
    //   if(_shape.type === 'point' && _shape.isIntersection && _shape.circle !== undefined && _shape.line !== undefined && _shape.uniqueId !== shape.uniqueId && _shape.x === shape.x && _shape.y === shape.y) {
    //     console.log(shape,'<-<<<<<<', _shape.x , _shape.y,shape.x , shape.y,'->_>>>>>>',_shape);
    //     removeShapeV2(_shape.uniqueId)
    //   }
    // })
    // clearCache();
    // saveData();
  }

  function removeParamInterShape(shape, parameter) {
    var paramShape = findShape(shape[parameter]);

    if (paramShape === false) {
      removeShapeV2(shape.uniqueId);
    }
  }

  function removeShape(id) {
    var shapeData = modelObj.interactionElements;
    var data = findShape(id);
    var shape = data.shape;
    var index = data.index;

    if (shape) {
      var connectionId = shape.connectionId;

      if (connectionId) {
        connectionId.forEach(function (cd) {
          shapeData.forEach(function (sd) {
            var checkingShape = sd;

            if (checkingShape && checkingShape.uniqueId === cd) {
              if (checkingShape.isDeletable === undefined || checkingShape.isDeletable === false) {
                if (checkingShape.connectionId !== undefined && checkingShape.connectionId.length > 1) {
                  var _index2 = checkingShape.connectionId.indexOf(shape.uniqueId);

                  if (_index2 > -1) {
                    checkingShape.connectionId.splice(_index2, 1);
                  }

                  if (checkType(checkingShape, ['line', 'segment', 'segmentDash', 'ray'])) {
                    if (checkingShape.firstPointId === shape.uniqueId || checkingShape.secondPointId === shape.uniqueId) {
                      checkingShape.connectionId.forEach(function (elem) {
                        var connectedShape = findShape(elem).shape;

                        if (connectedShape) {
                          var _index = connectedShape.connectionId.indexOf(checkingShape.uniqueId);

                          if (_index2 > -1) {
                            connectedShape.connectionId.splice(_index, 1);
                          }
                        }
                      });
                      sd = null;
                    }
                  }
                }
              }
            }
          });
        });
      }

      shapeData[index] = null;
      modelObj.interactionElements = shapeData.filter(function (e) {
        return e !== null;
      });
      clearCache(); // saveData();
    }
  } // =================================================


  this.updateIndex = function (_obj) {
    var value = JSON.parse(JSON.stringify(_obj.data));
    var shapeData = findShape(value.uniqueId);
    var currentShape = shapeData.shape;
    var actionType = _obj.type;

    if (actionType === 'remove') {
      removeShape(value.uniqueId);
    } else if (actionType === 'update') {
      if (currentShape) {
        Object.keys(value).forEach(function (i) {
          currentShape[i] = value[i];
        });
      }

      var type = value.type;

      if (modelObj.interactionType === 'scale') {
        scaleObj.x = isNaN(value.x) ? scaleObj.x : value.x;
        scaleObj.y = isNaN(value.y) ? scaleObj.y : value.y;
        scaleObj.xTo = isNaN(value.xTo) ? scaleObj.xTo : value.xTo;
        scaleObj.yTo = isNaN(value.yTo) ? scaleObj.yTo : value.yTo;
        dispatchEventScale();
      } else if (type === 'point') {
        currentShape.x = value.x;
        currentShape.y = value.y;

        if (typeof value.label !== 'undefined') {
          currentShape.label = value.label;
          updatePoints(currentShape);
        }
      } // else if (type === 'midPoint') {
      //   // if (typeof (value.label) !== 'undefined') {
      //   //   currentShape.label = value.label;
      //   //   updatePoints(currentShape);
      //   // }
      // } 
      else if (type.includes('segment')) {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.xTo = value.xTo;
          currentShape.yTo = value.yTo;
        } else if (type === 'line' || type === 'ray') {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.xTo = value.xTo;
          currentShape.yTo = value.yTo;

          if (value.label) {
            currentShape.label = value.label;
          }

          if (currentShape.connectionId) {
            for (var i = 0; i < currentShape.connectionId.length; i++) {
              var _shapeData = findShape(currentShape.connectionId[i]);

              if (_shapeData.shape && _shapeData.shape.type === 'point' && _shapeData.shape.uniqueId === currentShape.firstPointId) {
                _shapeData.shape.x = currentShape.x;
                _shapeData.shape.y = currentShape.y;
              }

              if (_shapeData.shape && _shapeData.shape.type === 'point' && _shapeData.shape.uniqueId === currentShape.secondPointId) {
                _shapeData.shape.x = currentShape.xTo;
                _shapeData.shape.y = currentShape.yTo;
              }
            }
          }

          updateLinePoints(currentShape);
        } else if (type === 'circle') {
          Object.keys(value).forEach(function (i) {
            currentShape[i] = value[i];
          });
        } else if (type === 'circle_3') {} else if (type === 'perpendicularLine' || type === 'parallelLine') {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.slope = value.slope;

          if (currentShape.connectionId) {
            currentShape.connectionId.forEach(function (id) {
              var shapeData = findShape(id);

              if (shapeData.shape && shapeData.shape.type === 'point') {
                shapeData.shape.x = currentShape.x;
                shapeData.shape.y = currentShape.y;
              }
            });
          }

          updatePLinePoints(currentShape);
        }
    }

    saveData();
  }; // =================================================


  this.draw = function () {
    var _ctx = modelObj.context;
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height,
        transperent = modelObj.transperent,
        interactionElements = modelObj.interactionElements,
        segmentColor = modelObj.segmentColor,
        fontSize = modelObj.fontSize,
        pointColor = modelObj.pointColor,
        interactionType = modelObj.interactionType,
        pointLabelColor = modelObj.pointLabelColor;

    if (modelObj.visible) {
      _ctx.save();

      _ctx.beginPath();

      _ctx.globalAlpha = transperent ? 0.5 : 1; // --------------------------------------

      _ctx.save();

      _ctx.fillStyle = '#000000';

      _ctx.rect(x, y, width, height);

      _ctx.clip();

      drawShapes(_ctx, modelObj);

      if (scaleObj.visible) {
        _ctx.save();

        _ctx.fillStyle = scaleObj.pointColor;
        _ctx.strokeStyle = scaleObj.segmentColor;
        _ctx.lineWidth = scaleObj.segmentWidth;

        _ctx.beginPath();

        _ctx.moveTo(scaleObj.x, scaleObj.y);

        _ctx.lineTo(scaleObj.xTo, scaleObj.yTo);

        _ctx.stroke();

        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.x, scaleObj.y, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.xTo, scaleObj.yTo, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.restore();
      }

      if (localObj.mouseDown.isMouseDown && interactionType === 'select' && localObj.currentUniqueId === null) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.fillStyle = 'rgba(69,146,176,0.1)';
        _ctx.strokeStyle = 'rgba(69,146,176,0.8)';
        var _localObj$mouseDown = localObj.mouseDown,
            orignalX = _localObj$mouseDown.orignalX,
            orignalY = _localObj$mouseDown.orignalY,
            _x3 = _localObj$mouseDown.x,
            _y3 = _localObj$mouseDown.y;

        _ctx.rect(orignalX, orignalY, _x3 - orignalX, _y3 - orignalY);

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        _ctx.restore();
      }

      _ctx.restore(); // --------------------------------------


      _ctx.closePath();

      _ctx.restore(); // --------------------------------------


      _ctx.save();

      var _modelObj$screen = modelObj.screen,
          sx = _modelObj$screen.x,
          sy = _modelObj$screen.y,
          sw = _modelObj$screen.w,
          sh = _modelObj$screen.h;
      _ctx.fillStyle = '#000000';

      _ctx.beginPath();

      _ctx.moveTo(sx, sy);

      _ctx.lineTo(sx, sy + sh);

      _ctx.lineTo(sx + sw, sy + sh);

      _ctx.lineTo(sx + sw, sy);

      _ctx.closePath();

      _ctx.clip();

      drawPoints(_ctx, modelObj);

      _ctx.restore(); // --------------------------------------
      // --------------------------------------


      _ctx.save();

      _ctx.fillStyle = '#000000';

      _ctx.beginPath();

      _ctx.moveTo(x, y);

      _ctx.lineTo(x, y + height);

      _ctx.lineTo(x + width, y + height);

      _ctx.lineTo(x + width, y);

      _ctx.closePath();

      _ctx.clip();

      if (!transperent) {
        drawlabels(_ctx, modelObj);
      }

      _ctx.restore(); // --------------------------------------

    }
  };

  function drawPoints(_ctx, _ref) {
    var x = _ref.x,
        y = _ref.y,
        height = _ref.height,
        interactionElements = _ref.interactionElements;
    interactionElements.forEach(function (item) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === 'point') {
          var draw = true;

          if (modelObj.showQuadrants === '1') {
            if (_xy.x < x || _xy.y > y + height) {
              draw = false;
            }
          }

          if (draw) {
            drawPoint(_ctx, item, true, false);
          }
        } // if (item.type === 'midPoint') {
        //   let draw = true;
        //   if (modelObj.showQuadrants === '1') {
        //     if (_xy.x < x || _xy.y > (y + height)) {
        //       draw = false;
        //     }
        //   }
        //   if (draw) {
        //     drawPoint(_ctx, item, true, false);
        //   }
        // }

      }
    });
  }

  function drawlabels(_ctx, _ref2) {
    var interactionElements = _ref2.interactionElements,
        pointLabelColor = _ref2.pointLabelColor,
        fontSize = _ref2.fontSize,
        lengthLabelColor = _ref2.lengthLabelColor;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === 'point') {
          // If a label(visible property) for particular point is to be changed.
          var pointLabelVisible = item.labelVisible !== undefined ? item.labelVisible : true;
          drawPoint(_ctx, item, false, pointLabelVisible && modelObj.shapes.point.label.visible);
        }

        if (item.type === 'length') {
          if (item.label) {
            // if (item.isSelected || item.isSelectedForLabel) {
            //   _ctx.lineWidth = item.isSelected ? 2 : 3; 
            // }
            var center = getPixelByPoint(item.labelX, item.labelY);
            center.x += item.labelDiffX;
            center.y += item.labelDiffY;

            _ctx.save();

            _ctx.beginPath();

            _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
            var textSize = _ctx.measureText(item.distanceText).width + fontSize / 2; // _ctx.fillStyle = 'rgba(255,255,255,1)';
            // _ctx.strokeStyle = 'rgba(199,199,199,1)';
            // _ctx.rect(center.x - textSize / 2, center.y - fontSize * 1.2, textSize, fontSize * (modelObj.labelBGRatio + 0.1));
            // _ctx.fill();
            // _ctx.stroke();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.textBaseline = 'bottom';
            _ctx.textAlign = 'center';
            _ctx.fillStyle = lengthLabelColor;

            _ctx.drawStyledText(item.label, center.x, center.y, modelObj.LabComClass.polo22KlettRegular, fontSize);

            _ctx.closePath();

            _ctx.restore();
          }
        }

        if (item.type === 'square' && modelObj.shapes.square.label.visible) {
          if (item.label) {
            var p = getPixelByPoint(item.labelX, item.labelY);
            var color = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            var _center = getPixelByPoint(item.labelX, item.labelY);

            _center.x += item.labelDiffX;
            _center.y += item.labelDiffY;

            _ctx.save();

            _ctx.beginPath();

            _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;

            var _textSize = _ctx.measureText(item.label).width + fontSize / 2;

            _ctx.fillStyle = 'rgba(255,255,255,1)';
            _ctx.strokeStyle = 'rgba(199,199,199,1)';

            _ctx.rect(_center.x - _textSize * 0.25, _center.y - fontSize * 1.2, _textSize * 0.65, fontSize * (modelObj.labelBGRatio + 0.1));

            _ctx.fill();

            _ctx.stroke();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.textBaseline = 'bottom';
            _ctx.textAlign = 'center';
            _ctx.fillStyle = lengthLabelColor;

            _ctx.drawStyledText(item.label, _center.x, _center.y, modelObj.LabComClass.polo22KlettRegular, fontSize); // drawStroked({
            //   ctx: _ctx,
            //   text: item.label,
            //   x: p.x,
            //   y: p.y,
            //   fillColor: color,
            //   center: true,
            //   diffX: Number(item.labelDiffX),
            //   diffY: Number(item.labelDiffY)
            // });


            _ctx.closePath();

            _ctx.restore();
          }
        }

        if (item.type.includes('segment') || checkType(item, ['angle', 'angleSize', 'line', 'ray', 'perpendicularLine', 'parallelLine', 'angleRay']) || item.type.includes('circle') || item.type.includes('compass')) {
          var showLable = true;

          if (modelObj.shapes.hasOwnProperty(item.type)) {
            if (modelObj.shapes[item.type].hasOwnProperty('label') && modelObj.shapes[item.type].label.hasOwnProperty('visible') && !modelObj.shapes[item.type].label.visible) {
              showLable = false;
            }
          }

          if (showLable && item.label !== undefined && item.labelX !== undefined && item.type !== 'angleSize') {
            var _p = getPixelByPoint(item.labelX, item.labelY);

            var _color2 = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            drawStroked({
              ctx: _ctx,
              text: item.label,
              x: _p.x,
              y: _p.y,
              fillColor: _color2,
              center: true,
              diffX: Number(item.labelDiffX),
              diffY: Number(item.labelDiffY)
            });
          } else if (showLable && item.label !== undefined && item.labelX !== undefined && item.type === 'angleSize') {
            var angle = modelObj.LabComClass.Maths.getAngle(item.x, item.y, item.xTo, item.yTo);
            var degree = item.degree * (item.clockwise ? -1 : 1); // let angleTextPos = modelObj.LabComClass.Maths.getPoint(item, angle + (degree / 2) * Math.PI / 180, getPointUnitByPixelUnit(25));

            var _p2 = getPixelByPoint(item.labelX, item.labelY);

            var _color3 = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            drawStroked({
              ctx: _ctx,
              text: item.label.replace('.', ','),
              x: _p2.x,
              y: _p2.y,
              fillColor: _color3,
              center: true,
              diffX: Number(item.labelDiffX),
              diffY: Number(item.labelDiffY)
            });
          }
        }
      }
    });
  }

  function reduceLineEnd(p1, p2, r) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var mag = Math.hypot(dx, dy);
    return {
      x: p2.x - r * dx / mag,
      y: p2.y - r * dy / mag
    };
  }

  function drawArrowHead(_ctx, _xy, _xTo_yTo) {
    var headlen = 10; // length of head in pixels

    var angle = modelObj.LabComClass.Maths.getAngle(_xy.x, _xy.y, _xTo_yTo.x, _xTo_yTo.y);
    var newPosition = reduceLineEnd(_xy, _xTo_yTo, modelObj.pointRadius);

    _ctx.save();

    _ctx.beginPath();

    _ctx.moveTo(newPosition.x, newPosition.y);

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle - Math.PI / 6), newPosition.y - headlen * Math.sin(angle - Math.PI / 6));

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle + Math.PI / 6), newPosition.y - headlen * Math.sin(angle + Math.PI / 6));

    _ctx.lineTo(newPosition.x, newPosition.y);

    _ctx.stroke();

    _ctx.fill();

    _ctx.closePath();

    _ctx.restore();
  }

  function drawShapes(_ctx, _ref3) {
    var interactionElements = _ref3.interactionElements,
        segmentColor = _ref3.segmentColor,
        fontSize = _ref3.fontSize,
        pointLabelColor = _ref3.pointLabelColor;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      var _xTo_yTo = item.xTo !== undefined ? getPixelByPoint(item.xTo, item.yTo) : null;

      var _xOr_yOr = item.xOr !== undefined ? getPixelByPoint(item.xOr, item.yOr) : null;

      var _xOrTo_yOrTo = item.xOrTo !== undefined ? getPixelByPoint(item.xOrTo, item.yOrTo) : null;

      if (item.visible) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.strokeStyle = segmentColor;
        _ctx.fillStyle = segmentColor;

        if (item.strokeColor) {
          _ctx.strokeStyle = item.strokeColor;
        }

        if (item.fillColor) {
          _ctx.fillStyle = item.fillColor;
        }

        if (item.lineWidth) {
          _ctx.lineWidth = item.lineWidth;
        }

        if (item.isSelected) {
          _ctx.lineWidth = item.type === 'triangle' ? 2 : 3;
        }

        if (item.isSelectedForLabel) {
          _ctx.lineWidth = 3;
        }

        if (modelObj.finalView) {
          _ctx.fillStyle = modelObj.finalColor;
          _ctx.strokeStyle = modelObj.finalColor;
        }

        if (item.type === 'point') {// drawPoint(_ctx, item, true, false);
        } else if (item.type.includes('segment')) {
          _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = 'bottom';
          _ctx.textAlign = 'left';

          if (item.type.includes('segmentDash')) {
            _ctx.setLineDash([6, 4]);
          }

          _ctx.moveTo(_xy.x, _xy.y);

          _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

          _ctx.stroke();

          if (item.arrowHead) {
            if (modelObj.LabComClass.Maths.getDistance(_xy, _xTo_yTo) > modelObj.pointRadius * 3) {
              drawArrowHead(_ctx, _xy, _xTo_yTo);
            }
          }

          if (modelObj.shapes.segment.segDistanceLabel && item.distance && modelObj.interactionType !== 'select' && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted) && modelObj.interactionType !== 'move' && !modelObj.interactionType.includes('brush') && !modelObj.interactionType === 'delete' && modelObj.interactionType !== 'labelTool') {
            var val = item.distance === undefined ? 0 : item.distance;

            if (modelObj.shapes.segment.digit !== undefined) {
              val = val.toFixed(modelObj.shapes.segment.digit).replace('.', ',');
            } // val = Number(val.toFixed(modelObj.shapes.segment.digit));


            var gap = fontSize / 3;
            var x = (_xy.x + _xTo_yTo.x) / 2.05;
            var h = fontSize;
            var y = (_xy.y + _xTo_yTo.y) / 2 + gap;

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = 'rgba(255,255,255,1)';

            _ctx.rect(x, y, _ctx.measureText(val).width + gap * 2, h);

            _ctx.fill();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.fillStyle = pointLabelColor;

            _ctx.fillText(val, x + gap, y + h * 1.05);

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'length') {
          if (item.secondPointId === undefined && item.mode === 'normal') {
            _ctx.save();

            _ctx.beginPath();

            _ctx.setLineDash([5, 15]);

            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

            _ctx.stroke();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'compass') {
          if (!item.isPloted) {
            _ctx.strokeStyle = segmentColor;

            _ctx.setLineDash([3, 3]);

            _ctx.lineWidth = 2;

            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          } else {
            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          }
        } else if (item.type === 'triangle') {
          if (item.thirdSegmentPlotted) {
            var p1 = getPixelByPoint(item.firstPoint.x, item.firstPoint.y);
            var p2 = getPixelByPoint(item.secondPoint.x, item.secondPoint.y);
            var p3 = getPixelByPoint(item.thirdPoint.x, item.thirdPoint.y);

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = item.fillColor ? item.fillColor : modelObj.shapes.defBgFill;

            _ctx.moveTo(p1.x, p1.y);

            _ctx.lineTo(p2.x, p2.y);

            _ctx.lineTo(p3.x, p3.y);

            _ctx.lineTo(p1.x, p1.y);

            _ctx.stroke();

            _ctx.fill();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'square') {
          if (item.secondPointPlotted) {
            var _p3 = getPixelByPoint(item.firstPoint.x, item.firstPoint.y);

            var _p4 = getPixelByPoint(item.secondPoint.x, item.secondPoint.y);

            var _p5 = getPixelByPoint(item.thirdPoint.x, item.thirdPoint.y);

            var p4 = getPixelByPoint(item.fourthPoint.x, item.fourthPoint.y);

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = item.fillColor ? item.fillColor : modelObj.shapes.defBgFill;
            _ctx.strokeStyle = item.strokeColor ? item.strokeColor : modelObj.pointColor;

            _ctx.moveTo(_p3.x, _p3.y);

            _ctx.lineTo(_p4.x, _p4.y);

            _ctx.lineTo(_p5.x, _p5.y);

            _ctx.lineTo(p4.x, p4.y);

            _ctx.lineTo(_p3.x, _p3.y);

            _ctx.stroke();

            _ctx.fill();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'line') {
          _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

          _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

          _ctx.stroke();
        } else if (item.type === 'ray') {
          if (_xy.x !== _xTo_yTo.x || _xy.y !== _xTo_yTo.y) {
            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.stroke();
          }
        } else if (item.type === 'circle_3') {
          var fp = findShape(item.firstPointId).shape;
          var sp = findShape(item.secondPointId).shape;
          var tp = findShape(item.thirdPointId).shape;

          if ((fp === null || fp === void 0 ? void 0 : fp.visible) && (sp === null || sp === void 0 ? void 0 : sp.visible) && (!item.thirdPointPloted || (tp === null || tp === void 0 ? void 0 : tp.visible))) {
            _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
            _ctx.textBaseline = 'bottom';
            _ctx.textAlign = 'left';

            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          }
        } else if (item.type === 'circle') {
          var _fp = findShape(item.firstPointId).shape;
          var _sp = findShape(item === null || item === void 0 ? void 0 : item.secondPointId).shape;

          if (_fp !== undefined && _sp !== undefined) {
            if (_fp.visible && _sp.visible && item.circleSize !== undefined || _fp.visible && _sp.visible && item.circleSize == undefined) {
              _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
              _ctx.textBaseline = 'bottom';
              _ctx.textAlign = 'left';

              _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

              _ctx.stroke();

              if (modelObj.shapes.circle.circleDistanceLabel && item.r && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted)) {
                var _val = Number(item.r);

                if (modelObj.shapes.circle.digit !== undefined) {
                  _val = _val.toFixed(modelObj.shapes.circle.digit).replace('.', ',');
                }

                var _gap = fontSize / 3;

                var _x4 = _xy.x;
                var _h = fontSize;

                var _y4 = _xy.y + _gap;

                _ctx.save();

                _ctx.beginPath();

                _ctx.fillStyle = 'rgba(255,255,255,1)';

                _ctx.rect(_x4, _y4, _ctx.measureText(_val).width + _gap * 2, _h);

                _ctx.fill();

                _ctx.closePath();

                _ctx.beginPath();

                _ctx.fillStyle = pointLabelColor;

                _ctx.fillText(_val, _x4 + _gap, _y4 + _h * 1.05);

                _ctx.closePath();

                _ctx.restore();
              }
            }
          } else {
            if (_fp !== undefined && _fp.visible && item.circleSize !== undefined || _fp.visible && item.circleSize == undefined) {
              _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
              _ctx.textBaseline = 'bottom';
              _ctx.textAlign = 'left';

              _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

              _ctx.stroke();

              if (modelObj.shapes.circle.circleDistanceLabel && item.r && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted)) {
                var _val2 = Number(item.r);

                if (modelObj.shapes.circle.digit !== undefined) {
                  _val2 = _val2.toFixed(modelObj.shapes.circle.digit).replace('.', ',');
                }

                var _gap2 = fontSize / 3;

                var _x5 = _xy.x;
                var _h2 = fontSize;

                var _y5 = _xy.y + _gap2;

                _ctx.save();

                _ctx.beginPath();

                _ctx.fillStyle = 'rgba(255,255,255,1)';

                _ctx.rect(_x5, _y5, _ctx.measureText(_val2).width + _gap2 * 2, _h2);

                _ctx.fill();

                _ctx.closePath();

                _ctx.beginPath();

                _ctx.fillStyle = pointLabelColor;

                _ctx.fillText(_val2, _x5 + _gap2, _y5 + _h2 * 1.05);

                _ctx.closePath();

                _ctx.restore();
              }
            }
          }
        } else if (item.type === 'semiCircle') {
          _ctx.beginPath();

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), -item.startAngle, -item.endAngle);

          _ctx.stroke();

          _ctx.closePath();
        } else if (item.type === 'angleRay') {
          _ctx.translate(_xy.x, _xy.y);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.stroke();
        } else if (item.type === 'angle' || item.type === 'angleSize') {
          _ctx.globalAlpha = 0.5;

          _ctx.translate(_xy.x, _xy.y);

          _ctx.beginPath();

          _ctx.moveTo(0, 0);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.fill();

          _ctx.closePath();

          if ((item.angleValue === 90 || item.degree === 90) && (modelObj.shapes.angle.dotOn90 || modelObj.shapes.angleSize.dotOn90)) {
            var _p6 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.endAngle, 16);

            var _p7 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.startAngle, 16);

            _ctx.beginPath();

            _ctx.strokeStyle = '#000000';
            _ctx.fillStyle = '#000000';

            _ctx.arc((_p7.x + _p6.x) / 2, (_p7.y + _p6.y) / 2, 2, 0, Math.PI * 2);

            _ctx.fill();

            _ctx.closePath();
          }

          _ctx.stroke();
        } else if (item.type === 'perpendicularLine' || item.type === 'parallelLine') {
          if (_xOr_yOr !== null && !isNaN(_xOr_yOr.x)) {
            _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

            _ctx.stroke();
          }
        } else if (item.type === 'polygonShape') {
          _ctx.fillStyle = item.fillColor ? item.fillColor : modelObj.shapes.defBgFill;
          item.path.forEach(function (elem, i) {
            var p = getPixelByPoint(elem.x, elem.y);

            if (i === 0) {
              _ctx.moveTo(p.x, p.y);
            }

            _ctx.lineTo(p.x, p.y);
          });

          _ctx.fill();
        }

        _ctx.closePath();

        _ctx.restore();
      }
    });
  }

  function drawStroked(_ref4) {
    var ctx = _ref4.ctx,
        text = _ref4.text,
        x = _ref4.x,
        y = _ref4.y,
        fillColor = _ref4.fillColor,
        _ref4$diffX = _ref4.diffX,
        diffX = _ref4$diffX === void 0 ? 0 : _ref4$diffX,
        _ref4$diffY = _ref4.diffY,
        diffY = _ref4$diffY === void 0 ? 0 : _ref4$diffY;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = 'rgba(255,255,255,1)';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'miter'; // Experiment with "bevel" & "round" for the effect you want!

    ctx.miterLimit = 2; // if (center) {
    //   x -= (ctx.measureText(text).width / 2);
    //   y -= 5;
    // }

    y += modelObj.fontSize * 0.6; // }
    // ctx.strokeText(text, x + diffX, y + diffY);
    // ctx.fillText(text, x + diffX, y + diffY);

    ctx.drawStyledText(text, x + diffX, y + diffY, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
    ctx.closePath();
    ctx.restore();
  }

  function drawPoint(_ctx, item, _drawShape, _drawText) {
    var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

    _ctx.beginPath();

    if (_drawShape) {
      _ctx.fillStyle = modelObj.pointColor;

      if (item.fillColor) {
        _ctx.fillStyle = item.fillColor;
      }

      if (modelObj.finalView) {
        _ctx.fillStyle = modelObj.finalColor;
        _ctx.strokeStyle = modelObj.finalColor;
      }

      _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius, 0, 2 * Math.PI);

      _ctx.fill();

      _ctx.closePath();

      if (item.isSelected || item.isSelectedForLabel) {
        _ctx.beginPath();

        _ctx.strokeStyle = item.strokeColor !== undefined ? item.strokeColor : modelObj.pointColor;

        if (item.isSelected) {
          _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius + 2, 0, 2 * Math.PI);
        } else {
          _ctx.lineWidth = 2;

          _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius + 3, 0, 2 * Math.PI);
        }

        _ctx.stroke();

        _ctx.closePath();
      }
    }

    if (item.label !== undefined && _drawText) {
      if (item.labelX === undefined) {
        item.labelX = item.x;
        item.labelY = item.y;
        item.labelDiffX = 0;
        item.labelDiffY = 0;
      }

      var labelPos = getPixelByPoint(item.labelX, item.labelY);
      var color = item.fillLabelColor ? item.fillLabelColor : modelObj.pointLabelColor;
      drawStroked({
        ctx: _ctx,
        text: item.label,
        x: labelPos.x,
        y: labelPos.y,
        fillColor: color,
        center: false,
        diffX: Number(item.labelDiffX),
        diffY: Number(item.labelDiffY)
      });
    }
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function addEvents() {
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });

    if (modelObj.eventsEnable) {
      if (modelObj.interactionType !== null) {
        if (modelObj.state && modelObj.visible) {
          if (modelObj.interactionType === 'scale') {
            _eventDataObj.r.push({
              id: 'scale1',
              arc: {
                x: scaleObj.x,
                y: scaleObj.y,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            }, {
              id: 'scale2',
              arc: {
                x: scaleObj.xTo,
                y: scaleObj.yTo,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            });
          } else {
            _eventDataObj.r.push({
              id: 0,
              rect: {
                x: modelObj.screen.x,
                y: modelObj.screen.y,
                w: modelObj.screen.w,
                h: modelObj.screen.h
              },
              eventListener: mouseHandle.bind(this)
            });
          }

          onViewUpdateCls.trigger('onGlobalUpdate', {
            type: 'addMouseEvent',
            data: _eventDataObj
          });
        }
      }
    }
  }

  var d;

  function checkForRightClick(e) {
    localObj.mouseDownData = null;

    if (localObj.isDevice) {
      localObj.mouseDownData = JSON.parse(JSON.stringify(e));
      localObj.mouseDownData.delayCounter = 0;
      modelObj.animClass.start({
        id: 'animation',
        fps: 1,
        frame: checkAfterDelay
      });
    } else {
      executeMouseDown(e);
    }
  }

  function rejectDelay() {
    modelObj.animClass.stop('animation');
    executeMouseDown(localObj.mouseDownData);
    localObj.mouseDownData = null;
  }

  function checkAfterDelay() {
    var mouseDownData = localObj.mouseDownData;
    mouseDownData.delayCounter++;

    if (mouseDownData.delayCounter > 2) {
      modelObj.animClass.stop('animation');

      if (typeof events.rightClick !== 'undefined') {
        events.rightClick({
          id: modelObj.id,
          type: 'rightClick',
          x: mouseDownData.pageX,
          y: mouseDownData.pageY
        }, true);
      }

      mouseDownData = null;
    }
  }

  function executeMouseDown(e) {
    var mouseDown = localObj.mouseDown;
    mouseDown.isMouseDown = true;
    mouseDown.x = e.pageX;
    mouseDown.orignalX = e.pageX;
    mouseDown.y = e.pageY;
    mouseDown.orignalY = e.pageY;
    mouseDown.ogX = e.pageX;
    mouseDown.ogY = e.pageY;
    mouseDown.objectDown = false;
    mouseDown.shapeSelected = selectShapeSpecial(e);
    localObj.selectFlag = true;

    if (mouseDown.lastShapeCompleted) {
      onMouseDown(e);
    }
  } // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        checkForRightClick(e);
        break;

      case 'pressmove':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onPressMove(e);
        break;

      case 'mousemove':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseMove(e);
        break;

      case 'mouseup':
        mouseUpCall(e); // addEvents();

        break;

      case 'rightmouseup':
        if (localObj.mouseDown.isMouseDown) {
          mouseUpCall(e);
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      case 'rightmousedown':
        localObj.mouseDown.isRightMouseDown = true;

        if (typeof events.rightClick !== 'undefined') {
          events.rightClick({
            id: modelObj.id,
            type: 'rightClick',
            x: e.pageX,
            y: e.pageY
          }, true);
        }

        break;

      case 'mouseupout':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseUp(e);
        localObj.mouseDown.isMouseDown = false;

        if (e.subId === 'scale1' || e.subId === 'scale2') {
          addEvents();
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      default:
        break;
    }
  }

  function mouseUpCall(e) {
    if (localObj.mouseDownData !== null) {
      rejectDelay();
    }

    onMouseUp(e);
    localObj.mouseDown.isMouseDown = false;
    localObj.mouseDown.objectDown = false;
    localObj.mouseDown.isRightMouseDown = false;
  }

  function setScaleValues() {
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height;
    scaleObj.originPos = {
      x: x + (width - 280),
      y: y + (height - 40),
      xTo: x + (width - 40),
      yTo: y + (height - 40)
    };
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
  }

  function addPoint(point, _obj) {
    var newShape = {
      type: 'point',
      x: point.x,
      y: point.y,
      label: ''
    };
    Object.keys(_obj).forEach(function (i) {
      newShape[i] = _obj[i];
    });

    if (point.isIntersection || point.isParameter) {
      Object.keys(point).forEach(function (i) {
        newShape[i] = point[i];
      });
    }

    localObj.newPlottedShapes.push(_obj.uniqueId);
    addNewShape(newShape);
  } // =================================================


  function checkSnapping(point, mouseEvent) {
    if (modelObj.showQuadrants === '1' && (point.x < 0 || point.y < 0)) {
      if (Math.abs(point.x) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.x = 0;
      }

      if (Math.abs(point.y) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.y = 0;
      }

      if (point.x < 0 || point.y < 0) {
        return null;
      }
    }

    var snappingPont = JSON.parse(JSON.stringify(point));
    var snappingData = {};
    var snappingFound = false;

    if (modelObj.pointSnapping &&
    /*!pressMove && */
    modelObj.interactionType !== 'move') {
      var pointMinDist = isItCloseToPlotedPoint(snappingPont, true); //returns closest point index, 
      //dist b/w current point (snappiongPont) and the point which is closest, 
      //the data of point which it is closest.
      // console.log('PMD',pointMinDist?.dist,pointMinDist?.plotedPoint.x,pointMinDist?.plotedPoint.y);
      //Checks if the current point is on intersection of lines or circles.

      var intersectionMinDist = isItCloseToIntersectionPoint(snappingPont); // console.log('IMD',intersectionMinDist);
      //checks if the current point is on parameter of circle or compass.

      var intersectionOfParameterMinDist = isItCloseToParameterPoint(snappingPont, mouseEvent); // console.log('IMP',intersectionOfParameterMinDist);
      // closest point is found intersection and parameter is not checked.

      if (intersectionMinDist && !snappingFound) {
        var intersectionCanBeSnapped = true;

        if (pointMinDist) {
          if (intersectionMinDist.dist > pointMinDist.dist) {
            intersectionCanBeSnapped = false;
          }
        }

        if (intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionMinDist.updateKeys;
          snappingFound = true;
        }
      }

      if (intersectionOfParameterMinDist && !snappingFound) {
        var _intersectionCanBeSnapped = true;

        if (snappingData) {
          if (intersectionOfParameterMinDist.dist > snappingData.dist) {
            _intersectionCanBeSnapped = false;
          }
        }

        if (_intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionOfParameterMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionOfParameterMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionOfParameterMinDist.updateKeys;
          snappingFound = true;
        }
      }
    } // check for point, intersection, shape parameter
    // check for snapping grid point


    if (!snappingFound && modelObj.snapToGrid) {
      var _modelObj$graphValues = modelObj.graphValues,
          XunitsPerGrid = _modelObj$graphValues.XunitsPerGrid,
          YunitsPerGrid = _modelObj$graphValues.YunitsPerGrid;
      var mulF = 1;
      var x = Math.round(point.x / (XunitsPerGrid * mulF)) * (XunitsPerGrid * mulF);
      var y = Math.round(point.y / (YunitsPerGrid * mulF)) * (YunitsPerGrid * mulF);

      if (modelObj.LabComClass.Maths.getDistance(point, {
        x: x,
        y: y
      }) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        snappingData = {};
        snappingData.x = x;
        snappingData.y = y;
        snappingFound = true;
      }
    }

    if (snappingFound) {
      Object.keys(snappingData).forEach(function (i) {
        point[i] = snappingData[i];
      });
    } // console.log('SF',snappingFound);


    return point;
  }

  function snapFunction(pointX, pointY) {
    if (modelObj.snapToGrid) {
      var _modelObj$graphValues2 = modelObj.graphValues,
          XunitsPerGrid = _modelObj$graphValues2.XunitsPerGrid,
          YunitsPerGrid = _modelObj$graphValues2.YunitsPerGrid;
      var mulF = 1;
      var snappingDiff = 10;
      var x = Math.round(pointX / (XunitsPerGrid * mulF)) * (XunitsPerGrid * mulF);
      var y = Math.round(pointY / (YunitsPerGrid * mulF)) * (YunitsPerGrid * mulF);
      var snappingData = {};

      if (modelObj.LabComClass.Maths.getDistance({
        x: pointX,
        y: pointY
      }, {
        x: x,
        y: y
      }) < getPointUnitByPixelUnit(snappingDiff)) {
        snappingData.x = x;
        snappingData.y = y;
      }

      return snappingData;
    } else {
      return {
        x: pointX,
        y: pointY
      };
    }
  }

  function addNewShape(_objNew) {
    var _obj = {
      type: modelObj.interactionType,
      step: modelObj.currentStep,
      visible: true
    };
    Object.keys(_objNew).forEach(function (i) {
      _obj[i] = _objNew[i];
    });
    modelObj.interactionElements.push(_obj);
    return _obj;
  }

  function onMouseDown(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    localObj.newPlottedShapes = [];
    var newShapes = localObj.newPlottedShapes;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point, e.type);
    localObj.currentUniqueId = null;
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));

    if (clickingOnExistingPoint !== null) {
      localObj.currentUniqueId = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    localObj.newShapeStarted = false;

    if (tool === 'point' && point !== null) {
      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: ++localObj.uniqueId,
          connectionId: []
        });
        localObj.currentUniqueId = localObj.uniqueId;
      }
    } else if (tool.includes('segment') && point !== null) {
      var firstPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      var segmentId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: firstPointId,
          connectionId: [segmentId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(segmentId);
      }

      addNewShape({
        uniqueId: segmentId,
        firstPointId: firstPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [firstPointId]
      });
      localObj.currentUniqueId = segmentId;
      newShapes.push(segmentId);
    } else if (tool === 'length') {
      if (clickingOnExistingPoint !== null && point !== null) {
        var lengthId = ++localObj.uniqueId;
        var _firstPointId = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(lengthId);
        addNewShape({
          uniqueId: lengthId,
          firstPointId: _firstPointId,
          x: point.x,
          y: point.y,
          xTo: point.x,
          yTo: point.y,
          labelAlign: 'center',
          mode: 'normal'
        });
        localObj.currentUniqueId = lengthId;
        newShapes.push(lengthId);
      } else {
        var selectedShapeID = selectShape(e);

        if (selectedShapeID) {
          var shapeData = findShape(selectedShapeID);

          if (shapeData.shape && shapeData.shape.type.includes('segment')) {
            var _lengthId = ++localObj.uniqueId;

            shapeData.shape.lengthId = _lengthId;
            shapeData.shape.connectionId.push(_lengthId);
            addNewShape({
              uniqueId: _lengthId,
              segmentID: selectedShapeID,
              x: shapeData.shape.x,
              y: shapeData.shape.y,
              xTo: shapeData.shape.xTo,
              yTo: shapeData.shape.yTo,
              labelAlign: 'center',
              mode: 'segment'
            });
            localObj.currentUniqueId = _lengthId;
            newShapes.push(_lengthId);
          } else if (shapeData.shape && (shapeData.shape.type === 'circle' || shapeData.shape.type === 'circle_3' || shapeData.shape.type === 'compass')) {
            var _lengthId2 = ++localObj.uniqueId;

            shapeData.shape.connectionId.push(_lengthId2);
            addNewShape({
              uniqueId: _lengthId2,
              circleId: selectedShapeID,
              x: shapeData.shape.x,
              y: shapeData.shape.y,
              xTo: shapeData.shape.x + shapeData.shape.r,
              yTo: shapeData.shape.y,
              pointX: point.x,
              pointY: point.y,
              angle: modelObj.LabComClass.Maths.getAngle(shapeData.shape.x, shapeData.shape.y, point.x, point.y),
              labelAlign: 'center',
              mode: 'circle'
            });
            localObj.currentUniqueId = _lengthId2;
            newShapes.push(_lengthId2);
          } else {
            shapeData.shape.isSelected = false;
          }
        }
      }
    } else if (tool === 'compass') {
      var newShape;

      var _lengthId3 = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId2 = localObj.currentUniqueId;
          newShape = {
            firstPointId: _firstPointId2,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _selectedShapeID = selectShape(e);

        if (_selectedShapeID) {
          var _shapeData2 = findShape(_selectedShapeID);

          if (_shapeData2.shape.visible === true) {
            if (_shapeData2.shape && _shapeData2.shape.type.includes('segment')) {
              newShape = {
                segmentID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                xTo: _shapeData2.shape.xTo,
                yTo: _shapeData2.shape.yTo
              };

              _shapeData2.shape.connectionId.push(_lengthId3);
            } else if (_shapeData2.shape && (_shapeData2.shape.type === 'circle' || _shapeData2.shape.type === 'compass' || _shapeData2.shape.type === 'circle_3')) {
              newShape = {
                circleID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                r: _shapeData2.shape.r
              };

              _shapeData2.shape.connectionId.push(_lengthId3);
            } else if (_shapeData2.shape.type === 'line' || _shapeData2.shape.type === 'parallelLine' || _shapeData2.shape.type === 'perpendicularLine' || _shapeData2.shape.type === 'point') {
              _shapeData2.shape.isSelected = false;
            }
          }
        }
      }

      if (newShape) {
        localObj.currentUniqueId = _lengthId3;
        newShape.connectionId = [];
        newShape.uniqueId = _lengthId3;
        newShape.isPloted = false;
        newShapes.push(_lengthId3);
        addNewShape(newShape);
      }
    } else if ((tool === 'line' || tool === 'ray') && point !== null) {
      var _firstPointId3 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var lineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId3,
          connectionId: [lineId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(lineId);
      }

      addNewShape({
        uniqueId: lineId,
        firstPointId: _firstPointId3,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [_firstPointId3]
      });
      localObj.currentUniqueId = lineId;
      newShapes.push(lineId);
    } else if (tool === 'angleRay' && point !== null) {
      var angleRayId = ++localObj.uniqueId;
      var rayId = ++localObj.uniqueId;
      var secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      newShapes.push(angleRayId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: secondPointId,
          connectionId: [rayId, angleRayId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(rayId);
      }

      addNewShape({
        uniqueId: angleRayId,
        firstPointId: secondPointId,
        firstRayPlotted: false,
        secondRayPlotted: false,
        x: point.x,
        y: point.y,
        connectionId: [secondPointId]
      });
      addNewShape({
        type: 'ray',
        uniqueId: rayId,
        angleRayId: angleRayId,
        secondPointId: secondPointId,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [secondPointId, angleRayId]
      });
      localObj.currentUniqueId = rayId;
      newShapes.push(rayId);
    } else if (tool === 'circle_3' && point !== null) {
      var circleId = ++localObj.uniqueId;

      var _firstPointId4 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId4,
          connectionId: [circleId],
          circleId: circleId
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(circleId);
        shapesData[clickingOnExistingPoint].circleId = circleId;
      }

      addNewShape({
        uniqueId: circleId,
        firstPointId: _firstPointId4,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId4]
      });
      var fp = findShape(_firstPointId4).shape;
      fp.isSelected = true;
      localObj.currentUniqueId = _firstPointId4;
      newShapes.push(circleId);
    } else if (tool === 'angle' && point !== null) {
      var angleId = ++localObj.uniqueId;

      var _firstPointId5 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId5,
          connectionId: [angleId],
          angleId: angleId
        });
        var _fp2 = findShape(_firstPointId5).shape;
        _fp2.isSelected = true;
      } else {
        var _fp3 = findShape(_firstPointId5).shape;
        _fp3.isSelected = true;
        shapesData[clickingOnExistingPoint].connectionId.push(angleId);
        shapesData[clickingOnExistingPoint].angleId = angleId;
      }

      addNewShape({
        uniqueId: angleId,
        firstPointId: _firstPointId5,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId5]
      });
      localObj.currentUniqueId = _firstPointId5;
      newShapes.push(angleId);
    } else if (tool === 'midPoint' && point !== null) {
      var midPointId = ++localObj.uniqueId;

      var _firstPointId6 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID2 = selectShape(e);

      var _shapeData3 = findShape(_selectedShapeID2).shape;

      if (clickingOnExistingPoint === null && point !== null && _selectedShapeID2 === null) {
        addPoint(point, {
          uniqueId: _firstPointId6,
          connectionId: [midPointId],
          midPointId: midPointId
        });
        var _fp4 = findShape(_firstPointId6).shape;
        _fp4.isSelected = true;
        addNewShape({
          uniqueId: midPointId,
          type: "midPoint",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y // connectionId: [firstPointId]

        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
        if (_shapeData3) {
          _shapeData3.isSelected = false;
        }

        shapesData[clickingOnExistingPoint].connectionId.push(midPointId);
        shapesData[clickingOnExistingPoint].midPointId = midPointId;
        shapesData[clickingOnExistingPoint].isSelected = true;
        addNewShape({
          uniqueId: midPointId,
          type: "midPoint",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          strokeColor: point.strokeColor != modelObj.pointColor ? point.strokeColor : modelObj.pointColor,
          fillColor: point.fillColor != modelObj.pointColor ? point.fillColor : modelObj.pointColor,
          // connectionId: [firstPointId],
          segmentId: _selectedShapeID2
        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (_selectedShapeID2 !== null && _shapeData3.type.includes('segment')) {
        if (_shapeData3 && _shapeData3.type.includes('segment')) {
          addNewShape({
            uniqueId: midPointId,
            type: "midPoint",
            firstPointPlotted: true,
            secondPointPlotted: true,
            firstPointId: _shapeData3.firstPointId,
            secondPointId: _shapeData3.secondPointId,
            x: (_shapeData3.x + _shapeData3.xTo) / 2,
            y: (_shapeData3.y + _shapeData3.yTo) / 2,
            firstPointCoords: {
              x: _shapeData3.x,
              y: _shapeData3.y
            },
            secondPointCoords: {
              x: _shapeData3.xTo,
              y: _shapeData3.yTo
            },
            segmentId: _selectedShapeID2,
            // connectionId: [firstPointId],
            onSegment: true,
            midPointId: midPointId
          });
          localObj.currentUniqueId = midPointId;
        }
      } else {
        _shapeData3.isSelected = false;
      }

      newShapes.push(midPointId);
    } else if (tool === 'square' && point !== null) {
      var squareId = ++localObj.uniqueId;

      var _firstPointId7 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null && point !== null) {
        addPoint(point, {
          uniqueId: _firstPointId7,
          connectionId: [squareId],
          squareId: squareId
        });
        addNewShape({
          uniqueId: squareId,
          type: "square",
          firstPointId: _firstPointId7,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId7]
        });
        localObj.currentUniqueId = _firstPointId7;
      } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
        shapesData[clickingOnExistingPoint].connectionId.push(squareId);
        shapesData[clickingOnExistingPoint].squareId = squareId;
        addNewShape({
          uniqueId: squareId,
          type: "square",
          firstPointId: _firstPointId7,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          strokeColor: point.strokeColor != modelObj.pointColor ? point.strokeColor : modelObj.pointColor,
          fillColor: point.fillColor != modelObj.pointColor ? point.fillColor : modelObj.pointColor,
          connectionId: [_firstPointId7]
        });
        localObj.currentUniqueId = _firstPointId7;
      }

      var _fp5 = findShape(_firstPointId7).shape;
      _fp5.isSelected = true;
      localObj.newPlottedShapes.push(squareId);
    } else if (tool === 'mirrorOnPoint' && point !== null) {
      var mirrorOnPointId = ++localObj.uniqueId;

      var _firstPointId8 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID3 = selectShape(e);

      var _shapeData4 = findShape(_selectedShapeID3).shape;

      if (_shapeData4 && _shapeData4.type === 'point' || _selectedShapeID3 === null || clickingOnExistingPoint !== null && shapesData[clickingOnExistingPoint].type === 'point') {
        if (_shapeData4) {
          _shapeData4.isSelected = false;
        }

        if (clickingOnExistingPoint === null) {
          addPoint(point, {
            uniqueId: _firstPointId8,
            connectionId: [mirrorOnPointId],
            mirrorOnPointId: mirrorOnPointId
          });
          var _fp6 = findShape(_firstPointId8).shape;
          _fp6.isSelected = true;
        } else {
          shapesData[clickingOnExistingPoint].connectionId.push(mirrorOnPointId);
          shapesData[clickingOnExistingPoint].mirrorOnPointId = mirrorOnPointId;
          var _fp7 = findShape(_firstPointId8).shape;
          _fp7.isSelected = true;
        }

        addNewShape({
          uniqueId: mirrorOnPointId,
          firstPointId: _firstPointId8,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y // connectionId: [firstPointId]

        });
        localObj.currentUniqueId = _firstPointId8;
        newShapes.push(mirrorOnPointId);
        localObj.newShapeStarted = true;
      } else {
        _shapeData4.isSelected = false;
      }
    } else if (tool === 'mirrorOnLine' && point !== null) {
      var mirrorOnLineId = ++localObj.uniqueId;

      var _firstPointId9 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId; // const selectedShapeID = selectShape(e);
      // const shapeData = findShape(selectedShapeID).shape;   
      // if ((shapeData && shapeData.type === 'point') || selectedShapeID === null || (clickingOnExistingPoint !== null && shapesData[clickingOnExistingPoint].type === 'point')) {
      //   if (shapeData) {
      //     shapeData.isSelected = false;
      //   }


      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId9,
          connectionId: [mirrorOnLineId],
          mirrorOnLineId: mirrorOnLineId
        });
        var _fp8 = findShape(_firstPointId9).shape;
        _fp8.isSelected = true;
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(mirrorOnLineId);
        shapesData[clickingOnExistingPoint].mirrorOnLineId = mirrorOnLineId;
        var _fp9 = findShape(_firstPointId9).shape;
        _fp9.isSelected = true;
      }

      addNewShape({
        uniqueId: mirrorOnLineId,
        firstPointId: _firstPointId9,
        firstPointPlotted: false,
        linePlotted: false,
        x: point.x,
        y: point.y,
        connectionId: []
      });
      localObj.currentUniqueId = _firstPointId9;
      newShapes.push(mirrorOnLineId);
      localObj.newShapeStarted = true; // }
      // else {
      //   shapeData.isSelected = false;
      // }
    } else if (tool === 'triangle' && point !== null) {
      var triangleId = ++localObj.uniqueId;

      var _segmentId = ++localObj.uniqueId;

      var _secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      newShapes.push(triangleId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _secondPointId,
          connectionId: [_segmentId, triangleId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(_segmentId);
        shapesData[clickingOnExistingPoint].connectionId.push(triangleId);
      }

      addNewShape({
        uniqueId: triangleId,
        firstPointId: _secondPointId,
        firstSegmentPlotted: false,
        secondSegmentPlotted: false,
        thirdSegmentPlotted: false,
        seg1Id: _segmentId,
        x: point.x,
        y: point.y,
        connectionId: [_secondPointId]
      });
      addNewShape({
        type: 'segment',
        uniqueId: _segmentId,
        triangleId: triangleId,
        secondPointId: _secondPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [_secondPointId]
      });
      localObj.currentUniqueId = _segmentId;
      newShapes.push(_segmentId);
    } else if (tool === 'perpendicularBisector' && point !== null) {
      var _selectedShapeID4 = selectShape(e);

      var selectedShapeData = findShape(_selectedShapeID4).shape;

      if (clickingOnExistingPoint === null && (selectedShapeData === null || selectedShapeData === void 0 ? void 0 : selectedShapeData.type) === 'point') {
        selectedShapeData.isSelected = false;
      }

      if (clickingOnExistingPoint !== null) {
        var perpBId = ++localObj.uniqueId;

        var _firstPointId10 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

        if (selectedShapeData) {
          selectedShapeData.isSelected = false;
        }

        shapesData[clickingOnExistingPoint].isSelected = false;
        addNewShape({
          uniqueId: perpBId,
          type: "perpendicularBisector",
          firstPointId: _firstPointId10,
          firstPointPlotted: false,
          secondPointPlotted: false,
          // connectionId: [firstPointId],
          mode: 'point'
        });
        localObj.newShapeStarted = true;
        newShapes.push(perpBId);
        localObj.currentUniqueId = perpBId;
        var _fp10 = findShape(_firstPointId10).shape;
        _fp10.isSelected = true;
      } else if (_selectedShapeID4 !== null && selectedShapeData.type.includes('segment')) {
        selectedShapeData.isSelected = false;

        var _perpBId = ++localObj.uniqueId;

        var segment = selectedShapeData;
        selectedShapeData.perpBId = _perpBId;
        addNewShape({
          uniqueId: _perpBId,
          segmentId: selectedShapeData.uniqueId,
          segment: selectedShapeData,
          segmentPlotted: false,
          // connectionId: [selectedShapeData.uniqueId],
          mode: 'segment'
        });
        localObj.newShapeStarted = true;
        newShapes.push(_perpBId);
        localObj.currentUniqueId = _perpBId;
      }
    } else if (tool === 'angleB' && point !== null) {
      var _selectedShapeID5 = selectShape(e);

      var _shapeData5 = findShape(_selectedShapeID5).shape;

      if (clickingOnExistingPoint === null && (_shapeData5 === null || _shapeData5 === void 0 ? void 0 : _shapeData5.type) === 'point') {
        _shapeData5.isSelected = false;
      }

      if (clickingOnExistingPoint !== null) {
        var angleBId = ++localObj.uniqueId;
        var _firstPointId11 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleBId);
        shapesData[clickingOnExistingPoint].angleBId = angleBId;
        shapesData[clickingOnExistingPoint].isSelected = true;
        addNewShape({
          uniqueId: angleBId,
          firstPointId: _firstPointId11,
          firstPointPlotted: false,
          secondPointPlotted: false,
          thirdPointPloted: false,
          x: point.x,
          y: point.y,
          mode: 'point',
          connectionId: [_firstPointId11]
        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = angleBId;
        newShapes.push(angleBId);

        if (_selectedShapeID5 !== null && _shapeData5.type !== 'point') {
          _shapeData5.isSelected = false;
        }
      } else if (_selectedShapeID5 !== null && (_shapeData5.type.includes('segment') || _shapeData5.type === 'line' || _shapeData5.type === 'ray')) {
        _shapeData5.isSelected = true;

        var _angleBId = ++localObj.uniqueId;

        var firstSegment = _shapeData5;
        _shapeData5.angleBId = _angleBId;
        addNewShape({
          uniqueId: _angleBId,
          firstSegmentId: _shapeData5.uniqueId,
          firstSegmentPlotted: false,
          secondSegmentPlotted: false,
          firstSegment: {
            x: firstSegment.x,
            y: firstSegment.y,
            xTo: firstSegment.xTo,
            yTo: firstSegment.yTo
          },
          firstConnId: firstSegment.connectionId,
          x: _shapeData5.x,
          y: _shapeData5.y,
          mode: 'segment' // connectionId: [shapeData.uniqueId]

        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = _angleBId;
        newShapes.push(_angleBId);
      } else if (_shapeData5 !== undefined) {
        _shapeData5.isSelected = false;
      }
    } else if (tool === 'angleSize' && point !== null) {
      localObj.mouseDown.lastShapeCompleted = false;
      var angleSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null && point !== null) {
        var _firstPointId12 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleSizeId);
        shapesData[clickingOnExistingPoint].angleSizeId = angleSizeId;
        addNewShape({
          uniqueId: angleSizeId,
          firstPointId: _firstPointId12,
          firstPointPlotted: false,
          secondPointPlotted: false,
          degree: 0,
          clockwise: true,
          x: point.x,
          y: point.y,
          mode: 'point',
          connectionId: [_firstPointId12]
        });
        localObj.currentUniqueId = _firstPointId12;
      } else {
        var _firstPointId13 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId13,
          angleSizeId: angleSizeId,
          connectionId: [angleSizeId]
        });
        addNewShape({
          uniqueId: angleSizeId,
          firstPointId: _firstPointId13,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId13],
          mode: 'point'
        });
      }

      newShapes.push(angleSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === 'segSize' && point !== null) {
      var segSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId14 = localObj.currentUniqueId;

        if (shapesData[clickingOnExistingPoint].connectionId.length == 0) {// shapesData[clickingOnExistingPoint].dontDrag = true;
        }

        shapesData[clickingOnExistingPoint].connectionId.push(segSizeId);
        shapesData[clickingOnExistingPoint].segSizeId = segSizeId;
        addNewShape({
          uniqueId: segSizeId,
          firstPointPlotted: false,
          firstPointId: _firstPointId14,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId14]
        });
        localObj.currentUniqueId = _firstPointId14;
        newShapes.push(segSizeId);
      } else {
        var _firstPointId15 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId15,
          segSizeId: segSizeId,
          connectionId: [segSizeId] // dontDrag:true

        });
        addNewShape({
          uniqueId: segSizeId,
          firstPointId: _firstPointId15,
          firstPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId15]
        });
        localObj.currentUniqueId = _firstPointId15;
      }

      var _fp11 = findShape(localObj.currentUniqueId);

      _fp11.isSelected = true;
      localObj.newPlottedShapes.push(segSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === 'circleSize' && point !== null) {
      var circleSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId16 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(circleSizeId);
        shapesData[clickingOnExistingPoint].circleSizeId = circleSizeId;
        addNewShape({
          uniqueId: circleSizeId,
          firstPointPlotted: false,
          firstPointId: _firstPointId16,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId16]
        });
        localObj.currentUniqueId = _firstPointId16;
        newShapes.push(circleSizeId);
      } else {
        var _firstPointId17 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId17,
          circleSizeId: circleSizeId,
          connectionId: [circleSizeId]
        });
        addNewShape({
          uniqueId: circleSizeId,
          firstPointId: _firstPointId17,
          firstPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId17]
        });
        localObj.currentUniqueId = _firstPointId17;
      }

      var _fp12 = findShape(localObj.currentUniqueId);

      _fp12.isSelected = true;
      localObj.newPlottedShapes.push(circleSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === 'circle' && point !== null) {
      var connectionId = [];

      var _firstPointId18 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _circleId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId18,
          connectionId: [_circleId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(_circleId);
      }

      if (clickingOnExistingPoint === null) {
        connectionId = [localObj.currentUniqueId];
      }

      addNewShape({
        uniqueId: _circleId,
        firstPointId: _firstPointId18,
        x: point.x,
        y: point.y,
        r: 0,
        connectionId: connectionId
      });
      localObj.currentUniqueId = _circleId;
      newShapes.push(_circleId);
    } else if (tool === 'perpendicularLine' || tool === 'parallelLine') {
      var _newShape;

      var perpendLineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId19 = localObj.currentUniqueId;
          _newShape = {
            firstPointId: _firstPointId19,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _d2 = getPLine(e, tool === 'perpendicularLine');

        if (_d2) {
          _newShape = _d2;
          _newShape.lineToPoint = true;
          var parentLine = findShape(_newShape.line);

          if (parentLine) {
            parentLine.shape.connectionId.push(perpendLineId);
            parentLine.shape.isSelected = true;
          }
        } else {
          var _firstPointId20 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId20,
            connectionId: [perpendLineId]
          });
          newShapes.push(_firstPointId20);
          _newShape = {
            firstPointId: _firstPointId20,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      }

      if (_newShape.pointToLine) {
        var _point = findShape(_newShape.firstPointId).shape;
        _point.isSelected = true;
      }

      _newShape.firstPointPlotted = false;
      _newShape.connectionId = [];
      _newShape.uniqueId = perpendLineId;
      localObj.currentUniqueId = perpendLineId;
      newShapes.push(_newShape.uniqueId);
      addNewShape(_newShape);
    } else if (tool.includes('brush')) {
      localObj.currentUniqueId = selectShapeBrush(e);
    } else if (tool === 'delete') {
      localObj.currentUniqueId = selectShapeBrush(e);
    } else if (tool === 'labelTool') {
      localObj.currentUniqueId = selectShapeLabel(e);
    } else if (tool === 'select' || tool === 'move') {
      localObj.currentUniqueId = moveShape(e);
      var shape = findShape(localObj.currentUniqueId).shape;

      if (shape && shape.type === 'triangle') {
        var _fp13 = findShape(shape.firstPointId).shape;
        var sp = findShape(shape.secondPointId).shape;
        var tp = findShape(shape.thirdPointId).shape;
        var seg1 = findShape(shape.seg1Id).shape;
        var seg2 = findShape(shape.seg2Id).shape;
        var seg3 = findShape(shape.seg3Id).shape;
        _fp13.isSelected = false;
        sp.isSelected = false;
        tp.isSelected = false;
        seg1.isSelected = false;
        seg2.isSelected = false;
        seg3.isSelected = false;
      }
    }
  } // =================================================


  function onMouseMove(e) {
    if (!localObj.mouseDown.lastShapeCompleted) {
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor: 'pointer'
      // });
      onPressMove(e);
    } else {// let cursor = 'default';
      // let downCursor = 'default';
      // if (isOnShape(e) !== null) {
      //   cursor = 'pointer';
      //   downCursor = 'pointer';
      // }
      // if (modelObj.interactionType === 'moveGraph') {
      //   cursor = 'grab';
      //   downCursor = 'grabbing';
      // }
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor,
      //   downCursor
      // });
    }
  }

  function pointInsideGraph(point) {
    var pointInPx = getPixelByPoint(point.x, point.y);
    var graph = modelObj.screen;

    if (pointInPx.x > graph.x && pointInPx.x < graph.x + graph.w && pointInPx.y > graph.y && pointInPx.y < graph.y + graph.h) {
      return true;
    }

    return false;
  }

  function onPressMove(e) {
    var tool = modelObj.interactionType;
    var shapesData = modelObj.interactionElements;
    var currentShape = localObj.currentUniqueId !== null ? findShape(localObj.currentUniqueId).shape : findShape(localObj.uniqueId).shape;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point, e.type);
    var pointInGraph = pointInsideGraph(point);

    if (e.subId === 'scale1' || e.subId === 'scale2') {
      if (e.subId === 'scale1') {
        scaleObj.x = point.x;
        scaleObj.y = point.y;
        dispatchEventScale();
      } else if (e.subId === 'scale2') {
        scaleObj.xTo = point.x;
        scaleObj.yTo = point.y;
        dispatchEventScale();
      }
    } else {
      if (pointInGraph) {
        if (point === null || localObj.mouseDown.objectDown && !(currentShape && (currentShape.isDraggable === undefined || currentShape.isDraggable))) {
          if (!(tool === 'move' && localObj.isLableSelected)) {
            console.info('rejected');
            return false;
          }
        }

        if (tool === 'point') {
          //Independent Point can move with mouse move.
          // if (currentShape.type == 'point' && currentShape.connectionId.length == 0) {  
          if (currentShape.type == 'point') {
            updatePointValues(currentShape, {
              x: point.x,
              y: point.y
            });
          }
        } else if (tool.includes('segment')) {
          currentShape.xTo = point.x;
          currentShape.yTo = point.y;
        } else if (tool === 'length') {
          if (currentShape && currentShape.type === 'length' && currentShape.secondPointId === undefined) {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
          }
        } else if (tool === 'compass') {
          if (currentShape && currentShape.type === 'compass') {
            if (!currentShape.isPloted) {
              currentShape.xTo = point.x;
              currentShape.yTo = point.y;
            } else {
              currentShape.x = point.x;
              currentShape.y = point.y;
            }
          }
        } else if (tool === 'line') {
          var line = shapesData[shapesData.length - 1];
          line.xTo = point.x;
          line.yTo = point.y;
          updateLinePoints(line);
        } else if (tool === 'ray') {
          var ray = shapesData[shapesData.length - 1];
          ray.xTo = point.x;
          ray.yTo = point.y;
          updateLinePoints(ray);
        } else if (tool === 'angleRay') {
          if (currentShape) {
            var angleRay = findShape(currentShape.angleRayId).shape;

            if (!angleRay.firstRayPlotted) {
              currentShape.x = point.x;
              currentShape.y = point.y;
              updateLinePoints(currentShape);
            } else {
              currentShape.xTo = point.x;
              currentShape.yTo = point.y;
              angleRay.thirdPoint = {
                x: point.x,
                y: point.y
              };
              updateLinePoints(currentShape);
            }
          }
        } else if (tool === 'triangle') {
          if (currentShape) {
            var triangle = findShape(currentShape.triangleId).shape;

            if (!triangle.firstSegmentPlotted) {
              currentShape.x = point.x;
              currentShape.y = point.y;
            } else {
              currentShape.xTo = point.x;
              currentShape.yTo = point.y;
              triangle.thirdPoint = {
                x: point.x,
                y: point.y
              };
            }
          }
        } else if (tool === 'angle') {// if (currentShape && localObj.mouseDown.isMouseDown) {
          //   currentShape.x = point.x;
          //   currentShape.y = point.y;
          // }
        } else if (tool === 'circle_3') {
          var index;

          for (var i = shapesData.length - 1; i >= 0; i--) {
            if (shapesData[i].type === 'circle_3') {
              index = i;
              break;
            }
          }

          var _currentShape = shapesData[index];
          var cData = {};

          if (_currentShape.type === 'circle_3' && _currentShape.secondPointPlotted !== false) {
            if (_currentShape.firstPointPlotted !== undefined && _currentShape.secondPointPlotted !== undefined) {
              var fp = findShape(_currentShape.firstPointId).shape;
              var sp = findShape(_currentShape.secondPointId).shape;
              cData = circle3Handler(fp, sp, point);
            }

            _currentShape.x = cData.x;
            _currentShape.y = cData.y;
            _currentShape.r = cData.r;
          }
        } else if (tool === 'circle') {
          var lastShape = shapesData[shapesData.length - 1];
          lastShape.r = Math.abs(modelObj.LabComClass.Maths.getDistance({
            x: lastShape.x,
            y: lastShape.y
          }, point));
          dispatchEventCircleMove(lastShape);
        } else if (tool === 'perpendicularLine' || tool === 'parallelLine') {
          if (localObj.mouseDown.isMouseDown) {
            if (currentShape.pointToLine && !currentShape.firstPointPlotted && currentShape.firstPointId !== undefined) {
              if (localObj.newPlottedShapes.includes(currentShape.firstPointId)) {
                var pointShape = findShape(currentShape.firstPointId).shape;
                pointShape.x = point.x;
                pointShape.y = point.y;
              }
            }
          }

          if (currentShape.lineToPoint) {
            currentShape.x = point.x;
            currentShape.y = point.y;
            updatePLinePoints(currentShape);
          }
        } else if (tool === 'move' && !localObj.mouseDown.objectDown || tool === 'moveGraph') {
          if (localObj.mouseDown.isMouseDown) {
            var _diffX = 0;
            var _diffY = 0;
            _diffX = e.pageX - localObj.mouseDown.x;
            _diffY = e.pageY - localObj.mouseDown.y;
            localObj.mouseDown.x = e.pageX;
            localObj.mouseDown.y = e.pageY;

            if (typeof events[tool] !== 'undefined') {
              events[tool]({
                id: modelObj.id,
                type: 'moveGraph',
                data: {
                  x: _diffX,
                  y: _diffY
                }
              }, true);
            }
          }
        } else if (tool === 'select' || tool === 'move' && localObj.mouseDown.objectDown) {
          if ((modelObj.shapesEditable || localObj.isLableSelected) && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown && (!localObj.selectAll || tool === 'move' && localObj.selectAll)) {
            var _diffX2 = 0;
            var _diffY2 = 0;
            _diffX2 = e.pageX - localObj.mouseDown.x;
            _diffY2 = e.pageY - localObj.mouseDown.y;
            var center = getPixelByPoint(0, 0);
            var diffValueInPoint = getPointByPixel(center.x + _diffX2, center.y + _diffY2);
            _diffX2 = diffValueInPoint.x;
            _diffY2 = diffValueInPoint.y;

            if (localObj.isLableSelected) {
              for (var _i = 0; _i < shapesData.length; _i++) {
                var _d = shapesData[_i];
                var lablePos = getPixelByPoint(_d.labelX, _d.labelY);
                var pixelDiff = {
                  x: e.pageX - lablePos.x,
                  y: e.pageY - lablePos.y
                };

                if (_d.isSelected) {
                  updateDiff(_d, pixelDiff);
                  break;
                }
              }
            } else {
              for (var _i2 = 0; _i2 < shapesData.length; _i2++) {
                shapesData[_i2].isMoved = false;
              }

              var _loop4 = function _loop4(_i3) {
                var _d = shapesData[_i3];

                if (_d.isDraggable !== undefined && !_d.isDraggable) {
                  return "continue";
                }

                if (_d.isSelected && !_d.isMoved && !_d.dontDrag) {
                  var _findShape;

                  _d.isMoved = true;

                  if (_d.type === 'point' && !_d.isIntersection && (_d.squareId === undefined || _d.squareId !== undefined && findShape(_d.squareId).shape === undefined || _d.squareId !== undefined && findShape(_d.squareId).shape !== undefined && !((_findShape = findShape(_d.squareId)) === null || _findShape === void 0 ? void 0 : _findShape.shape.isSelected))) {
                    _d.x += _diffX2;
                    _d.y += _diffY2;

                    if (_d.isParameter) {
                      var _modelObj$LabComClass = modelObj.LabComClass.Maths,
                          getDistance = _modelObj$LabComClass.getDistance,
                          getAngle = _modelObj$LabComClass.getAngle,
                          getPoint = _modelObj$LabComClass.getPoint,
                          pointInSegment = _modelObj$LabComClass.pointInSegment,
                          getLineintersect = _modelObj$LabComClass.getLineintersect,
                          getLinePointIntersection = _modelObj$LabComClass.getLinePointIntersection;

                      if (_d.line !== undefined) {
                        var _line = findShape(_d.line).shape;

                        if (_line) {
                          var dist = getDistance(_line, {
                            x: _line.xTo,
                            y: _line.yTo
                          });
                          var lineAngle = getAngle(_line.x, _line.y, _line.xTo, _line.yTo);
                          var newData = {};
                          var distFromFirstPoint = _d.pointAngle ? dist * _d.percentage : dist * _d.percentage * -1;
                          var intersection = getLinePointIntersection(_line, {
                            x: _line.xTo,
                            y: _line.yTo
                          }, {
                            x: _d.x,
                            y: _d.y
                          });
                          var intersectionDist = getDistance(_line, intersection);
                          newData.pointAngle = getAngle(_line.x, _line.y, intersection.x, intersection.y);
                          newData.pointAngle = Math.round(newData.pointAngle) === Math.round(lineAngle);
                          newData.percentage = intersectionDist / dist;
                          distFromFirstPoint = newData.pointAngle ? dist * newData.percentage : dist * newData.percentage * -1;
                          var p = getPoint(_line, lineAngle, distFromFirstPoint);
                          newData.x = p.x;
                          newData.y = p.y;
                          _d.x = newData.x;
                          _d.y = newData.y;
                          var setValues = true;

                          if (_line.type.includes('segment') || _line.type === 'ray') {
                            var endPoint = {
                              x: _line.xTo,
                              y: _line.yTo
                            };

                            if (_line.type === 'ray') {
                              endPoint = {
                                x: _line.xOr,
                                y: _line.yOr
                              };
                            }

                            setValues = pointInSegment(p, _line, endPoint);

                            if (!setValues) {
                              var dist1 = getDistance(p, _line);
                              var dist2 = getDistance(p, endPoint);

                              if (dist1 < dist2) {
                                newData.x = _line.x;
                                newData.y = _line.y;
                              } else {
                                newData.x = endPoint.x;
                                newData.y = endPoint.y;
                              }
                            }
                          }

                          Object.keys(newData).forEach(function (i) {
                            _d[i] = newData[i];
                          });
                        }
                      } else if (_d.circle !== undefined) {
                        var circle = findShape(_d.circle).shape;

                        if (circle) {
                          _d.angle = getAngle(circle.x, circle.y, _d.x, _d.y);
                        }

                        var newP = getPoint(circle, _d.angle, circle.r);
                        updateShapeValue(_d, {
                          x: newP.x,
                          y: newP.y
                        });
                      }
                    }

                    if (tool === 'move' || tool === 'select' && localObj.selectedItemsCount === 1) {
                      _d.x = point.x;
                      _d.y = point.y;
                    }

                    updatePoints(_d);
                  } else if (_d.type.includes('segment') && _d.squareId === undefined) {
                    var _fp14 = findShape(_d.firstPointId).shape; // if(!fp.isIntersection){

                    _d.x += _diffX2;
                    _d.y += _diffY2;
                    _d.xTo += _diffX2;
                    _d.yTo += _diffY2; // }
                  } else if (_d.type === 'line' || _d.type === 'ray') {
                    _d.x += _diffX2;
                    _d.y += _diffY2;
                    _d.xTo += _diffX2;
                    _d.yTo += _diffY2;
                    updateLinePoints(shapesData[_i3]);
                  } else if (_d.type === 'circle' && _d.circleSize === undefined) {
                    var centerPoint = findShape(_d.firstPointId);

                    var _endPoint = findShape(_d.secondPointId);

                    if (centerPoint && _endPoint && !centerPoint.shape.isIntersection && !_endPoint.shape.isIntersection && !centerPoint.shape.isParameter && !_endPoint.shape.isParameter) {
                      if (findDraggable([centerPoint.shape, _endPoint.shape])) {
                        if (!centerPoint.shape.isMoved) {
                          updateShapeValue(centerPoint.shape, {
                            x: centerPoint.shape.x + _diffX2,
                            y: centerPoint.shape.y + _diffY2
                          });
                          centerPoint.shape.isMoved = true;
                        }

                        if (!_endPoint.shape.isMoved) {
                          updateShapeValue(_endPoint.shape, {
                            x: _endPoint.shape.x + _diffX2,
                            y: _endPoint.shape.y + _diffY2
                          });
                          _endPoint.shape.isMoved = true;
                        }
                      }
                    }
                  } else if (_d.type === 'circle' && _d.circleSize !== undefined) {
                    var _centerPoint = findShape(_d.firstPointId);

                    if (_centerPoint) {
                      if (findDraggable([_centerPoint.shape])) {
                        if (!_centerPoint.shape.isMoved) {
                          updateShapeValue(_centerPoint.shape, {
                            x: _centerPoint.shape.x + _diffX2,
                            y: _centerPoint.shape.y + _diffY2
                          });
                          _centerPoint.isMoved = true;
                        }
                      }
                    }
                  } else if (_d.type === 'circle_3') {
                    var _fp15 = findShape(_d.firstPointId).shape;
                    var _sp2 = findShape(_d.secondPointId).shape;
                    var tp = findShape(_d.thirdPointId).shape;

                    if (!_fp15.isIntersection && !_sp2.isIntersection && !tp.isIntersection && !_fp15.isParameter && !_sp2.isParameter && !(tp.isParameter && (tp.line !== undefined || tp.circle !== undefined))) {
                      if (!_fp15.isMoved) {
                        _this.updateShape(_d.firstPointId, {
                          x: _fp15.x + _diffX2,
                          y: _fp15.y + _diffY2
                        });

                        _fp15.isMoved = true;
                      }

                      if (!_sp2.isMoved) {
                        _this.updateShape(_d.secondPointId, {
                          x: _sp2.x + _diffX2,
                          y: _sp2.y + _diffY2
                        });

                        _sp2.isMoved = true;
                      }

                      if (!tp.isMoved) {
                        _this.updateShape(_d.thirdPointId, {
                          x: tp.x + _diffX2,
                          y: tp.y + _diffY2
                        });

                        tp.isMoved = true;
                      }
                    }
                  } else if (_d.type === 'compass') {
                    var _centerPoint2$shape;

                    var _centerPoint2 = findShape(_d.connectionId[0]);

                    var outterrad = findShape(_d.uniqueId);

                    if ((_centerPoint2$shape = _centerPoint2.shape) === null || _centerPoint2$shape === void 0 ? void 0 : _centerPoint2$shape.line) {
                      var parentShape = findShape(_centerPoint2.shape.line).shape;
                      var _fp16 = findShape(parentShape.firstPointId).shape;
                      var _sp3 = findShape(parentShape.secondPointId).shape;

                      if (parentShape.type == 'segment' || parentShape.type == "segmentDash") {
                        if (modelObj.LabComClass.Maths.pointInSegment(_centerPoint2.shape, _fp16, _sp3)) // if(modelObj.LabComClass.Maths.pointInSegment(point,fp,sp))
                          {
                            if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && !_centerPoint2.shape.isParameter && !outterrad.shape.isParameter) {
                              if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                                if (!_centerPoint2.shape.isMoved) {
                                  updateShapeValue(_centerPoint2.shape, {
                                    x: _centerPoint2.shape.x + _diffX2,
                                    y: _centerPoint2.shape.y + _diffY2
                                  });
                                  _centerPoint2.isMoved = true;
                                }

                                updateShapeValue(outterrad.shape, {
                                  x: outterrad.shape.x + _diffX2,
                                  y: outterrad.shape.y + _diffY2
                                });
                              }
                            } else if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && _centerPoint2.shape.isParameter) {
                              if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                                if (!_centerPoint2.shape.isMoved) {
                                  updateShapeValue(_centerPoint2.shape, {
                                    x: _centerPoint2.shape.x + _diffX2,
                                    y: _centerPoint2.shape.y + _diffY2
                                  });
                                  _centerPoint2.isMoved = true;
                                }

                                updateShapeValue(outterrad.shape, {
                                  x: outterrad.shape.x + _diffX2,
                                  y: outterrad.shape.y + _diffY2
                                });
                              }
                            }
                          } else {
                          if (modelObj.LabComClass.Maths.getDistance(point, _fp16) <= 0) {
                            _centerPoint2.shape.x = _fp16.x;
                            _centerPoint2.shape.y = _fp16.y;
                            outterrad.shape.x = _fp16.x;
                            outterrad.shape.y = _fp16.y;
                          } else if (modelObj.LabComClass.Maths.getDistance(point, _sp3) <= 0) {
                            _centerPoint2.shape.x = _sp3.x;
                            _centerPoint2.shape.y = _sp3.y;
                            outterrad.shape.x = _sp3.x;
                            outterrad.shape.y = _sp3.y;
                          } else if (modelObj.LabComClass.Maths.getDistance(point, _fp16) < modelObj.LabComClass.Maths.getDistance(point, _sp3)) {
                            _centerPoint2.shape.x = _fp16.x;
                            _centerPoint2.shape.y = _fp16.y;
                            outterrad.shape.x = _fp16.x;
                            outterrad.shape.y = _fp16.y;
                          } else if (modelObj.LabComClass.Maths.getDistance(point, _sp3) < modelObj.LabComClass.Maths.getDistance(point, _fp16)) {
                            _centerPoint2.shape.x = _sp3.x;
                            _centerPoint2.shape.y = _sp3.y;
                            outterrad.shape.x = _sp3.x;
                            outterrad.shape.y = _sp3.y;
                          }
                        }
                      } else if (parentShape.type == 'line') {
                        if (modelObj.LabComClass.Maths.pointInSegment(point, {
                          x: parentShape.xOr,
                          y: parentShape.yOr
                        }, {
                          x: parentShape.xOrTo,
                          y: parentShape.yOrTo
                        })) {
                          if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && !_centerPoint2.shape.isParameter && !outterrad.shape.isParameter) {
                            if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                              if (!_centerPoint2.shape.isMoved) {
                                updateShapeValue(_centerPoint2.shape, {
                                  x: _centerPoint2.shape.x + _diffX2,
                                  y: _centerPoint2.shape.y + _diffY2
                                });
                                _centerPoint2.isMoved = true;
                              }

                              updateShapeValue(outterrad.shape, {
                                x: outterrad.shape.x + _diffX2,
                                y: outterrad.shape.y + _diffY2
                              });
                            }
                          } else if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && _centerPoint2.shape.isParameter) {
                            if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                              if (!_centerPoint2.shape.isMoved) {
                                updateShapeValue(_centerPoint2.shape, {
                                  x: _centerPoint2.shape.x + _diffX2,
                                  y: _centerPoint2.shape.y + _diffY2
                                });
                                _centerPoint2.isMoved = true;
                              }

                              updateShapeValue(outterrad.shape, {
                                x: outterrad.shape.x + _diffX2,
                                y: outterrad.shape.y + _diffY2
                              });
                            }
                          }
                        }
                      } else if (parentShape.type == 'ray') {
                        if (modelObj.LabComClass.Maths.pointInSegment(point, _fp16, {
                          x: parentShape.xOr,
                          y: parentShape.yOr
                        })) {
                          if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && !_centerPoint2.shape.isParameter && !outterrad.shape.isParameter) {
                            if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                              if (!_centerPoint2.shape.isMoved) {
                                updateShapeValue(_centerPoint2.shape, {
                                  x: _centerPoint2.shape.x + _diffX2,
                                  y: _centerPoint2.shape.y + _diffY2
                                });
                                _centerPoint2.isMoved = true;
                              }

                              updateShapeValue(outterrad.shape, {
                                x: outterrad.shape.x + _diffX2,
                                y: outterrad.shape.y + _diffY2
                              });
                            }
                          } else if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && _centerPoint2.shape.isParameter) {
                            if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                              if (!_centerPoint2.shape.isMoved) {
                                updateShapeValue(_centerPoint2.shape, {
                                  x: _centerPoint2.shape.x + _diffX2,
                                  y: _centerPoint2.shape.y + _diffY2
                                });
                                _centerPoint2.isMoved = true;
                              }

                              updateShapeValue(outterrad.shape, {
                                x: outterrad.shape.x + _diffX2,
                                y: outterrad.shape.y + _diffY2
                              });
                            }
                          }
                        } else {
                          if (modelObj.LabComClass.Maths.getDistance(_centerPoint2.shape, _fp16) <= outterrad.shape.r) {
                            _centerPoint2.shape.x = _fp16.x;
                            _centerPoint2.shape.y = _fp16.y;
                            outterrad.shape.x = _fp16.x;
                            outterrad.shape.y = _fp16.y;
                          } else if (modelObj.LabComClass.Maths.getDistance(point, _fp16)) {
                            _centerPoint2.shape.x = _fp16.x;
                            _centerPoint2.shape.y = _fp16.y;
                            outterrad.shape.x = _fp16.x;
                            outterrad.shape.y = _fp16.y;
                          }
                        }
                      }
                    } else {
                      if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && !_centerPoint2.shape.isParameter && !outterrad.shape.isParameter) {
                        if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                          if (!_centerPoint2.shape.isMoved) {
                            updateShapeValue(_centerPoint2.shape, {
                              x: _centerPoint2.shape.x + _diffX2,
                              y: _centerPoint2.shape.y + _diffY2
                            });
                            _centerPoint2.isMoved = true;
                          }

                          updateShapeValue(outterrad.shape, {
                            x: outterrad.shape.x + _diffX2,
                            y: outterrad.shape.y + _diffY2
                          });
                        }
                      } else if (_centerPoint2 && outterrad && !_centerPoint2.shape.isIntersection && !outterrad.shape.isIntersection && _centerPoint2.shape.isParameter) {
                        if (findDraggable([_centerPoint2.shape, outterrad.shape])) {
                          if (!_centerPoint2.shape.isMoved) {
                            updateShapeValue(_centerPoint2.shape, {
                              x: _centerPoint2.shape.x + _diffX2,
                              y: _centerPoint2.shape.y + _diffY2
                            });
                            _centerPoint2.isMoved = true;
                          }

                          updateShapeValue(outterrad.shape, {
                            x: outterrad.shape.x + _diffX2,
                            y: outterrad.shape.y + _diffY2
                          });
                        }
                      }
                    }
                  } else if (_d.type === 'perpendicularLine' || _d.type === 'parallelLine') {// _d.x += _diffX;
                    // _d.y += _diffY;
                    // _d.xTo += _diffX;
                    // _d.yTo += _diffY;
                  } else if (_d.type === 'square') {
                    var firstPoint = findShape(_d.firstPointId).shape;
                    var secondPoint = findShape(_d.secondPointId).shape;

                    if (!(firstPoint.isIntersection || firstPoint.isParameter || secondPoint.isIntersection || secondPoint.isParameter)) {
                      firstPoint.x = firstPoint.x + _diffX2;
                      firstPoint.y = firstPoint.y + _diffY2;
                      secondPoint.x = secondPoint.x + _diffX2;
                      secondPoint.y = secondPoint.y + _diffY2;
                    }
                  } else if (_d.type === 'triangle') {
                    var _firstPoint = findShapeById(_d.firstPointId);

                    var _secondPoint = findShapeById(_d.secondPointId);

                    var thirdPoint = findShapeById(_d.thirdPointId);
                    var seg1 = findShape(_d.seg1Id).shape;
                    var seg2 = findShape(_d.seg2Id).shape;
                    var seg3 = findShape(_d.seg3Id).shape;

                    if (!(_firstPoint.shape.isSelected || _secondPoint.shape.isSelected || thirdPoint.shape.isSelected || seg1.isSelected || seg2.isSelected || seg3.isSelected)) {
                      if (!(_firstPoint.shape.isIntersection || _firstPoint.shape.isParameter || _secondPoint.shape.isIntersection || _secondPoint.shape.isParameter || thirdPoint.shape.isIntersection || thirdPoint.shape.isParameter)) {
                        var ang1 = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, _firstPoint.shape.x, _firstPoint.shape.y);
                        var ang2 = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, _secondPoint.shape.x, _secondPoint.shape.y);
                        var ang3 = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, thirdPoint.shape.x, thirdPoint.shape.y);

                        var _dist2 = modelObj.LabComClass.Maths.getDistance(_d, _firstPoint.shape);

                        var _dist3 = modelObj.LabComClass.Maths.getDistance(_d, _secondPoint.shape);

                        var dist3 = modelObj.LabComClass.Maths.getDistance(_d, thirdPoint.shape);
                        findShapeById(_d.uniqueId, _d.x + _diffX2, _d.y + _diffY2);
                        var p1 = modelObj.LabComClass.Maths.getPoint(_d, ang1, _dist2);
                        var p2 = modelObj.LabComClass.Maths.getPoint(_d, ang2, _dist3);
                        var p3 = modelObj.LabComClass.Maths.getPoint(_d, ang3, dist3);
                        findShapeById(_d.firstPointId, p1.x, p1.y);
                        findShapeById(_d.secondPointId, p2.x, p2.y);
                        findShapeById(_d.thirdPointId, p3.x, p3.y);
                      }
                    }
                  }
                }
              };

              for (var _i3 = 0; _i3 < shapesData.length; _i3++) {
                var _ret = _loop4(_i3);

                if (_ret === "continue") continue;
              }

              for (var _i4 = 0; _i4 < shapesData.length; _i4++) {
                var _d3 = shapesData[_i4];

                if (_d3.isSelected) {
                  if (_d3.type === 'point') {
                    if (_d3.connectionId.length > 0) {
                      // console.log('HERE@@',_d.uniqueId);
                      updateShapes(_d3, _diffX2, _diffY2);
                    }
                  }

                  if ((_d3.type.includes('segment') || _d3.type === 'line' || _d3.type === 'ray') && !_d3.dontDrag) {
                    if (_d3.connectionId.length > 0) {
                      updateShapes(_d3, _diffX2, _diffY2);
                    }
                  }
                }
              }
            }
          } else if (tool === 'select'
          /*|| (localObj.selectAll && tool === 'move')*/
          ) {
              var _localObj$mouseDown2 = localObj.mouseDown,
                  orignalX = _localObj$mouseDown2.orignalX,
                  orignalY = _localObj$mouseDown2.orignalY,
                  x = _localObj$mouseDown2.x,
                  y = _localObj$mouseDown2.y;
              selectObjectsInPixelRange(orignalX, orignalY, x, y);
            }

          localObj.mouseDown.x = e.pageX;
          localObj.mouseDown.y = e.pageY;
        }

        updateAllShapes(e);
        updateAllShapes(e);
      }
    }

    return true;
  }

  function properPoint(e, fp, sp) {
    var parentType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'segment';

    if (e) {
      var mouse = getPointByPixel(e.pageX, e.pageY);
      var point = modelObj.LabComClass.Maths.getLinePointIntersection(fp, sp, mouse);
      var dist1 = modelObj.LabComClass.Maths.getDistance(point, fp);
      var dist2 = modelObj.LabComClass.Maths.getDistance(point, sp);
      var totalDist = modelObj.LabComClass.Maths.getDistance(fp, sp);
      var ans = to2Dec(dist1 + dist2) === to2Dec(totalDist);

      if (!ans) {
        if (dist1 < dist2) {
          point = {
            x: fp.x,
            y: fp.y
          };
        } else if (dist1 > dist2 && parentType === 'segment') {
          point = {
            x: sp.x,
            y: sp.y
          };
        }
      }

      return {
        ans: ans,
        point: point
      };
    }
  }

  function to(num) {
    return to2Dec(num);
  }

  function updateDiff(_d, newPos) {
    var max = 50;
    var min = -50;
    _d.labelDiffX = newPos.x;
    _d.labelDiffY = newPos.y; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffX = _d.labelDiffX > max ? max : _d.labelDiffX < min ? min : _d.labelDiffX; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffY = _d.labelDiffY > max ? max : _d.labelDiffY < min ? min : _d.labelDiffY;
  }

  this.setSegmentColor = function (color) {
    modelObj.segmentColor = color;
  };

  this.getSegmentColor = function (color) {
    return modelObj.segmentColor;
  };

  this.updateShape = function (uniqueId, _obj) {
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        shape.shape[i] = _obj[i];
      });
    }

    if (modelObj.interactionType === 'labelTool') {
      updateAllShapes();
    }
  };

  function updatePointValues(target, values) {
    var update = false;

    if (findDraggable([target])) {
      // if (target.isIntersection) {
      //   if (target.circle1 !== undefined && target.circle2 !== undefined) {
      //     update = true;
      //   } else {
      //     update = true;
      //   }
      // } else {
      //   update = true;
      // }
      if (target.isIntersection === undefined) {
        update = true;
      }
    }

    if (target.x === values.x && target.y === values.y) {
      update = true;
    }

    if (update) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }

    return update;
  }

  function selectObjectsInPixelRange(x, y, maxX, maxY) {
    if (x > maxX && y > maxY) {
      var temp = x;
      x = maxX;
      maxX = temp;
      temp = y;
      y = maxY;
      maxY = temp;
    } else if (x < maxX && y > maxY) {
      var _temp = y;
      y = maxY;
      maxY = _temp;
    } else if (x > maxX && y < maxY) {
      var _temp2 = x;
      x = maxX;
      maxX = _temp2;
    }

    var flag = false;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var shape = modelObj.interactionElements[i]; // if (shape.type === 'point') {

      var pos = getPixelByPoint(shape.x, shape.y); // console.log('POS',to(pos.x),to(pos.y),'----',to(x),to(maxX),to(y),to(maxY));

      if (!shape.isSelected) {
        if (pos.x >= x && pos.x <= maxX && pos.y >= y && pos.y <= maxY) {
          shape.isSelected = true;
          localObj.selectedItemsCount++;
          flag = true;
          localObj.itemCount++;
        }
      } // }

    }

    localObj.selectFlag = flag;

    if (localObj.itemCount > 0) {
      localObj.selectFlag = true;
    }
  }

  function updateAllShapes(e) {
    var _modelObj$LabComClass2 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass2.getDistance,
        getAngle = _modelObj$LabComClass2.getAngle,
        getPoint = _modelObj$LabComClass2.getPoint,
        pointInSegment = _modelObj$LabComClass2.pointInSegment,
        getLineintersect = _modelObj$LabComClass2.getLineintersect,
        getLinePointIntersection = _modelObj$LabComClass2.getLinePointIntersection;

    var _loop5 = function _loop5(i) {
      var shape = modelObj.interactionElements[i];

      if (shape.type.includes('segment') || shape.type === 'length' || shape.type === 'line' || shape.type === 'ray') {
        var firstPoint, secondPoint;
        var label = null;

        if (shape.firstPointId) {
          firstPoint = findShape(shape.firstPointId);

          if (firstPoint) {
            // label = firstPoint.shape.label;
            updateShapeValue(shape, {
              x: firstPoint.shape.x,
              y: firstPoint.shape.y
            });
          }
        }

        if (shape.secondPointId) {
          secondPoint = findShape(shape.secondPointId);

          if (secondPoint) {
            // if (label) {
            //   label += secondPoint.shape.label;
            //   if (shape.label === undefined) {
            //     shape.label = label;
            //   }
            // }
            updateShapeValue(shape, {
              xTo: secondPoint.shape.x,
              yTo: secondPoint.shape.y
            });
          }
        }

        if (shape.type === 'line' || shape.type === 'ray') {
          updateLinePoints(shape);

          if (shape.firstPointId && shape.secondPointId) {
            if (firstPoint.shape.visible && secondPoint.shape.visible) {
              shape.visible = true;
            } else {
              shape.visible = false;
            }
          }
        }

        if (shape.type.includes('segment')) {
          if (shape.lengthId) {
            var parentShape = findShape(shape.lengthId).shape;

            if (parentShape && (shape === null || shape === void 0 ? void 0 : shape.label) && !(shape === null || shape === void 0 ? void 0 : shape.onlyLength)) {
              if (shape.label.includes(' = ')) {
                shape.label = shape.label.replace(' = ' + shape.label.split(' = ')[1], '');
              }

              shape.label = modelObj.shapes.length.digit !== undefined ? shape.label + ' = ' + shape.distance.toFixed(modelObj.shapes.length.digit).toString().replace('.', ',') : shape.label + ' = ' + shape.distance.toFixed(2).toString().replace('.', ',');

              if (shape.label.split(' = ')[0] === '') {
                shape.label = '';
              }
            }

            if (shape.onlyLength) {
              shape.label = modelObj.shapes.length.digit !== undefined ? shape.distance.toFixed(modelObj.shapes.length.digit).toString().replace('.', ',') : shape.distance.toFixed(2).toString().replace('.', ',');
            }
          }

          var distancePos = {
            x: (shape.x + shape.xTo) / 2,
            y: (shape.y + shape.yTo) / 2
          };
          shape.labelX = distancePos.x;
          shape.labelY = distancePos.y;
          shape.distance = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        }

        if (shape.type === 'ray' || shape.type === 'line') {
          var _distancePos = {
            x: (shape.x + shape.xTo) / 2,
            y: (shape.y + shape.yTo) / 2
          };
          shape.labelX = _distancePos.x;
          shape.labelY = _distancePos.y;

          if (shape.type === 'ray' && shape.slope !== undefined) {
            shape.slope = modelObj.LabComClass.Maths.getAngle(shape.x, shape.y, shape.xTo, shape.yTo);
          }
        }

        if (shape.type.includes('segment') && shape.firstPointId && shape.secondPointId) {
          if (firstPoint.shape.visible && secondPoint.shape.visible) {
            shape.visible = true;
          } else {
            shape.visible = false;
          }
        }

        if (shape.type === 'length') {
          var text = '';

          if (shape.segmentID) {
            var segment = findShape(shape.segmentID);

            if (segment && segment.shape) {
              shape.x = segment.shape.x;
              shape.xTo = segment.shape.xTo;
              shape.y = segment.shape.y;
              shape.yTo = segment.shape.yTo; // const firstPoint = findShape(segment.shape.firstPointId);
              // const secondPoint = findShape(segment.shape.secondPointId);
              // if (firstPoint && firstPoint.shape && secondPoint && secondPoint.shape) {
              //   if (firstPoint.shape.label !== '' && secondPoint.shape.label !== '') {
              //     text = firstPoint.shape.label + '' + secondPoint.shape.label;
              //   }
              // }

              if (segment.shape.label) {
                text = segment.shape.label;
              }
            }
          } else if (shape.circleId) {
            var circle = findShape(shape.circleId);

            if (circle && circle.shape) {
              shape.x = circle.shape.x;
              shape.xTo = circle.shape.x + circle.shape.r;
              shape.y = circle.shape.y;
              shape.yTo = circle.shape.y;

              if (circle.shape.label === '' || circle.shape.label === undefined) {
                text = 'U';
              } else {
                text = "U\xA7q".concat(circle.shape.label, "\xA7r"); // text = `U(${circle.shape.label})`;
              }
            }
          } else {
            if (!shape.labelText) {
              var _firstPoint2 = findShape(shape.firstPointId);

              var _secondPoint2 = findShape(shape.secondPointId);

              if (_firstPoint2 && _firstPoint2.shape && _secondPoint2 && _secondPoint2.shape) {
                if (_firstPoint2.shape.label !== '' && _secondPoint2.shape.label !== '') {
                  text = _firstPoint2.shape.label + '' + _secondPoint2.shape.label;
                }
              }
            } else {
              text = shape.labelText;
            }
          }

          if (shape.circleId !== undefined) {
            shape.circumference = 2 * Math.PI * (shape.xTo - shape.x); //Circumference

            if (modelObj.shapes.length.digit !== undefined) {
              shape.circumference = Number(shape.circumference.toFixed(modelObj.shapes.length.digit));
            }

            var _distancePos2 = modelObj.LabComClass.Maths.getPoint(shape, shape.angle, Math.abs(shape.xTo - shape.x));

            if (text && !modelObj.shapes.length.onlyDistance) {
              shape.label = "".concat(text, " = ") + shape.circumference.toString().replace('.', ',');
            } else if (text && modelObj.shapes.length.onlyDistance) {
              shape.label = shape.circumference.toString().replace('.', ',');
              shape.distanceText = shape.circumference;
            }

            shape.labelX = _distancePos2.x;
            shape.labelY = _distancePos2.y;

            if (shape.labelDiffX === undefined) {
              shape.labelDiffX = 0;
              shape.labelDiffY = 0;
            }
          } else {
            shape.distance = getDistance(shape, {
              x: shape.xTo,
              y: shape.yTo
            });

            if (modelObj.shapes.length.digit !== undefined) {
              shape.distance = Number(shape.distance.toFixed(modelObj.shapes.length.digit));
            }

            var _distancePos3 = {
              x: (shape.x + shape.xTo) / 2,
              y: (shape.y + shape.yTo) / 2
            };

            if (text && !modelObj.shapes.length.onlyDistance) {
              // shape.label = `§d${text}§r = ` + shape.distance.toString().replace('.', ',');
              shape.label = "".concat(text, " = ") + shape.distance.toString().replace('.', ',');
              shape.distanceText = shape.distance; // shape.originalLabel = shape.label; 
            } else if (text && modelObj.shapes.length.onlyDistance) {
              shape.label = shape.distance.toString().replace('.', ',');
              shape.labelFor = text;
              shape.distanceText = shape.distance;
            } else if (text === '' && shape.firstPointId !== undefined && shape.secondPointId !== undefined || shape.segmentID !== undefined) {
              shape.label = shape.distance.toString().replace('.', ',');
            }

            if (shape.mode === 'segment') {
              shape.label = ''; //   if(shape.segmentID) {
              //     const parentShape = findShape(shape.segmentID).shape;
              //     if(parentShape.label === undefined || parentShape.label === "") {
              //       parentShape.label = shape.distance.toString().replace('.', ',');
              //       parentShape.onlyLength = true;
              //     }
              //   }
            }

            shape.labelX = _distancePos3.x;
            shape.labelY = _distancePos3.y;

            if (shape.labelDiffX === undefined) {
              shape.labelDiffX = 0;
              shape.labelDiffY = 0;
            }
          }
        }
      }

      if (shape.type === 'angleRay') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint3 = findShape(shape.firstPointId).shape;
          var _secondPoint3 = findShape(shape.secondPointId).shape;
          var thirdPoint;

          if (shape.thirdPointId !== undefined) {
            thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            thirdPoint = shape.thirdPoint;
          }

          if (thirdPoint) {
            shape.x = _secondPoint3.x;
            shape.y = _secondPoint3.y;
            var firstRay = new modelObj.LabComClass.Vector(_secondPoint3.x - _firstPoint3.x, _secondPoint3.y - _firstPoint3.y);
            var secondRay = new modelObj.LabComClass.Vector(thirdPoint.x - _firstPoint3.x, thirdPoint.y - _firstPoint3.y);
            shape.angle = secondRay.crossProduct(firstRay).z; // shape.angle *= (Math.PI / 180);
            // if (shape.angle < 0) {
            //   shape.angle += (Math.PI * 2);
            // }

            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, thirdPoint.x, thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, _firstPoint3.x, _firstPoint3.y);
            shape.angleStart = spineObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, _firstPoint3.x, _firstPoint3.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, _firstPoint3.x, _firstPoint3.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, _firstPoint3.x, _firstPoint3.y) * 180 / Math.PI;
            shape.angleEnd = spineObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, thirdPoint.x, thirdPoint.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, thirdPoint.x, thirdPoint.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, thirdPoint.x, thirdPoint.y) * 180 / Math.PI;
            var angle = shape.endAngle - shape.startAngle;

            if (angle < 0) {
              angle = angle * -1 * 180 / Math.PI;
            } else if (angle > 0) {
              angle = 360 - angle * 180 / Math.PI;
            }

            shape.labelX = shape.x + getPointUnitByPixelUnit(10);
            shape.labelY = shape.y - getPointUnitByPixelUnit(10);
            shape.angleText = '' + Math.round(angle);
            shape.angleValue = Math.round(angle);
            shape.visible = _firstPoint3.visible && _secondPoint3.visible && thirdPoint.visible ? true : false;
          }
        }
      }

      if (shape.type === 'angleB') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var fp = findShape(shape.firstPointId).shape;
          var sp = findShape(shape.secondPointId).shape;
          var tp;

          if (shape.thirdPointId !== undefined) {
            tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            tp = shape.thirdPoint;
          }

          if (tp) {
            var angleBisectorData = calculateBisector({
              firstPoint: fp,
              secondPoint: sp,
              thirdPoint: tp
            });
            shape.x = angleBisectorData.bisectorLine.x;
            shape.y = angleBisectorData.bisectorLine.y;
            shape.xTo = angleBisectorData.bisectorLine.xTo;
            shape.yTo = angleBisectorData.bisectorLine.yTo;
            var line = findShape(shape.bisectorLine.uniqueId).shape;
            line.x = angleBisectorData.bisectorLine.x;
            line.y = angleBisectorData.bisectorLine.y;
            line.xTo = angleBisectorData.bisectorLine.xTo;
            line.yTo = angleBisectorData.bisectorLine.yTo;
            line.slope = getSlope(line.x, line.y, line.xTo, line.yTo);
            line.visible = fp.visible && sp.visible && tp.visible && (line.xTo !== null || line.yTo !== null);
          }
        } else if (shape.mode === 'segment') {
          if (shape.firstSegment !== undefined && shape.secondSegment !== undefined) {
            var firstSegment = findShape(shape.firstSegmentId).shape;
            var secondSegment = findShape(shape.secondSegmentId).shape;
            var commonPt = shape.firstConnId.filter(function (value) {
              return shape.secondConnId.includes(value);
            })[0];

            if (commonPt === undefined) {} else {
              var pCommon = findCommon(firstSegment, secondSegment);
              shape.x = +pCommon.x;
              shape.y = +pCommon.y;
              var angleBData = calculateBisector({
                firstSegment: firstSegment,
                secondSegment: secondSegment,
                x: +pCommon.x,
                y: +pCommon.y
              }, "segment");
              var _line3 = findShape(shape.bisectorLine.uniqueId).shape;
              _line3.x = shape.x;
              _line3.y = shape.y;
              _line3.xTo = angleBData.bisectorLine.xTo;
              _line3.yTo = angleBData.bisectorLine.yTo;
              _line3.slope = getSlope(_line3.x, _line3.y, _line3.xTo, _line3.yTo);
            }
          }
        }
      }

      if (shape.type === 'perpendicularBisector') {
        if (shape.mode === 'point' && shape.firstPointPlotted && shape.secondPointPlotted) {
          var perpShape = {};
          var _fp17 = findShape(shape.firstPointId).shape;
          var _sp4 = findShape(shape.secondPointId).shape;
          var midPoint = {};
          midPoint.x = (_fp17.x + _sp4.x) / 2;
          midPoint.y = (_fp17.y + _sp4.y) / 2;
          var angle2Point = modelObj.LabComClass.Maths.getAngle(_fp17.x, _fp17.y, _sp4.x, _sp4.y);
          perpShape.x = midPoint.x;
          perpShape.y = midPoint.y;
          perpShape.angle = angle2Point + Math.PI / 2;
          perpShape.point = modelObj.LabComClass.Maths.getPoint(midPoint, perpShape.angle, getPointUnitByPixelUnit(20));
          var _line4 = findShape(shape.perpLineId).shape;
          _line4.x = midPoint.x;
          _line4.y = midPoint.y;
          _line4.xTo = perpShape.point.x;
          _line4.yTo = perpShape.point.y;
          _line4.slope = perpShape.angle;
          _line4.visible = _fp17.visible && _sp4.visible;
        }

        if (shape.mode === 'segment' && shape.segmentId !== undefined && shape.segmentPlotted) {
          var _perpShape = {};
          var _segment = findShape(shape.segmentId).shape;
          var _fp18 = {
            x: _segment.x,
            y: _segment.y
          };
          var _sp5 = {
            x: _segment.xTo,
            y: _segment.yTo
          };
          var _midPoint = {};
          _midPoint.x = (_fp18.x + _sp5.x) / 2;
          _midPoint.y = (_fp18.y + _sp5.y) / 2;

          var _angle2Point = modelObj.LabComClass.Maths.getAngle(_fp18.x, _fp18.y, _sp5.x, _sp5.y);

          _perpShape.x = _midPoint.x;
          _perpShape.y = _midPoint.y;
          _perpShape.angle = _angle2Point + Math.PI / 2;
          _perpShape.point = modelObj.LabComClass.Maths.getPoint(_midPoint, _perpShape.angle, getPointUnitByPixelUnit(20));
          var _line5 = findShape(shape.perpLineId).shape;
          _line5.x = _midPoint.x;
          _line5.y = _midPoint.y;
          _line5.xTo = _perpShape.point.x;
          _line5.yTo = _perpShape.point.y;
          _line5.slope = _perpShape.angle;
          _line5.visible = _segment.visible;
        }
      }

      if (shape.type === 'mirrorOnLine') {
        if (shape.lineId !== undefined && shape.linePlotted) {
          var _line6 = findShape(shape.lineId).shape;
          var parentPoint = findShape(shape.firstPointId).shape;
          var eqnLine = computeEqn(_line6);
          var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, parentPoint.x, parentPoint.y);
          shape.x = mirrorPoint.x;
          shape.y = mirrorPoint.y;
          var mirrorShape = findShape(shape.mirrorPointId).shape;
          mirrorShape.x = mirrorPoint.x;
          mirrorShape.y = mirrorPoint.y; // if(line.visible) {

          mirrorShape.visible = _line6.visible; // }
        }
      }

      if (shape.type === 'circle_3') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _fp19 = findShape(shape.firstPointId).shape;
          var _sp6 = findShape(shape.secondPointId).shape;

          var _tp;

          if (shape.thirdPointId !== undefined) {
            _tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _tp = shape.thirdPoint;
          }

          if (_tp) {
            var cData = circle3Handler(_fp19, _sp6, _tp);
            shape.x = cData.x;
            shape.y = cData.y;
            shape.r = cData.r;
            var labelPos = modelObj.LabComClass.Maths.getPoint(shape, 3 * Math.PI / 4, 0.8 * shape.r);
            shape.labelX = labelPos.x;
            shape.labelY = labelPos.y;
          }
        }
      }

      if (shape.type === 'angle') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint4 = findShape(shape.firstPointId).shape;
          var _secondPoint4 = findShape(shape.secondPointId).shape;

          var _thirdPoint;

          if (shape.thirdPointId !== undefined) {
            _thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _thirdPoint = shape.thirdPoint;
          }

          if (_thirdPoint) {
            shape.x = _secondPoint4.x;
            shape.y = _secondPoint4.y;

            var _firstRay = new modelObj.LabComClass.Vector(_secondPoint4.x - _firstPoint4.x, _secondPoint4.y - _firstPoint4.y);

            var _secondRay = new modelObj.LabComClass.Vector(_thirdPoint.x - _firstPoint4.x, _thirdPoint.y - _firstPoint4.y);

            shape.angle = _secondRay.crossProduct(_firstRay).z;
            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y);
            shape.angleStart = spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y) * 180 / Math.PI;
            shape.angleEnd = spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y) * 180 / Math.PI;

            var _angle3 = shape.endAngle - shape.startAngle;

            if (_angle3 < 0) {
              _angle3 = _angle3 * -1 * 180 / Math.PI;
            } else if (_angle3 > 0) {
              _angle3 = 360 - _angle3 * 180 / Math.PI;
            }

            shape.angleText = '' + Math.round(_angle3);
            shape.angleValue = Math.round(_angle3); // shape.label = shape.angleText + '°';  

            if (shape.newLabel) {
              shape.label = shape.newLabel + ' = ' + shape.angleText + '°';
            } else {
              shape.label = shape.angleText + '°';
            }

            shape.labelX = shape.x + getPointUnitByPixelUnit(10);
            shape.labelY = shape.y - getPointUnitByPixelUnit(10);
            shape.visible = _firstPoint4.visible && _secondPoint4.visible && _thirdPoint.visible ? true : false;
          }
        }
      }

      if (shape.type === 'angleSize') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined && (shape === null || shape === void 0 ? void 0 : shape.angleEntered) !== undefined) {
          var _fp20 = findShape(shape.firstPointId).shape;
          var _sp7 = findShape(shape.secondPointId).shape;
          shape.x = _sp7.x;
          shape.y = _sp7.y;
          var degree = shape.angleSign;
          var angleBet2Points = modelObj.LabComClass.Maths.getAngle(_sp7.x, _sp7.y, _fp20.x, _fp20.y);
          var angleText = modelObj.LabComClass.Maths.getPoint(shape, angleBet2Points + degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25)); // degree *= (shape.clockwise ? -1 : 1);

          var rayEnd = modelObj.LabComClass.Maths.getPoint(shape, angleBet2Points + degree * Math.PI / 180, getPointUnitByPixelUnit(10));

          if (shape.clockwise) {
            shape.startAngle = angleBet2Points;
            shape.endAngle = angleBet2Points + degree * Math.PI / 180;
          } else {
            shape.startAngle = angleBet2Points + degree * Math.PI / 180;
            shape.endAngle = angleBet2Points;
          }

          shape.angleStart = spineObj.LabComClass.Maths.getAngle(_sp7.x, _sp7.y, _fp20.x, _fp20.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_sp7.x, _sp7.y, _fp20.x, _fp20.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_sp7.x, _sp7.y, _fp20.x, _fp20.y) * 180 / Math.PI;
          shape.angleEnd = spineObj.LabComClass.Maths.getAngle(_sp7.x, _sp7.y, rayEnd.x, rayEnd.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_sp7.x, _sp7.y, rayEnd.x, rayEnd.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_sp7.x, _sp7.y, rayEnd.x, rayEnd.y) * 180 / Math.PI;
          var rayShape = findShape(shape.rayId).shape;
          rayShape.x = shape.x;
          rayShape.y = shape.y;
          rayShape.xTo = rayEnd.x;
          rayShape.yTo = rayEnd.y; // if (shape.labelX === undefined) {

          var angleTextPos = modelObj.LabComClass.Maths.getPoint(shape, angleBet2Points + degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));

          if (shape.newLabel) {
            shape.label = shape.newLabel + ' = ' + shape.degree + '°';
          } else {
            shape.label = shape.degree + '°';
          }

          shape.labelX = angleTextPos.x;
          shape.labelY = angleTextPos.y;
          shape.labelDiffX = shape.labelDiffX !== undefined ? shape.labelDiffX : 0;
          shape.labelDiffY = shape.labelDiffY !== undefined ? shape.labelDiffY : 0; // }

          shape.visible = _fp20.visible && _sp7.visible;
          rayShape.visible = _fp20.visible && _sp7.visible;
        }
      }

      if (shape.type === 'midPoint') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint5 = findShape(shape.firstPointId).shape;
          var _secondPoint5 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint5.x + _secondPoint5.x) / 2;
          shape.y = (_firstPoint5.y + _secondPoint5.y) / 2;
          var _midPoint2 = findShape(shape.midPointId).shape;
          _midPoint2.x = shape.x;
          _midPoint2.y = shape.y;

          if (shape.onSegment === undefined) {
            _midPoint2.visible = _firstPoint5.visible && _secondPoint5.visible ? true : false;
          }

          if (shape.onSegment) {
            var _midPoint3 = findShape(shape.midPointId).shape;
            var _segment2 = findShape(shape.segmentId).shape;
            _midPoint3.visible = _segment2.visible;
          }
        }
      }

      if (shape.type === 'mirrorOnPoint') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint6 = findShape(shape.firstPointId).shape;
          var _secondPoint6 = findShape(shape.secondPointId).shape;
          shape.x = 2 * _secondPoint6.x - _firstPoint6.x;
          shape.y = 2 * _secondPoint6.y - _firstPoint6.y;
          var mirrorOnPoint = findShape(shape.mirrorOnPointId).shape;
          mirrorOnPoint.x = shape.x;
          mirrorOnPoint.y = shape.y;
          mirrorOnPoint.visible = _firstPoint6.visible && _secondPoint6.visible;
        }
      } else if (shape.type === 'segSize') {
        if (shape.secondPointId !== undefined) {
          var _firstPoint7 = findShape(shape.firstPointId).shape;
          var _secondPoint7 = findShape(shape.secondPointId).shape;

          if (_secondPoint7.uniqueId === localObj.currentUniqueId) {
            var _angle4 = modelObj.LabComClass.Maths.getAngle(_firstPoint7.x, _firstPoint7.y, _secondPoint7.x, _secondPoint7.y);

            var newSecondPoint = modelObj.LabComClass.Maths.getPoint(_firstPoint7, _angle4, shape.distance);
            _secondPoint7.x = newSecondPoint.x;
            _secondPoint7.y = newSecondPoint.y;
            shape.slope = _angle4;
          } else
            /*if (firstPoint.uniqueId === localObj.currentUniqueId)*/
            {
              var _newSecondPoint = modelObj.LabComClass.Maths.getPoint(_firstPoint7, shape.slope, shape.distance);

              _secondPoint7.x = _newSecondPoint.x;
              _secondPoint7.y = _newSecondPoint.y;
            }
        }
      } else if (shape.type === 'triangle') {
        var _firstPoint8 = findShape(shape.firstPointId).shape;
        var _secondPoint8 = findShape(shape.secondPointId).shape;
        var _thirdPoint2 = findShape(shape.thirdPointId).shape;

        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined && shape.thirdPointId !== undefined) {
          shape.firstPoint = {
            x: _firstPoint8.x,
            y: _firstPoint8.y,
            label: _firstPoint8.label
          };
          shape.secondPoint = {
            x: _secondPoint8.x,
            y: _secondPoint8.y,
            label: _secondPoint8.label
          };
          shape.thirdPoint = {
            x: _thirdPoint2.x,
            y: _thirdPoint2.y,
            label: _thirdPoint2.label
          };
          shape.firstSegmentPlotted = true;
          shape.secondSegmentPlotted = true;
          shape.thirdSegmentPlotted = true;
          shape.visible = _firstPoint8.visible && _secondPoint8.visible && _thirdPoint2.visible;
        }
      } else if (shape.type === 'square') {
        var _firstPoint9 = findShape(shape.firstPointId).shape;
        var _secondPoint9 = findShape(shape.secondPointId).shape;
        var _thirdPoint3 = findShape(shape.thirdPointId).shape;
        var fourthPoint = findShape(shape.fourthPointId).shape;

        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined && shape.thirdPointId !== undefined && shape.fourthPointId !== undefined) {
          shape.firstPoint = {
            x: _firstPoint9.x,
            y: _firstPoint9.y
          };
          shape.secondPoint = {
            x: _secondPoint9.x,
            y: _secondPoint9.y
          };
          shape.thirdPoint = {
            x: _thirdPoint3.x,
            y: _thirdPoint3.y
          };
          shape.fourthPoint = {
            x: fourthPoint.x,
            y: fourthPoint.y
          };
          shape.distance = modelObj.LabComClass.Maths.getDistance(_firstPoint9, _secondPoint9);
          var thirdPointNew = modelObj.LabComClass.Maths.getPoint(_secondPoint9, modelObj.LabComClass.Maths.getAngle(_secondPoint9.x, _secondPoint9.y, _firstPoint9.x, _firstPoint9.y) - Math.PI / 2, shape.distance);
          var fourthPointNew = modelObj.LabComClass.Maths.getPoint(_firstPoint9, modelObj.LabComClass.Maths.getAngle(_secondPoint9.x, _secondPoint9.y, _firstPoint9.x, _firstPoint9.y) - Math.PI / 2, shape.distance);

          if (_firstPoint9.visible && _secondPoint9.visible) {
            shape.thirdPoint = {
              x: thirdPointNew.x,
              y: thirdPointNew.y
            };
            shape.fourthPoint = {
              x: fourthPointNew.x,
              y: fourthPointNew.y
            };
            _thirdPoint3.x = thirdPointNew.x;
            _thirdPoint3.y = thirdPointNew.y;
            fourthPoint.x = fourthPointNew.x;
            fourthPoint.y = fourthPointNew.y;
          }

          shape.visible = _firstPoint9.visible && _secondPoint9.visible; // thirdPoint.visible = shape.visible;
          // fourthPoint.visible = shape.visible;
        }
      } else if (shape.type === 'compass') {
        if (shape.segmentID !== undefined) {
          var _segment3 = findShape(shape.segmentID);

          var point = findShape(shape.connectionId[0]);

          if (_segment3 && _segment3.shape) {
            shape.r = getDistance(_segment3.shape, {
              x: _segment3.shape.xTo,
              y: _segment3.shape.yTo
            });
          }

          if (point && point.shape.circle) {
            var circleShape = findShape(point.shape.circle).shape;

            if (point.shape.isMoved) {
              // shape.r = shape.r;
              shape.x = point.shape.x;
              shape.y = point.shape.y;
            } else if (circleShape && point.shape.isParameter && shape.isMoved && e !== undefined) {
              var mouse = getPointByPixel(e.pageX, e.pageY);

              var _angle5 = modelObj.LabComClass.Maths.getAngle(circleShape.x, circleShape.y, mouse.x, mouse.y);

              point.shape.angle = _angle5;
              var newPoint = getPoint(circleShape, point.shape.angle, shape.r); // point.shape.x = newPoint.x;
              // point.shape.y = newPoint.y;

              shape.x = newPoint.x;
              shape.y = newPoint.y;
              shape.r = getDistance(_segment3.shape, {
                x: _segment3.shape.xTo,
                y: _segment3.shape.yTo
              }); // point.shape.isMoved = false;
            } else if (_segment3 && point.shape.isParameter) {
              // shape.r = circle.shape.r;
              shape.x = point.shape.x;
              shape.y = point.shape.y;
            } // if (segment && segment.shape) {
            //   shape.r = getDistance(segment.shape, { x: segment.shape.xTo, y: segment.shape.yTo });
            //   point.shape.isMoved = false;
            //   shape.isMoved = false;
            // }

          } else if (point && point.shape.line) {
            var _parentShape = findShape(point.shape.line).shape;
            var _fp21 = findShape(_parentShape.firstPointId).shape;
            var _sp8 = findShape(_parentShape.secondPointId).shape;

            if (_fp21 === undefined && (_parentShape.type === 'line' || _parentShape.type === 'ray')) {
              _fp21 = {
                x: _parentShape.x,
                y: _parentShape.y
              };
            }

            if (_sp8 === undefined && (_parentShape.type === 'line' || _parentShape.type === 'ray')) {
              // sp = modelObj.LabComClass.Maths.getPoint(fp,parentShape.slope,getPointUnitByPixelUnit(20));
              _sp8 = {
                x: _parentShape.xTo,
                y: _parentShape.yTo
              };
            }

            if (_parentShape.type === 'perpendicularLine' || _parentShape.type === 'parallelLine') {
              if (_fp21 === undefined) {
                _fp21 = {
                  x: _parentShape.x,
                  y: _parentShape.y
                };
                _sp8 = {
                  x: _parentShape.xTo,
                  y: _parentShape.yTo
                };
              }

              if (_sp8 === undefined) {
                _sp8 = {
                  x: _parentShape.xTo,
                  y: _parentShape.yTo
                };
              }
            }

            shape.x = point.shape.x;
            shape.y = point.shape.y;
            var linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection(_fp21, _sp8, shape);
            var pointdist = getDistance(_parentShape, linePointIntersection);
            var parentShapeDist = getDistance(_fp21, _sp8);

            if (pointInSegment(shape, _fp21, _sp8) && _parentShape.type.includes('segment')) {
              if (_segment3 && point.shape.isParameter && point.shape.isMoved) {
                // shape.r = circle.shape.r;
                shape.x = linePointIntersection.x;
                shape.y = linePointIntersection.y;
                point.shape.updateKeys.x = linePointIntersection.x;
                point.shape.updateKeys.y = linePointIntersection.y;
                point.shape.percentage = pointdist / parentShapeDist;
                point.shape.updateKeys.percentage = pointdist / parentShapeDist;
              } else if (_segment3 && point.shape.isParameter && shape.isMoved && e) {
                linePointIntersection = properPoint(e, _fp21, _sp8).point; // else {
                //   linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection(fp, sp, shape);
                // }

                pointdist = getDistance(_parentShape, linePointIntersection); // shape.r = circle.shape.r;

                shape.x = linePointIntersection.x;
                shape.y = linePointIntersection.y;
                point.shape.x = linePointIntersection.x;
                point.shape.y = linePointIntersection.y;
                point.shape.pointAngle = true;
                point.shape.updateKeys.x = linePointIntersection.x;
                point.shape.updateKeys.y = linePointIntersection.y;
                point.shape.percentage = pointdist / parentShapeDist;
                point.shape.updateKeys.percentage = pointdist / parentShapeDist;
              }
            } else if (pointInSegment(shape, {
              x: _parentShape.xOr,
              y: _parentShape.yOr
            }, {
              x: _parentShape.xOrTo,
              y: _parentShape.yOrTo
            }) && (_parentShape.type == "line" || _parentShape.type === 'perpendicularLine' || _parentShape.type === 'parallelLine')) {
              if (_segment3 && point.shape.isParameter && point.shape.isMoved) {
                // shape.r = circle.shape.r;
                shape.x = linePointIntersection.x;
                shape.y = linePointIntersection.y;
                point.shape.updateKeys.x = linePointIntersection.x;
                point.shape.updateKeys.y = linePointIntersection.y;
                point.shape.percentage = pointdist / parentShapeDist;
                point.shape.updateKeys.percentage = pointdist / parentShapeDist;
              } else if (_segment3 && point.shape.isParameter && shape.isMoved && e) {
                var _mouse = getPointByPixel(e.pageX, e.pageY);

                linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection({
                  x: _parentShape.xOr,
                  y: _parentShape.yOr
                }, {
                  x: _parentShape.xOrTo,
                  y: _parentShape.yOrTo
                }, _mouse);
                pointdist = getDistance(_parentShape, linePointIntersection); // shape.r = circle.shape.r;

                shape.x = linePointIntersection.x;
                shape.y = linePointIntersection.y;
                point.shape.x = linePointIntersection.x;
                point.shape.y = linePointIntersection.y;
                point.shape.updateKeys.x = linePointIntersection.x;
                point.shape.updateKeys.y = linePointIntersection.y;
                point.shape.percentage = pointdist / parentShapeDist;
                point.shape.updateKeys.percentage = pointdist / parentShapeDist;

                if (pointInSegment(shape, _fp21, {
                  x: _parentShape.xOr,
                  y: _parentShape.yOr
                })) {
                  point.shape.pointAngle = true;
                } else {
                  point.shape.pointAngle = false;
                }
              }
            } else if (pointInSegment(shape, _fp21, {
              x: _parentShape.xOr,
              y: _parentShape.yOr
            }) && _parentShape.type == "ray") {
              if (_segment3 && point.shape.isParameter && point.shape.isMoved) {
                // shape.r = circle.shape.r;
                shape.x = linePointIntersection.x;
                shape.y = linePointIntersection.y;
                point.shape.updateKeys.x = linePointIntersection.x;
                point.shape.updateKeys.y = linePointIntersection.y;
                point.shape.percentage = pointdist / parentShapeDist;
                point.shape.updateKeys.percentage = pointdist / parentShapeDist;
              } else if (_segment3 && point.shape.isParameter && shape.isMoved && e) {
                // linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection(fp,{x: parentShape.xOr, y:parentShape.yOr}, shape);
                linePointIntersection = properPoint(e, _fp21, _sp8, _parentShape.type).point;
                pointdist = getDistance(_parentShape, linePointIntersection); // shape.r = circle.shape.r;

                shape.x = linePointIntersection.x;
                shape.y = linePointIntersection.y;
                point.shape.x = linePointIntersection.x;
                point.shape.y = linePointIntersection.y;
                point.shape.pointAngle = true;
                point.shape.updateKeys.x = linePointIntersection.x;
                point.shape.updateKeys.y = linePointIntersection.y;
                point.shape.percentage = pointdist / parentShapeDist;
                point.shape.updateKeys.percentage = pointdist / parentShapeDist;
              }
            }
          }

          if (_segment3 && _segment3.shape) {
            shape.r = getDistance(_segment3.shape, {
              x: _segment3.shape.xTo,
              y: _segment3.shape.yTo
            });

            if (modelObj.interactionType === 'move' || modelObj.interactionType === 'select') {
              shape.x = point.shape.x;
              shape.y = point.shape.y;
            }

            if (point && point.shape) {
              point.shape.isMoved = false;
              shape.visible = point.shape.visible;
            }

            shape.isMoved = false;
          }
        } else if (shape.circleID !== undefined) {
          var _circle = findShape(shape.circleID);

          var _point2 = findShape(shape.connectionId[0]);

          if (_circle && _point2) {
            if (_point2.shape.circle) {
              if (_point2.shape.isMoved) {
                shape.r = _circle.shape.r;
                shape.x = _point2.shape.x;
                shape.y = _point2.shape.y;
              } else if (_circle && _point2.shape.isParameter && shape.isMoved) {
                shape.r = _circle.shape.r;

                var _mouse2 = getPointByPixel(e.pageX, e.pageY);

                if (_point2.shape.circle !== undefined && findShape(_point2.shape.circle) !== undefined) {
                  var _circleShape = findShape(_point2.shape.circle).shape;

                  var _angle6 = modelObj.LabComClass.Maths.getAngle(_circleShape.x, _circleShape.y, _mouse2.x, _mouse2.y);

                  _point2.shape.angle = _angle6;

                  var _newPoint3 = getPoint(_circleShape, _point2.shape.angle, _circleShape.r);

                  _point2.shape.x = _newPoint3.x;
                  _point2.shape.y = _newPoint3.y;
                  shape.x = _newPoint3.x;
                  shape.y = _newPoint3.y;
                } else {
                  var _angle7 = modelObj.LabComClass.Maths.getAngle(_circle.shape.x, _circle.shape.y, _mouse2.x, _mouse2.y);

                  _point2.shape.angle = _angle7;

                  var _newPoint4 = getPoint(_circle.shape, _point2.shape.angle, shape.r);

                  _point2.shape.x = _newPoint4.x;
                  _point2.shape.y = _newPoint4.y;
                  shape.x = _newPoint4.x;
                  shape.y = _newPoint4.y;
                }
              } else if (_circle && _point2.shape.isParameter) {
                shape.r = _circle.shape.r;
                shape.x = _point2.shape.x;
                shape.y = _point2.shape.y;
              }
            } else if (_point2.shape.line) {
              var _circle2 = findShape(shape.circleID);

              var _point3 = findShape(shape.connectionId[0]);

              var _parentShape2 = findShape(_point3.shape.line).shape;
              var _fp22 = findShape(_parentShape2.firstPointId).shape;
              var _sp9 = findShape(_parentShape2.secondPointId).shape;

              if (_fp22 === undefined && (_parentShape2.type === 'line' || _parentShape2.type === 'ray')) {
                _fp22 = {
                  x: _parentShape2.x,
                  y: _parentShape2.y
                };
              }

              if (_sp9 === undefined && (_parentShape2.type === 'line' || _parentShape2.type === 'ray')) {
                _sp9 = {
                  x: _parentShape2.xTo,
                  y: _parentShape2.yTo
                };
              }

              if (_parentShape2.type === 'perpendicularLine' || _parentShape2.type === 'parallelLine') {
                if (_fp22 === undefined) {
                  _fp22 = {
                    x: _parentShape2.x,
                    y: _parentShape2.y
                  };
                  _sp9 = {
                    x: _parentShape2.xTo,
                    y: _parentShape2.yTo
                  };
                }

                if (_sp9 === undefined) {
                  _sp9 = {
                    x: _parentShape2.xTo,
                    y: _parentShape2.yTo
                  };
                }
              }

              shape.x = _point3.shape.x;
              shape.y = _point3.shape.y;

              var _linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection(_fp22, _sp9, shape);

              var _pointdist = getDistance(_parentShape2, _linePointIntersection);

              var _parentShapeDist = getDistance(_fp22, _sp9);

              if (pointInSegment(shape, _fp22, _sp9) && _parentShape2.type.includes('segment')) {
                if (_circle2 && _point3.shape.isParameter && _point3.shape.isMoved) {
                  shape.r = _circle2.shape.r;
                  shape.x = _linePointIntersection.x;
                  shape.y = _linePointIntersection.y;
                  _point3.shape.updateKeys.x = _linePointIntersection.x;
                  _point3.shape.updateKeys.y = _linePointIntersection.y;
                  _point3.shape.percentage = _pointdist / _parentShapeDist;
                  _point3.shape.updateKeys.percentage = _pointdist / _parentShapeDist;
                } else if (_circle2 && _point3.shape.isParameter && shape.isMoved && e) {
                  _linePointIntersection = properPoint(e, _fp22, _sp9).point; // linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection(fp, sp, shape);

                  _pointdist = getDistance(_parentShape2, _linePointIntersection);
                  shape.r = _circle2.shape.r;
                  shape.x = _linePointIntersection.x;
                  shape.y = _linePointIntersection.y;
                  _point3.shape.x = _linePointIntersection.x;
                  _point3.shape.y = _linePointIntersection.y;
                  _point3.shape.pointAngle = true;
                  _point3.shape.updateKeys.x = _linePointIntersection.x;
                  _point3.shape.updateKeys.y = _linePointIntersection.y;
                  _point3.shape.percentage = _pointdist / _parentShapeDist;
                  _point3.shape.updateKeys.percentage = _pointdist / _parentShapeDist;
                }
              } else if (pointInSegment(shape, {
                x: _parentShape2.xOr,
                y: _parentShape2.yOr
              }, {
                x: _parentShape2.xOrTo,
                y: _parentShape2.yOrTo
              }) && (_parentShape2.type == "line" || _parentShape2.type === 'perpendicularLine' || _parentShape2.type === 'parallelLine')) {
                if (_circle2 && _point3.shape.isParameter && _point3.shape.isMoved) {
                  shape.r = _circle2.shape.r;
                  shape.x = _linePointIntersection.x;
                  shape.y = _linePointIntersection.y;
                  _point3.shape.updateKeys.x = _linePointIntersection.x;
                  _point3.shape.updateKeys.y = _linePointIntersection.y;
                  _point3.shape.percentage = _pointdist / _parentShapeDist;
                  _point3.shape.updateKeys.percentage = _pointdist / _parentShapeDist;
                } else if (_circle2 && _point3.shape.isParameter && shape.isMoved && e) {
                  var _mouse3 = getPointByPixel(e.pageX, e.pageY);

                  _linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection({
                    x: _parentShape2.xOr,
                    y: _parentShape2.yOr
                  }, {
                    x: _parentShape2.xOrTo,
                    y: _parentShape2.yOrTo
                  }, _mouse3);
                  _pointdist = getDistance(_parentShape2, _linePointIntersection);
                  shape.r = _circle2.shape.r;
                  shape.x = _linePointIntersection.x;
                  shape.y = _linePointIntersection.y;
                  _point3.shape.x = _linePointIntersection.x;
                  _point3.shape.y = _linePointIntersection.y;
                  _point3.shape.updateKeys.x = _linePointIntersection.x;
                  _point3.shape.updateKeys.y = _linePointIntersection.y;
                  _point3.shape.percentage = _pointdist / _parentShapeDist;
                  _point3.shape.updateKeys.percentage = _pointdist / _parentShapeDist;

                  if (pointInSegment(shape, _fp22, {
                    x: _parentShape2.xOr,
                    y: _parentShape2.yOr
                  })) {
                    _point3.shape.pointAngle = true;
                  } else {
                    _point3.shape.pointAngle = false;
                  }
                }
              } else if (pointInSegment(shape, _fp22, {
                x: _parentShape2.xOr,
                y: _parentShape2.yOr
              }) && _parentShape2.type == "ray") {
                if (_circle2 && _point3.shape.isParameter && _point3.shape.isMoved) {
                  shape.r = _circle2.shape.r;
                  shape.x = _linePointIntersection.x;
                  shape.y = _linePointIntersection.y;
                  _point3.shape.updateKeys.x = _linePointIntersection.x;
                  _point3.shape.updateKeys.y = _linePointIntersection.y;
                  _point3.shape.percentage = _pointdist / _parentShapeDist;
                  _point3.shape.updateKeys.percentage = _pointdist / _parentShapeDist;
                } else if (_circle2 && _point3.shape.isParameter && shape.isMoved && e) {
                  // linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection(fp,{x: parentShape.xOr, y:parentShape.yOr}, shape);
                  _linePointIntersection = properPoint(e, _fp22, _sp9, _parentShape2.type).point;
                  _pointdist = getDistance(_parentShape2, _linePointIntersection);
                  shape.r = _circle2.shape.r;
                  shape.x = _linePointIntersection.x;
                  shape.y = _linePointIntersection.y;
                  _point3.shape.x = _linePointIntersection.x;
                  _point3.shape.y = _linePointIntersection.y;
                  _point3.shape.pointAngle = true;
                  _point3.shape.updateKeys.x = _linePointIntersection.x;
                  _point3.shape.updateKeys.y = _linePointIntersection.y;
                  _point3.shape.percentage = _pointdist / _parentShapeDist;
                  _point3.shape.updateKeys.percentage = _pointdist / _parentShapeDist;
                }
              }
            }

            if (_circle) {
              shape.r = _circle.shape.r; // point.shape.x = shape.x;
              // point.shape.y = shape.y;

              if (modelObj.interactionType === 'move' || modelObj.interactionType === 'select') {
                shape.x = _point2.shape.x;
                shape.y = _point2.shape.y;
              }

              shape.visible = _point2.shape.visible;
              _point2.shape.isMoved = false;
              shape.isMoved = false;
            }
          }
        } else if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint10 = findShape(shape.firstPointId);

          var _secondPoint10 = findShape(shape.secondPointId);

          if (_firstPoint10 && _secondPoint10) {
            shape.r = getDistance(_firstPoint10.shape, _secondPoint10.shape);
          }

          if (shape.connectionId.length) {
            var _point4 = findShape(shape.connectionId[0]);

            if (_point4 && _point4.shape.circle) {
              var _circleShape2 = findShape(_point4.shape.circle).shape;

              if (_point4.shape.isMoved) {
                // shape.r = shape.r;
                shape.x = _point4.shape.x;
                shape.y = _point4.shape.y;
              } else if (_circleShape2 && _point4.shape.isParameter && shape.isMoved && e !== undefined) {
                var _mouse4 = getPointByPixel(e.pageX, e.pageY);

                var _angle8 = modelObj.LabComClass.Maths.getAngle(_circleShape2.x, _circleShape2.y, _mouse4.x, _mouse4.y);

                _point4.shape.angle = _angle8;

                var _newPoint5 = getPoint(_circleShape2, _point4.shape.angle, shape.r); // point.shape.x = newPoint.x;
                // point.shape.y = newPoint.y;


                shape.x = _point4.shape.x;
                shape.y = _point4.shape.y;
                shape.r = shape.r = getDistance(_firstPoint10.shape, _secondPoint10.shape); // point.shape.isMoved = false;
              } else if (_firstPoint10 && _secondPoint10 && _point4.shape.isParameter) {
                // shape.r = circle.shape.r;
                shape.x = _point4.shape.x;
                shape.y = _point4.shape.y;
              } // if (segment && segment.shape) {
              //   shape.r = getDistance(segment.shape, { x: segment.shape.xTo, y: segment.shape.yTo });
              //   point.shape.isMoved = false;
              //   shape.isMoved = false;
              // }

            } else if (_point4 && _point4.shape.line) {
              var _parentShape3 = findShape(_point4.shape.line).shape;
              var _fp23 = findShape(_parentShape3.firstPointId).shape;
              var _sp10 = findShape(_parentShape3.secondPointId).shape;
              shape.x = _point4.shape.x;
              shape.y = _point4.shape.y;

              if (_fp23 === undefined && (_parentShape3.type === 'line' || _parentShape3.type === 'ray')) {
                _fp23 = {
                  x: _parentShape3.x,
                  y: _parentShape3.y
                };
              }

              if (_sp10 === undefined && (_parentShape3.type === 'line' || _parentShape3.type === 'ray')) {
                _sp10 = modelObj.LabComClass.Maths.getPoint(_fp23, _parentShape3.slope, getPointUnitByPixelUnit(20));
                _sp10 = {
                  x: _parentShape3.xTo,
                  y: _parentShape3.yTo
                };
              }

              if (_parentShape3.type === 'perpendicularLine' || _parentShape3.type === 'parallelLine') {
                if (_fp23 === undefined) {
                  _fp23 = {
                    x: _parentShape3.x,
                    y: _parentShape3.y
                  };
                  _sp10 = {
                    x: _parentShape3.xTo,
                    y: _parentShape3.yTo
                  };
                }

                if (_sp10 === undefined) {
                  _sp10 = {
                    x: _parentShape3.xTo,
                    y: _parentShape3.yTo
                  };
                }
              }

              shape.x = _point4.shape.x;
              shape.y = _point4.shape.y;

              var _linePointIntersection2 = modelObj.LabComClass.Maths.getLinePointIntersection(_fp23, _sp10, shape);

              var _pointdist2 = getDistance(_parentShape3, _linePointIntersection2);

              var _parentShapeDist2 = getDistance(_fp23, _sp10);

              if (pointInSegment(shape, _fp23, _sp10) && _parentShape3.type.includes('segment')) {
                if (_fp23 && _sp10 && _point4.shape.isParameter && _point4.shape.isMoved) {
                  // shape.r = circle.shape.r;
                  shape.x = _linePointIntersection2.x;
                  shape.y = _linePointIntersection2.y;
                  _point4.shape.updateKeys.x = _linePointIntersection2.x;
                  _point4.shape.updateKeys.y = _linePointIntersection2.y;
                  _point4.shape.percentage = _pointdist2 / _parentShapeDist2;
                  _point4.shape.updateKeys.percentage = _pointdist2 / _parentShapeDist2;
                } else if (_fp23 && _sp10 && _point4.shape.isParameter && shape.isMoved && e) {
                  _linePointIntersection2 = properPoint(e, _fp23, _sp10).point;
                  _pointdist2 = getDistance(_parentShape3, _linePointIntersection2); // shape.r = circle.shape.r;

                  shape.x = _linePointIntersection2.x;
                  shape.y = _linePointIntersection2.y;
                  _point4.shape.x = _linePointIntersection2.x;
                  _point4.shape.y = _linePointIntersection2.y;
                  _point4.shape.pointAngle = true;
                  _point4.shape.updateKeys.x = _linePointIntersection2.x;
                  _point4.shape.updateKeys.y = _linePointIntersection2.y;
                  _point4.shape.percentage = _pointdist2 / _parentShapeDist2;
                  _point4.shape.updateKeys.percentage = _pointdist2 / _parentShapeDist2;
                }
              } else if (pointInSegment(shape, {
                x: _parentShape3.xOr,
                y: _parentShape3.yOr
              }, {
                x: _parentShape3.xOrTo,
                y: _parentShape3.yOrTo
              }) && (_parentShape3.type == "line" || _parentShape3.type === 'perpendicularLine' || _parentShape3.type === 'parallelLine')) {
                if (_fp23 && _sp10 && _point4.shape.isParameter && _point4.shape.isMoved) {
                  // shape.r = circle.shape.r;
                  shape.x = _linePointIntersection2.x;
                  shape.y = _linePointIntersection2.y;
                  _point4.shape.updateKeys.x = _linePointIntersection2.x;
                  _point4.shape.updateKeys.y = _linePointIntersection2.y;
                  _point4.shape.percentage = _pointdist2 / _parentShapeDist2;
                  _point4.shape.updateKeys.percentage = _pointdist2 / _parentShapeDist2;
                } else if (_fp23 && _sp10 && _point4.shape.isParameter && shape.isMoved && e) {
                  var _mouse5 = getPointByPixel(e.pageX, e.pageY);

                  _linePointIntersection2 = modelObj.LabComClass.Maths.getLinePointIntersection({
                    x: _parentShape3.xOr,
                    y: _parentShape3.yOr
                  }, {
                    x: _parentShape3.xOrTo,
                    y: _parentShape3.yOrTo
                  }, _mouse5);
                  _pointdist2 = getDistance(_parentShape3, _linePointIntersection2); // shape.r = circle.shape.r;

                  shape.x = _linePointIntersection2.x;
                  shape.y = _linePointIntersection2.y;
                  _point4.shape.x = _linePointIntersection2.x;
                  _point4.shape.y = _linePointIntersection2.y;
                  _point4.shape.updateKeys.x = _linePointIntersection2.x;
                  _point4.shape.updateKeys.y = _linePointIntersection2.y;
                  _point4.shape.percentage = _pointdist2 / _parentShapeDist2;
                  _point4.shape.updateKeys.percentage = _pointdist2 / _parentShapeDist2;

                  if (pointInSegment(shape, _fp23, {
                    x: _parentShape3.xOr,
                    y: _parentShape3.yOr
                  })) {
                    _point4.shape.pointAngle = true;
                  } else {
                    _point4.shape.pointAngle = false;
                  }
                }
              } else if (pointInSegment(shape, _fp23, {
                x: _parentShape3.xOr,
                y: _parentShape3.yOr
              }) && _parentShape3.type == "ray") {
                if (_fp23 && _sp10 && _point4.shape.isParameter && _point4.shape.isMoved) {
                  // shape.r = circle.shape.r;
                  shape.x = _linePointIntersection2.x;
                  shape.y = _linePointIntersection2.y;
                  _point4.shape.updateKeys.x = _linePointIntersection2.x;
                  _point4.shape.updateKeys.y = _linePointIntersection2.y;
                  _point4.shape.percentage = _pointdist2 / _parentShapeDist2;
                  _point4.shape.updateKeys.percentage = _pointdist2 / _parentShapeDist2;
                } else if (_fp23 && _sp10 && _point4.shape.isParameter && shape.isMoved && e) {
                  // linePointIntersection = modelObj.LabComClass.Maths.getLinePointIntersection(fp,{x: parentShape.xOr, y:parentShape.yOr}, shape);
                  _linePointIntersection2 = properPoint(e, _fp23, _sp10, _parentShape3.type).point;
                  _pointdist2 = getDistance(_parentShape3, _linePointIntersection2); // shape.r = circle.shape.r;

                  shape.x = _linePointIntersection2.x;
                  shape.y = _linePointIntersection2.y;
                  _point4.shape.x = _linePointIntersection2.x;
                  _point4.shape.y = _linePointIntersection2.y;
                  _point4.shape.pointAngle = true;
                  _point4.shape.updateKeys.x = _linePointIntersection2.x;
                  _point4.shape.updateKeys.y = _linePointIntersection2.y;
                  _point4.shape.percentage = _pointdist2 / _parentShapeDist2;
                  _point4.shape.updateKeys.percentage = _pointdist2 / _parentShapeDist2;

                  if (pointInSegment(shape, _fp23, {
                    x: _parentShape3.xOr,
                    y: _parentShape3.yOr
                  })) {
                    _point4.shape.pointAngle = true;
                  } else {
                    _point4.shape.pointAngle = false;
                  }
                }
              }
            }

            if (modelObj.interactionType === 'move' || modelObj.interactionType === 'select') {
              shape.x = _point4.shape.x;
              shape.y = _point4.shape.y;
            }

            shape.visible = _point4.shape.visible;
          }
        } else {
          shape.r = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        } // if (shape.centerPointId !== undefined) {
        //   const centerPoint = findShape(shape.centerPointId).shape;
        // if (centerPoint) {
        //   updateShapeValue(shape, {
        //     x: centerPoint.x,
        //     y: centerPoint.y
        //   });
        // }
        // }


        var _labelPos = modelObj.LabComClass.Maths.getPoint(shape, 3 * Math.PI / 4, 0.8 * shape.r);

        shape.labelX = _labelPos.x;
        shape.labelY = _labelPos.y; // shape.r = getDistance(shape, { x: shape.xTo, y: shape.yTo });
      } else if (shape.type === 'point' && modelObj.interactionType !== 'angle' && modelObj.interactionType !== 'angleB') {
        if (shape.firstPointPlotted && shape.secondPointPlotted && !shape.onSegment) {
          var _firstPoint11 = findShape(shape.firstPointId).shape;
          var _secondPoint11 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint11.x + _secondPoint11.x) / 2;
          shape.y = (_firstPoint11.y + _secondPoint11.y) / 2;
        }

        if (shape.onSegment) {
          shape.x = (shape.firstPointCoords.x + shape.secondPointCoords.x) / 2;
          shape.y = (shape.firstPointCoords.y + shape.secondPointCoords.y) / 2;
        } //segment Size.


        if (shape.segDistance !== undefined && shape.firstPointId !== undefined) {
          var _firstPoint12 = findShape(shape.firstPointId).shape;
          shape.visible = _firstPoint12.visible;
        }

        if (shape.isIntersection) {
          if (shape.l1 !== undefined && shape.l2 !== undefined) {
            var l1 = findShape(shape.l1);
            var l2 = findShape(shape.l2);

            if (l1 && l2) {
              l1 = l1.shape;
              l2 = l2.shape;
              var p = getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo); // if ((!p.onLine1 && l1.type.includes('segment')) || (!p.onLine2 && l2.type.includes('segment'))) {
              // New cond for inter of ray,segment and cross relations.

              if (!checkInSegment(p, l1) && (l1.type.includes('segment') || l1.type === 'ray') || !checkInSegment(p, l2) && (l2.type.includes('segment') || l2.type === 'ray')) {
                shape.visible = false;
              } else {
                shape.visible = true;
              }

              updateShapeValue(shape, {
                x: p.x,
                y: p.y
              });
            } else {
              shape.isIntersection = false;
            }
          }

          if (shape.circle !== undefined && shape.line !== undefined) {
            var _circle3 = findShape(shape.circle);

            var _line7 = findShape(shape.line);

            if (_circle3 && _line7) {
              _circle3 = _circle3.shape;
              _line7 = _line7.shape;
              var twoPointOnSameCircleLine = false;
              var shapeData = modelObj.interactionElements;
              shapeData.forEach(function (element) {
                if (element.uniqueId !== shape.uniqueId && element.type === 'point' && element.isIntersection && element.line !== undefined && element.circle !== undefined && element.line === shape.line && element.circle === shape.circle) {
                  twoPointOnSameCircleLine = element.uniqueId;
                }
              });

              if (twoPointOnSameCircleLine) {
                var data2 = getInteractionOfCircleLineV2(_circle3, _line7, shape);

                if (data2 !== null) {
                  var data = data2.point;

                  if (data !== null) {
                    updateShapeValue(shape, {
                      x: data.x,
                      y: data.y,
                      visible: data2.hide !== undefined ? false : true,
                      angle: modelObj.LabComClass.Maths.getAngle(_circle3.x, _circle3.y, data.x, data.y)
                    });
                  }
                } else if (data2.hide) {
                  shape.visible = false;
                } else {
                  shape.visible = false;
                }
              } else {
                var _data2 = getInteractionOfCircleLine(_circle3, _line7, shape);

                if (_data2 !== null) {
                  updateShapeValue(shape, {
                    x: _data2.x,
                    y: _data2.y,
                    visible: true,
                    angle: modelObj.LabComClass.Maths.getAngle(_circle3.x, _circle3.y, _data2.x, _data2.y)
                  });
                } else {
                  shape.visible = false;
                }
              }
            } else {
              shape.isIntersection = false;
            }
          } //  2 Circles intersection case.


          if (shape.circle1 !== undefined && shape.circle2 !== undefined) {
            var circle1 = findShape(shape.circle1);
            var circle2 = findShape(shape.circle2);

            if (circle1 && circle2) {
              circle1 = circle1.shape;
              circle2 = circle2.shape;

              var _data3 = getInteractionOfTwoCircles(circle1, circle2, shape, false, true);

              if (_data3 && _data3.x !== undefined && !isNaN(_data3.x)) {
                shape.visible = checkForCorrectIntersection(shape, circle1, circle2, _data3);
              } else {
                shape.visible = false;
              }
            } else {
              shape.isIntersection = false;
            }
          }
        }

        if (shape.isParameter && modelObj.shapesEditable) {
          if (shape.line !== undefined) {
            var _line8 = findShape(shape.line); // Needs to be checked.#1


            if (_line8) {
              _line8 = _line8.shape;
              var dist = getDistance(_line8, {
                x: _line8.xTo,
                y: _line8.yTo
              });
              var lineAngle = getAngle(_line8.x, _line8.y, _line8.xTo, _line8.yTo);
              var newData = {};
              var distFromFirstPoint = shape.pointAngle ? dist * shape.percentage : dist * shape.percentage * -1;

              if (e && shape.isSelected && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown && !localObj.isLableSelected && !modelObj.interactionType.includes('brush') && localObj.mouseDown.shapeSelected !== shape.line && e.type !== 'mouseup' && false) {
                var _mouse6 = getPointByPixel(e.pageX, e.pageY);

                var intersection;

                if (modelObj.interactionType === 'move' || modelObj.interactionType === 'select' && localObj.selectedItemsCount === 1) {
                  intersection = getLinePointIntersection(_line8, {
                    x: _line8.xTo,
                    y: _line8.yTo
                  }, _mouse6);
                  var intersectionDist = getDistance(_line8, intersection);
                  newData.pointAngle = getAngle(_line8.x, _line8.y, intersection.x, intersection.y);
                  newData.pointAngle = Math.round(newData.pointAngle) === Math.round(lineAngle);
                  newData.percentage = intersectionDist / dist;
                  distFromFirstPoint = newData.pointAngle ? dist * newData.percentage : dist * newData.percentage * -1;
                } else {
                  // This condition if one or more items are selected.
                  intersection = getLinePointIntersection(_line8, {
                    x: _line8.xTo,
                    y: _line8.yTo
                  }, _mouse6);

                  var _intersectionDist = getDistance(_line8, intersection);

                  newData.pointAngle = getAngle(_line8.x, _line8.y, intersection.x, intersection.y);
                  newData.pointAngle = Math.round(newData.pointAngle) === Math.round(lineAngle);
                  newData.percentage = _intersectionDist / dist;
                  distFromFirstPoint = newData.pointAngle ? dist * newData.percentage : dist * newData.percentage * -1;

                  if (_line8.type.includes('segment')) {
                    var inSegment = isInSegmentV2(dist, distFromFirstPoint);

                    if (inSegment.beyondFirst) {
                      newData.percentage = -newData.percentage;
                    }

                    if (newData.percentage < 0) {}
                  }
                }
              }

              var _p8 = getPoint(_line8, lineAngle, distFromFirstPoint);

              newData.x = _p8.x;
              newData.y = _p8.y;
              var setValues = true;

              if (_line8.type.includes('segment') || _line8.type === 'ray') {
                var endPoint = {
                  x: _line8.xTo,
                  y: _line8.yTo
                };

                if (_line8.type === 'ray') {
                  endPoint = {
                    x: _line8.xOr,
                    y: _line8.yOr
                  };
                }

                setValues = pointInSegment(_p8, _line8, endPoint);

                if (!setValues) {
                  var dist1 = getDistance(_p8, _line8);
                  var dist2 = getDistance(_p8, endPoint);

                  if (dist1 < dist2) {
                    newData.x = _line8.x;
                    newData.y = _line8.y;
                  } else {
                    newData.x = endPoint.x;
                    newData.y = endPoint.y;
                  }
                }
              }

              Object.keys(newData).forEach(function (i) {
                shape[i] = newData[i];
              });
            } // else {
            //   // shape.line = undefined;
            //   shape.isParameter = false;
            // }

          }

          if (shape.circle !== undefined) {
            var _circle4 = findShape(shape.circle);

            if (_circle4) {
              _circle4 = _circle4.shape; //last cond is for angleSizem if used on paraneter if circle, then if second point is plotted on the parameter then the point jumps so to avoid condition applied.

              if (e && shape.isSelected && localObj.mouseDown.objectDown && !(!localObj.mouseDown.lastShapeCompleted && modelObj.interactionType === 'angleSize') && !localObj.isLableSelected && !modelObj.interactionType.includes('brush') && localObj.mouseDown.shapeSelected === shape.uniqueId && false) {
                var _mouse7 = getPointByPixel(e.pageX, e.pageY);

                shape.angle = getAngle(_circle4.x, _circle4.y, _mouse7.x, _mouse7.y);
              }

              var newP = getPoint(_circle4, shape.angle, _circle4.r);
              updateShapeValue(shape, {
                x: newP.x,
                y: newP.y
              });
            } // else {
            //   // shape.circle = undefined;
            //   shape.isParameter = false;
            // }

          }
        }

        for (var j = 0; j < shape.connectionId.length; j++) {
          var _shapeData6 = findShape(shape.connectionId[j]);

          if (_shapeData6.shape) {
            if (_shapeData6.shape.type === 'perpendicularLine' || _shapeData6.shape.type === 'parallelLine') {
              _shapeData6.shape.visible = shape.visible;
              updateShapeValue(_shapeData6.shape, {
                x: shape.x,
                y: shape.y
              });
              updatePLinePoints(_shapeData6.shape);
            } else if (_shapeData6.shape.type === 'circle') {
              updateCircle(_shapeData6.shape);
            }
          }
        } //if shape (x and y) values are null then update keys values are passed to it.


        if (shape.updateKeys) {
          if (isNaN(shape.x) && isNaN(shape.y)) {
            shape.x = shape.updateKeys.x;
            shape.y = shape.updateKeys.y;
          }
        }
      } else if (shape.type === 'perpendicularLine' || shape.type === 'parallelLine') {
        updatePLinePoints(shape);
      } else if (shape.type === 'circle') {
        updateCircle(shape);
      }

      if (shape && shape.label !== undefined) {
        // if (shape.labelX === undefined && shape.type !== 'angleSize') {
        //   shape.labelX = shape.x;
        //   shape.labelY = shape.y;
        // }
        if (shape.type === 'point' && shape.label !== '') {
          shape.labelX = shape.x;
          shape.labelY = shape.y;
        }

        if (shape.labelDiffX === undefined) {
          shape.labelDiffX = 0;
          shape.labelDiffY = 0;
        }
      }
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      _loop5(i);
    }
  }

  function updateAllPointsSplCase() {
    var _modelObj$LabComClass3 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass3.getDistance,
        getAngle = _modelObj$LabComClass3.getAngle,
        getPoint = _modelObj$LabComClass3.getPoint,
        pointInSegment = _modelObj$LabComClass3.pointInSegment,
        getLineintersect = _modelObj$LabComClass3.getLineintersect,
        getLinePointIntersection = _modelObj$LabComClass3.getLinePointIntersection;

    var _loop6 = function _loop6(i) {
      var shape = modelObj.interactionElements[i];

      if (shape.type === 'point') {
        if (shape.isIntersection) {
          if (shape.circle !== undefined && shape.line !== undefined) {
            var circle = findShape(shape.circle);
            var line = findShape(shape.line);

            if (circle && line) {
              circle = circle.shape;
              line = line.shape;
              var twoPointOnSameCircleLine = false;
              var shapeData = modelObj.interactionElements;
              shapeData.forEach(function (element) {
                if (element.uniqueId !== shape.uniqueId && element.type === 'point' && element.isIntersection && element.line !== undefined && element.circle !== undefined && element.line === shape.line && element.circle === shape.circle) {
                  twoPointOnSameCircleLine = element.uniqueId;
                }
              });
              console.log("SPLACASE");

              if (twoPointOnSameCircleLine) {
                var data2 = getInteractionOfCircleLineV2(circle, line, shape);

                if (data2 !== null) {
                  var data = data2.point;

                  if (data !== null) {
                    updateShapeValue(shape, {
                      x: data.x,
                      y: data.y,
                      visible: data2.hide !== undefined ? false : true,
                      angle: modelObj.LabComClass.Maths.getAngle(circle.x, circle.y, data.x, data.y)
                    });
                  }
                } else if (data2.hide) {
                  console.log('----------');
                  shape.visible = false;
                } else {
                  shape.visible = false;
                }
              } else {
                var _data4 = getInteractionOfCircleLine(circle, line, shape);

                if (_data4 !== null) {
                  updateShapeValue(shape, {
                    x: _data4.x,
                    y: _data4.y,
                    visible: true,
                    angle: modelObj.LabComClass.Maths.getAngle(circle.x, circle.y, _data4.x, _data4.y)
                  });
                } else {
                  shape.visible = false;
                }
              }
            } else {
              shape.isIntersection = false;
            }
          }
        } //if shape (x and y) values are null then update keys values are passed to it.
        // if (shape.updateKeys) {
        //   if (isNaN(shape.x) && isNaN(shape.y)) {
        //     shape.x = shape.updateKeys.x;
        //     shape.y = shape.updateKeys.y;
        //   }
        // }

      }
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      _loop6(i);
    }
  }

  function checkInSegment(point, line) {
    var _modelObj$LabComClass4 = modelObj.LabComClass.Maths,
        pointInSegment = _modelObj$LabComClass4.pointInSegment,
        getDistance = _modelObj$LabComClass4.getDistance;

    if (point) {
      var endPoint = {
        x: line.xTo,
        y: line.yTo
      };

      if (line.type === 'ray') {
        endPoint = {
          x: line.xOr,
          y: line.yOr
        };
      }

      var setValues = true;
      setValues = pointInSegment(point, line, endPoint);
      return setValues;
    }
  }

  var isInSegmentV2 = function isInSegmentV2(dist, distFromFirstPoint) {
    if (distFromFirstPoint < 0) {
      return {
        beyondFirst: true
      };
    } else if (distFromFirstPoint > dist) {
      return {
        beyondFirst: false
      };
    } else {
      return true;
    }
  };
  /*
  const mouseLine = {};
  mouseLine.hyp = getDistance(mouse,shape);
  mouseLine.pointAngle = getAngle(mouse.x,mouse.y,shape.x,shape.y);
  mouseLine.mainAngle = mouseLine.pointAngle - lineAngle;
  mouseLine.base = Math.cos(mouseLine.mainAngle) * mouseLine.hyp;
  intersection = getPoint(mouse,lineAngle,mouseLine.base); */


  function circle3Handler(fp, sp, tp) {
    var l1, l2;

    if (fp.uniqueId !== undefined && sp.uniqueId !== undefined && tp.uniqueId !== undefined) {
      if (fp.uniqueId === localObj.currentUniqueId) {
        l1 = computePerpendicular(sp, tp);
        l2 = computePerpendicular(tp, fp);
      } else if (sp.uniqueId === localObj.currentUniqueId) {
        l1 = computePerpendicular(fp, tp);
        l2 = computePerpendicular(tp, sp);
      } else if (tp.uniqueId === localObj.currentUniqueId) {
        l1 = computePerpendicular(fp, sp);
        l2 = computePerpendicular(sp, tp);
      }
    } else {
      l1 = computePerpendicular(fp, sp);
      l2 = computePerpendicular(sp, tp);
    }

    if (l1 === undefined || l2 === undefined) {
      l1 = computePerpendicular(fp, sp);
      l2 = computePerpendicular(sp, tp);
    } // const l1 = computePerpendicular(fp,sp);
    // const l2 = computePerpendicular(sp,tp);


    var centerPoint = modelObj.LabComClass.Maths.getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);
    var radius = modelObj.LabComClass.Maths.getDistance(centerPoint, fp);
    return {
      x: centerPoint.x,
      y: centerPoint.y,
      r: radius
    };
  }

  function circle3Handlero(fp, sp, tp) {
    var p1 = {},
        p2 = {},
        coords = {};
    p1.x = (fp.x + sp.x) / 2;
    p1.y = (fp.y + sp.y) / 2;
    p2.x = (sp.x + tp.x) / 2;
    p2.y = (sp.y + tp.y) / 2;
    p1.m = to2Dec((sp.y - fp.y) / (sp.x - fp.x));
    p2.m = to2Dec((tp.y - sp.y) / (tp.x - sp.x));
    p1.slope = to2Dec(-1 / p1.m);
    p2.slope = to2Dec(-1 / p2.m);
    var p1Val = getPLineCoeff(p1); // getPerpendicular Line

    var p2Val = getPLineCoeff(p2); // getPerpendicular Line

    coords.x = (p1Val.b * p2Val.c - p2Val.b * p1Val.c) / (p1Val.a * p2Val.b - p2Val.a * p1Val.b);
    coords.y = (p1Val.c * p2Val.a - p2Val.c * p1Val.a) / (p1Val.a * p2Val.b - p2Val.a * p1Val.b);
    coords.r = modelObj.LabComClass.Maths.getDistance(coords, fp);
    return {
      x: coords.x,
      y: coords.y,
      r: coords.r
    };
  }

  function getPLineCoeff(p) {
    var eqn = {};

    if (!isFinite(p.slope)) {
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -p.x;
    } else {
      eqn.eqn = "(y-".concat(p.y, "=").concat(p.slope, "(x-").concat(p.x, "))");
      eqn.a = -p.slope;
      eqn.b = 1;
      eqn.c = to2Dec(-p.slope * -p.x - p.y);
    }

    return eqn;
  }

  function circle3HandlerOld(fp, sp, tp) {
    var p1 = {},
        p2 = {},
        coords = {};
    p1.x = (fp.x + sp.x) / 2;
    p1.y = (fp.y + sp.y) / 2;
    p2.x = (sp.x + tp.x) / 2;
    p2.y = (sp.y + tp.y) / 2;
    p1.m = to2Dec((sp.y - fp.y) / (sp.x - fp.x));
    p2.m = to2Dec((tp.y - sp.y) / (tp.x - sp.x));
    p1.slope = to2Dec(-1 / p1.m);
    p2.slope = to2Dec(-1 / p2.m);
    p1.eqn = "(y-".concat(p1.y, "=").concat(p1.slope, "(x-").concat(p1.x, "))");
    p1.a = -p1.slope;
    p1.b = 1;
    p1.c = to2Dec(-p1.slope * -p1.x - p1.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    p2.eqn = "(y-".concat(p2.y, "=").concat(p2.slope, "(x-").concat(p2.x, "))");
    p2.a = -p2.slope;
    p2.b = 1;
    p2.c = to2Dec(-p2.slope * -p2.x - p2.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    coords.x = (p1.b * p2.c - p2.b * p1.c) / (p1.a * p2.b - p2.a * p1.b);
    coords.y = (p1.c * p2.a - p2.c * p1.a) / (p1.a * p2.b - p2.a * p1.b);
    coords.r = modelObj.LabComClass.Maths.getDistance(coords, fp);
    return {
      x: coords.x,
      y: coords.y,
      r: coords.r
    };
  }

  function to2Dec(num) {
    return Math.round(num * 100) / 100;
  }

  function updateCircle(shape) {
    if (shape.type === 'circle') {
      if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
        var firstPoint = findShape(shape.firstPointId);
        var secondPoint = findShape(shape.secondPointId);

        if (firstPoint && secondPoint) {
          shape.x = firstPoint.shape.x;
          shape.y = firstPoint.shape.y;
          shape.r = modelObj.LabComClass.Maths.getDistance(firstPoint.shape, secondPoint.shape);
          var labelPos = modelObj.LabComClass.Maths.getPoint(shape, 3 * Math.PI / 4, 0.8 * shape.r);
          shape.labelX = labelPos.x;
          shape.labelY = labelPos.y;
        }
      }

      if (shape.circleSize) {
        var _firstPoint13 = findShape(shape.firstPointId);

        if (_firstPoint13) {
          shape.x = _firstPoint13.shape.x;
          shape.y = _firstPoint13.shape.y;
          shape.r = shape.r;

          var _labelPos2 = modelObj.LabComClass.Maths.getPoint(shape, 3 * Math.PI / 4, 0.8 * shape.r);

          shape.labelX = _labelPos2.x;
          shape.labelY = _labelPos2.y;
        }
      }
    }
  }

  function checkForCorrectIntersection(currentShape, circle1, circle2, newData) {
    var Vector = modelObj.LabComClass.Vector;

    if (currentShape.visible) {
      currentShape.x = newData.x;
      currentShape.y = newData.y;

      var _centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);

      var _firstIntersectLine = new Vector(newData.x - circle1.x, newData.y - circle1.y);

      currentShape.angle1 = _centerPointsLine.crossProduct(_firstIntersectLine).z;
      return true;
    }

    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length < 2) {
      return false;
    }

    if (modelObj.LabComClass.Maths.getDistance(intersection[0], intersection[1]) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      return false;
    }

    var centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);
    var firstIntersectLine = new Vector(intersection[0].x - circle1.x, intersection[0].y - circle1.y); // const secondIntersectLine = new Vector(intersection[1].x - circle1.x, intersection[1].y - circle1.y);

    var angle1 = centerPointsLine.crossProduct(firstIntersectLine).z; // const angle2 = centerPointsLine.crossProduct(secondIntersectLine).z;

    if (currentShape.angle1 < 0 && angle1 < 0 || currentShape.angle1 > 0 && angle1 > 0) {
      // currentShape.intersectAngle = angle1;
      currentShape.x = intersection[0].x;
      currentShape.y = intersection[0].y;
    } else {
      // currentShape.intersectAngle = angle2;
      currentShape.x = intersection[1].x;
      currentShape.y = intersection[1].y;
    }

    return true;
  } // vertical intsectin is not getting detected in circle line intersect


  function findCircleLineIntersect(circle, line) {
    return modelObj.LabComClass.Maths.findCircleLineIntersect({
      x: circle.x,
      y: circle.y,
      r: circle.r
    }, {
      x: line.x,
      y: line.y
    }, {
      x: line.xTo,
      y: line.yTo
    });
  }

  function findDraggable(elems) {
    var draggable = true;

    if (Array.isArray(elems)) {
      for (var i = 0; i < elems.length; i++) {
        if (elems[i] === undefined || !(elems[i].isDraggable === undefined || elems[i].isDraggable)) {
          draggable = false;
          break;
        }
      }
    } else if (!(elems.isDraggable === undefined || elems.isDraggable)) {
      draggable = false;
    }

    return draggable;
  }

  function updateShapeValue(target, values) {
    if (target.isDraggable === undefined || target.isDraggable) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }
  }

  function updateShapes(parentShape, _diffX, _diffY) {
    var otherShapes = parentShape.connectionId;

    for (var i = 0; i < otherShapes.length; i++) {
      var shape = findShape(otherShapes[i]).shape;

      if (shape === undefined || shape === false || shape.isMoved) {
        continue;
      }

      shape.isMoved = true;

      if (shape.type === 'point') {
        var draggable = true;

        if (!shape.isSelected && shape.connectionId.length) {
          for (var j = 0; j < shape.connectionId.length; j++) {
            var connectedShape = findShape(shape.connectionId[j]).shape;

            if (connectedShape && (connectedShape.type === 'line' || connectedShape.type === 'ray' || connectedShape.type.includes('segment'))) {
              var checkId = connectedShape.firstPointId === shape.uniqueId ? connectedShape.secondPointId : connectedShape.firstPointId;
              var connectedPoint = findShape(checkId);

              if (connectedPoint && connectedPoint.shape) {
                if (!(connectedPoint.shape.isDraggable === undefined || connectedPoint.shape.isDraggable === true)) {
                  draggable = false;
                }
              }
            }
          }
        }

        if (draggable) {
          if (parentShape.type.includes('segment') || parentShape.type === 'line' || parentShape.type === 'ray') {
            var fp = findShape(parentShape.firstPointId).shape;
            var sp = findShape(parentShape.secondPointId).shape;

            if (!fp.isIntersection && !(sp === null || sp === void 0 ? void 0 : sp.isIntersection) && fp.updateValue === undefined && !fp.isParameter && !(sp === null || sp === void 0 ? void 0 : sp.isParameter) && (sp === null || sp === void 0 ? void 0 : sp.updateValue) === undefined) {
              if (shape.uniqueId === sp.uniqueId) {
                updateShapeValue(shape, {
                  x: shape.x + _diffX,
                  y: shape.y + _diffY
                });
              }

              if (shape.uniqueId === fp.uniqueId) {
                // const newPoint = snapFunction(shape.x + _diffX ,shape.y + _diffY);
                // console.log(shape.x === newPoint.x,shape.y === newPoint.y,newPoint.x,newPoint.y);
                updateShapeValue(shape, {
                  x: shape.x + _diffX,
                  y: shape.y + _diffY
                }); // if(!(shape.x === newPoint.x && shape.y === newPoint.y)) {
                //   shape.x = newPoint.x;
                //   shape.y = newPoint.y;
                // }
              }
            }
          } else {
            updateShapeValue(shape, {
              x: shape.x + _diffX,
              y: shape.y + _diffY
            });
          }
        }
      } else if (shape.type === 'line' || shape.type === 'ray' || shape.type.includes('segment')) {
        if (shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        } else {
          shape.xTo = parentShape.x;
          shape.yTo = parentShape.y;
        }

        if (shape.type === 'line' || shape.type === 'ray') {
          updateLinePoints(shape);
        }
      } else if (shape.type === 'perpendicularLine' || shape.type === 'parallelLine') {
        if (parentShape.type === 'point') {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
          updatePLinePoints(shape);
        }
      } else if (shape.type === 'circle') {
        if (parentShape.type === 'point' && shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        }
      } else if (shape.type === 'compass') {
        if (parentShape.type === 'point' && shape.connectionId[0] === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        }
      }
    }
  }

  function findShape(uniqueId) {
    var shapesData = modelObj.interactionElements;

    for (var i = shapesData.length - 1; i >= 0; i--) {
      if (shapesData[i] && shapesData[i].uniqueId === uniqueId) {
        return {
          index: i,
          shape: shapesData[i]
        };
      }
    }

    return false;
  } // =================================================


  function onMouseUp(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    var _ctx = modelObj.context;
    _ctx.font = "".concat(modelObj.fontSize, "px ").concat(modelObj.LabComClass.polo22KlettRegular);
    var value = {
      type: tool
    };
    var _it = tool;
    var dataAvailable = false;
    var point = getPointByPixel(e.pageX, e.pageY);
    var currentShape = localObj.currentUniqueId !== null && findShape(localObj.currentUniqueId).shape;

    if (!localObj.mouseDown.lastShapeCompleted && localObj.currentUniqueId == null) {
      currentShape = findShape(localObj.uniqueId).shape;
    }

    point = checkSnapping(point, e.type);
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));
    var clickingOnExistingPointID = null;

    if (clickingOnExistingPoint !== null) {
      clickingOnExistingPointID = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    if (clickingOnExistingPointID !== null) {
      if (_it !== 'select' && _it !== 'move' && _it !== 'moveGraph' && currentShape) {
        currentShape.isSelected = false;
      }
    }

    var pointOnGraph = point !== null && pointInsideGraph(point);

    if (!pointOnGraph) {
      dataAvailable = false;
      localObj.mouseDown.lastShapeCompleted = false;
    }

    if (_it === 'point' && currentShape && pointOnGraph) {
      var _point5 = getPointByPixel(e.pageX, e.pageY);

      var _currentShape2 = localObj.currentUniqueId !== null && findShape(localObj.currentUniqueId).shape;

      if (!localObj.mouseDown.lastShapeCompleted && localObj.currentUniqueId == null) {
        _currentShape2 = findShape(localObj.uniqueId).shape;
      }

      _point5 = checkSnapping(_point5, e.type);
      clickingOnExistingPoint = checkPointv2(getPointByPixel(e.pageX, e.pageY));
      clickingOnExistingPointID = null; // if (clickingOnExistingPoint !== null) {
      //   clickingOnExistingPointID = shapesData[clickingOnExistingPoint].uniqueId;
      //   point = shapesData[clickingOnExistingPoint];
      // }
      // if (clickingOnExistingPointID !== null) {
      //   if (_it !== 'select' && _it !== 'move' && _it !== 'moveGraph' && currentShape) {
      //     currentShape.isSelected = false;
      //   }
      // }

      if (findDraggable([_currentShape2]) && !modelObj.plotPointOnExistingPoint) {
        // if (updatePointValues(currentShape, {
        //   x: point.x,
        //   y: point.y
        // })) {
        updatePointValues(_currentShape2, _point5);

        if (!modelObj.shapesEditable) {
          _currentShape2.isDraggable = false;
          value.isDraggable = _currentShape2.isDraggable;
        }

        dataAvailable = true;
        value.x = _point5.x;
        value.y = _point5.y;
        value.uniqueId = _currentShape2.uniqueId;

        if (dataAvailable) {
          dataAvailable = checkDataAvailable(_currentShape2, ['x', 'y']);
        } // }


        filterDuplicateInteractionElements();
      } else if (modelObj.plotPointOnExistingPoint) {
        dataAvailable = true;
        var pointId = ++localObj.uniqueId;
        value.x = _currentShape2.x;
        value.y = _currentShape2.y; // updatePointValues(currentShape, point);
        // updatePointValues(currentShape, {
        //     x: point.x,
        //     y: point.y
        //   });
        // addPoint(point, {
        //   uniqueId: pointId,
        //   connectionId: [currentShape.uniqueId]
        // });

        value.uniqueId = pointId;
      }
    } else if (currentShape && (_it.includes('segment') || _it === 'length' || _it === 'line' || _it === 'ray') && pointOnGraph) {
      if (findDraggable([currentShape])) {
        currentShape.xTo = point.x;
        currentShape.yTo = point.y;

        if (currentShape && _it === 'length') {}
      }

      if (tool === 'line' || tool === 'ray') {
        updateLinePoints(currentShape);
      }

      value.x = currentShape.x;
      value.y = currentShape.y;
      value.xTo = currentShape.xTo;
      value.yTo = currentShape.yTo;
      value.slope = currentShape.slope;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (_it === 'length' && (currentShape.circleId !== undefined || currentShape.segmentID !== undefined)) {
        if (currentShape.circleId) {
          var circle = findShape(currentShape.circleId).shape;
          circle.isSelected = false;
        } else if (currentShape.segmentID) {
          var segment = findShape(currentShape.segmentID).shape;
          segment.isSelected = false;

          if (segment.lengthId) {
            var parentShape = findShape(segment.lengthId).shape;

            if (parentShape.mode === 'segment') {
              if (segment.label === undefined || segment.label === "") {
                segment.label = segment.distance.toString().replace('.', ',');
                segment.onlyLength = true;
              }

              if ((segment === null || segment === void 0 ? void 0 : segment.label) && !(segment === null || segment === void 0 ? void 0 : segment.onlyLength)) {
                if (segment.label.includes(' = ')) {
                  segment.label = segment.label.replace(' = ' + segment.label.split(' = ')[1], '');
                }

                segment.label = modelObj.shapes.length.digit !== undefined ? segment.label + ' = ' + segment.distance.toFixed(modelObj.shapes.length.digit) : segment.label + ' = ' + segment.distance.toFixed(2);

                if (segment.label.split(' = ')[0] === '') {
                  segment.label = '';
                }
              }

              if (segment.onlyLength) {
                segment.label = modelObj.shapes.length.digit !== undefined ? segment.distance.toFixed(modelObj.shapes.length.digit).toString().replace('.', ',') : segment.distance.toFixed(2).toString().replace('.', ',');
              }

              var labelDiff = {};
              var angle = modelObj.LabComClass.Maths.getAngle(0, 0, segment.labelX, segment.labelY) + Math.PI;
              var newDiff = modelObj.LabComClass.Maths.getPoint({
                x: segment.labelX,
                y: segment.labelY
              }, angle, getPointUnitByPixelUnit(20));
              labelDiff.x = getPixelUnitByPointUnit(segment.labelX - newDiff.x);
              labelDiff.y = getPixelUnitByPointUnit(segment.labelY - newDiff.y);
              segment.labelDiffX = labelDiff.x;
              segment.labelDiffY = labelDiff.y;
            }
          }
        }
      }

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ['x', 'y', 'xTo', 'yTo']);
      }

      if (clickingOnExistingPoint === null) {
        if (_it !== 'length') {
          var secondPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: secondPointId,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = secondPointId;
          currentShape.connectionId.push(secondPointId);
        } else if (currentShape.firstPointId !== undefined) {
          if (localObj.newPlottedShapes.length > 0) {
            shapesData.pop();
          }
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        point.connectionId.push(currentShape.uniqueId);

        if (_it !== 'length') {
          currentShape.connectionId.push(clickingOnExistingPointID);
        }

        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (currentShape && _it === 'angleRay' && pointOnGraph) {
      var angleRay = findShape(currentShape.angleRayId).shape;

      if (!angleRay.firstRayPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var firstPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: firstPointId,
            connectionId: [currentShape.uniqueId, angleRay.uniqueId]
          });
          currentShape.firstPointId = firstPointId;
          currentShape.connectionId.push(firstPointId);
          angleRay.firstRayPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          point.connectionId.push(angleRay.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          angleRay.firstRayPlotted = true;
        }

        if (angleRay.firstRayPlotted) {
          angleRay.secondPointId = currentShape.firstPointId;
          var ray2 = addNewShape({
            type: 'ray',
            uniqueId: ++localObj.uniqueId,
            firstPointId: angleRay.secondPointId,
            angleRayId: currentShape.angleRayId,
            x: point.x,
            y: point.y,
            xOr: point.x,
            yOr: point.y,
            xTo: point.x,
            yTo: point.y,
            xOrTo: point.x,
            yOrTo: point.y,
            connectionId: [angleRay.secondPointId, angleRay.uniqueId]
          });
          localObj.currentUniqueId = localObj.uniqueId;
          angleRay.x = point.x;
          angleRay.y = point.y;
          angleRay.ray2Id = ray2.uniqueId;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId2 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId2,
            connectionId: [currentShape.uniqueId, angleRay.uniqueId]
          });
          currentShape.secondPointId = _secondPointId2;
          currentShape.connectionId.push(_secondPointId2);
          angleRay.secondRayPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          point.connectionId.push(angleRay.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          angleRay.secondRayPlotted = true;
        }

        if (angleRay.secondRayPlotted) {
          angleRay.thirdPointId = currentShape.secondPointId;
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleRay.secondRayPlotted) {
        var firstPoint = findShape(angleRay.firstPointId).shape;
        var secondPoint = findShape(angleRay.secondPointId).shape;
        var thirdPoint = findShape(angleRay.thirdPointId).shape;
        secondPoint.connectionId.push(angleRay.ray2Id);
        value.firstPoint = {
          x: firstPoint.x,
          y: firstPoint.y,
          label: firstPoint.label
        };
        value.secondPoint = {
          x: secondPoint.x,
          y: secondPoint.y,
          label: secondPoint.label
        };
        value.thirdPoint = {
          x: thirdPoint.x,
          y: thirdPoint.y,
          label: thirdPoint.label
        };
        value.x = secondPoint.x;
        value.y = secondPoint.y;
        var angleData = calculateAngle(value, 'angleRay');
        value.angle = angleData.angle;
        value.angleValue = angleData.angleValue;
        angleRay.label = angleData.angleText;
        angleRay.labelX = angleRay.x + getPointUnitByPixelUnit(10);
        angleRay.labelY = angleRay.y - getPointUnitByPixelUnit(10);
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'triangle' && pointOnGraph) {
      var triangle = findShape(currentShape.triangleId).shape;

      if (!triangle.firstSegmentPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var _firstPointId21 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId21,
            connectionId: [currentShape.uniqueId, triangle.uniqueId]
          });
          currentShape.firstPointId = _firstPointId21;
          currentShape.connectionId.push(_firstPointId21);
          triangle.firstSegmentPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          point.connectionId.push(triangle.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          triangle.firstSegmentPlotted = true;
        }

        if (triangle.firstSegmentPlotted) {
          triangle.secondPointId = currentShape.firstPointId;
          var seg2 = addNewShape({
            type: 'segment',
            uniqueId: ++localObj.uniqueId,
            firstPointId: triangle.secondPointId,
            triangleId: currentShape.triangleId,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y,
            connectionId: [triangle.secondPointId]
          });
          triangle.seg2Id = seg2.uniqueId;
          localObj.newPlottedShapes.push(localObj.uniqueId);
          localObj.currentUniqueId = localObj.uniqueId;
          triangle.x = point.x;
          triangle.y = point.y;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId3 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId3,
            connectionId: [currentShape.uniqueId, triangle.uniqueId]
          });
          currentShape.secondPointId = _secondPointId3;
          currentShape.connectionId.push(_secondPointId3);
          triangle.secondSegmentPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID || triangle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          point.connectionId.push(triangle.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          triangle.secondSegmentPlotted = true;
        }
      }

      if (triangle.secondSegmentPlotted) {
        var _secondPoint12 = findShape(triangle.firstPointId).shape;
        triangle.thirdPointId = currentShape.secondPointId;
        var seg3 = addNewShape({
          type: 'segment',
          uniqueId: ++localObj.uniqueId,
          firstPointId: triangle.thirdPointId,
          secondPointId: triangle.firstPointId,
          triangleId: currentShape.triangleId,
          x: point.x,
          y: point.y,
          xTo: _secondPoint12.x,
          yTo: _secondPoint12.y,
          connectionId: [triangle.thirdPointId, triangle.firstPointId]
        });
        triangle.seg3Id = seg3.uniqueId;
        localObj.newPlottedShapes.push(localObj.uniqueId);
        localObj.currentUniqueId = localObj.uniqueId;
        triangle.x = point.x;
        triangle.y = point.y;
        triangle.thirdSegmentPlotted = true;
        localObj.mouseDown.lastShapeCompleted = true;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (triangle.thirdSegmentPlotted) {
        var _firstPoint14 = findShape(triangle.firstPointId).shape;
        var _secondPoint13 = findShape(triangle.secondPointId).shape;
        var _thirdPoint4 = findShape(triangle.thirdPointId).shape;

        _firstPoint14.connectionId.push(triangle.seg3Id);

        _secondPoint13.connectionId.push(triangle.seg2Id);

        _thirdPoint4.connectionId.push(triangle.seg3Id);

        value.firstPoint = {
          x: _firstPoint14.x,
          y: _firstPoint14.y,
          label: _firstPoint14.label
        };
        value.secondPoint = {
          x: _secondPoint13.x,
          y: _secondPoint13.y,
          label: _secondPoint13.label
        };
        value.thirdPoint = {
          x: _thirdPoint4.x,
          y: _thirdPoint4.y,
          label: _thirdPoint4.label
        };
        triangle.connectionId.push(triangle.seg1Id, triangle.seg2Id, triangle.seg3Id);
        triangle.x = (_firstPoint14.x + _secondPoint13.x + _thirdPoint4.x) / 3;
        triangle.y = (_firstPoint14.y + _secondPoint13.y + _thirdPoint4.y) / 3;
        value.x = _secondPoint13.x;
        value.y = _secondPoint13.y;
        value.uniqueId = triangle.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'circle_3' && pointOnGraph) {
      var circle3;

      if (currentShape.type !== 'circle_3') {
        circle3 = findShape(currentShape.circleId).shape;
      } else {
        circle3 = currentShape;
      }

      if (!circle3.firstPointPlotted) {
        dataAvailable = false;
        var fp = findShape(circle3.firstPointId).shape;
        fp.isSelected = true;

        if (clickingOnExistingPoint === null) {
          var _secondPointId4 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId4,
            connectionId: [circle3.uniqueId],
            circleId: circle3.uniqueId
          });
          circle3.secondPointId = _secondPointId4;
          circle3.firstPointPlotted = true;
          var _fp24 = findShape(circle3.firstPointId).shape;
          _fp24.isSelected = true;
          var sp = findShape(circle3.secondPointId).shape;
          sp.isSelected = true;
        } else if (circle3.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(circle3.uniqueId);
          point.circle3Id = circle3.uniqueId;
          circle3.secondPointId = clickingOnExistingPointID;
          circle3.firstPointPlotted = true;
          var _fp25 = findShape(circle3.firstPointId).shape;
          _fp25.isSelected = true;
          var _sp11 = findShape(circle3.secondPointId).shape;
          _sp11.isSelected = true;
        }

        if (circle3.firstPointPlotted) {
          circle3.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          circle3.x = point.x;
          circle3.y = point.y;
          var _fp26 = findShape(circle3.firstPointId).shape;
          _fp26.isSelected = true;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var thirdPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: thirdPointId,
            connectionId: [circle3.uniqueId],
            circleId: circle3.uniqueId,
            isParameter: false
          });
          var _sp12 = findShape(circle3.secondPointId).shape;
          _sp12.isSelected = true;
          circle3.thirdPointId = thirdPointId;
          circle3.thirdPointPloted = true;
        } else if (circle3.secondPointId === clickingOnExistingPointID || circle3.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(circle3.uniqueId);
          circle3.thirdPointId = clickingOnExistingPointID;
          circle3.thirdPointPloted = true;
        }

        if (circle3.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (circle3.thirdPointPloted) {
        var _firstPoint15 = findShape(circle3.firstPointId).shape;
        var _secondPoint14 = findShape(circle3.secondPointId).shape;
        var _thirdPoint5 = findShape(circle3.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint15.x,
          y: _firstPoint15.y
        };
        value.secondPoint = {
          x: _secondPoint14.x,
          y: _secondPoint14.y
        };
        value.thirdPoint = {
          x: _thirdPoint5.x,
          y: _thirdPoint5.y
        };
        var circleData = computeCircle(value);
        var _fp27 = findShape(circle3.firstPointId).shape;
        _fp27.isSelected = false;
        var _sp13 = findShape(circle3.secondPointId).shape;
        _sp13.isSelected = false;
        var tp = findShape(circle3.thirdPointId).shape;
        tp.isSelected = false; // delete tp.updateKeys;
        // If parameter is on same circle then we delete isParamater attribute

        circle3.ploted = true;

        if (tp.circle === circle3.uniqueId && tp.isParameter) {
          delete tp.circle;
          delete tp.isParameter;
        }

        value.r = circleData.r;
        value.x = circleData.x;
        value.y = circleData.y;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'angle' && pointOnGraph) {
      var _angle9;

      if (currentShape.type === 'point') {
        _angle9 = findShape(currentShape.angleId).shape;
      } else {
        _angle9 = findShape(currentShape.uniqueId).shape;
      }

      if (!_angle9.firstPointPlotted) {
        dataAvailable = false;
        var _fp28 = findShape(_angle9.firstPointId).shape;
        _fp28.isSelected = true;

        if (clickingOnExistingPoint === null) {
          var _secondPointId5 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId5,
            connectionId: [_angle9.uniqueId],
            angleId: currentShape.angleId
          });
          var _fp29 = findShape(_angle9.firstPointId).shape;
          _fp29.isSelected = true;
          var _sp14 = findShape(_secondPointId5).shape;
          _sp14.isSelected = true;
          _angle9.secondPointId = _secondPointId5;
          _angle9.firstPointPlotted = true;
        } else if (_angle9.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(_angle9.uniqueId);
          point.angleId = currentShape.angleId;
          _angle9.secondPointId = clickingOnExistingPointID;
          _angle9.firstPointPlotted = true;
          var _sp15 = findShape(_angle9.secondPointId).shape;
          _sp15.isSelected = true;
        }

        if (_angle9.firstPointPlotted) {
          _angle9.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          _angle9.x = point.x;
          _angle9.y = point.y;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var _thirdPointId = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _thirdPointId,
            connectionId: [_angle9.uniqueId],
            angleId: _angle9.uniqueId
          });
          _angle9.thirdPointId = _thirdPointId;
          _angle9.thirdPointPloted = true;
        } else if (_angle9.secondPointId === clickingOnExistingPointID || _angle9.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(_angle9.uniqueId);
          _angle9.thirdPointId = clickingOnExistingPointID;
          point.angleId = _angle9.uniqueId;
          _angle9.thirdPointPloted = true;
        }

        if (_angle9.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (_angle9.thirdPointPloted) {
        var _firstPoint16 = findShape(_angle9.firstPointId).shape;
        var _secondPoint15 = findShape(_angle9.secondPointId).shape;
        var _thirdPoint6 = findShape(_angle9.thirdPointId).shape;
        _firstPoint16.isSelected = false;
        _secondPoint15.isSelected = false;
        _thirdPoint6.isSelected = false;
        value.firstPoint = {
          x: _firstPoint16.x,
          y: _firstPoint16.y,
          label: _firstPoint16.label
        };
        value.secondPoint = {
          x: _secondPoint15.x,
          y: _secondPoint15.y,
          label: _secondPoint15.label
        };
        value.thirdPoint = {
          x: _thirdPoint6.x,
          y: _thirdPoint6.y,
          label: _thirdPoint6.label
        };
        value.x = _secondPoint15.x;
        value.y = _secondPoint15.y;

        var _angleData = calculateAngle(value);

        value.angle = _angleData.angle;
        value.angleValue = _angleData.angleValue;
        _angle9.label = _angleData.angleText;
        _angle9.labelX = _angle9.x + getPointUnitByPixelUnit(10);
        _angle9.labelY = _angle9.y - getPointUnitByPixelUnit(10);
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'angleB' && pointOnGraph && localObj.newShapeStarted) {
      var angleB;

      if (currentShape.type === 'point') {
        angleB = findShape(currentShape.angleBId).shape;
      } else {
        angleB = findShape(currentShape.uniqueId).shape;
      }

      if (angleB.mode === 'point') {
        var _angleB, _angleB2;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB = angleB) === null || _angleB === void 0 ? void 0 : _angleB.firstPointPlotted)) {
          dataAvailable = false;

          if (clickingOnExistingPoint === null || angleB.firstPointId === clickingOnExistingPointID) {
            ;
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            point.angleBId = currentShape.uniqueId;
            angleB.secondPointId = clickingOnExistingPointID;
            angleB.firstPointPlotted = true;
            shapesData[clickingOnExistingPoint].isSelected = true;
          }

          if (angleB.firstPointPlotted) {
            angleB.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }
        } else {
          if (clickingOnExistingPoint === null || angleB.secondPointId === clickingOnExistingPointID || angleB.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            angleB.thirdPointId = clickingOnExistingPointID;
            point.angleBId = currentShape.uniqueId;
            angleB.thirdPointPloted = true;
            shapesData[clickingOnExistingPoint].isSelected = true;
          }

          if (angleB.thirdPointPloted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if ((_angleB2 = angleB) === null || _angleB2 === void 0 ? void 0 : _angleB2.thirdPointPloted) {
          var _firstPoint17 = findShape(angleB.firstPointId).shape;
          var _secondPoint16 = findShape(angleB.secondPointId).shape;
          var _thirdPoint7 = findShape(angleB.thirdPointId).shape;
          value.firstPoint = {
            x: _firstPoint17.x,
            y: _firstPoint17.y,
            label: _firstPoint17.label
          };
          value.secondPoint = {
            x: _secondPoint16.x,
            y: _secondPoint16.y,
            label: _secondPoint16.label
          };
          value.thirdPoint = {
            x: _thirdPoint7.x,
            y: _thirdPoint7.y,
            label: _thirdPoint7.label
          };
          value.x = _secondPoint16.x;
          value.y = _secondPoint16.y;
          value.uniqueId = angleB.uniqueId;
          var angleBData = calculateBisector(value);
          angleB.firstPoint = value.firstPoint;
          angleB.secondPoint = value.secondPoint;
          angleB.thirdPoint = value.thirdPoint;
          var lineId = addNewShape({
            firstPointId: _secondPoint16.uniqueId,
            connectionId: [_secondPoint16.uniqueId, angleB.uniqueId],
            type: 'line',
            uniqueId: ++localObj.uniqueId,
            x: _secondPoint16.x,
            y: _secondPoint16.y,
            xTo: angleBData.x,
            yTo: angleBData.y,
            dontDrag: true,
            slope: getSlope(_secondPoint16.x, _secondPoint16.y, angleBData.x, angleBData.y)
          });
          value.bisectorLine = lineId;
          angleB.bisectorLine = lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(lineId.uniqueId);
          dataAvailable = true;
          _firstPoint17.isSelected = false;
          _secondPoint16.isSelected = false;
          _thirdPoint7.isSelected = false;

          _firstPoint17.connectionId.push(lineId.uniqueId);

          _secondPoint16.connectionId.push(lineId.uniqueId);

          _thirdPoint7.connectionId.push(lineId.uniqueId);
        }
      } else if (angleB.mode === 'segment') {
        var _angleB3;

        var selectedShapeID = isOnShape(e);
        var selectedShape = findShape(selectedShapeID).shape;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB3 = angleB) === null || _angleB3 === void 0 ? void 0 : _angleB3.firstSegmentPlotted)) {
          dataAvailable = false;

          if (selectedShape !== undefined && (selectedShape.type.includes('segment') || selectedShape.type === 'line' || selectedShape.type === 'ray') && selectedShape.uniqueId === angleB.firstSegmentId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (selectedShape !== undefined && (selectedShape.type.includes('segment') || selectedShape.type === 'line' || selectedShape.type === 'ray')) {
            selectedShape.angleBId = angleB.uniqueId;
            angleB.secondSegmentId = selectedShape.uniqueId;
            angleB.firstSegmentPlotted = true;
            angleB.secondSegment = {
              x: selectedShape.x,
              y: selectedShape.y,
              xTo: selectedShape.xTo,
              yTo: selectedShape.yTo
            };
            angleB.secondConnId = selectedShape.connectionId;
            selectedShape.isSelected = true;
          }

          if (angleB.firstSegmentPlotted) {
            angleB.secondSegmentPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }

          if (angleB.secondSegmentPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if (angleB.secondSegmentPlotted) {
          value.firstSegment = angleB.firstSegment;
          value.secondSegment = angleB.secondSegment;
          var commonPt = angleB.firstConnId.filter(function (value) {
            return angleB.secondConnId.includes(value);
          })[0]; //gives unique id of common point.

          var intersectPoint = modelObj.LabComClass.Maths.getLineintersect(angleB.firstSegment.x, angleB.firstSegment.y, angleB.firstSegment.xTo, angleB.firstSegment.yTo, angleB.secondSegment.x, angleB.secondSegment.y, angleB.secondSegment.xTo, angleB.secondSegment.yTo);

          if (commonPt === undefined) {
            //if there is no common point between segments then the shape will be discontinued.
            clearCache();
            addEvents();
            return;
          }

          var pCommon = findCommon(angleB.firstSegment, angleB.secondSegment);
          value.x = +pCommon.x;
          value.y = +pCommon.y;
          angleB.x = +pCommon.x;
          angleB.y = +pCommon.y;
          value.uniqueId = angleB.uniqueId;

          var _angleBData = calculateBisector(value, "segment");

          var slope = getSlope(+pCommon.x, +pCommon.y, _angleBData.x, _angleBData.y);
          var newToPoint = modelObj.LabComClass.Maths.getPoint({
            x: +pCommon.x,
            y: +pCommon.y
          }, slope, getPointUnitByPixelUnit(50));

          var _lineId = addNewShape({
            firstPointId: commonPt,
            connectionId: [commonPt, angleB.uniqueId],
            dontDrag: true,
            type: 'line',
            uniqueId: ++localObj.uniqueId,
            x: +pCommon.x,
            y: +pCommon.y,
            xTo: _angleBData.bisectorLine.xTo,
            yTo: _angleBData.bisectorLine.yTo,
            slope: getSlope(+pCommon.x, +pCommon.y, _angleBData.bisectorLine.xTo, _angleBData.bisectorLine.yTo)
          });

          value.bisectorLine = _lineId;
          angleB.bisectorLine = _lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(_lineId.uniqueId);
          dataAvailable = true;
          var firstSegmentShape = findShape(angleB.firstSegmentId).shape;
          var secondSegmentShape = findShape(angleB.secondSegmentId).shape;
          firstSegmentShape.isSelected = false;
          secondSegmentShape.isSelected = false;
          firstSegmentShape.connectionId.push(_lineId.uniqueId);
          secondSegmentShape.connectionId.push(_lineId.uniqueId);
        }
      }
    } else if (currentShape && _it === 'angleSize' && pointOnGraph && localObj.newShapeStarted) {
      var angleSize;

      if (currentShape.type === 'point') {
        angleSize = findShape(currentShape.angleSizeId).shape;
      } else {
        angleSize = findShape(currentShape.uniqueId).shape;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleSize.mode === 'point') {
        var _angleSize;

        if (angleSize === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleSize = angleSize) === null || _angleSize === void 0 ? void 0 : _angleSize.firstPointPlotted)) {
          dataAvailable = false;
          point.angleSizeId = angleSize.uniqueId;
          localObj.currentUniqueId = null;
          angleSize.firstPointPlotted = true;
          angleSize.x = point.x;
          angleSize.y = point.y;
          var fpShape = findShape(angleSize.firstPointId).shape;
          fpShape.isSelected = true;
        } else if (!angleSize.secondPointPlotted) {
          if (clickingOnExistingPointID === angleSize.firstPointId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            var _secondPointId6;

            if (clickingOnExistingPointID >= 0 && clickingOnExistingPointID !== null) {
              _secondPointId6 = clickingOnExistingPointID;
              angleSize.connectionId.push(clickingOnExistingPointID);
            } else {
              _secondPointId6 = ++localObj.uniqueId;
              addPoint(point, {
                uniqueId: _secondPointId6,
                angleSizeId: angleSize.uniqueId,
                connectionId: [angleSize.uniqueId]
              });
            }

            if (_secondPointId6 !== undefined) {
              var _firstPoint18 = findShape(angleSize.firstPointId).shape;
              angleSize.secondPointId = _secondPointId6;
              angleSize.secondPointPlotted = true;
              angleSize.x = point.x;
              angleSize.y = point.y;
              angleSize.xTo = _firstPoint18.x;
              angleSize.yTo = _firstPoint18.y;

              if (angleSize.secondPointId >= 0) {
                var spShape = findShape(_secondPointId6).shape;

                if (spShape) {
                  var _fpShape = findShape(angleSize.firstPointId).shape;
                  _fpShape.isSelected = true;
                  spShape.isSelected = true;
                }
              }

              modelObj.waiting = true;

              if (typeof events.angleSize !== 'undefined') {
                events.angleSize({
                  id: modelObj.id,
                  type: 'angleSize',
                  visible: true,
                  data: JSON.parse(JSON.stringify(angleSize))
                }, true);
              }

              dataAvailable = false;
            }
          }
        } else {
          _this.removeUnplotedShapes();
        }
      } else if (angleSize.mode === 'segment') {
        var _selectedShapeID6 = isOnShape(e);

        var _selectedShape = findShape(_selectedShapeID6).shape;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === 'segSize' && pointOnGraph) {
      var _segSize;

      var segSize;

      if (currentShape.type === 'point') {
        segSize = findShape(currentShape.segSizeId).shape;
      } else {
        segSize = findShape(currentShape.uniqueId).shape;
      }

      point.x = currentShape.x;
      point.y = currentShape.y;
      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (segSize === undefined) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        localObj.mouseDown.isMouseDown = false;
      } else if (!((_segSize = segSize) === null || _segSize === void 0 ? void 0 : _segSize.firstPointPlotted)) {
        dataAvailable = false;
        point.segSizeId = segSize.uniqueId;
        localObj.currentUniqueId = null;
        segSize.firstPointPlotted = true;
        segSize.x = point.x;
        segSize.y = point.y;
        var _fp30 = findShape(segSize.firstPointId).shape;
        _fp30.isSelected = true;

        if (segSize.firstPointPlotted) {
          modelObj.waiting = true;

          if (typeof events.segSize !== 'undefined') {
            events.segSize({
              id: modelObj.id,
              type: 'segSize',
              visible: true,
              data: JSON.parse(JSON.stringify(segSize))
            }, true);
          }

          dataAvailable = false;
        }
      } else {
        _this.removeUnplotedShapes();
      }
    } else if (_it === 'labelTool') {
      if (localObj.currentUniqueId !== undefined && currentShape && !modelObj.waiting) {
        localObj.mouseDown.lastShapeCompleted = false;
        modelObj.waiting = true;

        if (typeof events.labelTool !== 'undefined') {
          events.labelTool({
            id: modelObj.id,
            type: 'labelTool',
            visible: true,
            data: JSON.parse(JSON.stringify(currentShape))
          }, true);
        }
      } else {
        localObj.mouseDown.lastShapeCompleted = false;

        _this.removeUnplotedShapes();
      }
    } else if (currentShape && _it === 'circleSize' && pointOnGraph) {
      var _circleSize;

      var circleSize;

      if (currentShape.type === 'point') {
        circleSize = findShape(currentShape.circleSizeId).shape;
      } else {
        circleSize = findShape(currentShape.uniqueId).shape;
      }

      point.x = currentShape.x;
      point.y = currentShape.y;
      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (circleSize === undefined) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        localObj.mouseDown.isMouseDown = false;
      } else if (!((_circleSize = circleSize) === null || _circleSize === void 0 ? void 0 : _circleSize.firstPointPlotted)) {
        dataAvailable = false;
        point.circleSizeId = circleSize.uniqueId;
        localObj.currentUniqueId = null;
        circleSize.firstPointPlotted = true;
        circleSize.x = point.x;
        circleSize.y = point.y;
        var _fp31 = findShape(circleSize.firstPointId).shape;
        _fp31.isSelected = true;

        if (circleSize.firstPointPlotted) {
          modelObj.waiting = true;

          if (typeof events.circleSize !== 'undefined') {
            events.circleSize({
              id: modelObj.id,
              type: 'circleSize',
              visible: true,
              data: JSON.parse(JSON.stringify(circleSize))
            }, true);
          }

          dataAvailable = false;
        }
      } else {
        _this.removeUnplotedShapes();
      }
    } else if (currentShape && _it === 'midPoint' && pointOnGraph) {
      var _midPoint4;

      var midPoint; // const selectedShapeID = isOnShape(e);

      var _selectedShapeID7 = selectShape(e);

      var _selectedShape2 = findShape(_selectedShapeID7).shape;

      if (currentShape.type === 'point' || currentShape.type.includes('segment')) {
        midPoint = findShape(currentShape.midPointId).shape;
      } else {
        midPoint = findShape(currentShape.uniqueId).shape;
      }

      var selectedShapeN = findShape(midPoint.firstPointId).shape;

      if (!((_midPoint4 = midPoint) === null || _midPoint4 === void 0 ? void 0 : _midPoint4.firstPointPlotted)) {
        dataAvailable = false;

        if (_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes('segment')) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if (clickingOnExistingPoint === null && !(_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes('segment'))) {
          var _secondPointId7 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId7,
            connectionId: [midPoint.uniqueId],
            midPointId: currentShape.midPointId
          });
          midPoint.secondPointId = _secondPointId7;
          midPoint.firstPointPlotted = true;
        } else if (midPoint.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(midPoint.uniqueId);
          point.midPointId = currentShape.midPointId;
          midPoint.secondPointId = clickingOnExistingPointID;
          midPoint.firstPointPlotted = true;
        }

        if (midPoint.firstPointPlotted) {
          midPoint.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          midPoint.x = point.x;
          midPoint.y = point.y;
        }

        selectedShapeN.isSelected = true;
      } else {
        if (midPoint.secondPointPlotted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (midPoint.secondPointPlotted && midPoint.onSegment === undefined) {
        var _findShape2;

        var _firstPoint19 = findShape(midPoint.firstPointId).shape;
        var _secondPoint17 = findShape(midPoint.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint19.x,
          y: _firstPoint19.y,
          label: _firstPoint19.label
        };
        value.secondPoint = {
          x: _secondPoint17.x,
          y: _secondPoint17.y,
          label: _secondPoint17.label
        };
        value.uniqueId = midPoint.uniqueId;
        value.x = (_firstPoint19.x + _secondPoint17.x) / 2;
        value.y = (_firstPoint19.y + _secondPoint17.y) / 2;
        midPoint.x = (_firstPoint19.x + _secondPoint17.x) / 2;
        midPoint.y = (_firstPoint19.y + _secondPoint17.y) / 2;
        value.midPointId = ++localObj.uniqueId;
        midPoint.midPointId = value.midPointId; // value.uniqueId = currentShape.uniqueId;

        dataAvailable = true;
        addPoint({
          type: 'point',
          x: value.x,
          y: value.y
        }, {
          connectionId: [midPoint.uniqueId],
          uniqueId: value.midPointId,
          kshitij: true,
          dontDrag: true,
          updateValue: false
        });

        var _segment4 = (_findShape2 = findShape(midPoint.segmentId)) === null || _findShape2 === void 0 ? void 0 : _findShape2.shape;

        if (_segment4) {
          _segment4.isMouseDown = false;
          _segment4.isSelected = false;
        }

        midPoint.strokeColor = modelObj.pointColor;
        midPoint.fillColor = modelObj.pointColor;
        selectedShapeN.isSelected = false;

        _firstPoint19.connectionId.push(value.midPointId);

        _secondPoint17.connectionId.push(value.midPointId);
      } else if (midPoint.secondPointPlotted && midPoint.onSegment !== undefined) {
        // value.x=(midPoint.x+midPoint.xTo)/2;
        // value.y=(midPoint.y+midPoint.yTo)/2;
        value.x = (midPoint.firstPointCoords.x + midPoint.secondPointCoords.x) / 2;
        value.y = (midPoint.firstPointCoords.y + midPoint.secondPointCoords.y) / 2;
        value.uniqueId = midPoint.uniqueId;
        value.midPointId = ++localObj.uniqueId;
        midPoint.midPointId = value.midPointId;
        dataAvailable = true;
        addPoint({
          type: 'point',
          x: value.x,
          y: value.y
        }, {
          connectionId: [midPoint.uniqueId],
          uniqueId: value.midPointId,
          kshitij: true,
          dontDrag: true,
          updateValue: false
        });
        var _segment5 = findShape(midPoint.segmentId).shape;
        _segment5.isMouseDown = false;
        _segment5.isSelected = false;

        _segment5.connectionId.push(value.midPointId);

        _segment5.midPointId = value.midPointId;
      }
    } else if (currentShape && _it === 'square' && pointOnGraph) {
      var square;

      if (currentShape.type === 'point') {
        square = findShape(currentShape.squareId).shape;
      }

      if (!square.firstPointPlotted) {
        if (clickingOnExistingPointID === square.firstPointId) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          var _fp32 = findShape(square.firstPointId).shape;
          _fp32.isSelected = true;
        } else if (clickingOnExistingPoint === null) {
          var _secondPointId8 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId8,
            connectionId: [square.uniqueId],
            squareId: currentShape.squareId // otherPointSquare: square.firstPointId,

          });
          square.secondPointId = _secondPointId8;
          square.firstPointPlotted = true;
          square.secondPointPlotted = true;
          var _fp33 = findShape(square.firstPointId).shape;
          _fp33.otherPointSquare = square.secondPointId;
          _fp33.isSelected = true;
          _fp33.squareFirstPoint = true;
          var _sp16 = findShape(square.secondPointId).shape;
          _sp16.squareSecondPoint = true;
          _sp16.otherPointSquare = square.firstPointId;
          _sp16.isSelected = true;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(square.uniqueId);
          point.squareId = currentShape.squareId;
          square.secondPointId = clickingOnExistingPointID; // shapesData[clickingOnExistingPoint].squareId = square.uniqueId;

          square.secondPointPlotted = true;
          square.firstPointPlotted = true;
          var _fp34 = findShape(square.firstPointId).shape;
          _fp34.isSelected = true;
          _fp34.squareFirstPoint = true;
          _fp34.otherPointSquare = square.secondPointId;
          var _sp17 = findShape(square.secondPointId).shape;
          _sp17.otherPointSquare = square.firstPointId;
          _sp17.squareSecondPoint = true;
          _sp17.isSelected = true;
        }
      }

      if (square.secondPointId) {
        var _firstPoint20 = findShape(square.firstPointId).shape;
        var _secondPoint18 = findShape(square.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint20.x,
          y: _firstPoint20.y
        };
        value.secondPoint = {
          x: _secondPoint18.x,
          y: _secondPoint18.y
        };
        value.firstPointId = square.firstPointId;
        value.secondPointId = square.secondPointId;
        value.side = modelObj.LabComClass.Maths.getDistance(_firstPoint20, _secondPoint18);
        value.label = 'A  §qQuadrat§r = ' + to2Dec(value.side * value.side);
        square.label = 'A  §qQuadrat§r = ' + to2Dec(value.side * value.side);

        var _thirdPoint8 = modelObj.LabComClass.Maths.getPoint(_secondPoint18, modelObj.LabComClass.Maths.getAngle(_secondPoint18.x, _secondPoint18.y, _firstPoint20.x, _firstPoint20.y) - Math.PI / 2, value.side);

        var fourthPoint = modelObj.LabComClass.Maths.getPoint(_firstPoint20, modelObj.LabComClass.Maths.getAngle(_secondPoint18.x, _secondPoint18.y, _firstPoint20.x, _firstPoint20.y) - Math.PI / 2, value.side);

        var _thirdPointId2 = ++localObj.uniqueId;

        var fourthPointId = ++localObj.uniqueId;
        square.labelX = (_firstPoint20.x + _thirdPoint8.x) / 2;
        square.labelY = (_firstPoint20.y + _thirdPoint8.y) / 2;
        addPoint(_thirdPoint8, {
          connectionId: [square.uniqueId],
          uniqueId: _thirdPointId2,
          squareId: square.uniqueId,
          dontDrag: true,
          updateValue: false
        });
        addPoint(fourthPoint, {
          connectionId: [square.uniqueId],
          uniqueId: fourthPointId,
          squareId: square.uniqueId,
          dontDrag: true,
          updateValue: false
        });
        var thirdp = findShape(_thirdPointId2).shape;
        var fourp = findShape(fourthPointId).shape;
        _thirdPoint8.uniqueId = _thirdPointId2;
        fourthPoint.uniqueId = fourthPointId;
        value.thirdPointId = _thirdPointId2;
        value.fourthPointId = fourthPointId;
        value.thirdPoint = _thirdPoint8;
        value.fourthPoint = fourthPoint;
        value.uniqueId = square.uniqueId;
        square.thirdPointId = _thirdPointId2;
        square.fourthPointId = fourthPointId;
        square.firstPoint = _firstPoint20;
        square.secondPoint = _secondPoint18;
        square.thirdPoint = _thirdPoint8;
        square.fourthPoint = fourthPoint;
        square.distance = value.side;
        var seg1 = addSegment(_firstPoint20, _secondPoint18, square.uniqueId);

        var _seg = addSegment(_secondPoint18, _thirdPoint8, square.uniqueId);

        var _seg2 = addSegment(_firstPoint20, fourthPoint, square.uniqueId);

        var seg4 = addSegment(_thirdPoint8, fourthPoint, square.uniqueId);
        square.segmentId1 = seg1.uniqueId;
        square.segmentId2 = _seg.uniqueId;
        square.segmentId3 = _seg2.uniqueId;
        square.segmentId4 = seg4.uniqueId;
        square.connectionId.push(seg1.uniqueId, _seg.uniqueId, _seg2.uniqueId, seg4.uniqueId);

        _this.updateShape(_firstPoint20.uniqueId, {
          connectionId: [].concat(_toConsumableArray(_firstPoint20.connectionId), [seg1.uniqueId])
        });

        _this.updateShape(_secondPoint18.uniqueId, {
          connectionId: [].concat(_toConsumableArray(_secondPoint18.connectionId), [seg1.uniqueId])
        });

        _this.updateShape(_secondPoint18.uniqueId, {
          connectionId: [].concat(_toConsumableArray(_secondPoint18.connectionId), [_seg.uniqueId])
        });

        _this.updateShape(_thirdPoint8.uniqueId, {
          connectionId: [].concat(_toConsumableArray(thirdp.connectionId), [_seg.uniqueId])
        });

        _this.updateShape(_thirdPoint8.uniqueId, {
          connectionId: [].concat(_toConsumableArray(thirdp.connectionId), [_seg2.uniqueId])
        });

        _this.updateShape(fourthPoint.uniqueId, {
          connectionId: [].concat(_toConsumableArray(fourp.connectionId), [_seg2.uniqueId])
        });

        _this.updateShape(fourthPoint.uniqueId, {
          connectionId: [].concat(_toConsumableArray(fourp.connectionId), [seg4.uniqueId])
        });

        _this.updateShape(_firstPoint20.uniqueId, {
          connectionId: [].concat(_toConsumableArray(_firstPoint20.connectionId), [seg4.uniqueId])
        }); // if(firstPoint.squarePoints !== undefined) {
        //   firstPoint.squarePoints = [...firstPoint?.squarePoints,fourthPointId,thirdPointId];
        // }
        // else {


        _firstPoint20.squarePoints = [fourthPointId, _thirdPointId2]; // }
        // if(secondPoint.squarePoints !== undefined) {
        //   secondPoint.squarePoints = [...secondPoint?.squarePoints,thirdPointId,fourthPointId];
        // }
        // else {  

        _secondPoint18.squarePoints = [_thirdPointId2, fourthPointId]; // }

        var _fp35 = findShape(square.firstPointId).shape;
        _fp35.isSelected = false;
        var _sp18 = findShape(square.secondPointId).shape;
        _sp18.isSelected = false;
        dataAvailable = true;
        square.fillColor = modelObj.shapes.defBgFill;
        square.strokeColor = modelObj.pointColor;
      }
    } else if (currentShape && _it === 'mirrorOnLine' && pointOnGraph) {
      var _mirrorOnLine;

      var mirrorOnLine;

      var _selectedShapeID8 = isOnShape(e);

      var _selectedShape3 = findShape(_selectedShapeID8).shape;

      if (currentShape.type === 'point') {
        mirrorOnLine = findShape(currentShape.mirrorOnLineId).shape;
      } else {
        mirrorOnLine = findShape(currentShape.uniqueId).shape;
      }

      if (!((_mirrorOnLine = mirrorOnLine) === null || _mirrorOnLine === void 0 ? void 0 : _mirrorOnLine.firstPointPlotted) && _typeof(mirrorOnLine) !== undefined) {
        var _mirrorOnLine2, _mirrorOnLine3;

        dataAvailable = false;
        var _fp36 = findShape(mirrorOnLine.firstPointId).shape;
        _fp36.isSelected = true;

        if (clickingOnExistingPoint === null && _selectedShape3 && checkType(_selectedShape3, localObj.lineTypes)) {
          var _lineId2 = _selectedShapeID8;
          mirrorOnLine.lineId = _lineId2;
          mirrorOnLine.firstPointPlotted = true;
        } else if (((_mirrorOnLine2 = mirrorOnLine) === null || _mirrorOnLine2 === void 0 ? void 0 : _mirrorOnLine2.firstPointId) === clickingOnExistingPointID || clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if ((_mirrorOnLine3 = mirrorOnLine) === null || _mirrorOnLine3 === void 0 ? void 0 : _mirrorOnLine3.firstPointPlotted) {
          mirrorOnLine.linePlotted = true;
          localObj.currentUniqueId = null; // mirrorOnLine.x = point.x;
          // mirrorOnLine.y = point.y;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (mirrorOnLine !== undefined && mirrorOnLine.linePlotted) {
        var _firstPoint21 = findShape(mirrorOnLine.firstPointId).shape;
        value.firstPoint = {
          x: _firstPoint21.x,
          y: _firstPoint21.y,
          uniqueId: _firstPoint21.uniqueId
        };
        mirrorOnLine.firstPoint = {
          x: _firstPoint21.x,
          y: _firstPoint21.y,
          uniqueId: _firstPoint21.uniqueId
        }; // const mirrorData = computeMirrorPoint(mirrorOnLine);

        var line = findShape(mirrorOnLine.lineId).shape;
        var eqnLine = computeEqn(line);
        var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, mirrorOnLine.x, mirrorOnLine.y);
        value.x = mirrorPoint.x;
        value.y = mirrorPoint.y;
        mirrorOnLine.x = mirrorPoint.x;
        mirrorOnLine.y = mirrorPoint.y;
        value.lineId = line.uniqueId;
        value.mirrorPointId = ++localObj.uniqueId;
        mirrorOnLine.mirrorPointId = value.mirrorPointId;
        addPoint(mirrorPoint, {
          uniqueId: value.mirrorPointId,
          mirrorOnLineId: mirrorOnLine.uniqueId,
          connectionId: [mirrorOnLine.uniqueId],
          dontDrag: true,
          updateValue: false
        });
        dataAvailable = true;
        var _fp37 = findShape(mirrorOnLine.firstPointId).shape;
        _fp37.isSelected = false;
        line.connectionId.push(value.mirrorPointId);
        mirrorOnLine.connectionId.push(value.mirrorPointId);
        line.connectionId.push(mirrorOnLine.uniqueId);
        line.mirrorOnLineId = value.mirrorPointId;

        _fp37.connectionId.push(value.mirrorPointId);

        _fp37.mirrorOnLineId = value.mirrorPointId;
      } else {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === 'mirrorOnPoint' && pointOnGraph) {
      var _mirrorOnPoint;

      var mirrorOnPoint; // const selectedShapeID = isOnShape(e);

      var _selectedShapeID9 = selectShape(e);

      var _selectedShape4 = findShape(_selectedShapeID9).shape;

      if (currentShape.type === 'point') {
        mirrorOnPoint = findShape(currentShape.mirrorOnPointId).shape;
      } else {
        mirrorOnPoint = findShape(currentShape.uniqueId).shape;
      }

      var _selectedShapeN = findShape(mirrorOnPoint.firstPointId).shape;

      if (!((_mirrorOnPoint = mirrorOnPoint) === null || _mirrorOnPoint === void 0 ? void 0 : _mirrorOnPoint.firstPointPlotted)) {
        dataAvailable = false;

        if (_selectedShape4 === null || _selectedShape4 === void 0 ? void 0 : _selectedShape4.type.includes('segment')) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if (clickingOnExistingPoint === null && !(_selectedShape4 === null || _selectedShape4 === void 0 ? void 0 : _selectedShape4.type.includes('segment'))) {
          var _secondPointId9 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId9,
            connectionId: [mirrorOnPoint.uniqueId],
            mirrorOnPointId: currentShape.mirrorOnPointId
          });
          mirrorOnPoint.secondPointId = _secondPointId9;
          mirrorOnPoint.firstPointPlotted = true;
        } else if (mirrorOnPoint.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(mirrorOnPoint.uniqueId);
          point.mirrorOnPointId = currentShape.mirrorOnPointId;
          mirrorOnPoint.secondPointId = clickingOnExistingPointID;
          mirrorOnPoint.firstPointPlotted = true;
        }

        if (mirrorOnPoint.firstPointPlotted) {
          mirrorOnPoint.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          mirrorOnPoint.x = point.x;
          mirrorOnPoint.y = point.y;
        }

        _selectedShapeN.isSelected = true;
      } else {
        if (mirrorOnPoint.secondPointPlotted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (mirrorOnPoint.secondPointPlotted) {
        var _firstPoint22 = findShape(mirrorOnPoint.firstPointId).shape;
        var _secondPoint19 = findShape(mirrorOnPoint.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint22.x,
          y: _firstPoint22.y,
          label: _firstPoint22.label
        };
        value.secondPoint = {
          x: _secondPoint19.x,
          y: _secondPoint19.y,
          label: _secondPoint19.label
        };
        value.uniqueId = mirrorOnPoint.uniqueId;
        value.x = 2 * _secondPoint19.x - _firstPoint22.x;
        value.y = 2 * _secondPoint19.y - _firstPoint22.y;
        mirrorOnPoint.x = 2 * _secondPoint19.x - _firstPoint22.x;
        mirrorOnPoint.y = 2 * _secondPoint19.y - _firstPoint22.y;
        value.mirrorOnPointId = ++localObj.uniqueId;
        mirrorOnPoint.mirrorOnPointId = value.mirrorOnPointId; // value.uniqueId = currentShape.uniqueId;

        dataAvailable = true;
        addPoint({
          type: 'point',
          x: value.x,
          y: value.y
        }, {
          connectionId: [mirrorOnPoint.uniqueId],
          uniqueId: value.mirrorOnPointId,
          kshitij: true,
          dontDrag: true,
          updateValue: false
        });
        mirrorOnPoint.strokeColor = modelObj.pointColor;
        mirrorOnPoint.fillColor = modelObj.pointColor;
        _selectedShapeN.isSelected = false;

        _firstPoint22.connectionId.push(value.mirrorOnPointId);

        _secondPoint19.connectionId.push(value.mirrorOnPointId);
      }
    } else if (currentShape && _it === 'perpendicularBisector' && pointOnGraph && localObj.newShapeStarted) {
      var onShape = findShape(isOnShape(e)).shape;
      var perpShape = currentShape;

      if (perpShape.mode === 'point') {
        if (!perpShape.firstPointPlotted) {
          if (perpShape.firstPointId === clickingOnExistingPointID || checkType(onShape, localObj.lineTypes)) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
            point.connectionId.push(perpShape.uniqueId);
            perpShape.secondPointId = clickingOnExistingPointID;
            perpShape.firstPointPlotted = true;
            var _fp38 = findShape(perpShape.firstPointId).shape;
            _fp38.isSelected = true;
          }

          if (perpShape.firstPointPlotted) {
            perpShape.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            perpShape.x = point.x;
            perpShape.y = point.y;
          }
        } else {
          if (perpShape.secondPointPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        if (perpShape.firstPointPlotted && perpShape.secondPointPlotted) {
          var _firstPoint23 = findShape(currentShape.firstPointId).shape;
          var _secondPoint20 = findShape(perpShape.secondPointId).shape;
          var _midPoint5 = {
            x: (_firstPoint23.x + _secondPoint20.x) / 2,
            y: (_firstPoint23.y + _secondPoint20.y) / 2
          };
          var valueObj = computePerpBisector(perpShape, _firstPoint23, _secondPoint20, _midPoint5);
          value = _objectSpread(_objectSpread({}, value), valueObj);
          dataAvailable = true;
          var _fp39 = findShape(perpShape.firstPointId).shape;
          perpShape.perpLineId = value.perpLineId;
          _fp39.isSelected = false;

          _firstPoint23.connectionId.push(value.perpLineId);

          _secondPoint20.connectionId.push(value.perpLineId);
        }
      } else if (perpShape.mode === 'segment') {
        var _firstPoint24 = {
          x: perpShape.segment.x,
          y: perpShape.segment.y
        };
        var _secondPoint21 = {
          x: perpShape.segment.xTo,
          y: perpShape.segment.yTo
        };
        var _midPoint6 = {
          x: (_firstPoint24.x + _secondPoint21.x) / 2,
          y: (_firstPoint24.y + _secondPoint21.y) / 2
        };

        var _valueObj = computePerpBisector(perpShape, _firstPoint24, _secondPoint21, _midPoint6);

        value = _objectSpread(_objectSpread({}, value), _valueObj);
        perpShape.perpLineId = value.perpLineId;
        var _segment6 = findShape(perpShape.segmentId).shape;

        _segment6.connectionId.push(value.perpLineId);

        perpShape.segmentPlotted = true;
        value.segmentPlotted = true;
        dataAvailable = true;
      }
    } else if (currentShape && (_it === 'perpendicularLine' || _it === 'parallelLine') && pointOnGraph) {
      // updatePLinePoints(currentShape);
      dataAvailable = true;

      if (currentShape.lineToPoint) {
        var _line9 = findShape(currentShape.line).shape;

        if (clickingOnExistingPoint === null) {
          var distance = Math.abs(modelObj.LabComClass.Maths.getPointLineDistance(point, _line9, {
            x: _line9.xTo,
            y: _line9.yTo
          }));
          var accepted = distance < getPointUnitByPixelUnit(modelObj.snappingDiff) && currentShape.lineSelected;

          if (accepted || distance > getPointUnitByPixelUnit(modelObj.snappingDiff)) {
            var _secondPointId10 = ++localObj.uniqueId;

            addPoint(point, {
              uniqueId: _secondPointId10,
              connectionId: [currentShape.uniqueId]
            });
            currentShape.secondPointId = _secondPointId10;
            currentShape.connectionId.push(_secondPointId10);
            localObj.mouseDown.lastShapeCompleted = true;
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else if (clickingOnExistingPointID === currentShape.firstPointId) {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          localObj.mouseDown.lastShapeCompleted = true;
        }

        if (dataAvailable) {
          _line9.isSelected = false;
        }
      } else {
        var _selectedShapeID10 = isOnShape(e);

        if (_selectedShapeID10) {
          var shapeData = findShape(_selectedShapeID10).shape;

          if (shapeData && checkType(shapeData, localObj.lineTypes)) {
            var _d4 = getPLine(e, _it === 'perpendicularLine');

            if (_d4) {
              currentShape.line = _selectedShapeID10; // Assigning parent line id to perp/parallel line.

              var parentLine = findShape(_d4.line).shape;
              parentLine.connectionId.push(currentShape.uniqueId);
              currentShape.slope = _d4.slope;
              var _firstPoint25 = findShape(currentShape.firstPointId).shape;
              _firstPoint25.isSelected = false;

              if (!_firstPoint25.connectionId.includes(currentShape.uniqueId)) {
                _firstPoint25.connectionId.push(currentShape.uniqueId);
              }

              updatePLinePoints(currentShape);
              localObj.mouseDown.lastShapeCompleted = true;
            }
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        }
      }

      if (currentShape.pointToLine) {
        currentShape.firstPointPlotted = true;
      } else {
        currentShape.lineSelected = true;
      }

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ['x', 'y', 'xTo', 'yTo']);
      }

      if (dataAvailable) {
        value.x = currentShape.x;
        value.y = currentShape.y;
        value.xTo = currentShape.xTo;
        value.yTo = currentShape.yTo;
        value.slope = currentShape.slope;
        value.uniqueId = currentShape.uniqueId;
        currentShape.visible = true;
      } else {
        dataAvailable = false;
        localObj.mouseDown.lastShapeCompleted = false;
      }
    } else if (currentShape && _it === 'compass') {
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (clickingOnExistingPoint === null) {
        if (currentShape.firstPointId !== undefined && !currentShape.isPloted) {
          shapesData.pop();
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = true;
        } else if (!currentShape.isPloted) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          currentShape.isPloted = true;
          currentShape.x = point.x;
          currentShape.y = point.y;
        } else if (pointOnGraph) {
          var centerPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: centerPointId,
            connectionId: [currentShape.uniqueId]
          }); //currentShape.centerPointId = centerPointId;

          currentShape.connectionId.push(centerPointId);
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID && !currentShape.isPloted) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else if (!currentShape.isPloted) {
        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        currentShape.isPloted = true;
      } else {
        point.connectionId.push(currentShape.uniqueId);
        currentShape.centerPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        currentShape.x = point.x;
        currentShape.y = point.y;
        localObj.mouseDown.lastShapeCompleted = true;
        var s = currentShape.firstPointId !== undefined ? findShape(currentShape.firstPointId) : findShape(currentShape.circleID);

        if (s) {
          s.shape.isSelected = false;
        }

        var selectedSegment = currentShape.segmentID >= 0 ? findShape(currentShape.segmentID).shape : undefined;

        if (selectedSegment) {
          selectedSegment.isSelected = false;
        }
      }
    } else if (_it === 'circle' && currentShape) {
      dataAvailable = true;
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;

      if (clickingOnExistingPoint === null && pointOnGraph) {
        var _secondPointId11 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _secondPointId11,
          connectionId: [currentShape.uniqueId]
        });
        currentShape.secondPointId = _secondPointId11;
        currentShape.connectionId.push(_secondPointId11);
      } else if (!pointOnGraph || currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        point.connectionId.push(currentShape.uniqueId);
        currentShape.secondPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (_it === 'scale') {
      dataAvailable = true;
      value.x = scaleObj.x;
      value.y = scaleObj.y;
      value.xTo = scaleObj.xTo;
      value.yTo = scaleObj.yTo;
      dispatchEventScale();
    } else if (_it.includes('brush') && currentShape) {
      currentShape.isSelected = false;

      if (true) {
        if (currentShape.type === 'point' || currentShape.type === 'angle' || currentShape.type === 'angleSize') {
          value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
          value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;

          switch (_it) {
            case 'brush1':
            case 'brush2':
            case 'brush3':
            case 'brush4':
            case 'brush5':
            case 'brush6':
            case 'brush7':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = modelObj.shapes[_it].color.stroke;
              currentShape.strokeColor = modelObj.shapes[_it].color.stroke;
              break;
          }
        } else {
          value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;

          switch (_it) {
            case 'brush1':
            case 'brush2':
            case 'brush3':
            case 'brush4':
            case 'brush5':
            case 'brush6':
            case 'brush7':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              currentShape.strokeColor = modelObj.shapes[_it].color.stroke;
              break;
          }
        }

        if (currentShape.type === 'square' || currentShape.type === 'triangle') {
          value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
          value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;

          switch (_it) {
            case 'brush1':
            case 'brush2':
            case 'brush3':
            case 'brush4':
            case 'brush5':
            case 'brush6':
            case 'brush7':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = '';
              currentShape.fillColor = modelObj.shapes[_it].color.stroke.slice(0, -1) + ', 0.5)';
              currentShape.strokeColor = modelObj.shapes[_it].color.stroke;
              ['firstPointId', 'secondPointId', 'thirdPointId'].forEach(function (point) {
                var pointShape = findShape(currentShape[point]).shape;
                pointShape.fillColor = modelObj.shapes[_it].color.stroke;
                pointShape.strokeColor = currentShape.strokeColor;
              });

              if (currentShape.type === 'square') {
                //Square fourth point
                var fourthPointShape = findShape(currentShape.fourthPointId).shape;
                fourthPointShape.fillColor = modelObj.shapes[_it].color.stroke;
                fourthPointShape.strokeColor = currentShape.strokeColor;
                ['segmentId1', 'segmentId2', 'segmentId3', 'segmentId4'].forEach(function (seg) {
                  var segmentShape = findShape(currentShape[seg]).shape;
                  segmentShape.fillColor = modelObj.shapes[_it].color.stroke;
                  segmentShape.strokeColor = currentShape.strokeColor;
                });
              } else {
                //Triangle Segments
                ['seg1Id', 'seg2Id', 'seg3Id'].forEach(function (seg) {
                  var segmentShape = findShape(currentShape[seg]).shape;
                  segmentShape.fillColor = modelObj.shapes[_it].color.stroke;
                  segmentShape.strokeColor = currentShape.strokeColor;
                });
              }

              break;
          }
        }

        localObj.mouseDown.lastShapeCompleted = true;
        localObj.mouseDown.isMouseDown = false;
        value.type = 'colour';
        value.shapeLabel = currentShape.label;
        value.color = currentShape.strokeColor;
        value.shapeId = currentShape.uniqueId;
        value.shapeType = currentShape.type;
        dataAvailable = true;
      }

      currentShape.isSelected = false;
      currentShape.isMouseDown = false;
    } else if (_it === 'delete') {
      dataAvailable = false;
      console.log('Loca', localObj.currentUniqueId, value);
      dataAvailable = true;
      removeShapesV2([localObj.currentUniqueId]);
    } else if (_it === 'select' || _it === 'move' && localObj.mouseDown.objectDown) {
      dataAvailable = false;
      selectShape(e);
    } else if (_it === 'move' || _it === 'moveGraph') {
      dataAvailable = false;
    }

    updateAllShapes(e);
    updateAllShapes(e);
    dispatchData(value, dataAvailable);
  }

  function addSegment(fp, sp, squareId) {
    var seg1 = addNewShape({
      type: 'segment',
      uniqueId: ++localObj.uniqueId,
      x: fp.x,
      y: fp.y,
      xTo: sp.x,
      yTo: sp.y,
      squareId: squareId,
      dontDrag: true,
      firstPointId: fp.uniqueId,
      secondPointId: sp.uniqueId,
      connectionId: [fp.uniqueId, sp.uniqueId]
    });
    localObj.newPlottedShapes.push(seg1.uniqueId);
    return seg1;
  } // This needed to remove the duplicate shapes and keep the latest one.
  // case: This happens when two intersection need to mark, and we mark 1st and on same place we mark another
  // by dragging the point.


  function filterDuplicateInteractionElements() {
    var uniqueElements = [];
    modelObj.interactionElements.forEach(function (element) {
      var index = uniqueElements.findIndex(function (shape) {
        return shape.uniqueId === element.uniqueId;
      });

      if (index === -1) {
        uniqueElements.push(element);
      } else {
        uniqueElements[index] = element;
      }
    });
    modelObj.interactionElements = uniqueElements;
  }

  function mirrorImage(a, b, c, x1, y1) {
    var temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b);
    var x = temp * a + x1;
    var y = temp * b + y1;
    return {
      x: x,
      y: y
    };
  }

  function dispatchData(value, dataAvailable) {
    var _it = modelObj.interactionType;

    if (value.uniqueId !== undefined) {
      var target = findShape(value.uniqueId);

      if (target.shape) {
        Object.keys(target.shape).forEach(function (i) {
          if (target.shape[i] !== undefined) {
            value[i] = target.shape[i];
          }
        });
      }
    } // saveData();


    if (_it === 'select' || _it === 'move' && localObj.mouseDown.objectDown) {
      if (localObj.selectFlag) {
        saveData();
      }

      if (typeof events[_it] !== 'undefined') {
        events[_it]({
          id: modelObj.id,
          type: 'select'
        }, true);
      }
    } else if (dataAvailable) {
      saveData();
      localObj.mouseDown.lastShapeCompleted = true;
      localObj.newShapeStarted = false;
      localObj.currentUniqueId = null;
      value.newPlottedShapes = localObj.newPlottedShapes;
      value.step = modelObj.currentStep;
      dispatchEventCustom(value);
    }

    localObj.isLableSelected = false;
    localObj.itemCount = 0;
  }

  function computePerpendicular(firstPoint, secondPoint) {
    var midPoint = {};
    midPoint.x = (firstPoint.x + secondPoint.x) / 2;
    midPoint.y = (firstPoint.y + secondPoint.y) / 2;
    var angle = modelObj.LabComClass.Maths.getAngle(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y) + Math.PI / 2;
    var point = modelObj.LabComClass.Maths.getPoint(midPoint, angle, getPointUnitByPixelUnit(10));
    return {
      type: 'line',
      x: midPoint.x,
      y: midPoint.y,
      xTo: point.x,
      yTo: point.y
    };
  }

  function computePerpBisector(perpShape, firstPoint, secondPoint, midPoint) {
    var value = {};
    var angle2Point = modelObj.LabComClass.Maths.getAngle(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y);
    perpShape.x = midPoint.x;
    perpShape.y = midPoint.y;
    perpShape.angle = angle2Point + Math.PI / 2;
    perpShape.point = modelObj.LabComClass.Maths.getPoint(midPoint, perpShape.angle, getPointUnitByPixelUnit(20)); // perpShape.two=modelObj.LabComClass.Maths.getPoint(midPoint,perpShape.angle,-10);

    value.x = midPoint.x;
    value.y = midPoint.y;
    value.xTo = perpShape.point.x;
    value.yTo = perpShape.point.y;
    value.uniqueId = perpShape.uniqueId;
    value.slope = isFinite(getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y)) ? getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y) : null;
    value.firstPoint = firstPoint;
    value.secondPoint = secondPoint;
    var perpLine = addNewShape({
      type: 'line',
      dontDrag: true,
      uniqueId: ++localObj.uniqueId,
      x: perpShape.point.x,
      y: perpShape.point.y,
      xTo: perpShape.x,
      yTo: perpShape.y,
      slope: getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y),
      connectionId: [perpShape.uniqueId]
    });
    localObj.newPlottedShapes.push(perpLine.uniqueId);
    value.perpLineId = perpLine.uniqueId;
    return value;
  }

  function findCommon(seg1, seg2) {
    var arr = [];
    var commArr = [];
    Object.keys(seg1).forEach(function (el, i) {
      if (el === 'x' || el === 'xTo' || el === 'y' || el === 'yTo') {
        arr.push(seg1[el]);
      }
    });
    Object.keys(seg2).forEach(function (el) {
      if (el === 'x' || el === 'xTo' || el === 'y' || el === 'yTo') {
        arr.push(seg2[el]);
      }
    });

    for (var i = 0; i < arr.length; i++) {
      if (i % 2 === 0) {
        commArr.push(arr[i] + '/' + arr[i + 1]);
      }
    }

    var duplicates = [];
    var tempArray = [].concat(commArr).sort();

    for (var _i5 = 0; _i5 < tempArray.length; _i5++) {
      if (tempArray[_i5 + 1] === tempArray[_i5]) {
        duplicates.push(tempArray[_i5]);
      }
    }

    if (duplicates[0] === undefined) {
      return undefined;
    }

    var cords = duplicates[0].split('/');
    return {
      x: cords[0],
      y: cords[1]
    }; // return duplicates;
  }

  function calculateBisector(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'point';
    var bisector = {};
    var firstSegment, secondSegment; // if (mode === 'point') {
    //   firstSegment = computeSegment(_obj.firstPoint, _obj.secondPoint);
    //   secondSegment = computeSegment(_obj.secondPoint, _obj.thirdPoint);
    // }

    /*else*/

    if (mode === 'segment') {
      firstSegment = _obj.firstSegment;
      secondSegment = _obj.secondSegment;
    } // bisector.eqn = computeBisectorEqn(computeEqn(firstSegment), computeEqn(secondSegment), firstSegment, secondSegment);
    // bisector.formEqn = computeSolvingEqn(bisector, secondSegment);
    // bisector.x = bisector.formEqn.computeX;
    // bisector.y = bisector.formEqn.computeY;


    if (mode === 'point') {
      var newBisector = computeNewBisector(_obj.firstPoint, _obj.secondPoint, _obj.thirdPoint);
      bisector.bisectorLine = {
        type: 'line',
        x: _obj.secondPoint.x,
        y: _obj.secondPoint.y,
        xTo: newBisector.x,
        yTo: newBisector.y // yTo:angleB.y

      };
    } else if (mode === 'segment') {
      var _newBisector = computeNewBisectorSegment(firstSegment, secondSegment);

      bisector.bisectorLine = {
        type: 'line',
        x: _obj.x,
        y: _obj.y,
        xTo: _newBisector.x,
        yTo: _newBisector.y // yTo:angleB.y

      };
    }

    return bisector;
  }

  function computeNewBisectorSegment(seg1, seg2) {
    var p1 = {},
        p2 = {},
        p3 = {},
        p4 = {};
    p1.x = seg1.x;
    p1.y = seg1.y;
    p2.x = seg1.xTo;
    p2.y = seg1.yTo;
    p3.x = seg2.x;
    p3.y = seg2.y;
    p4.x = seg2.xTo;
    p4.y = seg2.yTo;

    if (p2.x === p3.x && p2.y === p3.y) {
      return computeNewBisector(p1, p2, p4);
    } else if (p1.x === p3.x && p1.y === p3.y) {
      return computeNewBisector(p2, p1, p4);
    } else if (p2.x === p4.x && p2.y === p4.y) {
      return computeNewBisector(p1, p2, p3);
    } else if (p1.x === p4.x && p1.y === p4.y) {
      return computeNewBisector(p2, p1, p3);
    }
  }

  function computeNewBisector(fp, sp, tp) {
    var _modelObj$LabComClass5 = modelObj.LabComClass.Maths,
        getAngle = _modelObj$LabComClass5.getAngle,
        getPoint = _modelObj$LabComClass5.getPoint;

    if (fp.x === sp.x && fp.y === sp.y || sp.x === tp.x && sp.y === tp.y) {
      return {
        x: null,
        y: null
      };
    }

    var startAngle = getAngle(sp.x, sp.y, fp.x, fp.y);
    var endAngle = getAngle(sp.x, sp.y, tp.x, tp.y);
    var bisectorAngle = (startAngle + endAngle) / 2;
    var newPoint = getPoint(sp, bisectorAngle, getPointUnitByPixelUnit(20));
    return newPoint;
  }

  function computeBisectorEqn(first, second, m1, m2) {
    // const first={a:4,b:-3,c:4}
    // const second={a:6,b:8,c:-9};
    if (first.c < 0 && second.c >= 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
    }

    if (first.c >= 0 && second.c < 0) {
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    if (first.c < 0 && second.c < 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    var simpF = {},
        simpS = {};
    var step1LHS = "(".concat(first.a, "x+").concat(first.b, "y+").concat(first.c, ")/").concat(Math.sqrt(first.a * first.a + first.b * first.b));
    simpF.a = first.a / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.b = first.b / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.c = first.c / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.form = "".concat(simpF.a, "x+").concat(simpF.b, "y+").concat(simpF.c);
    var step1RHS = "(".concat(second.a, "x+").concat(second.b, "y+").concat(second.c, ")/").concat(Math.sqrt(second.a * second.a + second.b * second.b));
    simpS.a = second.a / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.b = second.b / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.c = second.c / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.form = "".concat(simpS.a, "x+").concat(simpS.b, "y+").concat(simpS.c);
    var answer = {};
    answer.firstCase = {};
    answer.secondCase = {};
    answer.firstCase.b = simpF.b - simpS.b;
    answer.firstCase.a = simpF.a - simpS.a;
    answer.firstCase.c = simpF.c - simpS.c;
    answer.secondCase.a = simpF.a + simpS.a;
    answer.secondCase.b = simpF.b + simpS.b;
    answer.secondCase.c = simpF.c + simpS.c;
    answer.required = {};
    var correctAnswer = checkAnswerCaseNew(first, second, answer.firstCase, answer.secondCase, m1, m2);
    answer.required = correctAnswer;
    return answer.required;
  }

  function checkAnswerCaseNew(segment1, segment2, firstCase, secondCase, m1, m2) {
    //a1a2+b1b2;
    var answer1 = findRatio(segment1, segment2, m1, m2);
    var product = {};
    var angle = answer1.degree;

    if (answer1.degree >= 270) {
      angle = answer1.degree - 270;
    }

    product.main = segment1.a * segment2.a + segment1.b * segment2.b;

    if (angle > 0 && angle < 90 && product.main < 0) {
      return firstCase;
    } else if (angle > 90 && product.main < 0) {
      return secondCase;
    } else if (angle > 90 && product.main > 0) {
      return firstCase;
    } else if (angle > 0 && angle < 90 && product.main > 0) {
      return secondCase;
    } else if (product.main === 0) {
      return secondCase;
    }
  }

  function findRatio(segment1, segment2, main1, main2) {
    var tangent = {};
    var angle = {};
    tangent.m1 = -(segment1.a / segment1.b);
    tangent.m2 = -(segment2.a / segment2.b);
    tangent.ratio = Math.abs((tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2));
    tangent.angle = Math.atan(tangent.ratio);
    tangent.degree = tangent.angle * (180 / Math.PI);
    tangent.obtuseAngle = Math.atan(-(tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2)) * (180 / Math.PI);
    tangent.tanTheta = (segment2.a * segment1.b - segment1.a * segment2.b) / (segment2.a * segment1.a + segment2.b * segment1.b);
    tangent.degSlope = Math.atan(tangent.tanTheta) * (180 / Math.PI);
    angle.startAngle = modelObj.LabComClass.Maths.getAngle(main1.xTo, main1.yTo, main1.x, main1.y);
    angle.endAngle = modelObj.LabComClass.Maths.getAngle(main2.x, main2.y, main2.xTo, main2.yTo);
    angle.angleRad = angle.startAngle - angle.endAngle;
    angle.angleS = angle.angleRad * 180 / Math.PI;

    if (angle.angleRad < 0) {
      angle.scene = 1;
      angle.degree = angle.angleRad * -1 * 180 / Math.PI;
    } else if (angle.angleRad > 0) {
      angle.scene = 2;
      angle.degree = 360 - angle.angleRad * 180 / Math.PI;
    }

    return angle;
  }

  function computeSolvingEqn(_obj, segment2) {
    var eqn = {};

    if (segment2.x === localObj.arbitaryX || segment2.xTo === localObj.arbitaryX) {
      localObj.arbitaryX = localObj.arbitaryX + 1;
    }

    localObj.arbitaryX = segment2.x - getPointUnitByPixelUnit(50);
    eqn.eqn = "".concat(_obj.eqn.a, "x +").concat(_obj.eqn.b, "y +").concat(_obj.eqn.c);
    eqn.calcY = "y=(".concat(-_obj.eqn.a, "x + ").concat(-_obj.eqn.c, ")/").concat(_obj.eqn.b);
    eqn.computeY = (-_obj.eqn.a * localObj.arbitaryX + -_obj.eqn.c) / _obj.eqn.b;
    eqn.computeX = localObj.arbitaryX;

    if (!isFinite(eqn.computeY)) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    if (Math.trunc(_obj.eqn.b * 100) == 0) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    return eqn;
  }

  function computeEqn(segment) {
    var eqn = {};
    eqn.segment = segment.label;
    eqn.slope = isFinite(getSlope(segment.x, segment.y, segment.xTo, segment.yTo)) ? getSlope(segment.x, segment.y, segment.xTo, segment.yTo) : undefined;

    if (eqn.slope !== undefined) {
      eqn.eqn = "y-".concat(segment.y, "=").concat(eqn.slope, "*(x-").concat(segment.x, ")");
      eqn.b = 1;
      eqn.a = -eqn.slope;
      eqn.c = eqn.slope * segment.x - segment.y;
      eqn.cMod = Math.abs(eqn.slope * segment.x - segment.y);
      eqn.form = "y+".concat(eqn.a, "x+").concat(eqn.c);
    } else {
      eqn.eqn = "x=".concat(segment.x);
      eqn.form = "x-".concat(segment.x);
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -segment.x;
      eqn.cMod = Math.abs(-segment.x);
    }

    return eqn;
  }

  function computeSegment(firstPoint, secondPoint) {
    var segment = {};
    segment.x = firstPoint.x;
    segment.y = firstPoint.y;
    segment.xTo = secondPoint.x;
    segment.yTo = secondPoint.y;

    if (firstPoint.label && secondPoint.label) {
      segment.label = firstPoint.label + secondPoint.label;
    }

    return segment;
  }

  function computeCircle(_obj) {
    // Calculate Center and Raduis
    // Logic Here
    // Mid Point
    var fp = _obj.firstPoint;
    var sp = _obj.secondPoint;
    var tp = _obj.thirdPoint;
    var cData = circle3Handler(fp, sp, tp);
    return {
      r: cData.r,
      x: cData.x,
      y: cData.y
    };
  }

  function calculateAngle(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "angle";
    var firstPoint = _obj.firstPoint,
        secondPoint = _obj.secondPoint,
        thirdPoint = _obj.thirdPoint;
    var startAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, firstPoint.x, firstPoint.y);
    var endAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, thirdPoint.x, thirdPoint.y);
    var angle = startAngle - endAngle;

    if (angle < 0) {
      angle = angle * -1 * 180 / Math.PI;
    } else if (angle > 0) {
      angle = 360 - angle * 180 / Math.PI;
    }

    var angleText;

    if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === 'angle') {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label, "=").concat(Math.round(angle), "\xB0");
    } else if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === 'angleRay') {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label);
    } else if (mode === 'angle') {
      angleText = "".concat(Math.round(angle), "\xB0");
    } else if (mode === 'angleRay') {
      angleText = "";
    }

    return {
      angleText: angleText,
      angle: angle,
      angleValue: Math.round(angle),
      startAngle: startAngle,
      endAngle: endAngle
    };
  }

  function checkDataAvailable(target, keys) {
    // eslint-disable-next-line consistent-return
    for (var i = 0; i < keys.length; i++) {
      if (target[keys[i]] === null || isNaN(target[keys[i]])) {
        return false;
      }
    }

    return true;
  }

  function checkPoint(_obj) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d = modelObj.interactionElements[i]; // if (_d.type === 'point' && _d.uniqueId !== localObj.uniqueId) 

      if (_d.type === 'point') {
        newDist = modelObj.LabComClass.Maths.getDistance(_obj, _d);
      }

      if (dist === null && newDist !== null || dist !== null && newDist < dist) {
        dist = newDist;
        index = i;
      }
    }

    if (index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      localObj.mouseDown.objectDown = true;
      return index;
    }

    return null;
  }

  function checkPointv2(_obj) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d = modelObj.interactionElements[i]; // if (_d.type === 'point' && _d.uniqueId !== localObj.uniqueId) 

      if (_d.type === 'point' && _d.uniqueId !== localObj.currentUniqueId) {
        newDist = modelObj.LabComClass.Maths.getDistance(_obj, _d);
      }

      if (dist === null && newDist !== null || dist !== null && newDist < dist) {
        dist = newDist;
        index = i;
      }
    }

    if (index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      localObj.mouseDown.objectDown = true;
      return index;
    }

    return null;
  }

  function isItCloseToPlotedPoint(point, avoidCurrentPoint) {
    var dist = null,
        newDist = null,
        index = null;

    for (var i = modelObj.interactionElements.length - 1; i >= 0; i--) {
      var _d = modelObj.interactionElements[i];

      if (!avoidCurrentPoint || _d.uniqueId !== localObj.currentUniqueId || modelObj.interactionType === 'move' && _d.uniqueId !== localObj.currentUniqueId) {
        if (_d.type === 'point') {
          newDist = modelObj.LabComClass.Maths.getDistance(point, _d);
        } else {
          newDist = null;
        }

        if (newDist !== null && (dist === null || newDist < dist)) {
          dist = newDist;
          index = i;
        }
      }
    }

    if (newDist !== null && index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      if (modelObj.interactionType === 'labelTool') {
        if (modelObj.interactionElements[index].isSelectedForLabel) {
          modelObj.interactionElements[index].isSelectedForLabel = true;
        } else {
          modelObj.interactionElements[index].isSelectedForLabel = false;
        }
      }

      return {
        dist: dist,
        index: index,
        plotedPoint: modelObj.interactionElements[index]
      };
    }

    return null;
  }

  function isItCloseToParameterPoint(point, mouseEvent) {
    var dist = null,
        newDist = null;
    var _modelObj$LabComClass6 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass6.getDistance,
        getPoint = _modelObj$LabComClass6.getPoint,
        getAngle = _modelObj$LabComClass6.getAngle,
        pointInSegment = _modelObj$LabComClass6.pointInSegment,
        getLineintersect = _modelObj$LabComClass6.getLineintersect,
        getPointLineDistance = _modelObj$LabComClass6.getPointLineDistance;
    var intersectionP = null;
    var cond = mouseEvent !== 'mousedown' ? modelObj.interactionElements.length - 1 : modelObj.interactionElements.length;

    for (var i = 0; i < cond; i++) {
      var shape = modelObj.interactionElements[i];

      if (shape.type !== 'point') {
        if (checkType(shape, localObj.lineTypes)) {
          var distFromLine = getPointLineDistance(point, shape, {
            x: shape.xTo,
            y: shape.yTo
          });
          newDist = Math.abs(distFromLine);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            var lineAngle = getAngle(shape.x, shape.y, shape.xTo, shape.yTo);
            var point2 = getPoint(point, lineAngle + Math.PI / 2, 2);
            var intersection = getLineintersect(shape.x, shape.y, shape.xTo, shape.yTo, point.x, point.y, point2.x, point2.y);
            var shapeLength = getDistance(shape, {
              x: shape.xTo,
              y: shape.yTo
            });
            var intersectionDist = getDistance(shape, intersection);
            var percentage = intersectionDist / shapeLength;
            var pointAngle = getAngle(shape.x, shape.y, intersection.x, intersection.y);
            var pointAccepted = true;

            if (shape.type.includes('segment')) {
              var isInSegment = pointInSegment(intersection, shape, {
                x: shape.xTo,
                y: shape.yTo
              });

              if (!isInSegment) {
                pointAccepted = false;
              }
            }

            if (shape.type === 'ray') {
              var _isInSegment = pointInSegment(intersection, shape, {
                x: shape.xOr,
                y: shape.yOr
              });

              if (!_isInSegment) {
                pointAccepted = false;
              }
            }

            if (pointAccepted) {
              dist = newDist;

              if (checkDataAvailable(intersection, ['x', 'y'])) {
                intersectionP = intersection;
                intersectionP.dist = dist;
                intersectionP.updateKeys = {
                  x: intersectionP.x,
                  y: intersectionP.y,
                  line: shape.uniqueId,
                  pointAngle: Math.round(pointAngle) === Math.round(lineAngle),
                  percentage: percentage,
                  isParameter: true
                };
              }
            }
          }
        }

        if (shape.type === 'circle' || shape.type === 'compass' || shape.type === 'circle_3' && !(shape.ploted === undefined)) {
          var distFromCenter = getDistance(shape, point);
          newDist = Math.abs(distFromCenter - shape.r);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            dist = newDist;
            var angle = getAngle(shape.x, shape.y, point.x, point.y);
            intersectionP = getPoint(shape, angle, shape.r);

            if (checkDataAvailable(intersectionP, ['x', 'y'])) {
              intersectionP.dist = dist;
              intersectionP.updateKeys = {
                x: intersectionP.x,
                y: intersectionP.y,
                circle: shape.uniqueId,
                angle: angle,
                degree: angle * 180 / Math.PI,
                isParameter: true
              };
            } else {
              intersectionP = null;
            }
          }
        }
      }
    }

    return intersectionP;
  }

  function isItCloseToIntersectionPoint(point) {
    var dist = null,
        newDist = null;
    var shapesData = modelObj.interactionElements;
    var intersectionP = null;

    for (var i = 0; i < shapesData.length - 1; i++) {
      var firstShape = shapesData[i];

      if (firstShape.type !== 'point') {
        for (var j = i + 1; j < shapesData.length; j++) {
          var secondShape = shapesData[j];

          if (secondShape.type !== 'point') {
            if (checkType(firstShape, localObj.lineTypes) && checkType(secondShape, localObj.lineTypes) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId && secondShape.firstPointId !== undefined && firstShape.firstPointId !== undefined) {
              // last condition added if one of the line which needs to be intersected has not been drawn completely.
              var data = getInteractionOfTwoLines(firstShape, secondShape, point); // returns dist of current point and the intersection points(older) 

              if (data !== null) {
                if (data.dist < dist || dist === null) {
                  newDist = data.dist;
                  dist = data.dist;
                  intersectionP = data;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    l1: firstShape.uniqueId,
                    l2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if ((checkType(firstShape, localObj.lineTypes) && checkType(secondShape, ['circle', 'compass', 'circle_3']) || checkType(secondShape, localObj.lineTypes) && checkType(firstShape, ['circle', 'compass', 'circle_3'])) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var circleShape = void 0,
                  lineShape = void 0;

              if (firstShape.type === 'circle' || firstShape.type === 'compass' || firstShape.type === 'circle_3') {
                circleShape = firstShape;
                lineShape = secondShape;
              } else {
                circleShape = secondShape;
                lineShape = firstShape;
              }

              var _data5 = getInteractionOfCircleLine(circleShape, lineShape, point, modelObj.snappingDiff);

              if (_data5 !== null && !(circleShape.type === 'circle_3' && circleShape.ploted === undefined)) {
                if (_data5.dist < dist || dist === null) {
                  newDist = _data5.dist;
                  dist = _data5.dist;
                  intersectionP = _data5;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    angle: modelObj.LabComClass.Maths.getAngle(circleShape.x, circleShape.y, intersectionP.x, intersectionP.y),
                    circle: circleShape.uniqueId,
                    line: lineShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if (checkType(firstShape, ['circle', 'compass', 'circle_3']) && checkType(secondShape, ['circle', 'compass', 'circle_3']) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var _data6 = getInteractionOfTwoCircles(firstShape, secondShape, point, modelObj.snappingDiff, false);

              if (_data6 && !(firstShape.type === 'circle_3' && firstShape.ploted === undefined || secondShape.type === 'circle_3' && secondShape.ploted === undefined)) {
                if (_data6.dist < dist || dist === null) {
                  newDist = _data6.dist;
                  dist = _data6.dist;
                  intersectionP = _data6;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    intersectAngle: intersectionP.angle1,
                    circle1: firstShape.uniqueId,
                    circle2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } // if (intersectionP) {
            //   break;
            // }

          }
        } // if (intersectionP) {
        //   break;
        // }

      }
    }

    return intersectionP;
  }

  function checkType(shape, types) {
    return types.includes(shape.type);
  }

  function getInteractionOfTwoCircles(circle1, circle2, point, snapDiff) {
    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length > 1) {
      var getDist = function getDist(p1, p2) {
        var dist = modelObj.LabComClass.Maths.getDistance(p1, point);

        if (snapDiff !== false) {
          if (dist <= getPointUnitByPixelUnit(snapDiff)) {
            p1.dist = dist;
            var centerPointsLine = new modelObj.LabComClass.Vector(circle2.x - circle1.x, circle2.y - circle1.y);
            var firstIntersectLine = new modelObj.LabComClass.Vector(p1.x - circle1.x, p1.y - circle1.y);
            p1.angle = centerPointsLine.crossProduct(firstIntersectLine).z;
            return dist;
          }

          return null;
        }

        p1.angle1 = modelObj.LabComClass.Maths.getAngle(circle1.x, circle1.y, p1.x, p1.y);
        p1.dist = dist;
        return dist;
      };

      var acceptedIntersections = [];
      var p = getDist(intersection[0], intersection[1]);

      if (p !== null) {
        acceptedIntersections.push(intersection[0]);
      }

      p = getDist(intersection[1], intersection[0]);

      if (p !== null) {
        acceptedIntersections.push(intersection[1]);
      }

      if (acceptedIntersections.length) {
        var lowestIndex = 0;
        var closeDist = acceptedIntersections[0].dist;

        for (var i = 0; i < acceptedIntersections.length; i++) {
          if (acceptedIntersections[i].dist < closeDist) {
            closeDist = acceptedIntersections[i].dist;
            lowestIndex = i;
          }
        }

        return acceptedIntersections[lowestIndex];
      }

      return null;
    }

    return null;
  }

  function getInteractionOfCircleLineV2(circle, line, point, snapDiff) {
    var lineData = {
      x: line.x,
      y: line.y,
      xTo: line.xTo,
      yTo: line.yTo
    };

    if (line.type === 'ray') {
      lineData.xTo = line.xOr;
      lineData.yTo = line.yOr;
    }

    var intersection = findCircleLineIntersect(circle, lineData);
    var distP1 = null,
        distP2 = null;

    function getDist(p) {
      if ((line.type.includes('segment') || line.type === 'ray') && !(p === null || p === void 0 ? void 0 : p.isInSegment)) {
        return null;
      }

      if (p === null || p === undefined) {
        return null;
      }

      var dist = modelObj.LabComClass.Maths.getDistance(p, point);

      if (snapDiff !== undefined) {
        if (dist < getPointUnitByPixelUnit(snapDiff)) {
          p.dist = dist;
          return dist;
        }

        return null;
      }

      p.dist = dist;
      return dist;
    }

    distP1 = getDist(intersection.p1);
    distP2 = getDist(intersection.p2); // console.log('Intersec',intersection.p1,intersection.p2,distP1,distP2,point.uniqueId);

    if (distP1 !== null && distP2 !== null) {
      if (distP1 < distP2) {
        return {
          point: intersection.p1,
          distP1: distP1,
          distP2: distP2,
          otherPoint: intersection.p2
        };
      }

      return {
        point: intersection.p2,
        distP1: distP1,
        distP2: distP2,
        otherPoint: intersection.p1
      };
    } else if (distP2 !== null && Math.round(distP2) === 0 && distP1 === null) {
      return {
        point: intersection.p2
      };
    } else if (distP1 !== null && Math.round(distP1) === 0 && distP2 === null) {
      return {
        point: intersection.p1
      };
    } else {
      return {
        point: point,
        hide: true
      };
    } // return null;

  }

  function getInteractionOfCircleLine(circle, line, point, snapDiff) {
    var lineData = {
      x: line.x,
      y: line.y,
      xTo: line.xTo,
      yTo: line.yTo
    };

    if (line.type === 'ray') {
      lineData.xTo = line.xOr;
      lineData.yTo = line.yOr;
    }

    var intersection = findCircleLineIntersect(circle, lineData);

    if (intersection.p1 || intersection.p2) {
      var getDist = function getDist(p) {
        if ((line.type.includes('segment') || line.type === 'ray') && !(p === null || p === void 0 ? void 0 : p.isInSegment)) {
          return null;
        }

        var dist = modelObj.LabComClass.Maths.getDistance(p, point);

        if (snapDiff !== undefined) {
          if (dist < getPointUnitByPixelUnit(snapDiff)) {
            p.dist = dist;
            return dist;
          }

          return null;
        }

        p.dist = dist;
        return dist;
      };

      var distP1 = null,
          distP2 = null;
      distP1 = getDist(intersection.p1);
      distP2 = getDist(intersection.p2);

      if (distP1 !== null && distP2 !== null) {
        if (distP1 < distP2) {
          return intersection.p1;
        }

        return intersection.p2;
      }

      if (distP1 !== null) {
        return intersection.p1;
      }

      if (distP2 !== null) {
        return intersection.p2;
      }

      return null;
    }

    return null;
  }

  function getInteractionOfTwoLines(l1, l2, point) {
    var intersection = modelObj.LabComClass.Maths.getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);

    if (intersection) {
      if (l1.type.includes('segment') && !intersection.onLine1 || l2.type.includes('segment') && !intersection.onLine2) {
        return null;
      } // If angle Ray or trinagle tools used and plotting on parameter of segment, then it creates intersection.


      var distance = modelObj.LabComClass.Maths.getDistance(intersection, point);

      if (distance < getPointUnitByPixelUnit(10)) {
        intersection.dist = distance;
        return intersection;
      }

      return null;
    }

    return null;
  }

  function findShapeById(_id) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var visible = modelObj.interactionElements; // const visible=modelObj.mathData;

    var index;
    var shape;
    visible.forEach(function (el, i) {
      if (el.uniqueId === _id) {
        index = i;
        modelObj.interactionElements[i].x = x !== null ? x : modelObj.interactionElements[i].x;
        modelObj.interactionElements[i].y = y !== null ? y : modelObj.interactionElements[i].y;
        el.x = modelObj.interactionElements[i].x;
        el.y = modelObj.interactionElements[i].y;
        shape = el;
      }
    });
    return {
      shape: shape,
      index: index
    };
  }

  function sign(p1, p2, p3) {
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
  }

  function PointInTriangle(pt, v1, v2, v3) {
    var d1, d2, d3;
    var has_neg, has_pos;
    d1 = sign(pt, v1, v2);
    d2 = sign(pt, v2, v3);
    d3 = sign(pt, v3, v1);
    has_neg = d1 < 0 || d2 < 0 || d3 < 0;
    has_pos = d1 > 0 || d2 > 0 || d3 > 0;
    return !(has_neg && has_pos);
  }

  function PointInSquare(pt, v1, v2, v3, v4) {
    var d1, d2, d3, d4;
    var has_neg, has_pos;
    d1 = sign(pt, v1, v2);
    d2 = sign(pt, v2, v3);
    d3 = sign(pt, v3, v4);
    d4 = sign(pt, v4, v1);
    has_neg = d1 < 0 || d2 < 0 || d3 < 0 || d4 < 0;
    has_pos = d1 > 0 || d2 > 0 || d3 > 0 || d4 > 0;
    return !(has_neg && has_pos);
  }

  function moveShape(e) {
    //Same as select Shape but doesnt have dont Select as it's required to move label even if it is not selectable.
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;

      for (var i = 0; i < shapesData.length; i++) {
        var _d = shapesData[i];

        if (_d.type === 'circle' || _d.type === 'compass' || _d.type === 'circle_3') {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === 'line'
        /*&& !_d.dontSelect*/
        || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        } else if (_d.type.includes('segment')
        /*&& !_d.dontSelect*/
        || _d.type === 'ray') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        } else if ((_d.type === 'angle' || _d.type === 'angleRay' || _d.type === 'angleSize') && _d.visible) {
          var angleWithPoint = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

          if (_d.angleStart < _d.angleEnd && angleWithPoint >= _d.angleStart && angleWithPoint <= _d.angleEnd && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          } else if (_d.angleStart > _d.angleEnd && (angleWithPoint >= _d.angleStart && angleWithPoint <= 360 || angleWithPoint >= 0 && angleWithPoint <= _d.angleEnd) && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          }
        } else if (_d.type == 'triangle') {
          if (PointInTriangle(p, _d.firstPoint, _d.secondPoint, _d.thirdPoint)) {
            newDist = 0;
          }
        } else if (_d.type == 'square') {
          if (PointInSquare(p, _d.firstPoint, _d.secondPoint, _d.thirdPoint, _d.fourthPoint)) {
            newDist = 0;
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i6 = 0; _i6 < shapesData.length; _i6++) {
      var _d5 = shapesData[_i6];
      var calculated = false;

      if (_d5.label !== undefined) {
        var label = getPixelByPoint(_d5.labelX, _d5.labelY);
        label.x += Number(_d5.labelDiffX);
        label.y += Number(_d5.labelDiffY);
        var w = ctx.measureText(_d5.label).width;

        if (_d5.labelAlign && _d5.labelAlign === 'center') {
          if (pxl.x > label.x - w / 2 - 20 && pxl.x < label.x + w / 2 + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 20 && pxl.x < label.x + w + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated && _d5.label !== undefined && _d5.label !== ''
      /*&& !_d.dontSelect*/
      ) {
        dist = Math.abs(newDist);
        index = _i6;
        labelId = _i6;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === 'move') {
            for (var _i7 = 0; _i7 < shapesData.length; _i7++) {
              shapesData[_i7].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;

          if (modelObj.interactionType === 'select') {
            localObj.selectedItemsCount++;
          } else {
            localObj.selectedItemsCount = 1;
          }
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
        }
      }
    }

    return null;
  }

  function selectShapeSpecial(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false); // console.log('Point',data); 

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null; // for (let i = 0; i < shapesData.length; i++) {

      for (var i = shapesData.length - 1; i >= 0; i--) {
        var _d = shapesData[i];

        if (_d.type === 'circle' || _d.type === 'compass' || _d.type === 'circle_3') {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === 'line' && !_d.dontSelect || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          // If perpendicular or parallel is partially plotted then xTo and yTo are NaN, so if evaluated directly then the result turns to 0 which is wrong, so a guard condition is added. 
          if (!isNaN(_d.xTo) || !isNaN(_d.yTo)) {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });
          }
        } else if (_d.type.includes('segment') && !_d.dontSelect || _d.type === 'ray') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        } else if ((_d.type === 'angle' || _d.type === 'angleRay' || _d.type === 'angleSize') && _d.visible) {
          var angleWithPoint = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

          if (_d.angleStart < _d.angleEnd && angleWithPoint >= _d.angleStart && angleWithPoint <= _d.angleEnd && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          } else if (_d.angleStart > _d.angleEnd && (angleWithPoint >= _d.angleStart && angleWithPoint <= 360 || angleWithPoint >= 0 && angleWithPoint <= _d.angleEnd) && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          }
        } //  else if ( _d.type == 'triangle'){
        //   if(PointInTriangle (p, _d.firstPoint, _d.secondPoint, _d.thirdPoint) ){
        //     newDist = 0;
        //   }
        // } else if ( _d.type == 'square'){
        //   if(PointInSquare (p, _d.firstPoint, _d.secondPoint, _d.thirdPoint, _d.fourthPoint) ){
        //     newDist = 0;
        //   }
        // }


        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i8 = 0; _i8 < shapesData.length; _i8++) {
      var _d6 = shapesData[_i8];
      var calculated = false;

      if (_d6.label !== undefined) {
        var label = getPixelByPoint(_d6.labelX, _d6.labelY);
        label.x += Number(_d6.labelDiffX);
        label.y += Number(_d6.labelDiffY);
        var w = ctx.measureText(_d6.label).width;

        if (_d6.labelAlign && _d6.labelAlign === 'center') {
          if (pxl.x > label.x - w / 2 - 20 && pxl.x < label.x + w / 2 + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 20 && pxl.x < label.x + w + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated && !_d6.dontSelect) {
        dist = Math.abs(newDist);
        index = _i8;
        labelId = _i8;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        // localObj.mouseDown.objectDown = true;
        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === 'move') {
            for (var _i9 = 0; _i9 < shapesData.length; _i9++) {// shapesData[i].isSelected = false;
            }
          } // shapesData[index].isSelected = true;
          // shapesData[index].isMouseDown = true;

        } else {// shapesData[index].isMouseDown = false;
          } // if (labelId === index) {
        //   localObj.isLableSelected = true;
        // }
        // console.log('Returning/...',shapesData[index].uniqueId);


        return shapesData[index].uniqueId;
      } // mouse up
      // if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
      //   if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
      //     shapesData[index].isSelected = false;
      //   }
      // }

    }

    return null;
  }

  function selectShape(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null; // for (let i = 0; i < shapesData.length; i++) {

      for (var i = shapesData.length - 1; i >= 0; i--) {
        var _d = shapesData[i];

        if (_d.type === 'circle' || _d.type === 'compass' || _d.type === 'circle_3') {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === 'line' && !_d.dontSelect || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          // If perpendicular or parallel is partially plotted then xTo and yTo are NaN, so if evaluated directly then the result turns to 0 which is wrong, so a guard condition is added. 
          if (!isNaN(_d.xTo) || !isNaN(_d.yTo)) {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });
          }
        } else if (_d.type.includes('segment') && !_d.dontSelect || _d.type === 'ray') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        } else if ((_d.type === 'angle' || _d.type === 'angleRay' || _d.type === 'angleSize') && _d.visible) {
          var angleWithPoint = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

          if (_d.angleStart < _d.angleEnd && angleWithPoint >= _d.angleStart && angleWithPoint <= _d.angleEnd && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          } else if (_d.angleStart > _d.angleEnd && (angleWithPoint >= _d.angleStart && angleWithPoint <= 360 || angleWithPoint >= 0 && angleWithPoint <= _d.angleEnd) && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          }
        } else if (_d.type == 'triangle') {
          if (PointInTriangle(p, _d.firstPoint, _d.secondPoint, _d.thirdPoint)) {
            newDist = 0;
          }
        } else if (_d.type == 'square') {
          if (PointInSquare(p, _d.firstPoint, _d.secondPoint, _d.thirdPoint, _d.fourthPoint)) {
            newDist = 0;
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i10 = 0; _i10 < shapesData.length; _i10++) {
      var _d7 = shapesData[_i10];
      var calculated = false;

      if (_d7.label !== undefined) {
        var label = getPixelByPoint(_d7.labelX, _d7.labelY);
        label.x += Number(_d7.labelDiffX);
        label.y += Number(_d7.labelDiffY);
        var w = ctx.measureText(_d7.label).width;

        if (_d7.labelAlign && _d7.labelAlign === 'center') {
          if (pxl.x > label.x - w / 2 - 20 && pxl.x < label.x + w / 2 + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 20 && pxl.x < label.x + w + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated && !_d7.dontSelect) {
        dist = Math.abs(newDist);
        index = _i10;
        labelId = _i10;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === 'move') {
            for (var _i11 = 0; _i11 < shapesData.length; _i11++) {
              shapesData[_i11].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
          localObj.selectedItemsCount--;
        }
      }
    }

    return null;
  }

  function selectShapeBrush(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    } // if (index === null || modelObj.ignorePointToColor) {


    if (index === null) {
      dist = null;
      newDist = null;
      index = null; // for (let i = 0; i < shapesData.length; i++) {

      for (var i = shapesData.length - 1; i >= 0; i--) {
        var _d = shapesData[i];

        if (_d.type !== 'point' && _d.type !== 'length') {
          if (_d.type === 'circle' || _d.type === 'compass' || _d.type === 'circle_3') {
            newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
          } else if (_d.type === 'line' || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
            // newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, { x: _d.xTo, y: _d.yTo });
            if (!isNaN(_d.xTo) || !isNaN(_d.yTo)) {
              newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
                x: _d.xTo,
                y: _d.yTo
              });
            }
          } else if (_d.type.includes('segment') || _d.type === 'ray') {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });

            if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
              var endPoint = {
                x: _d.xTo,
                y: _d.yTo
              };

              if (_d.type === 'ray') {
                endPoint = {
                  x: _d.xOr,
                  y: _d.yOr
                };
              }

              var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
              var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
              var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

              if (!(startPointDist <= length && endPointDist <= length)) {
                newDist = null;
              }
            }
          } else if ((_d.type === 'angle' || _d.type === 'angleRay') && _d.visible) {
            var angleWithPoint = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

            if (_d.angleStart < _d.angleEnd && angleWithPoint >= _d.angleStart && angleWithPoint <= _d.angleEnd && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              newDist = 0;
            } else if (_d.angleStart > _d.angleEnd && (angleWithPoint >= _d.angleStart && angleWithPoint <= 360 || angleWithPoint >= 0 && angleWithPoint <= _d.angleEnd) && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              newDist = 0;
            }
          } else if (_d.type === 'angleSize' && _d.visible) {
            var _angleWithPoint = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

            if (!_d.clockwise && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              if (_d.angleStart < _d.angleEnd && _angleWithPoint > _d.angleStart && _angleWithPoint < _d.angleEnd) {
                newDist = 0;
              } else if (_d.angleStart > _d.angleEnd && (_angleWithPoint >= _d.angleStart && _angleWithPoint <= 360 || _angleWithPoint >= 0 && _angleWithPoint <= _d.angleEnd)) {
                newDist = 0;
              }
            } else if (_d.clockwise && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              if (_d.angleStart > _d.angleEnd && _angleWithPoint < _d.angleStart && _angleWithPoint > _d.angleEnd) {
                newDist = 0;
              } else if (_d.angleStart < _d.angleEnd && (_angleWithPoint <= _d.angleStart && _angleWithPoint >= 0 || _angleWithPoint <= 360 && _angleWithPoint >= _d.angleEnd)) {
                newDist = 0;
              }
            }
          } else if (_d.type == 'triangle') {
            if (PointInTriangle(p, _d.firstPoint, _d.secondPoint, _d.thirdPoint)) {
              newDist = 0;
            }
          } else if (_d.type == 'square') {
            if (PointInSquare(p, _d.firstPoint, _d.secondPoint, _d.thirdPoint, _d.fourthPoint)) {
              newDist = 0;
            }
          } // console.log('Dist',dist,'newDist',newDist,'index',i);


          if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
            // if ((dist === null && newDist !== null) || (dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist))) {
            dist = Math.abs(newDist);
            index = i;
          }
        }
      }
    } // console.log('I/B',index);


    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i12 = 0; _i12 < shapesData.length; _i12++) {
      var _d8 = shapesData[_i12];
      var calculated = false;

      if (_d8.label !== undefined) {
        var label = getPixelByPoint(_d8.labelX, _d8.labelY);
        label.x += Number(_d8.labelDiffX);
        label.y += Number(_d8.labelDiffY);
        var w = ctx.measureText(_d8.label).width;

        if (_d8.type !== 'length') {
          if (_d8.labelAlign && _d8.labelAlign === 'center') {
            if (pxl.x > label.x - w / 2 - 5 && pxl.x < label.x + w / 2 + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5 && _d8.type !== 'segment') {
              newDist = 0;
              calculated = true;
            }
          } else if (pxl.x > label.x - 5 && pxl.x < label.x + w + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5 && _d8.type !== 'angle' && _d8.type !== 'angleSize' && _d8.type !== 'segment' && _d8.type !== 'point') {
            newDist = 0;
            calculated = true;
          }
        } else {
          var textSize = w + modelObj.fontSize / 2;

          if (pxl.x > label.x - w / 2 && pxl.x < label.x - w / 2 + w + modelObj.fontSize / 2 && pxl.y > label.y - modelObj.fontSize * 1.2 && pxl.y < label.y - (modelObj.fontSize * 1.2 + modelObj.fontSize * (modelObj.labelBGRatio + 0.1))) {
            newDist = 0;
            calculated = true;
          }
        } // else if (pxl.x > (label.x - 10) && pxl.x < (label.x + w + 10) && pxl.y > (label.y - modelObj.fontSize * 1) && pxl.y < (label.y + 10) && _d.type === 'angle' && _d.toColor) {
        //   newDist = 0;
        //   calculated = true;
        // }

      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated) {
        dist = Math.abs(newDist);
        index = _i12;
        labelId = _i12;
      }
    }

    ctx.closePath();
    ctx.restore(); // console.log('Touched',labelId,index,shapesData[index].label);

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          shapesData[index].isSelected = true; // shapesData[index].isMouseDown = true;
          // if (labelId === index) {
          //   localObj.isLableSelected = true;
          // }

          return shapesData[index].uniqueId;
        } else {
          // shapesData[index].isMouseDown = false;
          shapesData[index].isSelected = false; // return null;
        }
      } // mouse up


      if (shapesData[index].isSelected
      /*&& !shapesData[index].isMouseDown*/
      ) {
          if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
            shapesData[index].isSelected = false;
          }
        }
    }

    return null;
  }

  function selectShapeLabel(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    } // if (index === null || modelObj.ignorePointToColor) {


    if (index === null) {
      dist = null;
      newDist = null;
      index = null; // for (let i = 0; i < shapesData.length; i++) {

      for (var i = shapesData.length - 1; i >= 0; i--) {
        var _d = shapesData[i];

        if (_d.type !== 'point' && _d.type !== 'length') {
          if (_d.type === 'circle' || _d.type === 'compass' || _d.type === 'circle_3') {
            newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
          } else if (_d.type === 'line' || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });
          } else if (_d.type.includes('segment') || _d.type === 'ray') {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });

            if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
              var endPoint = {
                x: _d.xTo,
                y: _d.yTo
              };

              if (_d.type === 'ray') {
                endPoint = {
                  x: _d.xOr,
                  y: _d.yOr
                };
              }

              var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
              var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
              var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

              if (!(startPointDist <= length && endPointDist <= length)) {
                newDist = null;
              }
            }
          } else if ((_d.type === 'angle' || _d.type === 'angleRay') && _d.visible) {
            var angleWithPoint = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

            if (_d.angleStart < _d.angleEnd && angleWithPoint >= _d.angleStart && angleWithPoint <= _d.angleEnd && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              newDist = 0;
            } else if (_d.angleStart > _d.angleEnd && (angleWithPoint >= _d.angleStart && angleWithPoint <= 360 || angleWithPoint >= 0 && angleWithPoint <= _d.angleEnd) && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              newDist = 0;
            }
          } else if (_d.type === 'angleSize' && _d.visible) {
            var _angleWithPoint2 = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

            if (!_d.clockwise && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              if (_d.angleStart < _d.angleEnd && _angleWithPoint2 > _d.angleStart && _angleWithPoint2 < _d.angleEnd) {
                newDist = 0;
              } else if (_d.angleStart > _d.angleEnd && (_angleWithPoint2 >= _d.angleStart && _angleWithPoint2 <= 360 || _angleWithPoint2 >= 0 && _angleWithPoint2 <= _d.angleEnd)) {
                newDist = 0;
              }
            } else if (_d.clockwise && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
              if (_d.angleStart > _d.angleEnd && _angleWithPoint2 < _d.angleStart && _angleWithPoint2 > _d.angleEnd) {
                newDist = 0;
              } else if (_d.angleStart < _d.angleEnd && (_angleWithPoint2 <= _d.angleStart && _angleWithPoint2 >= 0 || _angleWithPoint2 <= 360 && _angleWithPoint2 >= _d.angleEnd)) {
                newDist = 0;
              }
            }
          } // console.log('Dist',dist,'newDist',newDist,'index',i);


          if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
            // if ((dist === null && newDist !== null) || (dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist))) {
            dist = Math.abs(newDist);
            index = i;
          }
        }
      }
    } // console.log('I/B',index);


    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i13 = 0; _i13 < shapesData.length; _i13++) {
      var _d9 = shapesData[_i13];
      var calculated = false;

      if (_d9.label !== undefined) {
        var label = getPixelByPoint(_d9.labelX, _d9.labelY);
        label.x += Number(_d9.labelDiffX);
        label.y += Number(_d9.labelDiffY);
        var w = ctx.measureText(_d9.label).width;

        if (_d9.type !== 'length') {
          if (_d9.labelAlign && _d9.labelAlign === 'center') {
            if (pxl.x > label.x - w / 2 - 5 && pxl.x < label.x + w / 2 + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5 && _d9.type !== 'segment') {
              newDist = 0;
              calculated = true;
            }
          } else if (pxl.x > label.x - 5 && pxl.x < label.x + w + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5 && _d9.type !== 'angle' && _d9.type !== 'angleSize' && _d9.type !== 'segment' && _d9.type !== 'point') {
            newDist = 0;
            calculated = true;
          }
        } else {
          var textSize = w + modelObj.fontSize / 2;

          if (pxl.x > label.x - w / 2 && pxl.x < label.x - w / 2 + w + modelObj.fontSize / 2 && pxl.y > label.y - modelObj.fontSize * 1.2 && pxl.y < label.y - (modelObj.fontSize * 1.2 + modelObj.fontSize * (modelObj.labelBGRatio + 0.1))) {
            newDist = 0;
            calculated = true;
          }
        } // else if (pxl.x > (label.x - 10) && pxl.x < (label.x + w + 10) && pxl.y > (label.y - modelObj.fontSize * 1) && pxl.y < (label.y + 10) && _d.type === 'angle' && _d.toColor) {
        //   newDist = 0;
        //   calculated = true;
        // }

      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated) {
        dist = Math.abs(newDist);
        index = _i13;
        labelId = _i13;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelectedForLabel) {
          shapesData[index].isSelectedForLabel = true; // shapesData[index].isMouseDown = true;

          if (labelId === index) {
            localObj.isLableSelected = true;
          }

          return shapesData[index].uniqueId;
        } else {
          // shapesData[index].isMouseDown = false;
          shapesData[index].isSelectedForLabel = false; // return null;
        }
      } // mouse up


      if (shapesData[index].isSelectedForLabel
      /*&& !shapesData[index].isMouseDown*/
      ) {
          if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
            shapesData[index].isSelectedForLabel = false;
          }
        }
    }

    return null;
  }

  function isOnShape(e) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;
    var _modelObj$LabComClass7 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass7.getDistance,
        getPointLineDistance = _modelObj$LabComClass7.getPointLineDistance;
    var data = isItCloseToPlotedPoint(getPointByPixel(e.pageX, e.pageY), false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;
      var p = getPointByPixel(e.pageX, e.pageY); // modelObj.interactionElements.forEach((_d, i) => {

      for (var i = modelObj.interactionElements.length - 1; i >= 0; i--) {
        var _d = modelObj.interactionElements[i];

        if (_d.type === 'circle' || _d.type === 'compass') {
          newDist = getDistance(p, _d) - _d.r;
        }

        if (_d.type === 'line' || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          // newDist = getPointLineDistance(p, _d, { x: _d.xTo, y: _d.yTo });
          if (!isNaN(_d.xTo) || !isNaN(_d.yTo)) {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });
          }
        }

        if (_d.type.includes('segment') || _d.type === 'ray') {
          newDist = getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = getDistance(p, _d);
            var endPointDist = getDistance(p, endPoint);
            var length = getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = newDist;
          index = i;
        }
      } // );

    }

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      return modelObj.interactionElements[index].uniqueId;
    }

    return null;
  }

  function getPLine(e, isPerpendicular) {
    var point = getPointByPixel(e.pageX, e.pageY);
    var data = {
      visible: true,
      x: point.x,
      y: point.y,
      xOr: point.x,
      yOr: point.y,
      xTo: point.x,
      yTo: point.y,
      xOrTo: point.x,
      yOrTo: point.y,
      slope: 0,
      distance: null
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d10 = modelObj.interactionElements[i];

      if (checkType(_d10, localObj.lineTypes) && _d10.uniqueId !== localObj.currentUniqueId) {
        var distance = getPointLineDistance({
          x: data.x,
          y: data.y
        }, {
          x: _d10.x,
          y: _d10.y
        }, {
          x: _d10.xTo,
          y: _d10.yTo
        });
        distance = Math.abs(distance);

        if (_d10.type.includes('segment') || _d10.type === 'ray') {
          if (distance < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d10.xTo,
              y: _d10.yTo
            };

            if (_d10.type === 'ray') {
              endPoint = {
                x: _d10.xOr,
                y: _d10.yOr
              };
            }

            if (!modelObj.LabComClass.Maths.pointInSegment(point, _d10, endPoint)) {
              continue;
            }
          } else {
            continue;
          }
        }

        if (data.distance === null || data.distance > distance) {
          data.distance = distance;
          data.line = _d10.uniqueId;
          data.slope = modelObj.LabComClass.Maths.getAngle(_d10.x, _d10.y, _d10.xTo, _d10.yTo);

          if (isPerpendicular) {
            data.slope += Math.PI / 2;
          }

          var newP = modelObj.LabComClass.Maths.getPoint({
            x: data.x,
            y: data.y
          }, data.slope, 10);
          data.xTo = newP.x;
          data.yTo = newP.y;
        }
      }
    }

    if (data.distance !== null && data.distance < getPointUnitByPixelUnit(10)) {
      return data;
    }

    return false;
  }

  function getPointLineDistance(_pt, _line1, _line2) {
    var _dist = modelObj.LabComClass.Maths.getDistance(_line1, _line2);

    var _ans = 0;

    if (_dist > 0) {
      var _num = (_line2.x - _line1.x) * (_line1.y - _pt.y) - (_line2.y - _line1.y) * (_line1.x - _pt.x);

      _ans = _num / _dist;
    }

    return _ans;
  }

  function updatePoints(shape) {
    // if(shape.segDistance !== undefined) {
    //   const firstPoint = findShape(shape.firstPointId).shape;
    //   const newSecondPoint = modelObj.LabComClass.Maths.getPoint(firstPoint,modelObj.LabComClass.Maths.getAngle(firstPoint.x,firstPoint.y,shape.x,shape.y),shape.segDistance);
    //   shape.segmentAngle = modelObj.LabComClass.Maths.getAngle(firstPoint.x,firstPoint.y,shape.x,shape.y);
    //   shape.x = newSecondPoint.x;
    //   shape.y = newSecondPoint.y;
    // }
    if (shape.label) {
      // const p = findLableByPoint(shape);
      shape.labelX = shape.x;
      shape.labelY = shape.y;

      if (shape.labelDiffX === 0) {
        shape.labelDiffX = 6;
        shape.labelDiffY = -9;
      }
    }
  } // =================================================


  function updateLinePoints(curInt) {
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 10;

    var _angle = modelObj.LabComClass.Maths.getAngle(curInt.x, curInt.y, curInt.xTo, curInt.yTo);

    var _newPoint = modelObj.LabComClass.Maths.getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;

    var _angle2 = modelObj.LabComClass.Maths.getAngle(curInt.xTo, curInt.yTo, curInt.x, curInt.y);

    var _newPoint2 = modelObj.LabComClass.Maths.getPoint({
      x: curInt.xTo,
      y: curInt.yTo
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y; // if (curInt.label) {
    //   const p = findLableByLine(curInt, { x: curInt.xTo, y: curInt.yTo });
    //   curInt.labelX = p.x;
    //   curInt.labelY = p.y;
    // }

    if (curInt && curInt.connectionId && curInt.connectionId.length) {
      for (var i = 0; i < curInt.connectionId.length; i++) {
        var shapeData = findShape(curInt.connectionId[i]);

        if (shapeData && (shapeData.shape.type === 'perpendicularLine' || shapeData.shape.type === 'parallelLine')) {
          shapeData.shape.slope = _angle;

          if (shapeData.shape.type === 'perpendicularLine') {
            shapeData.shape.slope += Math.PI / 2;
          }

          updatePLinePoints(shapeData.shape);
        }
      }
    }
  }

  function findLableByPoint(p1) {
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;

    var width = _ctx.measureText(p1.label).width;

    var height = _ctx.measureText(p1.label).height;

    _ctx.restore();

    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = modelObj.LabComClass.Maths.getRandomNumber(0, Math.PI * 2, 1, 0.1);
      var dist = 5;
      p = modelObj.LabComClass.Maths.getPoint(p1, angle, dist);

      if (angle > Math.PI - 1 && angle < Math.PI + 1) {
        p.x -= width;
      }

      if (angle > Math.PI + 1 && angle < Math.PI * 2) {
        p.y -= height;
      }

      if (angle < 1 || angle > Math.PI * 2 - 1) {
        p.x += width;
      }

      if (angle < Math.PI - 1) {
        p.y += height;
      }

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = p1.x;
        p.y = p1.y - 5;
        break;
      }

      counter++;
    }

    return p;
  }

  function getSlope(_x1, _y1, _x2, _y2) {
    return +((_y2 - _y1) / (_x2 - _x1)).toFixed(5) === -0 ? 0 : +((_y2 - _y1) / (_x2 - _x1)).toFixed(5);
  }

  ;

  function findLableByLine(shape, point2) {
    var _modelObj$LabComClass8 = modelObj.LabComClass.Maths,
        getRandomNumber = _modelObj$LabComClass8.getRandomNumber,
        getPoint = _modelObj$LabComClass8.getPoint,
        getAngle = _modelObj$LabComClass8.getAngle,
        getDistance = _modelObj$LabComClass8.getDistance,
        getPointLineDistance = _modelObj$LabComClass8.getPointLineDistance;

    if (shape.labelX !== undefined) {
      var pos = getPixelByPoint(shape.labelX, shape.labelY);

      if (pos.x > modelObj.x && pos.x < modelObj.x + modelObj.width && pos.y > modelObj.y && pos.y < modelObj.y + modelObj.height) {
        var dist = getPointLineDistance({
          x: shape.labelX,
          y: shape.labelY
        }, shape, {
          x: shape.xTo,
          y: shape.yTo
        });

        if (Math.abs(dist) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
          var nearbyPointFound = false;

          for (var i = 0; i < modelObj.interactionElements.length; i++) {
            var point = modelObj.interactionElements[i];

            if (point.type === 'point' && shape.label) {
              var _dist4 = getDistance({
                x: point.x + getPointUnitByPixelUnit(10),
                y: point.y - getPointUnitByPixelUnit(10)
              }, {
                x: shape.labelX,
                y: shape.labelY
              });

              if (_dist4 < getPointUnitByPixelUnit(modelObj.snappingDiff * 1.2)) {
                nearbyPointFound = true;
                break;
              }
            }
          }

          if (!nearbyPointFound) {
            return {
              x: shape.labelX,
              y: shape.labelY
            };
          }
        }
      }
    }

    var p1 = getPixelByPoint(shape.x, shape.y);
    var p2 = getPixelByPoint(point2.x, point2.y);
    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = getAngle(p1.x, p1.y, p2.x, p2.y);

      var _dist5 = getRandomNumber(-1 * (maxX - minX), maxX - minX, 1, 1);

      if (shape.type === 'ray') {
        _dist5 = Math.abs(_dist5);
      }

      p = getPoint(p1, angle, _dist5);

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        for (var _i14 = 0; _i14 < modelObj.interactionElements.length; _i14++) {
          var _shape = modelObj.interactionElements[_i14];

          if (_shape.type === 'point' && _shape.label) {
            var _dist6 = getDistance({
              x: _shape.x + getPointUnitByPixelUnit(10),
              y: _shape.y - getPointUnitByPixelUnit(10)
            }, p);

            if (_dist6 < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
              breakIt = false;
            }
          }
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = (p1.x + p2.x) / 2;
        p.y = (p1.y + p2.y) / 2;
        break;
      }

      counter++;
    }

    p = getPointByPixel(p.x, p.y);
    return p;
  }

  function updatePLinePoints(curInt) {
    var _modelObj$LabComClass9 = modelObj.LabComClass.Maths,
        getAngle = _modelObj$LabComClass9.getAngle,
        getPoint = _modelObj$LabComClass9.getPoint;
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 2;

    if (curInt.line !== undefined) {
      var shapeData = findShape(curInt.line);

      if (shapeData.shape) {
        var _d11 = shapeData.shape;

        if (_d11.x !== _d11.xTo && _d11.y !== _d11.yTo) {
          var slope = getAngle(_d11.x, _d11.y, _d11.xTo, _d11.yTo);

          if (curInt.type === 'perpendicularLine') {
            slope += Math.PI / 2;
          }

          curInt.slope = slope;
        }
      }
    }

    var _angle = curInt.slope;

    var _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;
    _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, 20);
    curInt.xTo = _newPoint.x;
    curInt.yTo = _newPoint.y;

    var _angle2 = curInt.slope + Math.PI;

    var _newPoint2 = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y;

    if (curInt.label) {
      var p = findLableByLine(curInt, {
        x: curInt.xTo,
        y: curInt.yTo
      });
      var labelTo = findLabelP(curInt, _angle);
      var labelTos = getPoint({
        x: curInt.x,
        y: curInt.y
      }, _angle, getPointUnitByPixelUnit(50));
      curInt.labelX = labelTo.x;
      curInt.labelY = labelTo.y;
    }
  }

  function findLabelP(shape, _angle) {
    var _modelObj$LabComClass10 = modelObj.LabComClass.Maths,
        getAngle = _modelObj$LabComClass10.getAngle,
        getPoint = _modelObj$LabComClass10.getPoint;
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var labelTo = getPoint({
      x: shape.x,
      y: shape.y
    }, _angle, getPointUnitByPixelUnit(50));

    if (labelTo.x < min.x || labelTo.x > max.x || labelTo.y < min.y || labelTo.y > max.y) {
      labelTo = getPoint({
        x: shape.x,
        y: shape.y
      }, Math.PI + _angle, getPointUnitByPixelUnit(50));
    }

    return labelTo;
  }

  function findLabelOld(shape, _angle) {
    var _modelObj$LabComClass11 = modelObj.LabComClass.Maths,
        getAngle = _modelObj$LabComClass11.getAngle,
        getPoint = _modelObj$LabComClass11.getPoint;
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var labelTo = {};
    var shapePx = getPixelByPoint(shape.x, shape.y);

    if (_angle < 0) {
      labelTo = getPoint({
        x: shape.x,
        y: shape.y
      }, _angle, getPointUnitByPixelUnit(shapePx.x - modelObj.x - 20));
    } else {
      labelTo = getPoint({
        x: shape.x,
        y: shape.y
      }, _angle, -getPointUnitByPixelUnit(shapePx.x - modelObj.x - 20));
    } // if(labelTo.x < min.x || labelTo.x > max.x || labelTo.y < min.y || labelTo.y > max.y) {
    //   labelTo = getPoint({ x: shape.x, y: shape.y }, Math.PI + _angle, getPointUnitByPixelUnit(50));
    // }


    return labelTo;
  } // =================================================


  function dispatchEventCustom(value) {
    if (modelObj.interactionType === 'labelTool') {
      saveData();
    }

    var _obj = {};
    _obj.id = modelObj.id;
    _obj.type = 'geoInteraction';
    value = JSON.parse(JSON.stringify(value));
    value.type = modelObj.interactionType;
    _obj.data = value;

    if (typeof events[_obj.type] !== 'undefined') {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventCircleMove(value) {
    var _obj = {};
    _obj.id = modelObj.id;
    value.type = modelObj.interactionType;
    _obj.type = 'geoCircle';
    _obj.data = value;

    if (typeof events[_obj.type] !== 'undefined') {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventScale() {
    var value = {};
    value.id = modelObj.id;
    value.type = 'geoScale';
    value.length = modelObj.LabComClass.Maths.getDistance({
      x: scaleObj.x,
      y: scaleObj.y
    }, {
      x: scaleObj.xTo,
      y: scaleObj.yTo
    });

    if (typeof events[value.type] !== 'undefined') {
      events[value.type](value, true);
    }
  }
}
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
// interactionType can be either of "point", "segment", "line", "circle".
function GeoDrawClass(_obj) {
  var events = {};
  var scaleObj = {
    x: 0,
    y: 0,
    xTo: 200,
    yTo: 200,
    pointColor: 'rgba(10,190,220,1)',
    pointRadius: 7,
    segmentColor: 'rgba(10,190,220,1)',
    segmentWidth: 3,
    visible: false
  };
  var modelObj = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    bgColor: 'rgba(255, 255, 255, 0.5)',
    state: true,
    visible: true,
    interactionType: '',
    interactionElements: [],
    pointColor: 'rgba(10,190,220,1)',
    pointLabelColor: 'rgba(51,51,51,1)',
    lengthLabelColor: 'rgba(51,51,51,1)',
    pointRadius: 5,
    segmentColor: 'rgba(10,190,220,1)',
    segmentWidth: 2,
    tempElements: [],
    transperent: false,
    eventsEnable: true,
    fontSize: 20,
    currentStep: 0,
    snapToGrid: false,
    snappingDiff: 10,
    // in pixel,
    deviceSnappingDiff: 25,
    shapesEditable: false,
    undoRedo: false,
    pointSnapping: true,
    finalColor: 'rgba(65,180,5,1)',
    screen: {},
    labelBGRatio: 1,
    waiting: false,
    shapes: {
      length: {
        digit: 0,
        onlyDistance: false
      },
      point: {
        label: {
          visible: true
        }
      },
      square: {
        label: {
          visible: true
        },
        fill: true
      },
      circle: {
        digit: 0,
        circleDistanceLabel: true
      },
      line: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        }
      },
      brush1: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        }
      },
      brush2: {
        color: {
          stroke: 'rgba(222,108,225,1)'
        }
      },
      brush3: {
        color: {
          stroke: 'rgba(255,204,0,1)'
        }
      },
      segment: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        },
        label: {
          visible: false
        },
        segDistanceLabel: false,
        digit: 1
      },
      angle: {
        dotOn90: true
      },
      angleSize: {
        dotOn90: true
      }
    }
  };
  var localObj = {
    mouseDown: {
      isMouseDown: false,
      lastShapeCompleted: true
    },
    uniqueId: 0,
    currentUniqueId: 0,
    allShapesData: [],
    tempData: [],
    mouseDownData: null,
    isDevice: false,
    newPlottedShapes: [],
    lineTypes: ['line', 'ray', 'perpendicularLine', 'parallelLine', 'segment', 'segmentDash'],
    isLableSelected: false,
    arbitaryX: 1,
    plotPointOnExistingPoint: false
  };

  var _this = this;

  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === 'object' && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === 'object' && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  }

  modelObj.centerX = modelObj.x + modelObj.width / 2;
  modelObj.centerY = modelObj.y + modelObj.height / 2;
  setScaleValues();
  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass();
  localObj.isDevice = modelObj.LabComClass.BrowserDetect.isDevice();

  if (localObj.isDevice) {
    modelObj.snappingDiff = modelObj.deviceSnappingDiff;
  } // addEvents();


  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.alpha = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.setTransperent = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.setLengthLabelColor = function (_color) {
    modelObj.lengthLabelColor = _color;
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  }; // =================================================


  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    addEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  };

  this.editable = function (flag) {
    modelObj.shapesEditable = flag;
    return modelObj.shapesEditable;
  };

  this.selectAll = function (_flag) {
    modelObj.interactionElements.forEach(function (item) {
      item.isSelected = _flag;
    });
  };

  this.snapToGrid = function (_flag) {
    modelObj.snapToGrid = _flag;
  };

  this.redoPossible = function () {
    return localObj.tempData.length !== 0;
  };

  this.setFinalView = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.finalView = _flag;
  };

  this.setPointSnapping = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.pointSnapping = _flag;
  };

  this.setStyle = function (uniqueId, _obj) {
    var styleApproved = {
      strokeColor: true,
      fillColor: true
    };
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        if (styleApproved[i]) {
          shape.shape[i] = _obj[i];
        }
      });
    }
  };

  this.deleteSelected = function () {
    if (modelObj.shapesEditable) {
      var selectedIds = [];
      modelObj.interactionElements.forEach(function (item) {
        if (item.isSelected && (item.isDeletable === undefined || item.isDeletable)) {
          selectedIds.push(item.uniqueId);
        }
      });
      removeShapes(selectedIds);
    }
  };

  this.setScaleDefaultPos = function (x1, y1, x2, y2) {
    var updateScalePos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    scaleObj.originPos = {
      x: x1,
      y: y1,
      xTo: x2,
      yTo: y2
    };

    if (updateScalePos) {
      scaleObj.x = scaleObj.originPos.x;
      scaleObj.y = scaleObj.originPos.y;
      scaleObj.xTo = scaleObj.originPos.xTo;
      scaleObj.yTo = scaleObj.originPos.yTo;
    }
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  };

  this.getStep = function () {
    return modelObj.currentStep;
  }; // =================================================


  this.showDrawing = function (_arr, _bool) {
    if (typeof _arr !== 'undefined' && _arr !== null) {
      _arr.forEach(function (item) {
        if (typeof item !== 'undefined') {
          item.visible = _bool;
        }
      });
    }
  }; // =================================================


  this.setInteractionType = function (_type) {
    if (typeof _type !== 'undefined') {
      if (modelObj.interactionType !== _type) {
        modelObj.interactionType = _type;
        clearCache();
        addEvents();
      }
    }
  };

  this.getInteractionType = function () {
    return modelObj.interactionType;
  };

  this.setStep = function (_step) {
    if (modelObj.currentStep > _step) {
      removeShapes(modelObj.interactionElements.filter(function (e) {
        return e.step > _step;
      }).map(function (e) {
        return e.uniqueId;
      }));
    }

    modelObj.currentStep = _step;
  };

  this.setSegmentDistanceLabel = function (_flag) {
    modelObj.shapes.segment.segDistanceLabel = _flag;
  };

  this.getCount = function () {
    return modelObj.interactionElements.length;
  };

  this.getData = function () {
    return {
      visible: JSON.parse(JSON.stringify(modelObj.interactionElements)),
      nonVisible: modelObj.tempElements
    };
  };

  this.setWaiting = function (_bool) {
    modelObj.waiting = _bool;
  };

  this.getWaiting = function () {
    return modelObj.waiting;
  };

  this.setScreenData = function (_obj) {
    modelObj.graphValues = _obj;
    modelObj.x = _obj.x;
    modelObj.y = _obj.y;
    modelObj.width = _obj.width;
    modelObj.height = _obj.height;
    modelObj.screen = _obj.screen;
    modelObj.centerX = _obj.originX;
    modelObj.centerY = _obj.originY;
    modelObj.showQuadrants = _obj.showQuadrants;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var shape = modelObj.interactionElements[i];

      if ((shape.type === 'line' || shape.type === 'ray') && shape.label) {
        var pos = findLableByLine(shape, {
          x: shape.xTo,
          y: shape.yTo
        });
        shape.labelX = pos.x;
        shape.labelY = pos.y;
      }
    }

    setScaleValues();
    updateAllShapes();
    addEvents();
  };

  this.plotAngleSize = function (_obj) {
    if (!modelObj.waiting) {
      var angleSize = {
        type: 'angleSize',
        uniqueId: ++localObj.uniqueId,
        x: 0,
        y: 0,
        xTo: 0,
        yTo: 0,
        degree: 0,
        clockwise: true,
        connectionId: []
      };
      var rayId = ++localObj.uniqueId;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var angle = modelObj.LabComClass.Maths.getAngle(angleSize.x, angleSize.y, angleSize.xTo, angleSize.yTo);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(angleSize, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + '°';
      }

      if (angleSize.labelX === undefined) {
        var angleTextPos = modelObj.LabComClass.Maths.getPoint(angleSize, angle + _obj.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleTextPos.x;
        angleSize.labelY = angleTextPos.y;
        angleSize.labelDiffX = angleSize.labelDiffX !== undefined ? angleSize.labelDiffX : 0;
        angleSize.labelDiffY = angleSize.labelDiffY !== undefined ? angleSize.labelDiffY : 0;
      }

      var newAngleSize = addNewShape(angleSize); // localObj.newPlottedShapes.push(angleSize.uniqueId);

      var ray = addNewShape({
        type: 'ray',
        uniqueId: rayId,
        x: angleSize.x,
        y: angleSize.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        connectionId: []
      }); // localObj.newPlottedShapes.push(rayId);

      updateLinePoints(ray);
      angleSize.connectionId.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;
      return {
        angleSize: newAngleSize,
        ray: ray
      };
    }
  };

  this.setAngleSize = function (_obj) {
    if (modelObj.waiting) {
      var rayId = ++localObj.uniqueId;
      var angleSize = findShape(_obj.uniqueId).shape;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var firstPoint = findShape(_obj.firstPointId).shape;
      var angle = modelObj.LabComClass.Maths.getAngle(_obj.x, _obj.y, firstPoint.x, firstPoint.y);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + '°';
      }

      if (angleSize.labelX === undefined) {
        var angleText = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleText.x;
        angleSize.labelY = angleText.y;
        angleSize.labelDiffX = 0;
        angleSize.labelDiffY = 0;
      }

      var newShape = addNewShape({
        type: 'ray',
        uniqueId: rayId,
        firstPointId: _obj.secondPointId,
        x: _obj.x,
        y: _obj.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        connectionId: [_obj.secondPointId]
      });
      updateLinePoints(newShape);
      angleSize.connectionId.push(rayId);
      localObj.newPlottedShapes.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fpShape = findShape(angleSize.firstPointId).shape;
      fpShape.isSelected = false;
      var spShape = findShape(angleSize.secondPointId).shape;

      if (spShape) {
        spShape.isSelected = false;
      }

      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  this.setSegSize = function (_obj) {
    if (modelObj.waiting) {
      var segmentId = ++localObj.uniqueId;
      var secondPointId = ++localObj.uniqueId;
      var segSize = findShape(_obj.uniqueId).shape;
      var firstPoint = findShape(segSize.firstPointId).shape;
      addNewShape({
        type: 'segment',
        uniqueId: segmentId,
        x: _obj.x,
        y: _obj.y,
        xTo: _obj.x + _obj.distance,
        yTo: _obj.y,
        connectionId: [_obj.firstPointId, secondPointId]
      });
      addNewShape({
        type: 'point',
        uniqueId: secondPointId,
        x: _obj.x + _obj.distance,
        y: _obj.y,
        connectionId: [segmentId]
      });
      segSize.connectionId.push(segmentId);
      segSize.connectionId.push(secondPointId);
      segSize.secondPointId = secondPointId;
      localObj.newPlottedShapes.push(segmentId);
      localObj.newPlottedShapes.push(secondPointId);
      segSize.segmentId = segmentId;
      segSize.distance = _obj.distance;
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fp = findShape(segSize.firstPointId).shape;
      fp.isSelected = false;
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  this.setCircleSize = function (_obj) {
    if (modelObj.waiting) {
      var circleId = ++localObj.uniqueId;
      var circleSize = findShape(_obj.uniqueId).shape;
      var firstPoint = findShape(circleSize.firstPointId).shape;
      addNewShape({
        type: 'circle',
        uniqueId: circleId,
        x: _obj.x,
        y: _obj.y,
        r: _obj.distance,
        connectionId: [_obj.firstPointId]
      });
      circleSize.connectionId.push(circleId);
      localObj.newPlottedShapes.push(circleId);
      circleSize.circleId = circleId;
      circleSize.r = _obj.distance;
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      var fp = findShape(circleSize.firstPointId).shape;
      fp.isSelected = false;
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  function getPointByPixel(_x, _y) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = (_x - _g.originX) / _g.unitX;
    pointY = -1 * (_y - _g.originY) / _g.unitY;
    return {
      x: pointX,
      y: pointY
    };
  }

  function getPixelByPoint(valueX, valueY) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = valueX * _g.unitX + _g.originX;
    pointY = valueY * _g.unitY / -1 + _g.originY;
    return {
      x: pointX,
      y: pointY
    };
  }

  function getPointUnitByPixelUnit(_pixelUnit) {
    return _pixelUnit / modelObj.graphValues.unitX;
  }

  function getPixelUnitByPointUnit(_pointUnit) {
    return _pointUnit * modelObj.graphValues.unitX;
  }

  this.setData = function (_data) {
    if (_data.visible !== undefined) {
      modelObj.interactionElements = JSON.parse(JSON.stringify(_data.visible));
    }

    if (_data.nonVisible !== undefined) {
      modelObj.tempElements = JSON.parse(JSON.stringify(_data.nonVisible));
    }

    clearCache();
  };

  this.getCurrentStepIndex = function (_num) {
    var arr = [];

    var _loop = typeof _num === 'undefined' ? 1 : _num;

    if (modelObj.interactionType !== 'scale') {
      for (var i = _loop; i > 0; i--) {
        arr.push(modelObj.interactionElements.length - i);
      }
    }

    return arr;
  };

  this.removeRecentShapes = function () {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (data.length) {
      removeShapes(data);
    } else {
      removeShapes(localObj.newPlottedShapes);
    }
  }; // =================================================


  this.clearAll = function () {
    modelObj.interactionElements = [];
    localObj.uniqueId = 0;
    modelObj.currentStep = 0;
    modelObj.finalView = false;

    _this.clearTemp();
  };

  this.clearTemp = function () {
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
    modelObj.tempElements = [];
    localObj.allShapesData = [];
    localObj.tempData = [];
    clearCache();
  };

  this.undo = function () {
    if (localObj.allShapesData.length) {
      localObj.tempData.push(localObj.allShapesData.pop());

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
      } else {
        modelObj.interactionElements = [];
      }
    }
  };

  this.redo = function () {
    if (localObj.tempData.length) {
      localObj.allShapesData.push(localObj.tempData.pop());

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
      } else {
        modelObj.interactionElements = [];
      }
    }
  };

  function saveData() {
    if (modelObj.undoRedo) {
      var currentData = JSON.stringify(modelObj.interactionElements);
      var addData = false;

      if (localObj.allShapesData.length) {
        var lastData = JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]);

        if (currentData !== lastData) {
          addData = true;
        }
      } else {
        addData = true;
      }

      if (addData) {
        localObj.allShapesData.push(JSON.parse(JSON.stringify(modelObj.interactionElements)));
        localObj.tempData = [];
      }
    }
  }

  this.addShape = function (_objData) {
    clearCache();

    var _obj = JSON.parse(JSON.stringify(_objData));

    _obj.uniqueId = ++localObj.uniqueId;

    if (!modelObj.shapesEditable) {
      _obj.isDraggable = false;
      _obj.isDeletable = false;
    }

    if (_obj.label) {
      if (_obj.labelX === undefined) {
        _obj.labelX = _obj.x;
        _obj.labelY = _obj.y;
      }

      if (_obj.labelDiffX === undefined) {
        _obj.labelDiffX = 0;
        _obj.labelDiffY = 0;
      }
    }

    _obj.connectionId = [];

    switch (_obj.type) {
      case 'point':
        updatePoints(addNewShape(_obj));
        break;

      case 'circle':
        updatePoints(addNewShape(_obj));
        break;

      case 'circle_3':
        updatePoints(addNewShape(_obj));
        break;

      case 'line':
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case 'triangle':
        addNewShape(_obj);
        break;

      case 'segment':
      case 'segmentDash':
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case 'ray':
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case 'perpendicularLine':
        updatePLinePoints(addNewShape(_obj));
        break;

      case 'parallelLine':
        updatePLinePoints(addNewShape(_obj));
        break;

      case 'length':
        _obj.labelAlign = 'center';
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case 'polygonShape':
        addNewShape(_obj);
        break;

      case 'angle':
      case 'angleRay':
      case 'angleB':
        addNewShape(_obj);
        break;

      case 'mirrorOnLine':
      case 'semiCircle':
      case 'square':
        addNewShape(_obj);

      default:
        break;
    }

    updateAllShapes();
    saveData();
    return _obj.uniqueId;
  };

  function checkForConnection(_obj) {
    if (_obj.type === 'line' || _obj.type === 'ray' || _obj.type === 'length') {
      modelObj.interactionElements.forEach(function (shape) {
        if (shape.type === 'point') {
          if (shape.x === _obj.x && shape.y === _obj.y) {
            _obj.firstPointId = shape.uniqueId;

            _obj.connectionId.push(_obj.firstPointId);
          }

          if (shape.x === _obj.xTo && shape.y === _obj.yTo) {
            _obj.secondPointId = shape.uniqueId;

            _obj.connectionId.push(_obj.secondPointId);
          }
        }
      });
    }
  }

  this.removeIncompleteShape = function () {
    if (!localObj.mouseDown.lastShapeCompleted) {
      _this.removeUnplotedShapes();
    } else {
      clearScreen(false);
    }
  };

  this.removeUnplotedShapes = function () {
    removeShapes(localObj.newPlottedShapes);
    clearScreen(true);
  };

  function clearScreen(closeThePanel) {
    localObj.newPlottedShapes = [];
    localObj.mouseDown.lastShapeCompleted = true;
    modelObj.waiting = false;

    if (closeThePanel) {
      if (typeof events.angleSize !== 'undefined') {
        events.angleSize({
          id: modelObj.id,
          type: 'angleSize',
          visible: false
        }, true);
      }

      if (typeof events.segSize !== 'undefined') {
        events.segSize({
          id: modelObj.id,
          type: 'segSize',
          visible: false
        }, true);
      }

      if (typeof events.circleSize !== 'undefined') {
        events.circleSize({
          id: modelObj.id,
          type: 'circleSize',
          visible: false
        }, true);
      }
    }
  }

  function clearCache() {
    modelObj.waiting = false;

    _this.removeIncompleteShape();

    localObj.newPlottedShapes = [];

    if (modelObj.interactionType !== 'select') {
      for (var i = 0; i < modelObj.interactionElements.length; i++) {
        modelObj.interactionElements[i].isSelected = false;
      }
    }

    scaleObj.visible = modelObj.interactionType === 'scale';
  }

  function removeShapes(data) {
    for (var i = 0; i < data.length; i++) {
      var shape = findShape(data[i]);

      if (shape && shape.index !== undefined) {
        removeShape(data[i]);
      }
    }

    saveData();
  }

  function removeShape(id) {
    var shapeData = modelObj.interactionElements;
    var data = findShape(id);
    var shape = data.shape;
    var index = data.index;

    if (shape) {
      var connectionId = shape.connectionId;

      if (connectionId) {
        connectionId.forEach(function (cd) {
          shapeData.forEach(function (sd) {
            var checkingShape = sd;

            if (checkingShape && checkingShape.uniqueId === cd) {
              if (checkingShape.isDeletable === undefined || checkingShape.isDeletable === false) {
                if (checkingShape.connectionId.length > 1) {
                  var _index2 = checkingShape.connectionId.indexOf(shape.uniqueId);

                  if (_index2 > -1) {
                    checkingShape.connectionId.splice(_index2, 1);
                  }

                  if (checkType(checkingShape, ['line', 'segment', 'segmentDash', 'ray'])) {
                    if (checkingShape.firstPointId === shape.uniqueId || checkingShape.secondPointId === shape.uniqueId) {
                      checkingShape.connectionId.forEach(function (elem) {
                        var connectedShape = findShape(elem).shape;

                        if (connectedShape) {
                          var _index = connectedShape.connectionId.indexOf(checkingShape.uniqueId);

                          if (_index2 > -1) {
                            connectedShape.connectionId.splice(_index, 1);
                          }
                        }
                      });
                      sd = null;
                    }
                  }
                }
              }
            }
          });
        });
      }

      shapeData[index] = null;
      modelObj.interactionElements = shapeData.filter(function (e) {
        return e !== null;
      });
      clearCache();
      saveData();
    }
  } // =================================================


  this.updateIndex = function (_obj) {
    var value = JSON.parse(JSON.stringify(_obj.data));
    var shapeData = findShape(value.uniqueId);
    var currentShape = shapeData.shape;
    var actionType = _obj.type;

    if (actionType === 'remove') {
      removeShape(value.uniqueId);
    } else if (actionType === 'update') {
      if (currentShape) {
        Object.keys(value).forEach(function (i) {
          currentShape[i] = value[i];
        });
      }

      var type = value.type;

      if (modelObj.interactionType === 'scale') {
        scaleObj.x = isNaN(value.x) ? scaleObj.x : value.x;
        scaleObj.y = isNaN(value.y) ? scaleObj.y : value.y;
        scaleObj.xTo = isNaN(value.xTo) ? scaleObj.xTo : value.xTo;
        scaleObj.yTo = isNaN(value.yTo) ? scaleObj.yTo : value.yTo;
        dispatchEventScale();
      } else if (type === 'point') {
        currentShape.x = value.x;
        currentShape.y = value.y;

        if (typeof value.label !== 'undefined') {
          currentShape.label = value.label;
          updatePoints(currentShape);
        }
      } // else if (type === 'midPoint') {
      //   // if (typeof (value.label) !== 'undefined') {
      //   //   currentShape.label = value.label;
      //   //   updatePoints(currentShape);
      //   // }
      // } 
      else if (type.includes('segment')) {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.xTo = value.xTo;
          currentShape.yTo = value.yTo;
        } else if (type === 'line' || type === 'ray') {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.xTo = value.xTo;
          currentShape.yTo = value.yTo;

          if (value.label) {
            currentShape.label = value.label;
          }

          if (currentShape.connectionId) {
            for (var i = 0; i < currentShape.connectionId.length; i++) {
              var _shapeData = findShape(currentShape.connectionId[i]);

              if (_shapeData.shape && _shapeData.shape.type === 'point' && _shapeData.shape.uniqueId === currentShape.firstPointId) {
                _shapeData.shape.x = currentShape.x;
                _shapeData.shape.y = currentShape.y;
              }

              if (_shapeData.shape && _shapeData.shape.type === 'point' && _shapeData.shape.uniqueId === currentShape.secondPointId) {
                _shapeData.shape.x = currentShape.xTo;
                _shapeData.shape.y = currentShape.yTo;
              }
            }
          }

          updateLinePoints(currentShape);
        } else if (type === 'circle') {
          Object.keys(value).forEach(function (i) {
            currentShape[i] = value[i];
          });
        } else if (type === 'circle_3') {} else if (type === 'perpendicularLine' || type === 'parallelLine') {
          currentShape.x = value.x;
          currentShape.y = value.y;
          currentShape.slope = value.slope;

          if (currentShape.connectionId) {
            currentShape.connectionId.forEach(function (id) {
              var shapeData = findShape(id);

              if (shapeData.shape && shapeData.shape.type === 'point') {
                shapeData.shape.x = currentShape.x;
                shapeData.shape.y = currentShape.y;
              }
            });
          }

          updatePLinePoints(currentShape);
        }
    }

    saveData();
  }; // =================================================


  this.draw = function () {
    var _ctx = modelObj.context;
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height,
        transperent = modelObj.transperent,
        interactionElements = modelObj.interactionElements,
        segmentColor = modelObj.segmentColor,
        fontSize = modelObj.fontSize,
        pointColor = modelObj.pointColor,
        interactionType = modelObj.interactionType,
        pointLabelColor = modelObj.pointLabelColor;

    if (modelObj.visible) {
      _ctx.save();

      _ctx.beginPath();

      _ctx.globalAlpha = transperent ? 0.5 : 1; // --------------------------------------

      _ctx.save();

      _ctx.fillStyle = '#000000';

      _ctx.rect(x, y, width, height);

      _ctx.clip();

      drawShapes(_ctx, modelObj);

      if (scaleObj.visible) {
        _ctx.save();

        _ctx.fillStyle = scaleObj.pointColor;
        _ctx.strokeStyle = scaleObj.segmentColor;
        _ctx.lineWidth = scaleObj.segmentWidth;

        _ctx.beginPath();

        _ctx.moveTo(scaleObj.x, scaleObj.y);

        _ctx.lineTo(scaleObj.xTo, scaleObj.yTo);

        _ctx.stroke();

        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.x, scaleObj.y, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.xTo, scaleObj.yTo, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.restore();
      }

      if (localObj.mouseDown.isMouseDown && interactionType === 'select' && localObj.currentUniqueId === null) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.fillStyle = 'rgba(69,146,176,0.1)';
        _ctx.strokeStyle = 'rgba(69,146,176,0.8)';
        var _localObj$mouseDown = localObj.mouseDown,
            orignalX = _localObj$mouseDown.orignalX,
            orignalY = _localObj$mouseDown.orignalY,
            _x3 = _localObj$mouseDown.x,
            _y3 = _localObj$mouseDown.y;

        _ctx.rect(orignalX, orignalY, _x3 - orignalX, _y3 - orignalY);

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        _ctx.restore();
      }

      _ctx.restore(); // --------------------------------------


      _ctx.closePath();

      _ctx.restore(); // --------------------------------------


      _ctx.save();

      var _modelObj$screen = modelObj.screen,
          sx = _modelObj$screen.x,
          sy = _modelObj$screen.y,
          sw = _modelObj$screen.w,
          sh = _modelObj$screen.h;
      _ctx.fillStyle = '#000000';

      _ctx.beginPath();

      _ctx.moveTo(sx, sy);

      _ctx.lineTo(sx, sy + sh);

      _ctx.lineTo(sx + sw, sy + sh);

      _ctx.lineTo(sx + sw, sy);

      _ctx.closePath();

      _ctx.clip();

      drawPoints(_ctx, modelObj);

      _ctx.restore(); // --------------------------------------
      // --------------------------------------


      _ctx.save();

      _ctx.fillStyle = '#000000';

      _ctx.beginPath();

      _ctx.moveTo(x, y);

      _ctx.lineTo(x, y + height);

      _ctx.lineTo(x + width, y + height);

      _ctx.lineTo(x + width, y);

      _ctx.closePath();

      _ctx.clip();

      if (!transperent) {
        drawlabels(_ctx, modelObj);
      }

      _ctx.restore(); // --------------------------------------

    }
  };

  function drawPoints(_ctx, _ref) {
    var x = _ref.x,
        y = _ref.y,
        height = _ref.height,
        interactionElements = _ref.interactionElements;
    interactionElements.forEach(function (item) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === 'point') {
          var draw = true;

          if (modelObj.showQuadrants === '1') {
            if (_xy.x < x || _xy.y > y + height) {
              draw = false;
            }
          }

          if (draw) {
            drawPoint(_ctx, item, true, false);
          }
        } // if (item.type === 'midPoint') {
        //   let draw = true;
        //   if (modelObj.showQuadrants === '1') {
        //     if (_xy.x < x || _xy.y > (y + height)) {
        //       draw = false;
        //     }
        //   }
        //   if (draw) {
        //     drawPoint(_ctx, item, true, false);
        //   }
        // }

      }
    });
  }

  function drawlabels(_ctx, _ref2) {
    var interactionElements = _ref2.interactionElements,
        pointLabelColor = _ref2.pointLabelColor,
        fontSize = _ref2.fontSize,
        lengthLabelColor = _ref2.lengthLabelColor;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === 'point') {
          // If a label(visible property) for particular point is to be changed.
          var pointLabelVisible = item.labelVisible !== undefined ? item.labelVisible : true;
          drawPoint(_ctx, item, false, pointLabelVisible && modelObj.shapes.point.label.visible);
        }

        if (item.type === 'length') {
          if (item.label) {
            var center = getPixelByPoint(item.labelX, item.labelY);
            center.x += item.labelDiffX;
            center.y += item.labelDiffY;

            _ctx.save();

            _ctx.beginPath();

            _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
            var textSize = _ctx.measureText(item.distanceText).width + fontSize / 2;
            _ctx.fillStyle = 'rgba(255,255,255,1)';
            _ctx.strokeStyle = 'rgba(199,199,199,1)';

            _ctx.rect(center.x - textSize / 2, center.y - fontSize * 1.2, textSize, fontSize * (modelObj.labelBGRatio + 0.1));

            _ctx.fill();

            _ctx.stroke();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.textBaseline = 'bottom';
            _ctx.textAlign = 'center';
            _ctx.fillStyle = lengthLabelColor;

            _ctx.drawStyledText(item.label, center.x, center.y, modelObj.LabComClass.polo22KlettRegular, fontSize);

            _ctx.closePath();

            _ctx.restore();
          }
        }

        if (item.type === 'square' && modelObj.shapes.square.label.visible) {
          if (item.label) {
            var p = getPixelByPoint(item.labelX, item.labelY);
            var color = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            var _center = getPixelByPoint(item.labelX, item.labelY);

            _center.x += item.labelDiffX;
            _center.y += item.labelDiffY;

            _ctx.save();

            _ctx.beginPath();

            _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;

            var _textSize = _ctx.measureText(item.label).width + fontSize / 2;

            _ctx.fillStyle = 'rgba(255,255,255,1)';
            _ctx.strokeStyle = 'rgba(199,199,199,1)';

            _ctx.rect(_center.x - _textSize * 0.25, _center.y - fontSize * 1.2, _textSize * 0.65, fontSize * (modelObj.labelBGRatio + 0.1));

            _ctx.fill();

            _ctx.stroke();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.textBaseline = 'bottom';
            _ctx.textAlign = 'center';
            _ctx.fillStyle = lengthLabelColor;

            _ctx.drawStyledText(item.label, _center.x, _center.y, modelObj.LabComClass.polo22KlettRegular, fontSize); // drawStroked({
            //   ctx: _ctx,
            //   text: item.label,
            //   x: p.x,
            //   y: p.y,
            //   fillColor: color,
            //   center: true,
            //   diffX: Number(item.labelDiffX),
            //   diffY: Number(item.labelDiffY)
            // });


            _ctx.closePath();

            _ctx.restore();
          }
        }

        if (item.type.includes('segment') || checkType(item, ['angle', 'angleSize', 'line', 'ray', 'perpendicularLine', 'parallelLine', 'angleRay'])) {
          var showLable = true;

          if (modelObj.shapes.hasOwnProperty(item.type)) {
            if (modelObj.shapes[item.type].hasOwnProperty('label') && modelObj.shapes[item.type].label.hasOwnProperty('visible') && !modelObj.shapes[item.type].label.visible) {
              showLable = false;
            }
          }

          if (showLable && item.label !== undefined && item.labelX !== undefined && item.type !== 'angleSize') {
            var _p = getPixelByPoint(item.labelX, item.labelY);

            var _color2 = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            drawStroked({
              ctx: _ctx,
              text: item.label,
              x: _p.x,
              y: _p.y,
              fillColor: _color2,
              center: true,
              diffX: Number(item.labelDiffX),
              diffY: Number(item.labelDiffY)
            });
          } else if (showLable && item.label !== undefined && item.labelX !== undefined && item.type === 'angleSize') {
            var angle = modelObj.LabComClass.Maths.getAngle(item.x, item.y, item.xTo, item.yTo);
            var degree = item.degree * (item.clockwise ? -1 : 1);
            var angleTextPos = modelObj.LabComClass.Maths.getPoint(item, angle + degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));

            var _p2 = getPixelByPoint(angleTextPos.x, angleTextPos.y);

            var _color3 = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;

            drawStroked({
              ctx: _ctx,
              text: item.label.replace('.', ','),
              x: _p2.x,
              y: _p2.y,
              fillColor: _color3,
              center: true,
              diffX: Number(item.labelDiffX),
              diffY: Number(item.labelDiffY)
            });
          }
        }
      }
    });
  }

  function reduceLineEnd(p1, p2, r) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var mag = Math.hypot(dx, dy);
    return {
      x: p2.x - r * dx / mag,
      y: p2.y - r * dy / mag
    };
  }

  function drawArrowHead(_ctx, _xy, _xTo_yTo) {
    var headlen = 10; // length of head in pixels

    var angle = modelObj.LabComClass.Maths.getAngle(_xy.x, _xy.y, _xTo_yTo.x, _xTo_yTo.y);
    var newPosition = reduceLineEnd(_xy, _xTo_yTo, modelObj.pointRadius);

    _ctx.save();

    _ctx.beginPath();

    _ctx.moveTo(newPosition.x, newPosition.y);

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle - Math.PI / 6), newPosition.y - headlen * Math.sin(angle - Math.PI / 6));

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle + Math.PI / 6), newPosition.y - headlen * Math.sin(angle + Math.PI / 6));

    _ctx.lineTo(newPosition.x, newPosition.y);

    _ctx.stroke();

    _ctx.fill();

    _ctx.closePath();

    _ctx.restore();
  }

  function drawShapes(_ctx, _ref3) {
    var interactionElements = _ref3.interactionElements,
        segmentColor = _ref3.segmentColor,
        fontSize = _ref3.fontSize,
        pointLabelColor = _ref3.pointLabelColor;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      var _xTo_yTo = item.xTo !== undefined ? getPixelByPoint(item.xTo, item.yTo) : null;

      var _xOr_yOr = item.xOr !== undefined ? getPixelByPoint(item.xOr, item.yOr) : null;

      var _xOrTo_yOrTo = item.xOrTo !== undefined ? getPixelByPoint(item.xOrTo, item.yOrTo) : null;

      if (item.visible) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.strokeStyle = segmentColor;
        _ctx.fillStyle = segmentColor;

        if (item.strokeColor) {
          _ctx.strokeStyle = item.strokeColor;
        }

        if (item.fillColor) {
          _ctx.fillStyle = item.fillColor;
        }

        if (item.lineWidth) {
          _ctx.lineWidth = item.lineWidth;
        }

        if (item.isSelected) {
          _ctx.lineWidth = 2;
        }

        if (modelObj.finalView) {
          _ctx.fillStyle = modelObj.finalColor;
          _ctx.strokeStyle = modelObj.finalColor;
        }

        if (item.type === 'point') {// drawPoint(_ctx, item, true, false);
        } else if (item.type.includes('segment')) {
          _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = 'bottom';
          _ctx.textAlign = 'left';

          if (item.type.includes('segmentDash')) {
            _ctx.setLineDash([6, 4]);
          }

          _ctx.moveTo(_xy.x, _xy.y);

          _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

          _ctx.stroke();

          if (item.arrowHead) {
            if (modelObj.LabComClass.Maths.getDistance(_xy, _xTo_yTo) > modelObj.pointRadius * 3) {
              drawArrowHead(_ctx, _xy, _xTo_yTo);
            }
          }

          if (modelObj.shapes.segment.segDistanceLabel && item.distance && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted) && modelObj.interactionType !== 'move' && modelObj.interactionType !== 'brush1' && modelObj.interactionType !== 'brush2' && modelObj.interactionType !== 'brush3') {
            var val = item.distance === undefined ? 0 : item.distance;

            if (modelObj.shapes.segment.digit !== undefined) {
              val = val.toFixed(modelObj.shapes.segment.digit).replace('.', ',');
            } // val = Number(val.toFixed(modelObj.shapes.segment.digit));


            var gap = fontSize / 3;
            var x = (_xy.x + _xTo_yTo.x) / 2.05;
            var h = fontSize;
            var y = (_xy.y + _xTo_yTo.y) / 2 + gap;

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = 'rgba(255,255,255,1)';

            _ctx.rect(x, y, _ctx.measureText(val).width + gap * 2, h);

            _ctx.fill();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.fillStyle = pointLabelColor;

            _ctx.fillText(val, x + gap, y + h * 1.05);

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'length') {
          if (item.secondPointId === undefined && item.mode === 'normal') {
            _ctx.save();

            _ctx.beginPath();

            _ctx.setLineDash([5, 15]);

            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

            _ctx.stroke();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'compass') {
          if (!item.isPloted) {
            _ctx.strokeStyle = segmentColor;

            _ctx.setLineDash([3, 3]);

            _ctx.lineWidth = 2;

            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          } else {
            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          }
        } else if (item.type === 'triangle') {
          if (item.thirdSegmentPlotted) {
            var p1 = getPixelByPoint(item.firstPoint.x, item.firstPoint.y);
            var p2 = getPixelByPoint(item.secondPoint.x, item.secondPoint.y);
            var p3 = getPixelByPoint(item.thirdPoint.x, item.thirdPoint.y);

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = item.fillColor ? item.fillColor : 'rgba(112,146,190,0.5)';

            _ctx.moveTo(p1.x, p1.y);

            _ctx.lineTo(p2.x, p2.y);

            _ctx.lineTo(p3.x, p3.y);

            _ctx.lineTo(p1.x, p1.y);

            _ctx.stroke();

            _ctx.fill();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'square') {
          if (item.secondPointPlotted) {
            var _p3 = getPixelByPoint(item.firstPoint.x, item.firstPoint.y);

            var _p4 = getPixelByPoint(item.secondPoint.x, item.secondPoint.y);

            var _p5 = getPixelByPoint(item.thirdPoint.x, item.thirdPoint.y);

            var p4 = getPixelByPoint(item.fourthPoint.x, item.fourthPoint.y);

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = item.fillColor ? item.fillColor : 'rgba(112,146,190,0.5)';

            _ctx.moveTo(_p3.x, _p3.y);

            _ctx.lineTo(_p4.x, _p4.y);

            _ctx.lineTo(_p5.x, _p5.y);

            _ctx.lineTo(p4.x, p4.y);

            _ctx.lineTo(_p3.x, _p3.y);

            _ctx.stroke();

            if (modelObj.shapes.square.fill) {
              _ctx.fill();
            }

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'line') {
          _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

          _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

          _ctx.stroke();
        } else if (item.type === 'ray') {
          if (_xy.x !== _xTo_yTo.x || _xy.y !== _xTo_yTo.y) {
            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.stroke();
          }
        } else if (item.type === 'circle_3') {
          _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = 'bottom';
          _ctx.textAlign = 'left';

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

          _ctx.stroke();
        } else if (item.type === 'circle') {
          _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = 'bottom';
          _ctx.textAlign = 'left';

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

          _ctx.stroke();

          if (modelObj.shapes.circle.circleDistanceLabel && item.r && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted)) {
            var _val = Number(item.r);

            if (modelObj.shapes.circle.digit !== undefined) {
              _val = _val.toFixed(modelObj.shapes.circle.digit).replace('.', ',');
            }

            var _gap = fontSize / 3;

            var _x4 = _xy.x;
            var _h = fontSize;

            var _y4 = _xy.y + _gap;

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = 'rgba(255,255,255,1)';

            _ctx.rect(_x4, _y4, _ctx.measureText(_val).width + _gap * 2, _h);

            _ctx.fill();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.fillStyle = pointLabelColor;

            _ctx.fillText(_val, _x4 + _gap, _y4 + _h * 1.05);

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'semiCircle') {
          _ctx.beginPath();

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), -item.startAngle, -item.endAngle);

          _ctx.stroke();

          _ctx.closePath();
        } else if (item.type === 'angleRay') {
          _ctx.translate(_xy.x, _xy.y);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.stroke();
        } else if (item.type === 'angle' || item.type === 'angleSize') {
          _ctx.globalAlpha = 0.5;

          _ctx.translate(_xy.x, _xy.y);

          _ctx.beginPath();

          _ctx.moveTo(0, 0);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.fill();

          _ctx.closePath();

          if ((item.angleValue === 90 || item.degree === 90) && (modelObj.shapes.angle.dotOn90 || modelObj.shapes.angleSize.dotOn90)) {
            var _p6 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.endAngle, 16);

            var _p7 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.startAngle, 16);

            _ctx.beginPath();

            _ctx.strokeStyle = '#000000';
            _ctx.fillStyle = '#000000';

            _ctx.arc((_p7.x + _p6.x) / 2, (_p7.y + _p6.y) / 2, 2, 0, Math.PI * 2);

            _ctx.fill();

            _ctx.closePath();
          }

          _ctx.stroke();
        } else if (item.type === 'perpendicularLine' || item.type === 'parallelLine') {
          if (_xOr_yOr !== null && !isNaN(_xOr_yOr.x)) {
            _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

            _ctx.stroke();
          }
        } else if (item.type === 'polygonShape') {
          _ctx.fillStyle = item.fillColor ? item.fillColor : 'rgba(112,146,190,0.5)';
          item.path.forEach(function (elem, i) {
            var p = getPixelByPoint(elem.x, elem.y);

            if (i === 0) {
              _ctx.moveTo(p.x, p.y);
            }

            _ctx.lineTo(p.x, p.y);
          });

          _ctx.fill();
        }

        _ctx.closePath();

        _ctx.restore();
      }
    });
  }

  function drawStroked(_ref4) {
    var ctx = _ref4.ctx,
        text = _ref4.text,
        x = _ref4.x,
        y = _ref4.y,
        fillColor = _ref4.fillColor,
        _ref4$diffX = _ref4.diffX,
        diffX = _ref4$diffX === void 0 ? 0 : _ref4$diffX,
        _ref4$diffY = _ref4.diffY,
        diffY = _ref4$diffY === void 0 ? 0 : _ref4$diffY;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = 'rgba(255,255,255,1)';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'miter'; // Experiment with "bevel" & "round" for the effect you want!

    ctx.miterLimit = 2; // if (center) {
    //   x -= (ctx.measureText(text).width / 2);
    //   y -= 5;
    // }

    y += modelObj.fontSize * 0.6; // }
    // ctx.strokeText(text, x + diffX, y + diffY);
    // ctx.fillText(text, x + diffX, y + diffY);

    ctx.drawStyledText(text, x + diffX, y + diffY, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
    ctx.closePath();
    ctx.restore();
  }

  function drawPoint(_ctx, item, _drawShape, _drawText) {
    var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

    _ctx.beginPath();

    if (_drawShape) {
      _ctx.fillStyle = modelObj.pointColor;

      if (item.fillColor) {
        _ctx.fillStyle = item.fillColor;
      }

      if (modelObj.finalView) {
        _ctx.fillStyle = modelObj.finalColor;
        _ctx.strokeStyle = modelObj.finalColor;
      }

      _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius, 0, 2 * Math.PI);

      _ctx.fill();

      _ctx.closePath();

      if (item.isSelected) {
        _ctx.beginPath();

        _ctx.strokeStyle = modelObj.pointColor;

        _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius + 2, 0, 2 * Math.PI);

        _ctx.stroke();

        _ctx.closePath();
      }
    }

    if (item.label !== undefined && _drawText) {
      if (item.labelX === undefined) {
        item.labelX = item.x;
        item.labelY = item.y;
        item.labelDiffX = 0;
        item.labelDiffY = 0;
      }

      var labelPos = getPixelByPoint(item.labelX, item.labelY);
      var color = item.fillLabelColor ? item.fillLabelColor : modelObj.pointLabelColor;
      drawStroked({
        ctx: _ctx,
        text: item.label,
        x: labelPos.x,
        y: labelPos.y,
        fillColor: color,
        center: false,
        diffX: Number(item.labelDiffX),
        diffY: Number(item.labelDiffY)
      });
    }
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function addEvents() {
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });

    if (modelObj.eventsEnable) {
      if (modelObj.interactionType !== null) {
        if (modelObj.state && modelObj.visible) {
          if (modelObj.interactionType === 'scale') {
            _eventDataObj.r.push({
              id: 'scale1',
              arc: {
                x: scaleObj.x,
                y: scaleObj.y,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            }, {
              id: 'scale2',
              arc: {
                x: scaleObj.xTo,
                y: scaleObj.yTo,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            });
          } else {
            _eventDataObj.r.push({
              id: 0,
              rect: {
                x: modelObj.screen.x,
                y: modelObj.screen.y,
                w: modelObj.screen.w,
                h: modelObj.screen.h
              },
              eventListener: mouseHandle.bind(this)
            });
          }

          onViewUpdateCls.trigger('onGlobalUpdate', {
            type: 'addMouseEvent',
            data: _eventDataObj
          });
        }
      }
    }
  }

  var d;

  function checkForRightClick(e) {
    localObj.mouseDownData = null;

    if (localObj.isDevice) {
      localObj.mouseDownData = JSON.parse(JSON.stringify(e));
      localObj.mouseDownData.delayCounter = 0;
      modelObj.animClass.start({
        id: 'animation',
        fps: 1,
        frame: checkAfterDelay
      });
    } else {
      executeMouseDown(e);
    }
  }

  function rejectDelay() {
    modelObj.animClass.stop('animation');
    executeMouseDown(localObj.mouseDownData);
    localObj.mouseDownData = null;
  }

  function checkAfterDelay() {
    var mouseDownData = localObj.mouseDownData;
    mouseDownData.delayCounter++;

    if (mouseDownData.delayCounter > 2) {
      modelObj.animClass.stop('animation');

      if (typeof events.rightClick !== 'undefined') {
        events.rightClick({
          id: modelObj.id,
          type: 'rightClick',
          x: mouseDownData.pageX,
          y: mouseDownData.pageY
        }, true);
      }

      mouseDownData = null;
    }
  }

  function executeMouseDown(e) {
    var mouseDown = localObj.mouseDown;
    mouseDown.isMouseDown = true;
    mouseDown.x = e.pageX;
    mouseDown.orignalX = e.pageX;
    mouseDown.y = e.pageY;
    mouseDown.orignalY = e.pageY;
    mouseDown.objectDown = false;

    if (mouseDown.lastShapeCompleted) {
      onMouseDown(e);
    }
  } // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        checkForRightClick(e);
        break;

      case 'pressmove':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onPressMove(e);
        break;

      case 'mousemove':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseMove(e);
        break;

      case 'mouseup':
        mouseUpCall(e); // addEvents();

        break;

      case 'rightmouseup':
        if (localObj.mouseDown.isMouseDown) {
          mouseUpCall(e);
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      case 'rightmousedown':
        localObj.mouseDown.isRightMouseDown = true;

        if (typeof events.rightClick !== 'undefined') {
          events.rightClick({
            id: modelObj.id,
            type: 'rightClick',
            x: e.pageX,
            y: e.pageY
          }, true);
        }

        break;

      case 'mouseupout':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseUp(e);
        localObj.mouseDown.isMouseDown = false;

        if (e.subId === 'scale1' || e.subId === 'scale2') {
          addEvents();
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      default:
        break;
    }
  }

  function mouseUpCall(e) {
    if (localObj.mouseDownData !== null) {
      rejectDelay();
    }

    onMouseUp(e);
    localObj.mouseDown.isMouseDown = false;
    localObj.mouseDown.objectDown = false;
    localObj.mouseDown.isRightMouseDown = false;
  }

  function setScaleValues() {
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height;
    scaleObj.originPos = {
      x: x + (width - 280),
      y: y + (height - 40),
      xTo: x + (width - 40),
      yTo: y + (height - 40)
    };
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
  }

  function addPoint(point, _obj) {
    var newShape = {
      type: 'point',
      x: point.x,
      y: point.y,
      label: ''
    };
    Object.keys(_obj).forEach(function (i) {
      newShape[i] = _obj[i];
    });

    if (point.isIntersection || point.isParameter) {
      Object.keys(point).forEach(function (i) {
        newShape[i] = point[i];
      });
    }

    localObj.newPlottedShapes.push(_obj.uniqueId);
    addNewShape(newShape);
  } // =================================================


  function checkSnapping(point) {
    if (modelObj.showQuadrants === '1' && (point.x < 0 || point.y < 0)) {
      if (Math.abs(point.x) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.x = 0;
      }

      if (Math.abs(point.y) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.y = 0;
      }

      if (point.x < 0 || point.y < 0) {
        return null;
      }
    }

    var snappingPont = JSON.parse(JSON.stringify(point));
    var snappingData = {};
    var snappingFound = false;

    if (modelObj.pointSnapping) {
      var pointMinDist = isItCloseToPlotedPoint(snappingPont, true);
      var intersectionMinDist = isItCloseToIntersectionPoint(snappingPont);
      var intersectionOfParameterMinDist = isItCloseToParameterPoint(snappingPont);

      if (pointMinDist) {
        snappingData.x = pointMinDist.plotedPoint.x;
        snappingData.y = pointMinDist.plotedPoint.y;
        snappingFound = true;
      }

      if (intersectionMinDist && !snappingFound) {
        var intersectionCanBeSnapped = true;

        if (pointMinDist) {
          if (intersectionMinDist.dist > pointMinDist.dist) {
            intersectionCanBeSnapped = false;
          }
        }

        if (intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionMinDist.updateKeys;
          snappingFound = true;
        }
      }

      if (intersectionOfParameterMinDist && !snappingFound) {
        var _intersectionCanBeSnapped = true;

        if (snappingData) {
          if (intersectionOfParameterMinDist.dist > snappingData.dist) {
            _intersectionCanBeSnapped = false;
          }
        }

        if (_intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionOfParameterMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionOfParameterMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionOfParameterMinDist.updateKeys;
          snappingFound = true;
        }
      }
    } // check for point, intersection, shape parameter
    // check for snapping grid point


    if (!snappingFound && modelObj.snapToGrid) {
      var _modelObj$graphValues = modelObj.graphValues,
          XunitsPerGrid = _modelObj$graphValues.XunitsPerGrid,
          YunitsPerGrid = _modelObj$graphValues.YunitsPerGrid;
      var x = Math.round(point.x / XunitsPerGrid) * XunitsPerGrid;
      var y = Math.round(point.y / YunitsPerGrid) * YunitsPerGrid;

      if (modelObj.LabComClass.Maths.getDistance(point, {
        x: x,
        y: y
      }) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        snappingData = {};
        snappingData.x = x;
        snappingData.y = y;
        snappingFound = true;
      }
    }

    if (snappingFound) {
      Object.keys(snappingData).forEach(function (i) {
        point[i] = snappingData[i];
      });
    }

    return point;
  }

  function addNewShape(_objNew) {
    var _obj = {
      type: modelObj.interactionType,
      step: modelObj.currentStep,
      visible: true
    };
    Object.keys(_objNew).forEach(function (i) {
      _obj[i] = _objNew[i];
    });
    modelObj.interactionElements.push(_obj);
    return _obj;
  }

  function onMouseDown(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    localObj.newPlottedShapes = [];
    var newShapes = localObj.newPlottedShapes;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point);
    localObj.currentUniqueId = null;
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));

    if (clickingOnExistingPoint !== null) {
      localObj.currentUniqueId = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    localObj.newShapeStarted = false;

    if (tool === 'point' && point !== null) {
      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: ++localObj.uniqueId,
          connectionId: []
        });
        localObj.currentUniqueId = localObj.uniqueId;
      }
    } else if (tool.includes('segment') && point !== null) {
      var firstPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      var segmentId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: firstPointId,
          connectionId: [segmentId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(segmentId);
      }

      addNewShape({
        uniqueId: segmentId,
        firstPointId: firstPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [firstPointId]
      });
      localObj.currentUniqueId = segmentId;
      newShapes.push(segmentId);
    } else if (tool === 'length') {
      if (clickingOnExistingPoint !== null && point !== null) {
        var lengthId = ++localObj.uniqueId;
        var _firstPointId = localObj.currentUniqueId;
        addNewShape({
          uniqueId: lengthId,
          firstPointId: _firstPointId,
          x: point.x,
          y: point.y,
          xTo: point.x,
          yTo: point.y,
          labelAlign: 'center',
          mode: 'normal'
        });
        localObj.currentUniqueId = lengthId;
        newShapes.push(lengthId);
      } else {
        var selectedShapeID = selectShape(e);

        if (selectedShapeID) {
          var shapeData = findShape(selectedShapeID);

          if (shapeData.shape && shapeData.shape.type.includes('segment')) {
            var _lengthId = ++localObj.uniqueId;

            addNewShape({
              uniqueId: _lengthId,
              segmentID: selectedShapeID,
              x: shapeData.shape.x,
              y: shapeData.shape.y,
              xTo: shapeData.shape.xTo,
              yTo: shapeData.shape.yTo,
              labelAlign: 'center',
              mode: 'segment'
            });
            localObj.currentUniqueId = _lengthId;
            newShapes.push(_lengthId);
          } else if (shapeData.shape && (shapeData.shape.type === 'circle' || shapeData.shape.type === 'circle_3' || shapeData.shape.type === 'compass')) {
            var _lengthId2 = ++localObj.uniqueId;

            addNewShape({
              uniqueId: _lengthId2,
              circleId: selectedShapeID,
              x: shapeData.shape.x,
              y: shapeData.shape.y,
              xTo: shapeData.shape.x + shapeData.shape.r,
              yTo: shapeData.shape.y,
              pointX: point.x,
              pointY: point.y,
              labelAlign: 'center',
              mode: 'circle'
            });
            localObj.currentUniqueId = _lengthId2;
            newShapes.push(_lengthId2);
          } else {
            shapeData.shape.isSelected = false;
          }
        }
      }
    } else if (tool === 'compass') {
      var newShape;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId2 = localObj.currentUniqueId;
          newShape = {
            firstPointId: _firstPointId2,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _selectedShapeID = selectShape(e);

        if (_selectedShapeID) {
          var _shapeData2 = findShape(_selectedShapeID);

          if (_shapeData2.shape.visible === true) {
            if (_shapeData2.shape && _shapeData2.shape.type.includes('segment')) {
              newShape = {
                segmentID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                xTo: _shapeData2.shape.xTo,
                yTo: _shapeData2.shape.yTo
              };
            } else if (_shapeData2.shape && (_shapeData2.shape.type === 'circle' || _shapeData2.shape.type === 'compass')) {
              newShape = {
                circleID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                r: _shapeData2.shape.r
              };
            } else if (_shapeData2.shape.type === 'line' || _shapeData2.shape.type === 'parallelLine' || _shapeData2.shape.type === 'perpendicularLine') {
              _shapeData2.shape.isSelected = false;
            }
          }
        }
      }

      if (newShape) {
        var _lengthId3 = ++localObj.uniqueId;

        localObj.currentUniqueId = _lengthId3;
        newShape.connectionId = [];
        newShape.uniqueId = _lengthId3;
        newShape.isPloted = false;
        newShapes.push(_lengthId3);
        addNewShape(newShape);
      }
    } else if ((tool === 'line' || tool === 'ray') && point !== null) {
      var _firstPointId3 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var lineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId3,
          connectionId: [lineId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(lineId);
      }

      addNewShape({
        uniqueId: lineId,
        firstPointId: _firstPointId3,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [_firstPointId3]
      });
      localObj.currentUniqueId = lineId;
      newShapes.push(lineId);
    } else if (tool === 'angleRay' && point !== null) {
      var angleRayId = ++localObj.uniqueId;
      var rayId = ++localObj.uniqueId;
      var secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      newShapes.push(angleRayId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: secondPointId,
          connectionId: [rayId, angleRayId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(rayId);
      }

      addNewShape({
        uniqueId: angleRayId,
        firstPointId: secondPointId,
        firstRayPlotted: false,
        secondRayPlotted: false,
        x: point.x,
        y: point.y,
        connectionId: [secondPointId]
      });
      addNewShape({
        type: 'ray',
        uniqueId: rayId,
        angleRayId: angleRayId,
        secondPointId: secondPointId,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [secondPointId]
      });
      localObj.currentUniqueId = rayId;
      newShapes.push(rayId);
    } else if (tool === 'circle_3' && point !== null) {
      var circleId = ++localObj.uniqueId;

      var _firstPointId4 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId4,
          connectionId: [circleId],
          circleId: circleId
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(circleId);
        shapesData[clickingOnExistingPoint].circleId = circleId;
      }

      addNewShape({
        uniqueId: circleId,
        firstPointId: _firstPointId4,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId4]
      });
      var fp = findShape(_firstPointId4).shape;
      fp.isSelected = true;
      localObj.currentUniqueId = _firstPointId4;
      newShapes.push(circleId);
    } else if (tool === 'angle' && point !== null) {
      var angleId = ++localObj.uniqueId;

      var _firstPointId5 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId5,
          connectionId: [angleId],
          angleId: angleId
        });
        var _fp = findShape(_firstPointId5).shape;
        _fp.isSelected = true;
      } else {
        var _fp2 = findShape(_firstPointId5).shape;
        _fp2.isSelected = true;
        shapesData[clickingOnExistingPoint].connectionId.push(angleId);
        shapesData[clickingOnExistingPoint].angleId = angleId;
      }

      addNewShape({
        uniqueId: angleId,
        firstPointId: _firstPointId5,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId5]
      });
      localObj.currentUniqueId = _firstPointId5;
      newShapes.push(angleId);
    } else if (tool === 'midPoint' && point !== null) {
      var midPointId = ++localObj.uniqueId;

      var _firstPointId6 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID2 = selectShape(e);

      var _shapeData3 = findShape(_selectedShapeID2).shape;

      if (clickingOnExistingPoint === null && point !== null && _selectedShapeID2 === null) {
        addPoint(point, {
          uniqueId: _firstPointId6,
          connectionId: [midPointId],
          midPointId: midPointId
        });
        addNewShape({
          uniqueId: midPointId,
          type: "midPoint",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId6]
        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
        if (_shapeData3) {
          _shapeData3.isSelected = false;
        }

        shapesData[clickingOnExistingPoint].connectionId.push(midPointId);
        shapesData[clickingOnExistingPoint].midPointId = midPointId;
        addNewShape({
          uniqueId: midPointId,
          type: "midPoint",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          strokeColor: point.strokeColor != modelObj.pointColor ? point.strokeColor : modelObj.pointColor,
          fillColor: point.fillColor != modelObj.pointColor ? point.fillColor : modelObj.pointColor,
          connectionId: [_firstPointId6],
          segmentId: _selectedShapeID2
        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (_selectedShapeID2 !== null && _shapeData3.type.includes('segment')) {
        if (_shapeData3 && _shapeData3.type.includes('segment')) {
          addNewShape({
            uniqueId: midPointId,
            type: "midPoint",
            firstPointId: _firstPointId6,
            firstPointPlotted: true,
            secondPointPlotted: true,
            x: (_shapeData3.x + _shapeData3.xTo) / 2,
            y: (_shapeData3.y + _shapeData3.yTo) / 2,
            firstPointCoords: {
              x: _shapeData3.x,
              y: _shapeData3.y
            },
            secondPointCoords: {
              x: _shapeData3.xTo,
              y: _shapeData3.yTo
            },
            segmentId: _selectedShapeID2,
            connectionId: [_firstPointId6],
            onSegment: true,
            midPointId: midPointId
          });
          localObj.currentUniqueId = midPointId;
        }
      } else {
        _shapeData3.isSelected = false;
      }

      newShapes.push(midPointId);
    } else if (tool === 'square' && point !== null) {
      var squareId = ++localObj.uniqueId;

      var _firstPointId7 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null && point !== null) {
        addPoint(point, {
          uniqueId: _firstPointId7,
          connectionId: [squareId],
          squareId: squareId
        });
        addNewShape({
          uniqueId: squareId,
          type: "square",
          firstPointId: _firstPointId7,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId7]
        });
        localObj.currentUniqueId = _firstPointId7;
      } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
        shapesData[clickingOnExistingPoint].connectionId.push(squareId);
        shapesData[clickingOnExistingPoint].squareId = squareId;
        addNewShape({
          uniqueId: squareId,
          type: "square",
          firstPointId: _firstPointId7,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          strokeColor: point.strokeColor != modelObj.pointColor ? point.strokeColor : modelObj.pointColor,
          fillColor: point.fillColor != modelObj.pointColor ? point.fillColor : modelObj.pointColor,
          connectionId: [_firstPointId7]
        });
        localObj.currentUniqueId = _firstPointId7;
      }

      var _fp3 = findShape(_firstPointId7).shape;
      _fp3.isSelected = true;
      localObj.newPlottedShapes.push(squareId);
    } else if (tool === 'mirrorOnLine' && point !== null) {
      var mirrorOnLineId = ++localObj.uniqueId;

      var _firstPointId8 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID3 = selectShape(e);

      var _shapeData4 = findShape(_selectedShapeID3).shape;

      if (_shapeData4 && _shapeData4.type === 'point' || _selectedShapeID3 === null || clickingOnExistingPoint !== null && shapesData[clickingOnExistingPoint].type === 'point') {
        if (_shapeData4) {
          _shapeData4.isSelected = false;
        }

        if (clickingOnExistingPoint === null) {
          addPoint(point, {
            uniqueId: _firstPointId8,
            connectionId: [mirrorOnLineId],
            mirrorOnLineId: mirrorOnLineId
          });
          var _fp4 = findShape(_firstPointId8).shape;
          _fp4.isSelected = true;
        } else {
          shapesData[clickingOnExistingPoint].connectionId.push(mirrorOnLineId);
          shapesData[clickingOnExistingPoint].mirrorOnLineId = mirrorOnLineId;
          var _fp5 = findShape(_firstPointId8).shape;
          _fp5.isSelected = true;
        }

        addNewShape({
          uniqueId: mirrorOnLineId,
          firstPointId: _firstPointId8,
          firstPointPlotted: false,
          linePlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId8]
        });
        localObj.currentUniqueId = _firstPointId8;
        newShapes.push(mirrorOnLineId);
        localObj.newShapeStarted = true;
      } else {
        _shapeData4.isSelected = false;
      }
    } else if (tool === 'triangle' && point !== null) {
      var triangleId = ++localObj.uniqueId;

      var _segmentId = ++localObj.uniqueId;

      var _secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      newShapes.push(triangleId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _secondPointId,
          connectionId: [_segmentId, triangleId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(_segmentId);
      }

      addNewShape({
        uniqueId: triangleId,
        firstPointId: _secondPointId,
        firstSegmentPlotted: false,
        secondSegmentPlotted: false,
        thirdSegmentPlotted: false,
        x: point.x,
        y: point.y,
        connectionId: [_secondPointId]
      });
      addNewShape({
        type: 'segment',
        uniqueId: _segmentId,
        triangleId: triangleId,
        secondPointId: _secondPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [_secondPointId]
      });
      localObj.currentUniqueId = _segmentId;
      newShapes.push(_segmentId);
    } else if (tool === 'perpendicularBisector' && point !== null) {
      var _selectedShapeID4 = selectShape(e);

      var selectedShapeData = findShape(_selectedShapeID4).shape;

      if (clickingOnExistingPoint !== null) {
        var perpBId = ++localObj.uniqueId;

        var _firstPointId9 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

        if (selectedShapeData) {
          selectedShapeData.isSelected = false;
        }

        shapesData[clickingOnExistingPoint].isSelected = false;
        addNewShape({
          uniqueId: perpBId,
          type: "perpendicularBisector",
          firstPointId: _firstPointId9,
          firstPointPlotted: false,
          secondPointPlotted: false,
          connectionId: [_firstPointId9],
          mode: 'point'
        });
        localObj.newShapeStarted = true;
        newShapes.push(perpBId);
        localObj.currentUniqueId = perpBId;
        var _fp6 = findShape(_firstPointId9).shape;
        _fp6.isSelected = true;
      } else if (_selectedShapeID4 !== null && selectedShapeData.type.includes('segment')) {
        selectedShapeData.isSelected = false;

        var _perpBId = ++localObj.uniqueId;

        var segment = selectedShapeData;
        selectedShapeData.perpBId = _perpBId;
        addNewShape({
          uniqueId: _perpBId,
          segmentId: selectedShapeData.uniqueId,
          segment: selectedShapeData,
          segmentPlotted: false,
          connectionId: [selectedShapeData.uniqueId],
          mode: 'segment'
        });
        localObj.newShapeStarted = true;
        newShapes.push(_perpBId);
        localObj.currentUniqueId = _perpBId;
      }
    } else if (tool === 'angleB' && point !== null) {
      var _selectedShapeID5 = selectShape(e);

      var _shapeData5 = findShape(_selectedShapeID5).shape;

      if (clickingOnExistingPoint !== null) {
        var angleBId = ++localObj.uniqueId;
        var _firstPointId10 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleBId);
        shapesData[clickingOnExistingPoint].angleBId = angleBId;
        shapesData[clickingOnExistingPoint].isSelected = true;
        addNewShape({
          uniqueId: angleBId,
          firstPointId: _firstPointId10,
          firstPointPlotted: false,
          secondPointPlotted: false,
          thirdPointPloted: false,
          x: point.x,
          y: point.y,
          mode: 'point',
          connectionId: [_firstPointId10]
        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = angleBId;
        newShapes.push(angleBId);

        if (_selectedShapeID5 !== null && _shapeData5.type !== 'point') {
          _shapeData5.isSelected = false;
        }
      } else if (_selectedShapeID5 !== null && _shapeData5.type.includes('segment')) {
        _shapeData5.isSelected = true;

        var _angleBId = ++localObj.uniqueId;

        var firstSegment = _shapeData5;
        _shapeData5.angleBId = _angleBId;
        addNewShape({
          uniqueId: _angleBId,
          firstSegmentId: _shapeData5.uniqueId,
          firstSegmentPlotted: false,
          secondSegmentPlotted: false,
          firstSegment: {
            x: firstSegment.x,
            y: firstSegment.y,
            xTo: firstSegment.xTo,
            yTo: firstSegment.yTo
          },
          x: _shapeData5.x,
          y: _shapeData5.y,
          mode: 'segment',
          connectionId: [_shapeData5.uniqueId]
        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = _angleBId;
        newShapes.push(_angleBId);
      } else {}
    } else if (tool === 'angleSize' && point !== null) {
      localObj.mouseDown.lastShapeCompleted = false;
      var angleSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null && point !== null) {
        var _firstPointId11 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleSizeId);
        shapesData[clickingOnExistingPoint].angleSizeId = angleSizeId;
        addNewShape({
          uniqueId: angleSizeId,
          firstPointId: _firstPointId11,
          firstPointPlotted: false,
          secondPointPlotted: false,
          degree: 0,
          clockwise: true,
          x: point.x,
          y: point.y,
          mode: 'point',
          connectionId: [_firstPointId11]
        });
        localObj.currentUniqueId = _firstPointId11;
        newShapes.push(angleSizeId);
        localObj.newShapeStarted = true;
      } else {
        localObj.newShapeStarted = false;
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (tool === 'segSize' && point !== null) {
      var segSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId12 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(segSizeId);
        shapesData[clickingOnExistingPoint].segSizeId = segSizeId;
        addNewShape({
          uniqueId: segSizeId,
          firstPointPlotted: false,
          firstPointId: _firstPointId12,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId12]
        });
        localObj.currentUniqueId = _firstPointId12;
        newShapes.push(segSizeId);
      } else {
        var _firstPointId13 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId13,
          segSizeId: segSizeId,
          connectionId: [segSizeId]
        });
        addNewShape({
          uniqueId: segSizeId,
          firstPointId: _firstPointId13,
          firstPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId13]
        });
        localObj.currentUniqueId = _firstPointId13;
      }

      var _fp7 = findShape(localObj.currentUniqueId);

      _fp7.isSelected = true;
      localObj.newPlottedShapes.push(segSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === 'circleSize' && point !== null) {
      var circleSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId14 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(circleSizeId);
        shapesData[clickingOnExistingPoint].circleSizeId = circleSizeId;
        addNewShape({
          uniqueId: circleSizeId,
          firstPointPlotted: false,
          firstPointId: _firstPointId14,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId14]
        });
        localObj.currentUniqueId = _firstPointId14;
        newShapes.push(circleSizeId);
      } else {
        var _firstPointId15 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId15,
          circleSizeId: circleSizeId,
          connectionId: [circleSizeId]
        });
        addNewShape({
          uniqueId: circleSizeId,
          firstPointId: _firstPointId15,
          firstPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId15]
        });
        localObj.currentUniqueId = _firstPointId15;
      }

      var _fp8 = findShape(localObj.currentUniqueId);

      _fp8.isSelected = true;
      localObj.newPlottedShapes.push(circleSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === 'circle' && point !== null) {
      var connectionId = [];

      var _firstPointId16 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _circleId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId16,
          connectionId: [_circleId],
          isSelected: true
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(_circleId);
        shapesData[clickingOnExistingPoint].isSelected = true;
      }

      if (clickingOnExistingPoint === null) {
        connectionId = [localObj.currentUniqueId];
      }

      addNewShape({
        uniqueId: _circleId,
        firstPointId: _firstPointId16,
        x: point.x,
        y: point.y,
        r: 0,
        connectionId: connectionId
      });
      localObj.currentUniqueId = _circleId;
      newShapes.push(_circleId);
    } else if (tool === 'perpendicularLine' || tool === 'parallelLine') {
      var _newShape;

      var perpendLineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId17 = localObj.currentUniqueId;
          _newShape = {
            firstPointId: _firstPointId17,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _d2 = getPLine(e, tool === 'perpendicularLine');

        if (_d2) {
          _newShape = _d2;
          _newShape.lineToPoint = true;
          var parentLine = findShape(_newShape.line);

          if (parentLine) {
            parentLine.shape.connectionId.push(perpendLineId);
            parentLine.shape.isSelected = true;
          }
        } else {
          var _firstPointId18 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId18,
            connectionId: [perpendLineId]
          });
          newShapes.push(_firstPointId18);
          _newShape = {
            firstPointId: _firstPointId18,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      }

      if (_newShape.pointToLine) {
        var _point = findShape(_newShape.firstPointId).shape;
        _point.isSelected = true;
      }

      _newShape.firstPointPlotted = false;
      _newShape.connectionId = [];
      _newShape.uniqueId = perpendLineId;
      localObj.currentUniqueId = perpendLineId;
      newShapes.push(_newShape.uniqueId);
      addNewShape(_newShape);
    } else if (tool === 'brush1' || tool === 'brush2' || tool === 'brush3') {
      localObj.currentUniqueId = selectShape(e);
    } else if (tool === 'select' || tool === 'move') {
      localObj.currentUniqueId = moveShape(e);
    }
  } // =================================================


  function onMouseMove(e) {
    if (!localObj.mouseDown.lastShapeCompleted) {
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor: 'pointer'
      // });
      onPressMove(e);
    } else {// let cursor = 'default';
      // let downCursor = 'default';
      // if (isOnShape(e) !== null) {
      //   cursor = 'pointer';
      //   downCursor = 'pointer';
      // }
      // if (modelObj.interactionType === 'moveGraph') {
      //   cursor = 'grab';
      //   downCursor = 'grabbing';
      // }
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor,
      //   downCursor
      // });
    }
  }

  function onPressMove(e) {
    var tool = modelObj.interactionType;
    var shapesData = modelObj.interactionElements;
    var currentShape = localObj.currentUniqueId !== null ? findShape(localObj.currentUniqueId).shape : findShape(localObj.uniqueId).shape;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point);

    if (e.subId === 'scale1' || e.subId === 'scale2') {
      if (e.subId === 'scale1') {
        scaleObj.x = point.x;
        scaleObj.y = point.y;
        dispatchEventScale();
      } else if (e.subId === 'scale2') {
        scaleObj.xTo = point.x;
        scaleObj.yTo = point.y;
        dispatchEventScale();
      }
    } else {
      if (point === null || localObj.mouseDown.objectDown && !(currentShape && (currentShape.isDraggable === undefined || currentShape.isDraggable))) {
        if (!(tool === 'move' && localObj.isLableSelected)) {
          console.info('rejected');
          return false;
        }
      }

      if (tool === 'point') {
        if (currentShape.type == 'point' && currentShape.connectionId.length == 0) {
          updatePointValues(currentShape, {
            x: point.x,
            y: point.y
          });
        }
      } else if (tool.includes('segment')) {
        currentShape.xTo = point.x;
        currentShape.yTo = point.y;
      } else if (tool === 'length') {
        if (currentShape && currentShape.type === 'length' && currentShape.secondPointId === undefined) {
          currentShape.xTo = point.x;
          currentShape.yTo = point.y;
        }
      } else if (tool === 'compass') {
        if (currentShape && currentShape.type === 'compass') {
          if (!currentShape.isPloted) {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
          } else {
            currentShape.x = point.x;
            currentShape.y = point.y;
          }
        }
      } else if (tool === 'line') {
        var line = shapesData[shapesData.length - 1];
        line.xTo = point.x;
        line.yTo = point.y;
        updateLinePoints(line);
      } else if (tool === 'ray') {
        var ray = shapesData[shapesData.length - 1];
        ray.xTo = point.x;
        ray.yTo = point.y;
        updateLinePoints(ray);
      } else if (tool === 'angleRay') {
        if (currentShape) {
          var angleRay = findShape(currentShape.angleRayId).shape;

          if (!angleRay.firstRayPlotted) {
            currentShape.x = point.x;
            currentShape.y = point.y;
            updateLinePoints(currentShape);
          } else {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
            angleRay.thirdPoint = {
              x: point.x,
              y: point.y
            };
            updateLinePoints(currentShape);
          }
        }
      } else if (tool === 'triangle') {
        if (currentShape) {
          var triangle = findShape(currentShape.triangleId).shape;

          if (!triangle.firstSegmentPlotted) {
            currentShape.x = point.x;
            currentShape.y = point.y;
          } else {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
            triangle.thirdPoint = {
              x: point.x,
              y: point.y
            };
          }
        }
      } else if (tool === 'angle') {// if (currentShape && localObj.mouseDown.isMouseDown) {
        //   currentShape.x = point.x;
        //   currentShape.y = point.y;
        // }
      } else if (tool === 'circle_3') {
        var index;

        for (var i = shapesData.length - 1; i >= 0; i--) {
          if (shapesData[i].type === 'circle_3') {
            index = i;
            break;
          }
        }

        var _currentShape = shapesData[index];
        var cData = {};

        if (_currentShape.type === 'circle_3' && _currentShape.secondPointPlotted !== false) {
          if (_currentShape.firstPointPlotted !== undefined && _currentShape.secondPointPlotted !== undefined) {
            var fp = findShape(_currentShape.firstPointId).shape;
            var sp = findShape(_currentShape.secondPointId).shape;
            cData = circle3Handler(fp, sp, point);
          }

          _currentShape.x = cData.x;
          _currentShape.y = cData.y;
          _currentShape.r = cData.r;
        }
      } // else if( tool === 'angleB'){
      //   let angleBisectorData={};
      //   if(currentShape.type==='angleB' && currentShape.secondPointPlotted !== false){
      //     if (currentShape.firstPointPlotted !== undefined && currentShape.secondPointPlotted !== undefined) {
      //       const fp = findShape(currentShape.firstPointId).shape;
      //       const sp = findShape(currentShape.secondPointId).shape;
      //       angleBisectorData = calculateBisector({firstPoint:fp, secondPoint:sp, thirdPoint:point});
      //     }
      //     currentShape.x = angleBisectorData.bisectorLine.x;
      //     currentShape.y = angleBisectorData.bisectorLine.y;
      //     currentShape.xTo = angleBisectorData.bisectorLine.xTo;
      //     currentShape.yTo= angleBisectorData.bisectorLine.yTo;
      //   }
      // } 
      else if (tool === 'circle') {
          var lastShape = shapesData[shapesData.length - 1];
          lastShape.r = Math.abs(modelObj.LabComClass.Maths.getDistance({
            x: lastShape.x,
            y: lastShape.y
          }, point));
          dispatchEventCircleMove(lastShape);
        } else if (tool === 'perpendicularLine' || tool === 'parallelLine') {
          if (localObj.mouseDown.isMouseDown) {
            if (currentShape.pointToLine && !currentShape.firstPointPlotted && currentShape.firstPointId !== undefined) {
              if (localObj.newPlottedShapes.includes(currentShape.firstPointId)) {
                var pointShape = findShape(currentShape.firstPointId).shape;
                pointShape.x = point.x;
                pointShape.y = point.y;
              }
            }
          }

          if (currentShape.lineToPoint) {
            currentShape.x = point.x;
            currentShape.y = point.y;
            updatePLinePoints(currentShape);
          }
        } else if (tool === 'move' && !localObj.mouseDown.objectDown || tool === 'moveGraph') {
          if (localObj.mouseDown.isMouseDown) {
            var _diffX = 0;
            var _diffY = 0;
            _diffX = e.pageX - localObj.mouseDown.x;
            _diffY = e.pageY - localObj.mouseDown.y;
            localObj.mouseDown.x = e.pageX;
            localObj.mouseDown.y = e.pageY;

            if (typeof events[tool] !== 'undefined') {
              events[tool]({
                id: modelObj.id,
                type: 'moveGraph',
                data: {
                  x: _diffX,
                  y: _diffY
                }
              }, true);
            }
          }
        } else if (tool === 'select' || tool === 'move' && localObj.mouseDown.objectDown) {
          if ((modelObj.shapesEditable || localObj.isLableSelected) && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown) {
            var _diffX2 = 0;
            var _diffY2 = 0;
            _diffX2 = e.pageX - localObj.mouseDown.x;
            _diffY2 = e.pageY - localObj.mouseDown.y;
            var center = getPixelByPoint(0, 0);
            var diffValueInPoint = getPointByPixel(center.x + _diffX2, center.y + _diffY2);
            _diffX2 = diffValueInPoint.x;
            _diffY2 = diffValueInPoint.y;

            if (localObj.isLableSelected) {
              for (var _i = 0; _i < shapesData.length; _i++) {
                var _d = shapesData[_i];
                var lablePos = getPixelByPoint(_d.labelX, _d.labelY);
                var pixelDiff = {
                  x: e.pageX - lablePos.x,
                  y: e.pageY - lablePos.y
                };

                if (_d.isSelected) {
                  updateDiff(_d, pixelDiff);
                  break;
                }
              }
            } else {
              for (var _i2 = 0; _i2 < shapesData.length; _i2++) {
                shapesData[_i2].isMoved = false;
              }

              for (var _i3 = 0; _i3 < shapesData.length; _i3++) {
                var _d3 = shapesData[_i3];

                if (_d3.isDraggable !== undefined && !_d3.isDraggable) {
                  continue;
                }

                if (_d3.isSelected && !_d3.isMoved) {
                  _d3.isMoved = true;

                  if (_d3.type === 'point') {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;

                    if (tool === 'move') {
                      _d3.x = point.x;
                      _d3.y = point.y;
                    }

                    updatePoints(_d3);
                  } else if (_d3.type.includes('segment')) {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;
                    _d3.xTo += _diffX2;
                    _d3.yTo += _diffY2;
                  } else if (_d3.type === 'line' || _d3.type === 'ray') {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;
                    _d3.xTo += _diffX2;
                    _d3.yTo += _diffY2;
                    updateLinePoints(shapesData[_i3]);
                  } else if (_d3.type === 'circle') {
                    var centerPoint = findShape(_d3.firstPointId);
                    var endPoint = findShape(_d3.secondPointId);

                    if (centerPoint && endPoint) {
                      if (findDraggable([centerPoint.shape, endPoint.shape])) {
                        if (!centerPoint.shape.isMoved) {
                          updateShapeValue(centerPoint.shape, {
                            x: centerPoint.shape.x + _diffX2,
                            y: centerPoint.shape.y + _diffY2
                          });
                          centerPoint.isMoved = true;
                        }

                        if (!endPoint.shape.isMoved) {
                          updateShapeValue(endPoint.shape, {
                            x: endPoint.shape.x + _diffX2,
                            y: endPoint.shape.y + _diffY2
                          });
                          endPoint.isMoved = true;
                        }
                      }
                    }
                  } else if (_d3.type === 'compass') {
                    var _centerPoint = findShape(_d3.centerPointId);

                    if (_centerPoint) {
                      updateShapeValue(_centerPoint.shape, {
                        x: _centerPoint.shape.x + _diffX2,
                        y: _centerPoint.shape.y + _diffY2
                      });
                    }
                  } else if (_d3.type === 'perpendicularLine' || _d3.type === 'parallelLine') {// _d.x += _diffX;
                    // _d.y += _diffY;
                    // _d.xTo += _diffX;
                    // _d.yTo += _diffY;
                    // updatePLinePoints(shapesData[i]);
                  }
                }
              }

              for (var _i4 = 0; _i4 < shapesData.length; _i4++) {
                var _d4 = shapesData[_i4];

                if (_d4.isSelected) {
                  if (_d4.type === 'point') {
                    if (_d4.connectionId.length > 0) {
                      updateShapes(_d4, _diffX2, _diffY2);
                    }
                  }

                  if (_d4.type.includes('segment') || _d4.type === 'line' || _d4.type === 'ray') {
                    if (_d4.connectionId.length > 0) {
                      updateShapes(_d4, _diffX2, _diffY2);
                    }
                  }
                }
              }
            }
          } else if (tool === 'select') {
            var _localObj$mouseDown2 = localObj.mouseDown,
                orignalX = _localObj$mouseDown2.orignalX,
                orignalY = _localObj$mouseDown2.orignalY,
                x = _localObj$mouseDown2.x,
                y = _localObj$mouseDown2.y;
            selectObjectsInPixelRange(orignalX, orignalY, x, y);
          }

          localObj.mouseDown.x = e.pageX;
          localObj.mouseDown.y = e.pageY;
        }

      updateAllShapes(e);
      updateAllShapes(e);
    }

    return true;
  }

  function updateDiff(_d, newPos) {
    var max = 50;
    var min = -50;
    _d.labelDiffX = newPos.x;
    _d.labelDiffY = newPos.y; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffX = _d.labelDiffX > max ? max : _d.labelDiffX < min ? min : _d.labelDiffX; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffY = _d.labelDiffY > max ? max : _d.labelDiffY < min ? min : _d.labelDiffY;
  }

  this.setSegmentColor = function (color) {
    modelObj.segmentColor = color;
  };

  this.getSegmentColor = function (color) {
    return modelObj.segmentColor;
  };

  this.updateShape = function (uniqueId, _obj) {
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        shape.shape[i] = _obj[i];
      });
    }
  };

  function updatePointValues(target, values) {
    var update = false;

    if (findDraggable([target])) {
      if (target.isIntersection) {
        if (target.circle1 !== undefined && target.circle2 !== undefined) {
          update = true;
        } else {
          update = true;
        }
      } else {
        update = true;
      }
    }

    if (target.x === values.x && target.y === values.y) {
      update = true;
    }

    if (update) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }

    return update;
  }

  function selectObjectsInPixelRange(x, y, maxX, maxY) {
    if (x > maxX) {
      var temp = x;
      x = maxX;
      maxX = temp;
      temp = y;
      y = maxY;
      maxY = temp;
    }

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var shape = modelObj.interactionElements[i];

      if (shape.type === 'point') {
        if (!shape.isSelected) {
          var pos = getPixelByPoint(shape.x, shape.y);

          if (pos.x >= x && pos.x <= maxX && pos.y >= y && pos.y <= maxY) {
            shape.isSelected = true;
          }
        }
      }
    }
  }

  function updateAllShapes(e) {
    var _modelObj$LabComClass = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass.getDistance,
        getAngle = _modelObj$LabComClass.getAngle,
        getPoint = _modelObj$LabComClass.getPoint,
        pointInSegment = _modelObj$LabComClass.pointInSegment,
        getLineintersect = _modelObj$LabComClass.getLineintersect,
        getLinePointIntersection = _modelObj$LabComClass.getLinePointIntersection;

    var _loop2 = function _loop2(i) {
      var shape = modelObj.interactionElements[i];

      if (shape.type.includes('segment') || shape.type === 'length' || shape.type === 'line' || shape.type === 'ray') {
        var firstPoint, secondPoint;
        var label = null;

        if (shape.firstPointId) {
          firstPoint = findShape(shape.firstPointId);

          if (firstPoint) {
            label = firstPoint.shape.label;
            updateShapeValue(shape, {
              x: firstPoint.shape.x,
              y: firstPoint.shape.y
            });
          }
        }

        if (shape.secondPointId) {
          secondPoint = findShape(shape.secondPointId);

          if (secondPoint) {
            if (label) {
              label += secondPoint.shape.label;

              if (shape.label === undefined) {
                shape.label = label;
              }
            }

            updateShapeValue(shape, {
              xTo: secondPoint.shape.x,
              yTo: secondPoint.shape.y
            });
          }
        }

        if (shape.type === 'line' || shape.type === 'ray') {
          updateLinePoints(shape);
        }

        if (shape.type.includes('segment')) {
          var distancePos = {
            x: (shape.x + shape.xTo) / 2,
            y: (shape.y + shape.yTo) / 2
          };
          shape.labelX = distancePos.x;
          shape.labelY = distancePos.y;
          shape.distance = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        }

        if (shape.type.includes('segment') && shape.firstPointId && shape.secondPointId) {
          if (firstPoint.shape.visible && secondPoint.shape.visible) {
            shape.visible = true;
          } else {
            shape.visible = false;
          }
        }

        if (shape.type === 'length') {
          var text = '';

          if (shape.segmentID) {
            var segment = findShape(shape.segmentID);

            if (segment && segment.shape) {
              shape.x = segment.shape.x;
              shape.xTo = segment.shape.xTo;
              shape.y = segment.shape.y;
              shape.yTo = segment.shape.yTo;

              var _firstPoint = findShape(segment.shape.firstPointId);

              var _secondPoint = findShape(segment.shape.secondPointId);

              if (_firstPoint && _firstPoint.shape && _secondPoint && _secondPoint.shape) {
                if (_firstPoint.shape.label !== '' && _secondPoint.shape.label !== '') {
                  text = _firstPoint.shape.label + '' + _secondPoint.shape.label;
                }
              } else if (segment.shape.label) {
                text = segment.shape.label;
              }
            }
          } else if (shape.circleId) {
            var circle = findShape(shape.circleId);

            if (circle && circle.shape) {
              shape.x = circle.shape.x;
              shape.xTo = circle.shape.x + circle.shape.r;
              shape.y = circle.shape.y;
              shape.yTo = circle.shape.y;
              text = 'C';
            }
          } else {
            if (!shape.labelText) {
              var _firstPoint2 = findShape(shape.firstPointId);

              var _secondPoint2 = findShape(shape.secondPointId);

              if (_firstPoint2 && _firstPoint2.shape && _secondPoint2 && _secondPoint2.shape) {
                if (_firstPoint2.shape.label !== '' && _secondPoint2.shape.label !== '') {
                  text = _firstPoint2.shape.label + '' + _secondPoint2.shape.label;
                }
              }
            } else {
              text = shape.labelText;
            }
          }

          if (shape.circleId !== undefined) {
            shape.circumference = 2 * Math.PI * (shape.xTo - shape.x); //Circumference

            if (modelObj.shapes.length.digit !== undefined) {
              shape.circumference = Number(shape.circumference.toFixed(modelObj.shapes.length.digit));
            }

            var _distancePos = {
              x: shape.pointX,
              y: shape.pointY
            };

            if (text && !modelObj.shapes.length.onlyDistance) {
              shape.label = "".concat(text, " = ") + shape.circumference.toString().replace('.', ',');
            } else if (text && modelObj.shapes.length.onlyDistance) {
              shape.label = shape.circumference.toString().replace('.', ',');
              shape.distanceText = shape.circumference;
            }

            shape.labelX = _distancePos.x;
            shape.labelY = _distancePos.y;

            if (shape.labelDiffX === undefined) {
              shape.labelDiffX = 0;
              shape.labelDiffY = 0;
            }
          } else {
            shape.distance = getDistance(shape, {
              x: shape.xTo,
              y: shape.yTo
            });

            if (modelObj.shapes.length.digit !== undefined) {
              shape.distance = Number(shape.distance.toFixed(modelObj.shapes.length.digit));
            }

            var _distancePos2 = {
              x: (shape.x + shape.xTo) / 2,
              y: (shape.y + shape.yTo) / 2
            };

            if (text && !modelObj.shapes.length.onlyDistance) {
              shape.label = "\xA7d".concat(text, "\xA7r = ") + shape.distance.toString().replace('.', ',');
            } else if (text && modelObj.shapes.length.onlyDistance) {
              shape.label = shape.distance.toString().replace('.', ',');
              shape.labelFor = text;
              shape.distanceText = shape.distance;
            } else if (text === '' && shape.firstPointId !== undefined && shape.secondPointId !== undefined || shape.segmentID !== undefined) {
              shape.label = shape.distance.toString().replace('.', ',');
            }

            shape.labelX = _distancePos2.x;
            shape.labelY = _distancePos2.y;

            if (shape.labelDiffX === undefined) {
              shape.labelDiffX = 0;
              shape.labelDiffY = 0;
            }
          }
        }
      }

      if (shape.type === 'angleRay') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint3 = findShape(shape.firstPointId).shape;
          var _secondPoint3 = findShape(shape.secondPointId).shape;
          var thirdPoint;

          if (shape.thirdPointId !== undefined) {
            thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            thirdPoint = shape.thirdPoint;
          }

          if (thirdPoint) {
            shape.x = _secondPoint3.x;
            shape.y = _secondPoint3.y;
            var firstRay = new modelObj.LabComClass.Vector(_secondPoint3.x - _firstPoint3.x, _secondPoint3.y - _firstPoint3.y);
            var secondRay = new modelObj.LabComClass.Vector(thirdPoint.x - _firstPoint3.x, thirdPoint.y - _firstPoint3.y);
            shape.angle = secondRay.crossProduct(firstRay).z; // shape.angle *= (Math.PI / 180);
            // if (shape.angle < 0) {
            //   shape.angle += (Math.PI * 2);
            // }

            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, thirdPoint.x, thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, _firstPoint3.x, _firstPoint3.y);
            var angle = shape.endAngle - shape.startAngle;

            if (angle < 0) {
              angle = angle * -1 * 180 / Math.PI;
            } else if (angle > 0) {
              angle = 360 - angle * 180 / Math.PI;
            }

            shape.labelX = shape.x + getPointUnitByPixelUnit(10);
            shape.labelY = shape.y - getPointUnitByPixelUnit(10);
            shape.angleText = '' + Math.round(angle);
            shape.angleValue = Math.round(angle);
          }
        }
      }

      if (shape.type === 'angleB') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var fp = findShape(shape.firstPointId).shape;
          var sp = findShape(shape.secondPointId).shape;
          var tp;

          if (shape.thirdPointId !== undefined) {
            tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            tp = shape.thirdPoint;
          }

          if (tp) {
            var angleBisectorData = calculateBisector({
              firstPoint: fp,
              secondPoint: sp,
              thirdPoint: tp
            });
            shape.x = angleBisectorData.bisectorLine.x;
            shape.y = angleBisectorData.bisectorLine.y;
            shape.xTo = angleBisectorData.bisectorLine.xTo;
            shape.yTo = angleBisectorData.bisectorLine.yTo;
          }
        }
      }

      if (shape.type === 'mirrorOnLine') {
        if (shape.line !== undefined && shape.linePlotted) {
          var eqnLine = computeEqn(shape.line);
          var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, shape.x, shape.y);
          shape.x = mirrorPoint.x;
          shape.y = mirrorPoint.y;
        }
      }

      if (shape.type === 'circle_3') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _fp9 = findShape(shape.firstPointId).shape;
          var _sp = findShape(shape.secondPointId).shape;

          var _tp;

          if (shape.thirdPointId !== undefined) {
            _tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _tp = shape.thirdPoint;
          }

          if (_tp) {
            var cData = circle3Handler(_fp9, _sp, _tp);
            shape.x = cData.x;
            shape.y = cData.y;
            shape.r = cData.r;
          }
        }
      }

      if (shape.type === 'angle') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint4 = findShape(shape.firstPointId).shape;
          var _secondPoint4 = findShape(shape.secondPointId).shape;

          var _thirdPoint;

          if (shape.thirdPointId !== undefined) {
            _thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _thirdPoint = shape.thirdPoint;
          }

          if (_thirdPoint) {
            shape.x = _secondPoint4.x;
            shape.y = _secondPoint4.y;

            var _firstRay = new modelObj.LabComClass.Vector(_secondPoint4.x - _firstPoint4.x, _secondPoint4.y - _firstPoint4.y);

            var _secondRay = new modelObj.LabComClass.Vector(_thirdPoint.x - _firstPoint4.x, _thirdPoint.y - _firstPoint4.y);

            shape.angle = _secondRay.crossProduct(_firstRay).z;
            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y);

            var _angle3 = shape.endAngle - shape.startAngle;

            if (_angle3 < 0) {
              _angle3 = _angle3 * -1 * 180 / Math.PI;
            } else if (_angle3 > 0) {
              _angle3 = 360 - _angle3 * 180 / Math.PI;
            }

            shape.angleText = '' + Math.round(_angle3);
            shape.angleValue = Math.round(_angle3);
            shape.labelX = shape.x + getPointUnitByPixelUnit(10);
            shape.labelY = shape.y - getPointUnitByPixelUnit(10);
          }
        }
      }

      if (shape.type === 'midPoint') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint5 = findShape(shape.firstPointId).shape;
          var _secondPoint5 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint5.x + _secondPoint5.x) / 2;
          shape.y = (_firstPoint5.y + _secondPoint5.y) / 2;
        }
      } else if (shape.type === 'triangle') {
        var _firstPoint6 = findShape(shape.firstPointId).shape;
        var _secondPoint6 = findShape(shape.secondPointId).shape;
        var _thirdPoint2 = findShape(shape.thirdPointId).shape;

        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined && shape.thirdPointId !== undefined) {
          shape.firstPoint = {
            x: _firstPoint6.x,
            y: _firstPoint6.y,
            label: _firstPoint6.label
          };
          shape.secondPoint = {
            x: _secondPoint6.x,
            y: _secondPoint6.y,
            label: _secondPoint6.label
          };
          shape.thirdPoint = {
            x: _thirdPoint2.x,
            y: _thirdPoint2.y,
            label: _thirdPoint2.label
          };
          shape.firstSegmentPlotted = true;
          shape.secondSegmentPlotted = true;
          shape.thirdSegmentPlotted = true;
        }
      } else if (shape.type === 'compass') {
        if (shape.segmentID !== undefined) {
          var _segment = findShape(shape.segmentID);

          if (_segment && _segment.shape) {
            shape.r = getDistance(_segment.shape, {
              x: _segment.shape.xTo,
              y: _segment.shape.yTo
            });
          }
        } else if (shape.circleID !== undefined) {
          var _circle = findShape(shape.circleID);

          if (_circle) {
            shape.r = _circle.shape.r;
          }
        } else if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint7 = findShape(shape.firstPointId);

          var _secondPoint7 = findShape(shape.secondPointId);

          if (_firstPoint7 && _secondPoint7) {
            shape.r = getDistance(_firstPoint7.shape, _secondPoint7.shape);
          }
        } else {
          shape.r = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        }

        if (shape.centerPointId !== undefined) {
          var centerPoint = findShape(shape.centerPointId).shape;

          if (centerPoint) {
            updateShapeValue(shape, {
              x: centerPoint.x,
              y: centerPoint.y
            });
          }
        } // shape.r = getDistance(shape, { x: shape.xTo, y: shape.yTo });

      } else if (shape.type === 'point' && modelObj.interactionType !== 'angle') {
        if (shape.firstPointPlotted && shape.secondPointPlotted && !shape.onSegment) {
          var _firstPoint8 = findShape(shape.firstPointId).shape;
          var _secondPoint8 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint8.x + _secondPoint8.x) / 2;
          shape.y = (_firstPoint8.y + _secondPoint8.y) / 2;
        }

        if (shape.onSegment) {
          shape.x = (shape.firstPointCoords.x + shape.secondPointCoords.x) / 2;
          shape.y = (shape.firstPointCoords.y + shape.secondPointCoords.y) / 2;
        }

        if (shape.isIntersection) {
          if (shape.l1 !== undefined && shape.l2 !== undefined) {
            var l1 = findShape(shape.l1);
            var l2 = findShape(shape.l2);

            if (l1 && l2) {
              l1 = l1.shape;
              l2 = l2.shape;
              var p = getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);

              if (!p.onLine1 && l1.type.includes('segment') || !p.onLine2 && l2.type.includes('segment')) {
                shape.visible = false;
              } else {
                shape.visible = true;
              }

              updateShapeValue(shape, {
                x: p.x,
                y: p.y
              });
            }
          }

          if (shape.circle !== undefined && shape.line !== undefined) {
            var _circle2 = findShape(shape.circle);

            var line = findShape(shape.line);

            if (_circle2 && line) {
              _circle2 = _circle2.shape;
              line = line.shape;
              var data = getInteractionOfCircleLine(_circle2, line, shape);

              if (data !== null) {
                updateShapeValue(shape, {
                  x: data.x,
                  y: data.y
                });
                shape.visible = true;
              } else {
                shape.visible = false;
              }
            }
          }

          if (shape.circle1 !== undefined && shape.circle2 !== undefined) {
            var circle1 = findShape(shape.circle1);
            var circle2 = findShape(shape.circle2);

            if (circle1 && circle2) {
              circle1 = circle1.shape;
              circle2 = circle2.shape;

              var _data2 = getInteractionOfTwoCircles(circle1, circle2, shape, false, true);

              if (_data2 && _data2.x !== undefined && !isNaN(_data2.x)) {
                shape.visible = checkForCorrectIntersection(shape, circle1, circle2, _data2);
              } else {
                shape.visible = false;
              }
            }
          }
        }

        if (shape.isParameter && modelObj.shapesEditable) {
          if (shape.line !== undefined) {
            var _line = findShape(shape.line);

            if (_line) {
              _line = _line.shape;
              var dist = getDistance(_line, {
                x: _line.xTo,
                y: _line.yTo
              });
              var lineAngle = getAngle(_line.x, _line.y, _line.xTo, _line.yTo);
              var newData = {};
              var distFromFirstPoint = shape.pointAngle ? dist * shape.percentage : dist * shape.percentage * -1;

              if (e && shape.isSelected && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown) {
                var mouse = getPointByPixel(e.pageX, e.pageY);
                var intersection = getLinePointIntersection(_line, {
                  x: _line.xTo,
                  y: _line.yTo
                }, mouse);
                var intersectionDist = getDistance(_line, intersection);
                newData.pointAngle = getAngle(_line.x, _line.y, intersection.x, intersection.y);
                newData.pointAngle = Math.round(newData.pointAngle) === Math.round(lineAngle);
                newData.percentage = intersectionDist / dist;
                distFromFirstPoint = newData.pointAngle ? dist * newData.percentage : dist * newData.percentage * -1;
              }

              var _p8 = getPoint(_line, lineAngle, distFromFirstPoint);

              newData.x = _p8.x;
              newData.y = _p8.y;
              var setValues = true;

              if (_line.type.includes('segment') || _line.type === 'ray') {
                var endPoint = {
                  x: _line.xTo,
                  y: _line.yTo
                };

                if (_line.type === 'ray') {
                  endPoint = {
                    x: _line.xOr,
                    y: _line.yOr
                  };
                }

                setValues = pointInSegment(_p8, _line, endPoint);

                if (!setValues) {
                  var dist1 = getDistance(_p8, _line);
                  var dist2 = getDistance(_p8, endPoint);

                  if (dist1 < dist2) {
                    newData.x = _line.x;
                    newData.y = _line.y;
                  } else {
                    newData.x = endPoint.x;
                    newData.y = endPoint.y;
                  }
                }
              }

              Object.keys(newData).forEach(function (i) {
                shape[i] = newData[i];
              });
            }
          }

          if (shape.circle !== undefined) {
            var _circle3 = findShape(shape.circle);

            if (_circle3) {
              _circle3 = _circle3.shape;

              if (e && shape.isSelected && localObj.mouseDown.objectDown) {
                var _mouse = getPointByPixel(e.pageX, e.pageY);

                shape.angle = getAngle(_circle3.x, _circle3.y, _mouse.x, _mouse.y);
              }

              var newP = getPoint(_circle3, shape.angle, _circle3.r);
              updateShapeValue(shape, {
                x: newP.x,
                y: newP.y
              });
            }
          }
        }

        for (var j = 0; j < shape.connectionId.length; j++) {
          var shapeData = findShape(shape.connectionId[j]);

          if (shapeData.shape) {
            if (shapeData.shape.type === 'perpendicularLine' || shapeData.shape.type === 'parallelLine') {
              shapeData.shape.visible = shape.visible;
              updateShapeValue(shapeData.shape, {
                x: shape.x,
                y: shape.y
              });
              updatePLinePoints(shapeData.shape);
            } else if (shapeData.shape.type === 'circle') {
              updateCircle(shapeData.shape);
            }
          }
        }
      } else if (shape.type === 'perpendicularLine' || shape.type === 'parallelLine') {
        updatePLinePoints(shape);
      } else if (shape.type === 'circle') {
        updateCircle(shape);
      }

      if (shape && shape.label !== undefined) {
        if (shape.labelX === undefined) {
          shape.labelX = shape.x;
          shape.labelY = shape.y;
        }

        if (shape.labelDiffX === undefined) {
          shape.labelDiffX = 0;
          shape.labelDiffY = 0;
        }
      }
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      _loop2(i);
    }
  }

  function circle3Handler(fp, sp, tp) {
    var p1 = {},
        p2 = {},
        coords = {};
    p1.x = (fp.x + sp.x) / 2;
    p1.y = (fp.y + sp.y) / 2;
    p2.x = (sp.x + tp.x) / 2;
    p2.y = (sp.y + tp.y) / 2;
    p1.m = to2Dec((sp.y - fp.y) / (sp.x - fp.x));
    p2.m = to2Dec((tp.y - sp.y) / (tp.x - sp.x));
    p1.slope = to2Dec(-1 / p1.m);
    p2.slope = to2Dec(-1 / p2.m);
    var p1Val = getPLineCoeff(p1); // getPerpendicular Line

    var p2Val = getPLineCoeff(p2); // getPerpendicular Line

    coords.x = (p1Val.b * p2Val.c - p2Val.b * p1Val.c) / (p1Val.a * p2Val.b - p2Val.a * p1Val.b);
    coords.y = (p1Val.c * p2Val.a - p2Val.c * p1Val.a) / (p1Val.a * p2Val.b - p2Val.a * p1Val.b);
    coords.r = modelObj.LabComClass.Maths.getDistance(coords, fp);
    return {
      x: coords.x,
      y: coords.y,
      r: coords.r
    };
  }

  function getPLineCoeff(p) {
    var eqn = {};

    if (!isFinite(p.slope)) {
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -p.x;
    } else {
      eqn.eqn = "(y-".concat(p.y, "=").concat(p.slope, "(x-").concat(p.x, "))");
      eqn.a = -p.slope;
      eqn.b = 1;
      eqn.c = to2Dec(-p.slope * -p.x - p.y);
    }

    return eqn;
  }

  function circle3HandlerOld(fp, sp, tp) {
    var p1 = {},
        p2 = {},
        coords = {};
    p1.x = (fp.x + sp.x) / 2;
    p1.y = (fp.y + sp.y) / 2;
    p2.x = (sp.x + tp.x) / 2;
    p2.y = (sp.y + tp.y) / 2;
    p1.m = to2Dec((sp.y - fp.y) / (sp.x - fp.x));
    p2.m = to2Dec((tp.y - sp.y) / (tp.x - sp.x));
    p1.slope = to2Dec(-1 / p1.m);
    p2.slope = to2Dec(-1 / p2.m);
    p1.eqn = "(y-".concat(p1.y, "=").concat(p1.slope, "(x-").concat(p1.x, "))");
    p1.a = -p1.slope;
    p1.b = 1;
    p1.c = to2Dec(-p1.slope * -p1.x - p1.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    p2.eqn = "(y-".concat(p2.y, "=").concat(p2.slope, "(x-").concat(p2.x, "))");
    p2.a = -p2.slope;
    p2.b = 1;
    p2.c = to2Dec(-p2.slope * -p2.x - p2.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    coords.x = (p1.b * p2.c - p2.b * p1.c) / (p1.a * p2.b - p2.a * p1.b);
    coords.y = (p1.c * p2.a - p2.c * p1.a) / (p1.a * p2.b - p2.a * p1.b);
    coords.r = modelObj.LabComClass.Maths.getDistance(coords, fp);
    return {
      x: coords.x,
      y: coords.y,
      r: coords.r
    };
  }

  function to2Dec(num) {
    return Math.round(num * 100) / 100;
  }

  function updateCircle(shape) {
    if (shape.type === 'circle') {
      if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
        var firstPoint = findShape(shape.firstPointId);
        var secondPoint = findShape(shape.secondPointId);

        if (firstPoint && secondPoint) {
          shape.x = firstPoint.shape.x;
          shape.y = firstPoint.shape.y;
          shape.r = modelObj.LabComClass.Maths.getDistance(firstPoint.shape, secondPoint.shape);
        }
      }
    }
  }

  function checkForCorrectIntersection(currentShape, circle1, circle2, newData) {
    var Vector = modelObj.LabComClass.Vector;

    if (currentShape.visible) {
      currentShape.x = newData.x;
      currentShape.y = newData.y;

      var _centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);

      var _firstIntersectLine = new Vector(newData.x - circle1.x, newData.y - circle1.y);

      currentShape.angle1 = _centerPointsLine.crossProduct(_firstIntersectLine).z;
      return true;
    }

    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length < 2) {
      return false;
    }

    if (modelObj.LabComClass.Maths.getDistance(intersection[0], intersection[1]) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      return false;
    }

    var centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);
    var firstIntersectLine = new Vector(intersection[0].x - circle1.x, intersection[0].y - circle1.y); // const secondIntersectLine = new Vector(intersection[1].x - circle1.x, intersection[1].y - circle1.y);

    var angle1 = centerPointsLine.crossProduct(firstIntersectLine).z; // const angle2 = centerPointsLine.crossProduct(secondIntersectLine).z;

    if (currentShape.angle1 < 0 && angle1 < 0 || currentShape.angle1 > 0 && angle1 > 0) {
      // currentShape.intersectAngle = angle1;
      currentShape.x = intersection[0].x;
      currentShape.y = intersection[0].y;
    } else {
      // currentShape.intersectAngle = angle2;
      currentShape.x = intersection[1].x;
      currentShape.y = intersection[1].y;
    }

    return true;
  } // vertical intsectin is not getting detected in circle line intersect


  function findCircleLineIntersect(circle, line) {
    return modelObj.LabComClass.Maths.findCircleLineIntersect({
      x: circle.x,
      y: circle.y,
      r: circle.r
    }, {
      x: line.x,
      y: line.y
    }, {
      x: line.xTo,
      y: line.yTo
    });
  }

  function findDraggable(elems) {
    var draggable = true;

    if (Array.isArray(elems)) {
      for (var i = 0; i < elems.length; i++) {
        if (elems[i] === undefined || !(elems[i].isDraggable === undefined || elems[i].isDraggable)) {
          draggable = false;
          break;
        }
      }
    } else if (!(elems.isDraggable === undefined || elems.isDraggable)) {
      draggable = false;
    }

    return draggable;
  }

  function updateShapeValue(target, values) {
    if (target.isDraggable === undefined || target.isDraggable) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }
  }

  function updateShapes(parentShape, _diffX, _diffY) {
    var otherShapes = parentShape.connectionId;

    for (var i = 0; i < otherShapes.length; i++) {
      var shape = findShape(otherShapes[i]).shape;

      if (shape === undefined || shape === false || shape.isMoved) {
        continue;
      }

      shape.isMoved = true;

      if (shape.type === 'point') {
        var draggable = true;

        if (!shape.isSelected && shape.connectionId.length) {
          for (var j = 0; j < shape.connectionId.length; j++) {
            var connectedShape = findShape(shape.connectionId[j]).shape;

            if (connectedShape && (connectedShape.type === 'line' || connectedShape.type === 'ray' || connectedShape.type.includes('segment'))) {
              var checkId = connectedShape.firstPointId === shape.uniqueId ? connectedShape.secondPointId : connectedShape.firstPointId;
              var connectedPoint = findShape(checkId);

              if (connectedPoint && connectedPoint.shape) {
                if (!(connectedPoint.shape.isDraggable === undefined || connectedPoint.shape.isDraggable === true)) {
                  draggable = false;
                }
              }
            }
          }
        }

        if (draggable) {
          updateShapeValue(shape, {
            x: shape.x + _diffX,
            y: shape.y + _diffY
          });
        }
      } else if (shape.type === 'line' || shape.type === 'ray' || shape.type.includes('segment')) {
        if (shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        } else {
          shape.xTo = parentShape.x;
          shape.yTo = parentShape.y;
        }

        if (shape.type === 'line' || shape.type === 'ray') {
          updateLinePoints(shape);
        }
      } else if (shape.type === 'perpendicularLine' || shape.type === 'parallelLine') {
        if (parentShape.type === 'point') {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
          updatePLinePoints(shape);
        }
      } else if (shape.type === 'circle') {
        if (parentShape.type === 'point' && shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        }
      }
    }
  }

  function findShape(uniqueId) {
    var shapesData = modelObj.interactionElements;

    for (var i = shapesData.length - 1; i >= 0; i--) {
      if (shapesData[i] && shapesData[i].uniqueId === uniqueId) {
        return {
          index: i,
          shape: shapesData[i]
        };
      }
    }

    return false;
  } // =================================================


  function onMouseUp(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    var _ctx = modelObj.context;
    _ctx.font = "".concat(modelObj.fontSize, "px ").concat(modelObj.LabComClass.polo22KlettRegular);
    var value = {
      type: tool
    };
    var _it = tool;
    var dataAvailable = false;
    var point = getPointByPixel(e.pageX, e.pageY);
    var currentShape = localObj.currentUniqueId !== null && findShape(localObj.currentUniqueId).shape;

    if (!localObj.mouseDown.lastShapeCompleted && localObj.currentUniqueId == null) {
      currentShape = findShape(localObj.uniqueId).shape;
    }

    point = checkSnapping(point);
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));
    var clickingOnExistingPointID = null;

    if (clickingOnExistingPoint !== null) {
      clickingOnExistingPointID = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    if (clickingOnExistingPointID !== null) {
      if (_it !== 'select' && _it !== 'move' && _it !== 'moveGraph' && currentShape) {
        currentShape.isSelected = false;
      }
    }

    var pointOnGraph = point !== null;

    if (_it === 'point' && currentShape && pointOnGraph) {
      var _point2 = getPointByPixel(e.pageX, e.pageY);

      var _currentShape2 = localObj.currentUniqueId !== null && findShape(localObj.currentUniqueId).shape;

      if (!localObj.mouseDown.lastShapeCompleted && localObj.currentUniqueId == null) {
        _currentShape2 = findShape(localObj.uniqueId).shape;
      }

      _point2 = checkSnapping(_point2);
      clickingOnExistingPoint = checkPointv2(getPointByPixel(e.pageX, e.pageY));
      clickingOnExistingPointID = null;

      if (clickingOnExistingPoint !== null) {
        clickingOnExistingPointID = shapesData[clickingOnExistingPoint].uniqueId;
        _point2 = shapesData[clickingOnExistingPoint];
      }

      if (clickingOnExistingPointID !== null) {
        if (_it !== 'select' && _it !== 'move' && _it !== 'moveGraph' && _currentShape2) {
          _currentShape2.isSelected = false;
        }
      }

      if (findDraggable([_currentShape2])) {
        // if (updatePointValues(currentShape, {
        //   x: point.x,
        //   y: point.y
        // })) {
        updatePointValues(_currentShape2, _point2);

        if (!modelObj.shapesEditable) {
          _currentShape2.isDraggable = false;
          value.isDraggable = _currentShape2.isDraggable;
        }

        dataAvailable = true;
        value.x = _point2.x;
        value.y = _point2.y;
        value.uniqueId = _currentShape2.uniqueId;

        if (dataAvailable) {
          dataAvailable = checkDataAvailable(_currentShape2, ['x', 'y']);
        } // }


        filterDuplicateInteractionElements();
      } else if (modelObj.plotPointOnExistingPoint) {
        dataAvailable = true;
        var pointId = ++localObj.uniqueId;
        value.x = _currentShape2.x;
        value.y = _currentShape2.y;
        addPoint(_point2, {
          uniqueId: pointId,
          connectionId: [_currentShape2.uniqueId]
        });
        value.uniqueId = pointId;
      }
    } else if (currentShape && (_it.includes('segment') || _it === 'length' || _it === 'line' || _it === 'ray') && pointOnGraph) {
      if (findDraggable([currentShape])) {
        currentShape.xTo = point.x;
        currentShape.yTo = point.y;
      }

      if (tool === 'line' || tool === 'ray') {
        updateLinePoints(currentShape);
      }

      value.x = currentShape.x;
      value.y = currentShape.y;
      value.xTo = currentShape.xTo;
      value.yTo = currentShape.yTo;
      value.slope = currentShape.slope;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (_it === 'length' && (currentShape.circleId !== undefined || currentShape.segmentID !== undefined)) {
        if (currentShape.circleId) {
          var circle = findShape(currentShape.circleId).shape;
          circle.isSelected = false;
        } else if (currentShape.segmentID) {
          var segment = findShape(currentShape.segmentID).shape;
          segment.isSelected = false;
        }
      }

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ['x', 'y', 'xTo', 'yTo']);
      }

      if (clickingOnExistingPoint === null) {
        if (_it !== 'length') {
          var secondPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: secondPointId,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = secondPointId;
          currentShape.connectionId.push(secondPointId);
        } else if (currentShape.firstPointId !== undefined) {
          if (localObj.newPlottedShapes.length > 0) {
            shapesData.pop();
          }
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        if (_it !== 'length') {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
        }

        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (currentShape && _it === 'angleRay' && pointOnGraph) {
      var angleRay = findShape(currentShape.angleRayId).shape;

      if (!angleRay.firstRayPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var firstPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: firstPointId,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.firstPointId = firstPointId;
          currentShape.connectionId.push(firstPointId);
          angleRay.firstRayPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          angleRay.firstRayPlotted = true;
        }

        if (angleRay.firstRayPlotted) {
          angleRay.secondPointId = currentShape.firstPointId;
          addNewShape({
            type: 'ray',
            uniqueId: ++localObj.uniqueId,
            firstPointId: angleRay.secondPointId,
            angleRayId: currentShape.angleRayId,
            x: point.x,
            y: point.y,
            xOr: point.x,
            yOr: point.y,
            xTo: point.x,
            yTo: point.y,
            xOrTo: point.x,
            yOrTo: point.y,
            connectionId: [angleRay.secondPointId]
          });
          localObj.currentUniqueId = localObj.uniqueId;
          angleRay.x = point.x;
          angleRay.y = point.y;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId2 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId2,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = _secondPointId2;
          currentShape.connectionId.push(_secondPointId2);
          angleRay.secondRayPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          angleRay.secondRayPlotted = true;
        }

        if (angleRay.secondRayPlotted) {
          angleRay.thirdPointId = currentShape.secondPointId;
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleRay.secondRayPlotted) {
        var firstPoint = findShape(angleRay.firstPointId).shape;
        var secondPoint = findShape(angleRay.secondPointId).shape;
        var thirdPoint = findShape(angleRay.thirdPointId).shape;
        value.firstPoint = {
          x: firstPoint.x,
          y: firstPoint.y,
          label: firstPoint.label
        };
        value.secondPoint = {
          x: secondPoint.x,
          y: secondPoint.y,
          label: secondPoint.label
        };
        value.thirdPoint = {
          x: thirdPoint.x,
          y: thirdPoint.y,
          label: thirdPoint.label
        };
        value.x = secondPoint.x;
        value.y = secondPoint.y;
        var angleData = calculateAngle(value, 'angleRay');
        value.angle = angleData.angle;
        value.angleValue = angleData.angleValue;
        angleRay.label = angleData.angleText;
        angleRay.labelX = angleRay.x + getPointUnitByPixelUnit(10);
        angleRay.labelY = angleRay.y - getPointUnitByPixelUnit(10);
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'triangle' && pointOnGraph) {
      var triangle = findShape(currentShape.triangleId).shape;

      if (!triangle.firstSegmentPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var _firstPointId19 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId19,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.firstPointId = _firstPointId19;
          currentShape.connectionId.push(_firstPointId19);
          triangle.firstSegmentPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          triangle.firstSegmentPlotted = true;
        }

        if (triangle.firstSegmentPlotted) {
          triangle.secondPointId = currentShape.firstPointId;
          addNewShape({
            type: 'segment',
            uniqueId: ++localObj.uniqueId,
            firstPointId: triangle.secondPointId,
            triangleId: currentShape.triangleId,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y,
            connectionId: [triangle.secondPointId]
          });
          localObj.newPlottedShapes.push(localObj.uniqueId);
          localObj.currentUniqueId = localObj.uniqueId;
          triangle.x = point.x;
          triangle.y = point.y;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId3 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId3,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = _secondPointId3;
          currentShape.connectionId.push(_secondPointId3);
          triangle.secondSegmentPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID || triangle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          triangle.secondSegmentPlotted = true;
        }
      }

      if (triangle.secondSegmentPlotted) {
        var _secondPoint9 = findShape(triangle.firstPointId).shape;
        triangle.thirdPointId = currentShape.secondPointId;
        addNewShape({
          type: 'segment',
          uniqueId: ++localObj.uniqueId,
          firstPointId: triangle.thirdPointId,
          secondPointId: triangle.firstPointId,
          triangleId: currentShape.triangleId,
          x: point.x,
          y: point.y,
          xTo: _secondPoint9.x,
          yTo: _secondPoint9.y,
          connectionId: [triangle.thirdPointId, triangle.firstPointId]
        });
        localObj.newPlottedShapes.push(localObj.uniqueId);
        localObj.currentUniqueId = localObj.uniqueId;
        triangle.x = point.x;
        triangle.y = point.y;
        triangle.thirdSegmentPlotted = true;
        localObj.mouseDown.lastShapeCompleted = true;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (triangle.thirdSegmentPlotted) {
        var _firstPoint9 = findShape(triangle.firstPointId).shape;
        var _secondPoint10 = findShape(triangle.secondPointId).shape;
        var _thirdPoint3 = findShape(triangle.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint9.x,
          y: _firstPoint9.y,
          label: _firstPoint9.label
        };
        value.secondPoint = {
          x: _secondPoint10.x,
          y: _secondPoint10.y,
          label: _secondPoint10.label
        };
        value.thirdPoint = {
          x: _thirdPoint3.x,
          y: _thirdPoint3.y,
          label: _thirdPoint3.label
        };
        value.x = _secondPoint10.x;
        value.y = _secondPoint10.y;
        value.uniqueId = triangle.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'circle_3' && pointOnGraph) {
      var circle3;

      if (currentShape.type !== 'circle_3') {
        circle3 = findShape(currentShape.circleId).shape;
      } else {
        circle3 = currentShape;
      }

      if (!circle3.firstPointPlotted) {
        dataAvailable = false;
        var fp = findShape(circle3.firstPointId).shape;
        fp.isSelected = true;

        if (clickingOnExistingPoint === null) {
          var _secondPointId4 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId4,
            connectionId: [circle3.uniqueId],
            circleId: circle3.uniqueId
          });
          circle3.secondPointId = _secondPointId4;
          circle3.firstPointPlotted = true;
          var _fp10 = findShape(circle3.firstPointId).shape;
          _fp10.isSelected = true;
          var sp = findShape(circle3.secondPointId).shape;
          sp.isSelected = true;
        } else if (circle3.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(circle3.uniqueId);
          point.circle3Id = circle3.uniqueId;
          circle3.secondPointId = clickingOnExistingPointID;
          circle3.firstPointPlotted = true;
          var _fp11 = findShape(circle3.firstPointId).shape;
          _fp11.isSelected = true;
          var _sp2 = findShape(circle3.secondPointId).shape;
          _sp2.isSelected = true;
        }

        if (circle3.firstPointPlotted) {
          circle3.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          circle3.x = point.x;
          circle3.y = point.y;
          var _fp12 = findShape(circle3.firstPointId).shape;
          _fp12.isSelected = true;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var thirdPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: thirdPointId,
            connectionId: [circle3.uniqueId]
          });
          var _sp3 = findShape(circle3.secondPointId).shape;
          _sp3.isSelected = true;
          circle3.thirdPointId = thirdPointId;
          circle3.thirdPointPloted = true;
        } else if (circle3.secondPointId === clickingOnExistingPointID || circle3.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(circle3.uniqueId);
          circle3.thirdPointId = clickingOnExistingPointID;
          circle3.thirdPointPloted = true;
        }

        if (circle3.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (circle3.thirdPointPloted) {
        var _firstPoint10 = findShape(circle3.firstPointId).shape;
        var _secondPoint11 = findShape(circle3.secondPointId).shape;
        var _thirdPoint4 = findShape(circle3.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint10.x,
          y: _firstPoint10.y
        };
        value.secondPoint = {
          x: _secondPoint11.x,
          y: _secondPoint11.y
        };
        value.thirdPoint = {
          x: _thirdPoint4.x,
          y: _thirdPoint4.y
        };
        var circleData = computeCircle(value);
        var _fp13 = findShape(circle3.firstPointId).shape;
        _fp13.isSelected = false;
        var _sp4 = findShape(circle3.secondPointId).shape;
        _sp4.isSelected = false;
        var tp = findShape(circle3.thirdPointId).shape;
        tp.isSelected = false;
        value.r = circleData.r;
        value.x = circleData.x;
        value.y = circleData.y;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'angle' && pointOnGraph) {
      var angle;

      if (currentShape.type === 'point') {
        angle = findShape(currentShape.angleId).shape;
      } else {
        angle = findShape(currentShape.uniqueId).shape;
      }

      if (!angle.firstPointPlotted) {
        dataAvailable = false;
        var _fp14 = findShape(angle.firstPointId).shape;
        _fp14.isSelected = true;

        if (clickingOnExistingPoint === null) {
          var _secondPointId5 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId5,
            connectionId: [angle.uniqueId],
            angleId: currentShape.angleId
          });
          var _fp15 = findShape(angle.firstPointId).shape;
          _fp15.isSelected = true;
          var _sp5 = findShape(_secondPointId5).shape;
          _sp5.isSelected = true;
          angle.secondPointId = _secondPointId5;
          angle.firstPointPlotted = true;
        } else if (angle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(angle.uniqueId);
          point.angleId = currentShape.angleId;
          angle.secondPointId = clickingOnExistingPointID;
          angle.firstPointPlotted = true;
          var _sp6 = findShape(angle.secondPointId).shape;
          _sp6.isSelected = true;
        }

        if (angle.firstPointPlotted) {
          angle.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          angle.x = point.x;
          angle.y = point.y;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var _thirdPointId = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _thirdPointId,
            connectionId: [angle.uniqueId],
            angleId: angle.uniqueId
          });
          angle.thirdPointId = _thirdPointId;
          angle.thirdPointPloted = true;
        } else if (angle.secondPointId === clickingOnExistingPointID || angle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(angle.uniqueId);
          angle.thirdPointId = clickingOnExistingPointID;
          point.angleId = angle.uniqueId;
          angle.thirdPointPloted = true;
        }

        if (angle.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angle.thirdPointPloted) {
        var _firstPoint11 = findShape(angle.firstPointId).shape;
        var _secondPoint12 = findShape(angle.secondPointId).shape;
        var _thirdPoint5 = findShape(angle.thirdPointId).shape;
        _firstPoint11.isSelected = false;
        _secondPoint12.isSelected = false;
        _thirdPoint5.isSelected = false;
        value.firstPoint = {
          x: _firstPoint11.x,
          y: _firstPoint11.y,
          label: _firstPoint11.label
        };
        value.secondPoint = {
          x: _secondPoint12.x,
          y: _secondPoint12.y,
          label: _secondPoint12.label
        };
        value.thirdPoint = {
          x: _thirdPoint5.x,
          y: _thirdPoint5.y,
          label: _thirdPoint5.label
        };
        value.x = _secondPoint12.x;
        value.y = _secondPoint12.y;

        var _angleData = calculateAngle(value);

        value.angle = _angleData.angle;
        value.angleValue = _angleData.angleValue;
        angle.label = _angleData.angleText;
        angle.labelX = angle.x + getPointUnitByPixelUnit(10);
        angle.labelY = angle.y - getPointUnitByPixelUnit(10);
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'angleB' && pointOnGraph && localObj.newShapeStarted) {
      var angleB;

      if (currentShape.type === 'point') {
        angleB = findShape(currentShape.angleBId).shape;
      } else {
        angleB = findShape(currentShape.uniqueId).shape;
      }

      if (angleB.mode === 'point') {
        var _angleB, _angleB2;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB = angleB) === null || _angleB === void 0 ? void 0 : _angleB.firstPointPlotted)) {
          dataAvailable = false;

          if (clickingOnExistingPoint === null || angleB.firstPointId === clickingOnExistingPointID) {
            ;
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            point.angleBId = currentShape.uniqueId;
            angleB.secondPointId = clickingOnExistingPointID;
            angleB.firstPointPlotted = true;
            shapesData[clickingOnExistingPoint].isSelected = true;
          }

          if (angleB.firstPointPlotted) {
            angleB.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }
        } else {
          if (clickingOnExistingPoint === null || angleB.secondPointId === clickingOnExistingPointID || angleB.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            angleB.thirdPointId = clickingOnExistingPointID;
            point.angleBId = currentShape.uniqueId;
            angleB.thirdPointPloted = true;
            shapesData[clickingOnExistingPoint].isSelected = true;
          }

          if (angleB.thirdPointPloted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if ((_angleB2 = angleB) === null || _angleB2 === void 0 ? void 0 : _angleB2.thirdPointPloted) {
          var _firstPoint12 = findShape(angleB.firstPointId).shape;
          var _secondPoint13 = findShape(angleB.secondPointId).shape;
          var _thirdPoint6 = findShape(angleB.thirdPointId).shape;
          value.firstPoint = {
            x: _firstPoint12.x,
            y: _firstPoint12.y,
            label: _firstPoint12.label
          };
          value.secondPoint = {
            x: _secondPoint13.x,
            y: _secondPoint13.y,
            label: _secondPoint13.label
          };
          value.thirdPoint = {
            x: _thirdPoint6.x,
            y: _thirdPoint6.y,
            label: _thirdPoint6.label
          };
          value.x = _secondPoint13.x;
          value.y = _secondPoint13.y;
          value.uniqueId = angleB.uniqueId;
          var angleBData = calculateBisector(value);
          angleB.firstPoint = value.firstPoint;
          angleB.secondPoint = value.secondPoint;
          angleB.thirdPoint = value.thirdPoint; // addNewShape(angleB.bisectorLine);

          var lineId = addNewShape({
            type: 'line',
            uniqueId: ++localObj.uniqueId,
            x: _secondPoint13.x,
            y: _secondPoint13.y,
            xTo: angleBData.x,
            yTo: angleBData.y,
            slope: getSlope(_secondPoint13.x, _secondPoint13.y, angleBData.x, angleBData.y)
          });
          value.bisectorLine = lineId;
          angleB.bisectorLine = lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(lineId.uniqueId);
          dataAvailable = true;
        }
      } else if (angleB.mode === 'segment') {
        var _angleB3;

        var selectedShapeID = isOnShape(e);
        var selectedShape = findShape(selectedShapeID).shape;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB3 = angleB) === null || _angleB3 === void 0 ? void 0 : _angleB3.firstSegmentPlotted)) {
          dataAvailable = false;

          if (selectedShape !== undefined && selectedShape.type.includes('segment') && selectedShape.uniqueId === angleB.firstSegmentId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (selectedShape !== undefined && selectedShape.type.includes('segment')) {
            selectedShape.angleBId = angleB.uniqueId;
            angleB.secondSegmentId = selectedShape.uniqueId;
            angleB.firstSegmentPlotted = true;
            angleB.secondSegment = {
              x: selectedShape.x,
              y: selectedShape.y,
              xTo: selectedShape.xTo,
              yTo: selectedShape.yTo
            };
            selectedShape.isSelected = true;
          }

          if (angleB.firstSegmentPlotted) {
            angleB.secondSegmentPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }

          if (angleB.secondSegmentPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if (angleB.secondSegmentPlotted) {
          value.firstSegment = angleB.firstSegment;
          value.secondSegment = angleB.secondSegment;
          var pCommon = findCommon(angleB.firstSegment, angleB.secondSegment);
          value.x = +pCommon.x;
          value.y = +pCommon.y;
          angleB.x = +pCommon.x;
          angleB.y = +pCommon.y;
          value.uniqueId = angleB.uniqueId;

          var _angleBData = calculateBisector(value, "segment");

          var _lineId = addNewShape({
            type: 'line',
            uniqueId: ++localObj.uniqueId,
            x: +pCommon.x,
            y: +pCommon.y,
            xTo: _angleBData.x,
            yTo: _angleBData.y,
            slope: getSlope(+pCommon.x, +pCommon.y, _angleBData.x, _angleBData.y)
          });

          value.bisectorLine = _lineId;
          angleB.bisectorLine = _lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(_lineId.uniqueId);
          dataAvailable = true;
        }
      }
    } else if (currentShape && _it === 'angleSize' && pointOnGraph && localObj.newShapeStarted) {
      var angleSize;

      if (currentShape.type === 'point') {
        angleSize = findShape(currentShape.angleSizeId).shape;
      } else {
        angleSize = findShape(currentShape.uniqueId).shape;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleSize.mode === 'point') {
        var _angleSize;

        if (angleSize === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleSize = angleSize) === null || _angleSize === void 0 ? void 0 : _angleSize.firstPointPlotted)) {
          dataAvailable = false;
          point.angleSizeId = angleSize.uniqueId;
          localObj.currentUniqueId = null;
          angleSize.firstPointPlotted = true;
          angleSize.x = point.x;
          angleSize.y = point.y;
          var fpShape = findShape(angleSize.firstPointId).shape;
          fpShape.isSelected = true;
        } else if (!angleSize.secondPointPlotted) {
          if (clickingOnExistingPointID === angleSize.firstPointId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            var _secondPointId6;

            if (clickingOnExistingPointID >= 0 && clickingOnExistingPointID !== null) {
              _secondPointId6 = clickingOnExistingPointID;
              angleSize.connectionId.push(clickingOnExistingPointID);
            } else {
              localObj.mouseDown.lastShapeCompleted = false;
              dataAvailable = false;
            }

            if (_secondPointId6 !== undefined) {
              var _firstPoint13 = findShape(angleSize.firstPointId).shape;
              angleSize.secondPointId = _secondPointId6;
              angleSize.secondPointPlotted = true;
              angleSize.x = point.x;
              angleSize.y = point.y;
              angleSize.xTo = _firstPoint13.x;
              angleSize.yTo = _firstPoint13.y;

              if (angleSize.secondPointId >= 0) {
                var spShape = findShape(_secondPointId6).shape;

                if (spShape) {
                  var _fpShape = findShape(angleSize.firstPointId).shape;
                  _fpShape.isSelected = true;
                  spShape.isSelected = true;
                }
              }

              modelObj.waiting = true;

              if (typeof events.angleSize !== 'undefined') {
                events.angleSize({
                  id: modelObj.id,
                  type: 'angleSize',
                  visible: true,
                  data: JSON.parse(JSON.stringify(angleSize))
                }, true);
              }

              dataAvailable = false;
            }
          }
        } else {
          _this.removeUnplotedShapes();
        }
      } else if (angleSize.mode === 'segment') {
        var _selectedShapeID6 = isOnShape(e);

        var _selectedShape = findShape(_selectedShapeID6).shape;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === 'segSize' && pointOnGraph) {
      var _segSize;

      var segSize;

      if (currentShape.type === 'point') {
        segSize = findShape(currentShape.segSizeId).shape;
      } else {
        segSize = findShape(currentShape.uniqueId).shape;
      } // point.x = currentShape.x;
      // point.y = currentShape.y;


      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (segSize === undefined) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        localObj.mouseDown.isMouseDown = false;
      } else if (!((_segSize = segSize) === null || _segSize === void 0 ? void 0 : _segSize.firstPointPlotted)) {
        dataAvailable = false;
        point.segSizeId = segSize.uniqueId;
        localObj.currentUniqueId = null;
        segSize.firstPointPlotted = true;
        segSize.x = point.x;
        segSize.y = point.y;
        var _fp16 = findShape(segSize.firstPointId).shape;
        _fp16.isSelected = true;

        if (segSize.firstPointPlotted) {
          modelObj.waiting = true;

          if (typeof events.segSize !== 'undefined') {
            events.segSize({
              id: modelObj.id,
              type: 'segSize',
              visible: true,
              data: JSON.parse(JSON.stringify(segSize))
            }, true);
          }

          dataAvailable = false;
        }
      } else {
        _this.removeUnplotedShapes();
      }
    } else if (currentShape && _it === 'circleSize' && pointOnGraph) {
      var _circleSize;

      var circleSize;

      if (currentShape.type === 'point') {
        circleSize = findShape(currentShape.circleSizeId).shape;
      } else {
        circleSize = findShape(currentShape.uniqueId).shape;
      } // point.x = currentShape.x;
      // point.y = currentShape.y;


      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (circleSize === undefined) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        localObj.mouseDown.isMouseDown = false;
      } else if (!((_circleSize = circleSize) === null || _circleSize === void 0 ? void 0 : _circleSize.firstPointPlotted)) {
        dataAvailable = false;
        point.circleSizeId = circleSize.uniqueId;
        localObj.currentUniqueId = null;
        circleSize.firstPointPlotted = true;
        circleSize.x = point.x;
        circleSize.y = point.y;
        var _fp17 = findShape(circleSize.firstPointId).shape;
        _fp17.isSelected = true;

        if (circleSize.firstPointPlotted) {
          modelObj.waiting = true;

          if (typeof events.circleSize !== 'undefined') {
            events.circleSize({
              id: modelObj.id,
              type: 'circleSize',
              visible: true,
              data: JSON.parse(JSON.stringify(circleSize))
            }, true);
          }

          dataAvailable = false;
        }
      } else {
        _this.removeUnplotedShapes();
      }
    } else if (currentShape && _it === 'midPoint' && pointOnGraph) {
      var _midPoint;

      var midPoint;

      var _selectedShapeID7 = isOnShape(e);

      var _selectedShape2 = findShape(_selectedShapeID7).shape;

      if (currentShape.type === 'point' || currentShape.type.includes('segment')) {
        midPoint = findShape(currentShape.midPointId).shape;
      } else {
        midPoint = findShape(currentShape.uniqueId).shape;
      }

      var selectedShapeN = findShape(midPoint.firstPointId).shape;

      if (!((_midPoint = midPoint) === null || _midPoint === void 0 ? void 0 : _midPoint.firstPointPlotted)) {
        dataAvailable = false;

        if (_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes('segment')) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if (clickingOnExistingPoint === null && !(_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes('segment'))) {
          var _secondPointId7 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId7,
            connectionId: [midPoint.uniqueId],
            midPointId: currentShape.midPointId
          });
          midPoint.secondPointId = _secondPointId7;
          midPoint.firstPointPlotted = true;
        } else if (midPoint.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(midPoint.uniqueId);
          point.midPointId = currentShape.midPointId;
          midPoint.secondPointId = clickingOnExistingPointID;
          midPoint.firstPointPlotted = true;
        }

        if (midPoint.firstPointPlotted) {
          midPoint.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          midPoint.x = point.x;
          midPoint.y = point.y;
        }

        selectedShapeN.isSelected = true;
      } else {
        if (midPoint.secondPointPlotted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (midPoint.secondPointPlotted && midPoint.onSegment === undefined) {
        var _findShape;

        var _firstPoint14 = findShape(midPoint.firstPointId).shape;
        var _secondPoint14 = findShape(midPoint.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint14.x,
          y: _firstPoint14.y,
          label: _firstPoint14.label
        };
        value.secondPoint = {
          x: _secondPoint14.x,
          y: _secondPoint14.y,
          label: _secondPoint14.label
        };
        value.uniqueId = midPoint.uniqueId;
        value.x = (_firstPoint14.x + _secondPoint14.x) / 2;
        value.y = (_firstPoint14.y + _secondPoint14.y) / 2;
        midPoint.x = (_firstPoint14.x + _secondPoint14.x) / 2;
        midPoint.y = (_firstPoint14.y + _secondPoint14.y) / 2;
        value.midPointId = ++localObj.uniqueId;
        midPoint.midPointId = value.midPointId; // value.uniqueId = currentShape.uniqueId;

        dataAvailable = true;
        addPoint({
          type: 'point',
          x: value.x,
          y: value.y
        }, {
          connectionId: [midPoint.uniqueId],
          uniqueId: value.midPointId,
          kshitij: true
        });

        var _segment2 = (_findShape = findShape(midPoint.segmentId)) === null || _findShape === void 0 ? void 0 : _findShape.shape;

        if (_segment2) {
          _segment2.isMouseDown = false;
          _segment2.isSelected = false;
        }

        midPoint.strokeColor = modelObj.pointColor;
        midPoint.fillColor = modelObj.pointColor;
        selectedShapeN.isSelected = false;
      } else if (midPoint.secondPointPlotted && midPoint.onSegment !== undefined) {
        // value.x=(midPoint.x+midPoint.xTo)/2;
        // value.y=(midPoint.y+midPoint.yTo)/2;
        value.x = (midPoint.firstPointCoords.x + midPoint.secondPointCoords.x) / 2;
        value.y = (midPoint.firstPointCoords.y + midPoint.secondPointCoords.y) / 2;
        value.uniqueId = midPoint.uniqueId;
        value.midPointId = ++localObj.uniqueId;
        midPoint.midPointId = value.midPointId;
        dataAvailable = true;
        addPoint({
          type: 'point',
          x: value.x,
          y: value.y
        }, {
          connectionId: [midPoint.uniqueId],
          uniqueId: value.midPointId,
          kshitij: true
        });
        var _segment3 = findShape(midPoint.segmentId).shape;
        _segment3.isMouseDown = false;
        _segment3.isSelected = false;
      }
    } else if (currentShape && _it === 'square' && pointOnGraph) {
      var square;

      if (currentShape.type === 'point') {
        square = findShape(currentShape.squareId).shape;
      }

      if (!square.firstPointPlotted) {
        if (clickingOnExistingPointID === square.firstPointId) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          var _fp18 = findShape(square.firstPointId).shape;
          _fp18.isSelected = true;
        } else if (clickingOnExistingPoint === null) {
          var _secondPointId8 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId8,
            connectionId: [square.uniqueId],
            squareId: currentShape.squareId
          });
          square.secondPointId = _secondPointId8;
          square.firstPointPlotted = true;
          square.secondPointPlotted = true;
          var _fp19 = findShape(square.firstPointId).shape;
          _fp19.isSelected = true;
          var _sp7 = findShape(square.secondPointId).shape;
          _sp7.isSelected = true;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(square.uniqueId);
          point.squareId = currentShape.squareId;
          square.secondPointId = clickingOnExistingPointID;
          square.secondPointPlotted = true;
          square.firstPointPlotted = true;
          var _fp20 = findShape(square.firstPointId).shape;
          _fp20.isSelected = true;
          var _sp8 = findShape(square.secondPointId).shape;
          _sp8.isSelected = true;
        }
      }

      if (square.secondPointId) {
        var _firstPoint15 = findShape(square.firstPointId).shape;
        var _secondPoint15 = findShape(square.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint15.x,
          y: _firstPoint15.y
        };
        value.secondPoint = {
          x: _secondPoint15.x,
          y: _secondPoint15.y
        };
        value.firstPointId = square.firstPointId;
        value.secondPointId = square.secondPointId;
        value.side = modelObj.LabComClass.Maths.getDistance(_firstPoint15, _secondPoint15);
        value.label = 'A  §qQuadrat§r = ' + to2Dec(value.side * value.side);
        square.label = 'A  §qQuadrat§r = ' + to2Dec(value.side * value.side);

        var _thirdPoint7 = modelObj.LabComClass.Maths.getPoint(_secondPoint15, modelObj.LabComClass.Maths.getAngle(_secondPoint15.x, _secondPoint15.y, _firstPoint15.x, _firstPoint15.y) - Math.PI / 2, value.side);

        var fourthPoint = modelObj.LabComClass.Maths.getPoint(_firstPoint15, modelObj.LabComClass.Maths.getAngle(_secondPoint15.x, _secondPoint15.y, _firstPoint15.x, _firstPoint15.y) - Math.PI / 2, value.side);

        var _thirdPointId2 = ++localObj.uniqueId;

        var fourthPointId = ++localObj.uniqueId;
        square.labelX = (_firstPoint15.x + _thirdPoint7.x) / 2;
        square.labelY = (_firstPoint15.y + _thirdPoint7.y) / 2;
        addPoint(_thirdPoint7, {
          connectionId: [square.uniqueId],
          uniqueId: _thirdPointId2,
          squareId: square.uniqueId
        });
        addPoint(fourthPoint, {
          connectionId: [square.uniqueId],
          uniqueId: fourthPointId,
          squareId: square.uniqueId
        });
        value.thirdPointId = _thirdPointId2;
        value.fourthPointId = fourthPointId;
        value.thirdPoint = _thirdPoint7;
        value.fourthPoint = fourthPoint;
        value.uniqueId = square.uniqueId;
        square.thirdPointId = _thirdPointId2;
        square.fourthPointId = fourthPointId;
        square.firstPoint = _firstPoint15;
        square.secondPoint = _secondPoint15;
        square.thirdPoint = _thirdPoint7;
        square.fourthPoint = fourthPoint;
        addSegment(_firstPoint15.x, _firstPoint15.y, _secondPoint15.x, _secondPoint15.y, square.uniqueId);
        addSegment(_secondPoint15.x, _secondPoint15.y, _thirdPoint7.x, _thirdPoint7.y, square.uniqueId);
        addSegment(_firstPoint15.x, _firstPoint15.y, fourthPoint.x, fourthPoint.y, square.uniqueId);
        addSegment(_thirdPoint7.x, _thirdPoint7.y, fourthPoint.x, fourthPoint.y), square.uniqueId;
        var _fp21 = findShape(square.firstPointId).shape;
        _fp21.isSelected = false;
        var _sp9 = findShape(square.secondPointId).shape;
        _sp9.isSelected = false;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'mirrorOnLine' && pointOnGraph) {
      var _mirrorOnLine;

      var mirrorOnLine;

      var _selectedShapeID8 = isOnShape(e);

      var _selectedShape3 = findShape(_selectedShapeID8).shape;

      if (currentShape.type === 'point') {
        mirrorOnLine = findShape(currentShape.mirrorOnLineId).shape;
      } else {
        mirrorOnLine = findShape(currentShape.uniqueId).shape;
      }

      if (!((_mirrorOnLine = mirrorOnLine) === null || _mirrorOnLine === void 0 ? void 0 : _mirrorOnLine.firstPointPlotted) && _typeof(mirrorOnLine) !== undefined) {
        var _mirrorOnLine2, _mirrorOnLine3;

        dataAvailable = false;
        var _fp22 = findShape(mirrorOnLine.firstPointId).shape;
        _fp22.isSelected = true;

        if (clickingOnExistingPoint === null && _selectedShape3 && checkType(_selectedShape3, localObj.lineTypes)) {
          var _lineId2 = _selectedShapeID8;
          mirrorOnLine.lineId = _lineId2;
          mirrorOnLine.firstPointPlotted = true;
        } else if (((_mirrorOnLine2 = mirrorOnLine) === null || _mirrorOnLine2 === void 0 ? void 0 : _mirrorOnLine2.firstPointId) === clickingOnExistingPointID || clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if ((_mirrorOnLine3 = mirrorOnLine) === null || _mirrorOnLine3 === void 0 ? void 0 : _mirrorOnLine3.firstPointPlotted) {
          mirrorOnLine.linePlotted = true;
          localObj.currentUniqueId = null; // mirrorOnLine.x = point.x;
          // mirrorOnLine.y = point.y;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (mirrorOnLine !== undefined && mirrorOnLine.linePlotted) {
        var _firstPoint16 = findShape(mirrorOnLine.firstPointId).shape;
        value.firstPoint = {
          x: _firstPoint16.x,
          y: _firstPoint16.y,
          uniqueId: _firstPoint16.uniqueId
        };
        mirrorOnLine.firstPoint = {
          x: _firstPoint16.x,
          y: _firstPoint16.y,
          uniqueId: _firstPoint16.uniqueId
        }; // const mirrorData = computeMirrorPoint(mirrorOnLine);

        var line = findShape(mirrorOnLine.lineId).shape;
        var eqnLine = computeEqn(line);
        var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, mirrorOnLine.x, mirrorOnLine.y);
        value.x = mirrorPoint.x;
        value.y = mirrorPoint.y;
        mirrorOnLine.x = mirrorPoint.x;
        mirrorOnLine.y = mirrorPoint.y;
        value.lineId = line.uniqueId;
        value.mirrorPointId = ++localObj.uniqueId;
        addPoint(mirrorPoint, {
          uniqueId: value.mirrorPointId,
          mirrorOnLineId: mirrorOnLine.uniqueId,
          connectionId: [mirrorOnLine.uniqueId]
        });
        dataAvailable = true;
        var _fp23 = findShape(mirrorOnLine.firstPointId).shape;
        _fp23.isSelected = false;
      } else {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === 'perpendicularBisector' && pointOnGraph && localObj.newShapeStarted) {
      var perpShape = currentShape;

      if (perpShape.mode === 'point') {
        if (!perpShape.firstPointPlotted) {
          if (perpShape.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
            point.connectionId.push(perpShape.uniqueId);
            perpShape.secondPointId = clickingOnExistingPointID;
            perpShape.firstPointPlotted = true;
            var _fp24 = findShape(perpShape.firstPointId).shape;
            _fp24.isSelected = true;
          }

          if (perpShape.firstPointPlotted) {
            perpShape.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            perpShape.x = point.x;
            perpShape.y = point.y;
          }
        } else {
          if (perpShape.secondPointPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        if (perpShape.firstPointPlotted && perpShape.secondPointPlotted) {
          var _firstPoint17 = findShape(currentShape.firstPointId).shape;
          var _secondPoint16 = findShape(perpShape.secondPointId).shape;
          var _midPoint2 = {
            x: (_firstPoint17.x + _secondPoint16.x) / 2,
            y: (_firstPoint17.y + _secondPoint16.y) / 2
          };
          var valueObj = computePerpBisector(perpShape, _firstPoint17, _secondPoint16, _midPoint2);
          value = _objectSpread(_objectSpread({}, value), valueObj);
          dataAvailable = true;
          var _fp25 = findShape(perpShape.firstPointId).shape;
          _fp25.isSelected = false;
        }
      } else if (perpShape.mode === 'segment') {
        var _firstPoint18 = {
          x: perpShape.segment.x,
          y: perpShape.segment.y
        };
        var _secondPoint17 = {
          x: perpShape.segment.xTo,
          y: perpShape.segment.yTo
        };
        var _midPoint3 = {
          x: (_firstPoint18.x + _secondPoint17.x) / 2,
          y: (_firstPoint18.y + _secondPoint17.y) / 2
        };

        var _valueObj = computePerpBisector(perpShape, _firstPoint18, _secondPoint17, _midPoint3);

        value = _objectSpread(_objectSpread({}, value), _valueObj);
        dataAvailable = true;
      }
    } else if (currentShape && (_it === 'perpendicularLine' || _it === 'parallelLine') && pointOnGraph) {
      // updatePLinePoints(currentShape);
      dataAvailable = true;

      if (currentShape.lineToPoint) {
        var _line3 = findShape(currentShape.line).shape;

        if (clickingOnExistingPoint === null) {
          var distance = Math.abs(modelObj.LabComClass.Maths.getPointLineDistance(point, _line3, {
            x: _line3.xTo,
            y: _line3.yTo
          }));
          var accepted = distance < getPointUnitByPixelUnit(modelObj.snappingDiff) && currentShape.lineSelected;

          if (accepted || distance > getPointUnitByPixelUnit(modelObj.snappingDiff)) {
            var _secondPointId9 = ++localObj.uniqueId;

            addPoint(point, {
              uniqueId: _secondPointId9,
              connectionId: [currentShape.uniqueId]
            });
            currentShape.secondPointId = _secondPointId9;
            currentShape.connectionId.push(_secondPointId9);
            localObj.mouseDown.lastShapeCompleted = true;
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else if (clickingOnExistingPointID === currentShape.firstPointId) {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          localObj.mouseDown.lastShapeCompleted = true;
        }

        if (dataAvailable) {
          _line3.isSelected = false;
        }
      } else {
        var _selectedShapeID9 = isOnShape(e);

        if (_selectedShapeID9) {
          var shapeData = findShape(_selectedShapeID9).shape;

          if (shapeData && checkType(shapeData, localObj.lineTypes)) {
            var _d5 = getPLine(e, _it === 'perpendicularLine');

            if (_d5) {
              currentShape.slope = _d5.slope;
              var _firstPoint19 = findShape(currentShape.firstPointId).shape;
              _firstPoint19.isSelected = false;
              updatePLinePoints(currentShape);
              localObj.mouseDown.lastShapeCompleted = true;
            }
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        }
      }

      if (currentShape.pointToLine) {
        currentShape.firstPointPlotted = true;
      } else {
        currentShape.lineSelected = true;
      }

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ['x', 'y', 'xTo', 'yTo']);
      }

      if (dataAvailable) {
        value.x = currentShape.x;
        value.y = currentShape.y;
        value.xTo = currentShape.xTo;
        value.yTo = currentShape.yTo;
        value.slope = currentShape.slope;
        value.uniqueId = currentShape.uniqueId;
        currentShape.visible = true;
      } else {
        dataAvailable = false;
        localObj.mouseDown.lastShapeCompleted = false;
      }
    } else if (currentShape && _it === 'compass') {
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (clickingOnExistingPoint === null) {
        if (currentShape.firstPointId !== undefined && !currentShape.isPloted) {
          shapesData.pop();
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = true;
        } else if (!currentShape.isPloted) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          currentShape.isPloted = true;
        } else if (pointOnGraph) {
          var centerPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: centerPointId,
            connectionId: [currentShape.uniqueId]
          }); //currentShape.centerPointId = centerPointId;

          currentShape.connectionId.push(centerPointId);
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID && !currentShape.isPloted) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else if (!currentShape.isPloted) {
        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        currentShape.isPloted = true;
      } else {
        point.connectionId.push(currentShape.uniqueId);
        currentShape.centerPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        localObj.mouseDown.lastShapeCompleted = true;
        var s = currentShape.firstPointId !== undefined ? findShape(currentShape.firstPointId) : findShape(currentShape.circleID);

        if (s) {
          s.shape.isSelected = false;
        }

        var selectedSegment = currentShape.segmentID >= 0 ? findShape(currentShape.segmentID).shape : undefined;

        if (selectedSegment) {
          selectedSegment.isSelected = false;
        }
      }
    } else if (_it === 'circle' && currentShape) {
      dataAvailable = true;
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;

      if (clickingOnExistingPoint === null && pointOnGraph) {
        var _secondPointId10 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _secondPointId10,
          connectionId: [currentShape.uniqueId]
        });
        currentShape.secondPointId = _secondPointId10;
        currentShape.connectionId.push(_secondPointId10);
        var _fp26 = findShape(currentShape.firstPointId).shape;
        _fp26.isSelected = false;
      } else if (!pointOnGraph || currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        var _fp27 = findShape(currentShape.firstPointId).shape;
        _fp27.isSelected = false;
        point.connectionId.push(currentShape.uniqueId);
        currentShape.secondPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (_it === 'scale') {
      dataAvailable = true;
      value.x = scaleObj.x;
      value.y = scaleObj.y;
      value.xTo = scaleObj.xTo;
      value.yTo = scaleObj.yTo;
      dispatchEventScale();
    } else if ((_it === 'brush1' || _it === 'brush2' || _it === 'brush3') && currentShape) {
      if (currentShape.toColor) {
        if (currentShape.type === 'point' || currentShape.type === 'angle') {
          value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
          value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;

          switch (_it) {
            case 'brush1':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = modelObj.shapes.brush1.color.stroke;
              currentShape.strokeColor = modelObj.shapes.brush1.color.stroke;
              break;

            case 'brush2':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = modelObj.shapes.brush2.color.stroke;
              currentShape.strokeColor = modelObj.shapes.brush2.color.stroke;
              break;

            case 'brush3':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              value.prevFillColor = currentShape.fillColor === undefined ? modelObj.segmentColor : currentShape.fillColor;
              currentShape.fillColor = modelObj.shapes.brush3.color.stroke;
              currentShape.strokeColor = modelObj.shapes.brush3.color.stroke;
              break;
          }
        } else {
          value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;

          switch (_it) {
            case 'brush1':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              currentShape.strokeColor = modelObj.shapes.brush1.color.stroke;
              break;

            case 'brush2':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              currentShape.strokeColor = modelObj.shapes.brush2.color.stroke;
              break;

            case 'brush3':
              value.prevStrokeColor = currentShape.strokeColor === undefined ? modelObj.segmentColor : currentShape.strokeColor;
              currentShape.strokeColor = modelObj.shapes.brush3.color.stroke;
              break;
          }
        }

        localObj.mouseDown.lastShapeCompleted = true;
        localObj.mouseDown.isMouseDown = false;
        value.type = 'colour';
        value.shapeLabel = currentShape.label;
        value.color = currentShape.strokeColor;
        value.shapeId = currentShape.uniqueId;
        value.shapeType = currentShape.type;
        dataAvailable = true;
      }

      currentShape.isSelected = false;
      currentShape.isMouseDown = false;
    } else if (_it === 'select' || _it === 'move' && localObj.mouseDown.objectDown) {
      dataAvailable = false;
      selectShape(e);
    } else if (_it === 'move' || _it === 'moveGraph') {
      dataAvailable = false;
    }

    updateAllShapes(e);
    updateAllShapes(e);
    dispatchData(value, dataAvailable);
  }

  function addSegment(x, y, xTo, yTo, squareId) {
    var seg1 = addNewShape({
      type: 'segment',
      uniqueId: ++localObj.uniqueId,
      x: x,
      y: y,
      xTo: xTo,
      yTo: yTo,
      squareId: squareId
    });
    localObj.newPlottedShapes.push(seg1.uniqueId);
    return seg1;
  } // This needed to remove the duplicate shapes and keep the latest one.
  // case: This happens when two intersection need to mark, and we mark 1st and on same place we mark another
  // by dragging the point.


  function filterDuplicateInteractionElements() {
    var uniqueElements = [];
    modelObj.interactionElements.forEach(function (element) {
      var index = uniqueElements.findIndex(function (shape) {
        return shape.uniqueId === element.uniqueId;
      });

      if (index === -1) {
        uniqueElements.push(element);
      } else {
        uniqueElements[index] = element;
      }
    });
    modelObj.interactionElements = uniqueElements;
  }

  function mirrorImage(a, b, c, x1, y1) {
    var temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b);
    var x = temp * a + x1;
    var y = temp * b + y1;
    return {
      x: x,
      y: y
    };
  }

  function dispatchData(value, dataAvailable) {
    var _it = modelObj.interactionType;

    if (value.uniqueId !== undefined) {
      var target = findShape(value.uniqueId);

      if (target.shape) {
        Object.keys(target.shape).forEach(function (i) {
          if (target.shape[i] !== undefined) {
            value[i] = target.shape[i];
          }
        });
      }
    }

    saveData();

    if (_it === 'select' || _it === 'move' && localObj.mouseDown.objectDown) {
      if (typeof events[_it] !== 'undefined') {
        events[_it]({
          id: modelObj.id,
          type: 'select'
        }, true);
      }
    } else if (dataAvailable) {
      localObj.mouseDown.lastShapeCompleted = true;
      localObj.newShapeStarted = false;
      localObj.currentUniqueId = null;
      value.newPlottedShapes = localObj.newPlottedShapes;
      value.step = modelObj.currentStep;
      dispatchEventCustom(value);
    }

    localObj.isLableSelected = false;
  }

  function computePerpBisector(perpShape, firstPoint, secondPoint, midPoint) {
    var value = {};
    var angle2Point = modelObj.LabComClass.Maths.getAngle(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y);
    perpShape.x = midPoint.x;
    perpShape.y = midPoint.y;
    perpShape.angle = angle2Point + Math.PI / 2;
    perpShape.point = modelObj.LabComClass.Maths.getPoint(midPoint, perpShape.angle, getPointUnitByPixelUnit(10)); // perpShape.two=modelObj.LabComClass.Maths.getPoint(midPoint,perpShape.angle,-10);

    value.x = midPoint.x;
    value.y = midPoint.y;
    value.xTo = perpShape.point.x;
    value.yTo = perpShape.point.y;
    value.uniqueId = perpShape.uniqueId;
    value.slope = isFinite(getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y)) ? getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y) : null;
    value.firstPoint = firstPoint;
    value.secondPoint = secondPoint;
    var perpLine = addNewShape({
      type: 'line',
      uniqueId: ++localObj.uniqueId,
      x: perpShape.point.x,
      y: perpShape.point.y,
      xTo: perpShape.x,
      yTo: perpShape.y,
      slope: getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y)
    });
    localObj.newPlottedShapes.push(perpLine.uniqueId);
    return value;
  }

  function findCommon(seg1, seg2) {
    var arr = [];
    var commArr = [];
    Object.values(seg1).forEach(function (el) {
      arr.push(el);
    });
    Object.values(seg2).forEach(function (el) {
      arr.push(el);
    });

    for (var i = 0; i < arr.length; i++) {
      if (i % 2 === 0) {
        commArr.push(arr[i] + '/' + arr[i + 1]);
      }
    }

    var duplicates = [];
    var tempArray = [].concat(commArr).sort();

    for (var _i5 = 0; _i5 < tempArray.length; _i5++) {
      if (tempArray[_i5 + 1] === tempArray[_i5]) {
        duplicates.push(tempArray[_i5]);
      }
    }

    var cords = duplicates[0].split('/');
    return {
      x: cords[0],
      y: cords[1]
    }; // return duplicates;
  }

  function calculateBisector(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'point';
    var bisector = {};
    var firstSegment, secondSegment;

    if (mode === 'point') {
      firstSegment = computeSegment(_obj.firstPoint, _obj.secondPoint);
      secondSegment = computeSegment(_obj.secondPoint, _obj.thirdPoint);
    } else if (mode === 'segment') {
      firstSegment = _obj.firstSegment;
      secondSegment = _obj.secondSegment;
    }

    bisector.eqn = computeBisectorEqn(computeEqn(firstSegment), computeEqn(secondSegment), firstSegment, secondSegment);
    bisector.formEqn = computeSolvingEqn(bisector, secondSegment);
    bisector.x = bisector.formEqn.computeX;
    bisector.y = bisector.formEqn.computeY;

    if (mode === 'point') {
      bisector.bisectorLine = {
        type: 'line',
        x: _obj.secondPoint.x,
        y: _obj.secondPoint.y,
        xTo: bisector.x,
        yTo: bisector.y // yTo:angleB.y

      };
    } else if (mode === 'segment') {
      bisector.bisectorLine = {
        type: 'line',
        x: _obj.x,
        y: _obj.y,
        xTo: bisector.x,
        yTo: bisector.y // yTo:angleB.y

      };
    }

    return bisector;
  }

  function computeBisectorEqn(first, second, m1, m2) {
    // const first={a:4,b:-3,c:4}
    // const second={a:6,b:8,c:-9};
    if (first.c < 0 && second.c >= 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
    }

    if (first.c >= 0 && second.c < 0) {
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    if (first.c < 0 && second.c < 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    var simpF = {},
        simpS = {};
    var step1LHS = "(".concat(first.a, "x+").concat(first.b, "y+").concat(first.c, ")/").concat(Math.sqrt(first.a * first.a + first.b * first.b));
    simpF.a = first.a / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.b = first.b / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.c = first.c / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.form = "".concat(simpF.a, "x+").concat(simpF.b, "y+").concat(simpF.c);
    var step1RHS = "(".concat(second.a, "x+").concat(second.b, "y+").concat(second.c, ")/").concat(Math.sqrt(second.a * second.a + second.b * second.b));
    simpS.a = second.a / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.b = second.b / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.c = second.c / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.form = "".concat(simpS.a, "x+").concat(simpS.b, "y+").concat(simpS.c);
    var answer = {};
    answer.firstCase = {};
    answer.secondCase = {};
    answer.firstCase.b = simpF.b - simpS.b;
    answer.firstCase.a = simpF.a - simpS.a;
    answer.firstCase.c = simpF.c - simpS.c;
    answer.secondCase.a = simpF.a + simpS.a;
    answer.secondCase.b = simpF.b + simpS.b;
    answer.secondCase.c = simpF.c + simpS.c;
    answer.required = {};
    var correctAnswer = checkAnswerCaseNew(first, second, answer.firstCase, answer.secondCase, m1, m2);
    answer.required = correctAnswer;
    return answer.required;
  }

  function checkAnswerCaseNew(segment1, segment2, firstCase, secondCase, m1, m2) {
    //a1a2+b1b2;
    var answer1 = findRatio(segment1, segment2, m1, m2);
    var product = {};
    var angle = answer1.degree;

    if (answer1.degree >= 270) {
      angle = answer1.degree - 270;
    }

    product.main = segment1.a * segment2.a + segment1.b * segment2.b;

    if (angle > 0 && angle < 90 && product.main < 0) {
      return firstCase;
    } else if (angle > 90 && product.main < 0) {
      return secondCase;
    } else if (angle > 90 && product.main > 0) {
      return firstCase;
    } else if (angle > 0 && angle < 90 && product.main > 0) {
      return secondCase;
    } else if (product.main === 0) {
      return secondCase;
    }
  }

  function findRatio(segment1, segment2, main1, main2) {
    var tangent = {};
    var angle = {};
    tangent.m1 = -(segment1.a / segment1.b);
    tangent.m2 = -(segment2.a / segment2.b);
    tangent.ratio = Math.abs((tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2));
    tangent.angle = Math.atan(tangent.ratio);
    tangent.degree = tangent.angle * (180 / Math.PI);
    tangent.obtuseAngle = Math.atan(-(tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2)) * (180 / Math.PI);
    tangent.tanTheta = (segment2.a * segment1.b - segment1.a * segment2.b) / (segment2.a * segment1.a + segment2.b * segment1.b);
    tangent.degSlope = Math.atan(tangent.tanTheta) * (180 / Math.PI);
    angle.startAngle = modelObj.LabComClass.Maths.getAngle(main1.xTo, main1.yTo, main1.x, main1.y);
    angle.endAngle = modelObj.LabComClass.Maths.getAngle(main2.x, main2.y, main2.xTo, main2.yTo);
    angle.angleRad = angle.startAngle - angle.endAngle;
    angle.angleS = angle.angleRad * 180 / Math.PI;

    if (angle.angleRad < 0) {
      angle.scene = 1;
      angle.degree = angle.angleRad * -1 * 180 / Math.PI;
    } else if (angle.angleRad > 0) {
      angle.scene = 2;
      angle.degree = 360 - angle.angleRad * 180 / Math.PI;
    }

    return angle;
  }

  function computeSolvingEqn(_obj, segment2) {
    var eqn = {};

    if (segment2.x === localObj.arbitaryX || segment2.xTo === localObj.arbitaryX) {
      localObj.arbitaryX = localObj.arbitaryX + 1;
    }

    eqn.eqn = "".concat(_obj.eqn.a, "x +").concat(_obj.eqn.b, "y +").concat(_obj.eqn.c);
    eqn.calcY = "y=(".concat(-_obj.eqn.a, "x + ").concat(-_obj.eqn.c, ")/").concat(_obj.eqn.b);
    eqn.computeY = (-_obj.eqn.a * localObj.arbitaryX + -_obj.eqn.c) / _obj.eqn.b;
    eqn.computeX = localObj.arbitaryX;

    if (!isFinite(eqn.computeY)) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    if (Math.trunc(_obj.eqn.b * 100) == 0) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    return eqn;
  }

  function computeEqn(segment) {
    var eqn = {};
    eqn.segment = segment.label;
    eqn.slope = isFinite(getSlope(segment.x, segment.y, segment.xTo, segment.yTo)) ? getSlope(segment.x, segment.y, segment.xTo, segment.yTo) : undefined;

    if (eqn.slope !== undefined) {
      eqn.eqn = "y-".concat(segment.y, "=").concat(eqn.slope, "*(x-").concat(segment.x, ")");
      eqn.b = 1;
      eqn.a = -eqn.slope;
      eqn.c = eqn.slope * segment.x - segment.y;
      eqn.cMod = Math.abs(eqn.slope * segment.x - segment.y);
      eqn.form = "y+".concat(eqn.a, "x+").concat(eqn.c);
    } else {
      eqn.eqn = "x=".concat(segment.x);
      eqn.form = "x-".concat(segment.x);
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -segment.x;
      eqn.cMod = Math.abs(-segment.x);
    }

    return eqn;
  }

  function computeSegment(firstPoint, secondPoint) {
    var segment = {};
    segment.x = firstPoint.x;
    segment.y = firstPoint.y;
    segment.xTo = secondPoint.x;
    segment.yTo = secondPoint.y;

    if (firstPoint.label && secondPoint.label) {
      segment.label = firstPoint.label + secondPoint.label;
    }

    return segment;
  }

  function computeCircle(_obj) {
    // Calculate Center and Raduis
    // Logic Here
    // Mid Point
    var fp = _obj.firstPoint;
    var sp = _obj.secondPoint;
    var tp = _obj.thirdPoint;
    var cData = circle3Handler(fp, sp, tp);
    return {
      r: cData.r,
      x: cData.x,
      y: cData.y
    };
  }

  function calculateAngle(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "angle";
    var firstPoint = _obj.firstPoint,
        secondPoint = _obj.secondPoint,
        thirdPoint = _obj.thirdPoint;
    var startAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, firstPoint.x, firstPoint.y);
    var endAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, thirdPoint.x, thirdPoint.y);
    var angle = startAngle - endAngle;

    if (angle < 0) {
      angle = angle * -1 * 180 / Math.PI;
    } else if (angle > 0) {
      angle = 360 - angle * 180 / Math.PI;
    }

    var angleText;

    if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === 'angle') {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label, "=").concat(Math.round(angle), "\xB0");
    } else if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === 'angleRay') {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label);
    } else if (mode === 'angle') {
      angleText = "".concat(Math.round(angle), "\xB0");
    } else if (mode === 'angleRay') {
      angleText = "";
    }

    return {
      angleText: angleText,
      angle: angle,
      angleValue: Math.round(angle),
      startAngle: startAngle,
      endAngle: endAngle
    };
  }

  function checkDataAvailable(target, keys) {
    // eslint-disable-next-line consistent-return
    for (var i = 0; i < keys.length; i++) {
      if (target[keys[i]] === null || isNaN(target[keys[i]])) {
        return false;
      }
    }

    return true;
  }

  function checkPoint(_obj) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d = modelObj.interactionElements[i]; // if (_d.type === 'point' && _d.uniqueId !== localObj.uniqueId) 

      if (_d.type === 'point') {
        newDist = modelObj.LabComClass.Maths.getDistance(_obj, _d);
      }

      if (dist === null && newDist !== null || dist !== null && newDist < dist) {
        dist = newDist;
        index = i;
      }
    }

    if (index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      localObj.mouseDown.objectDown = true;
      return index;
    }

    return null;
  }

  function checkPointv2(_obj) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d = modelObj.interactionElements[i]; // if (_d.type === 'point' && _d.uniqueId !== localObj.uniqueId) 

      if (_d.type === 'point' && _d.uniqueId !== localObj.currentUniqueId) {
        newDist = modelObj.LabComClass.Maths.getDistance(_obj, _d);
      }

      if (dist === null && newDist !== null || dist !== null && newDist < dist) {
        dist = newDist;
        index = i;
      }
    }

    if (index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      localObj.mouseDown.objectDown = true;
      return index;
    }

    return null;
  }

  function isItCloseToPlotedPoint(point, avoidCurrentPoint) {
    var dist = null,
        newDist = null,
        index = null;

    for (var i = modelObj.interactionElements.length - 1; i >= 0; i--) {
      var _d = modelObj.interactionElements[i];

      if (!avoidCurrentPoint || _d.uniqueId !== localObj.currentUniqueId || modelObj.interactionType === 'move' && _d.uniqueId !== localObj.currentUniqueId) {
        if (_d.type === 'point') {
          newDist = modelObj.LabComClass.Maths.getDistance(point, _d);
        } else {
          newDist = null;
        }

        if (newDist !== null && (dist === null || newDist < dist)) {
          dist = newDist;
          index = i;
        }
      }
    }

    if (newDist !== null && index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      return {
        dist: dist,
        index: index,
        plotedPoint: modelObj.interactionElements[index]
      };
    }

    return null;
  }

  function isItCloseToParameterPoint(point) {
    var dist = null,
        newDist = null;
    var _modelObj$LabComClass2 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass2.getDistance,
        getPoint = _modelObj$LabComClass2.getPoint,
        getAngle = _modelObj$LabComClass2.getAngle,
        pointInSegment = _modelObj$LabComClass2.pointInSegment,
        getLineintersect = _modelObj$LabComClass2.getLineintersect,
        getPointLineDistance = _modelObj$LabComClass2.getPointLineDistance;
    var intersectionP = null;

    for (var i = 0; i < modelObj.interactionElements.length - 1; i++) {
      var shape = modelObj.interactionElements[i];

      if (shape.type !== 'point') {
        if (checkType(shape, localObj.lineTypes)) {
          var distFromLine = getPointLineDistance(point, shape, {
            x: shape.xTo,
            y: shape.yTo
          });
          newDist = Math.abs(distFromLine);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            var lineAngle = getAngle(shape.x, shape.y, shape.xTo, shape.yTo);
            var point2 = getPoint(point, lineAngle + Math.PI / 2, 2);
            var intersection = getLineintersect(shape.x, shape.y, shape.xTo, shape.yTo, point.x, point.y, point2.x, point2.y);
            var shapeLength = getDistance(shape, {
              x: shape.xTo,
              y: shape.yTo
            });
            var intersectionDist = getDistance(shape, intersection);
            var percentage = intersectionDist / shapeLength;
            var pointAngle = getAngle(shape.x, shape.y, intersection.x, intersection.y);
            var pointAccepted = true;

            if (shape.type.includes('segment')) {
              var isInSegment = pointInSegment(intersection, shape, {
                x: shape.xTo,
                y: shape.yTo
              });

              if (!isInSegment) {
                pointAccepted = false;
              }
            }

            if (shape.type === 'ray') {
              var _isInSegment = pointInSegment(intersection, shape, {
                x: shape.xOr,
                y: shape.yOr
              });

              if (!_isInSegment) {
                pointAccepted = false;
              }
            }

            if (pointAccepted) {
              dist = newDist;

              if (checkDataAvailable(intersection, ['x', 'y'])) {
                intersectionP = intersection;
                intersectionP.dist = dist;
                intersectionP.updateKeys = {
                  x: intersectionP.x,
                  y: intersectionP.y,
                  line: shape.uniqueId,
                  pointAngle: Math.round(pointAngle) === Math.round(lineAngle),
                  percentage: percentage,
                  isParameter: true
                };
              }
            }
          }
        }

        if (shape.type === 'circle' || shape.type === 'compass') {
          var distFromCenter = getDistance(shape, point);
          newDist = Math.abs(distFromCenter - shape.r);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            dist = newDist;
            var angle = getAngle(shape.x, shape.y, point.x, point.y);
            intersectionP = getPoint(shape, angle, shape.r);

            if (checkDataAvailable(intersectionP, ['x', 'y'])) {
              intersectionP.dist = dist;
              intersectionP.updateKeys = {
                x: intersectionP.x,
                y: intersectionP.y,
                circle: shape.uniqueId,
                angle: angle,
                isParameter: true
              };
            } else {
              intersectionP = null;
            }
          }
        }
      }
    }

    return intersectionP;
  }

  function isItCloseToIntersectionPoint(point) {
    var dist = null,
        newDist = null;
    var shapesData = modelObj.interactionElements;
    var intersectionP = null;

    for (var i = 0; i < shapesData.length - 1; i++) {
      var firstShape = shapesData[i];

      if (firstShape.type !== 'point') {
        for (var j = i + 1; j < shapesData.length; j++) {
          var secondShape = shapesData[j];

          if (secondShape.type !== 'point') {
            if (checkType(firstShape, localObj.lineTypes) && checkType(secondShape, localObj.lineTypes) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var data = getInteractionOfTwoLines(firstShape, secondShape, point);

              if (data !== null) {
                if (data.dist < dist || dist === null) {
                  newDist = data.dist;
                  dist = data.dist;
                  intersectionP = data;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    l1: firstShape.uniqueId,
                    l2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if ((checkType(firstShape, localObj.lineTypes) && checkType(secondShape, ['circle', 'compass']) || checkType(secondShape, localObj.lineTypes) && checkType(firstShape, ['circle', 'compass'])) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var circleShape = void 0,
                  lineShape = void 0;

              if (firstShape.type === 'circle' || firstShape.type === 'compass') {
                circleShape = firstShape;
                lineShape = secondShape;
              } else {
                circleShape = secondShape;
                lineShape = firstShape;
              }

              var _data3 = getInteractionOfCircleLine(circleShape, lineShape, point, modelObj.snappingDiff);

              if (_data3 !== null) {
                if (_data3.dist < dist || dist === null) {
                  newDist = _data3.dist;
                  dist = _data3.dist;
                  intersectionP = _data3;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    circle: circleShape.uniqueId,
                    line: lineShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if (checkType(firstShape, ['circle', 'compass']) && checkType(secondShape, ['circle', 'compass']) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var _data4 = getInteractionOfTwoCircles(firstShape, secondShape, point, modelObj.snappingDiff, false);

              if (_data4) {
                if (_data4.dist < dist || dist === null) {
                  newDist = _data4.dist;
                  dist = _data4.dist;
                  intersectionP = _data4;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    intersectAngle: intersectionP.angle1,
                    circle1: firstShape.uniqueId,
                    circle2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } // if (intersectionP) {
            //   break;
            // }

          }
        } // if (intersectionP) {
        //   break;
        // }

      }
    }

    return intersectionP;
  }

  function checkType(shape, types) {
    return types.includes(shape.type);
  }

  function getInteractionOfTwoCircles(circle1, circle2, point, snapDiff) {
    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length > 1) {
      var getDist = function getDist(p1, p2) {
        var dist = modelObj.LabComClass.Maths.getDistance(p1, point);

        if (snapDiff !== false) {
          if (dist <= getPointUnitByPixelUnit(snapDiff)) {
            p1.dist = dist;
            var centerPointsLine = new modelObj.LabComClass.Vector(circle2.x - circle1.x, circle2.y - circle1.y);
            var firstIntersectLine = new modelObj.LabComClass.Vector(p1.x - circle1.x, p1.y - circle1.y);
            p1.angle = centerPointsLine.crossProduct(firstIntersectLine).z;
            return dist;
          }

          return null;
        }

        p1.angle1 = modelObj.LabComClass.Maths.getAngle(circle1.x, circle1.y, p1.x, p1.y);
        p1.dist = dist;
        return dist;
      };

      var acceptedIntersections = [];
      var p = getDist(intersection[0], intersection[1]);

      if (p !== null) {
        acceptedIntersections.push(intersection[0]);
      }

      p = getDist(intersection[1], intersection[0]);

      if (p !== null) {
        acceptedIntersections.push(intersection[1]);
      }

      if (acceptedIntersections.length) {
        var lowestIndex = 0;
        var closeDist = acceptedIntersections[0].dist;

        for (var i = 0; i < acceptedIntersections.length; i++) {
          if (acceptedIntersections[i].dist < closeDist) {
            closeDist = acceptedIntersections[i].dist;
            lowestIndex = i;
          }
        }

        return acceptedIntersections[lowestIndex];
      }

      return null;
    }

    return null;
  }

  function getInteractionOfCircleLine(circle, line, point, snapDiff) {
    var lineData = {
      x: line.x,
      y: line.y,
      xTo: line.xTo,
      yTo: line.yTo
    };

    if (line.type === 'ray') {
      lineData.xTo = line.xOr;
      lineData.yTo = line.yOr;
    }

    var intersection = findCircleLineIntersect(circle, lineData);

    if (intersection.p1 || intersection.p2) {
      var getDist = function getDist(p) {
        if ((line.type.includes('segment') || line.type === 'ray') && !p.isInSegment) {
          return null;
        }

        var dist = modelObj.LabComClass.Maths.getDistance(p, point);

        if (snapDiff !== undefined) {
          if (dist < getPointUnitByPixelUnit(snapDiff)) {
            p.dist = dist;
            return dist;
          }

          return null;
        }

        p.dist = dist;
        return dist;
      };

      var distP1 = null,
          distP2 = null;
      distP1 = getDist(intersection.p1);
      distP2 = getDist(intersection.p2);

      if (distP1 !== null && distP2 !== null) {
        if (distP1 < distP2) {
          return intersection.p1;
        }

        return intersection.p2;
      }

      if (distP1 !== null) {
        return intersection.p1;
      }

      if (distP2 !== null) {
        return intersection.p2;
      }

      return null;
    }

    return null;
  }

  function getInteractionOfTwoLines(l1, l2, point) {
    var intersection = modelObj.LabComClass.Maths.getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);

    if (intersection) {
      if (l1.type.includes('segment') && !intersection.onLine1 || l2.type.includes('segment') && !intersection.onLine2) {
        return null;
      }

      var distance = modelObj.LabComClass.Maths.getDistance(intersection, point);

      if (distance < getPointUnitByPixelUnit(10)) {
        intersection.dist = distance;
        return intersection;
      }

      return null;
    }

    return null;
  }

  function moveShape(e) {
    //Same as select Shape but doesnt have dont Select as it's required to move label even if it is not selectable.
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;

      for (var i = 0; i < shapesData.length; i++) {
        var _d = shapesData[i];

        if (_d.type === 'circle' || _d.type === 'compass' || _d.type === 'circle_3') {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === 'line'
        /*&& !_d.dontSelect*/
        || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        } else if (_d.type.includes('segment')
        /*&& !_d.dontSelect*/
        || _d.type === 'ray') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i6 = 0; _i6 < shapesData.length; _i6++) {
      var _d6 = shapesData[_i6];
      var calculated = false;

      if (_d6.label !== undefined) {
        var label = getPixelByPoint(_d6.labelX, _d6.labelY);
        label.x += Number(_d6.labelDiffX);
        label.y += Number(_d6.labelDiffY);
        var w = ctx.measureText(_d6.label).width;

        if (_d6.labelAlign && _d6.labelAlign === 'center') {
          if (pxl.x > label.x - w / 2 - 20 && pxl.x < label.x + w / 2 + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 20 && pxl.x < label.x + w + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated
      /*&& !_d.dontSelect*/
      ) {
        dist = Math.abs(newDist);
        index = _i6;
        labelId = _i6;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === 'move') {
            for (var _i7 = 0; _i7 < shapesData.length; _i7++) {
              shapesData[_i7].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
        }
      }
    }

    return null;
  }

  function selectShape(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;

      for (var i = 0; i < shapesData.length; i++) {
        var _d = shapesData[i];

        if (_d.type === 'circle' || _d.type === 'compass' || _d.type === 'circle_3') {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === 'line' && !_d.dontSelect || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        } else if (_d.type.includes('segment') && !_d.dontSelect || _d.type === 'ray') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i8 = 0; _i8 < shapesData.length; _i8++) {
      var _d7 = shapesData[_i8];
      var calculated = false;

      if (_d7.label !== undefined) {
        var label = getPixelByPoint(_d7.labelX, _d7.labelY);
        label.x += Number(_d7.labelDiffX);
        label.y += Number(_d7.labelDiffY);
        var w = ctx.measureText(_d7.label).width;

        if (_d7.labelAlign && _d7.labelAlign === 'center') {
          if (pxl.x > label.x - w / 2 - 20 && pxl.x < label.x + w / 2 + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 20 && pxl.x < label.x + w + 22 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 10) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null && !_d7.dontSelect || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated && !_d7.dontSelect) {
        dist = Math.abs(newDist);
        index = _i8;
        labelId = _i8;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === 'move') {
            for (var _i9 = 0; _i9 < shapesData.length; _i9++) {
              shapesData[_i9].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
        }
      }
    }

    return null;
  }

  function isOnShape(e) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;
    var _modelObj$LabComClass3 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass3.getDistance,
        getPointLineDistance = _modelObj$LabComClass3.getPointLineDistance;
    var data = isItCloseToPlotedPoint(getPointByPixel(e.pageX, e.pageY), false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;
      var p = getPointByPixel(e.pageX, e.pageY);
      modelObj.interactionElements.forEach(function (_d, i) {
        if (_d.type === 'circle' || _d.type === 'compass') {
          newDist = getDistance(p, _d) - _d.r;
        }

        if (_d.type === 'line' || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          // newDist = getPointLineDistance(p, _d, { x: _d.xTo, y: _d.yTo });
          if (!isNaN(_d.xTo) || !isNaN(_d.yTo)) {
            newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
              x: _d.xTo,
              y: _d.yTo
            });
          }
        }

        if (_d.type.includes('segment') || _d.type === 'ray') {
          newDist = getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = getDistance(p, _d);
            var endPointDist = getDistance(p, endPoint);
            var length = getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = newDist;
          index = i;
        }
      });
    }

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      return modelObj.interactionElements[index].uniqueId;
    }

    return null;
  }

  function getPLine(e, isPerpendicular) {
    var point = getPointByPixel(e.pageX, e.pageY);
    var data = {
      visible: true,
      x: point.x,
      y: point.y,
      xOr: point.x,
      yOr: point.y,
      xTo: point.x,
      yTo: point.y,
      xOrTo: point.x,
      yOrTo: point.y,
      slope: 0,
      distance: null
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d8 = modelObj.interactionElements[i];

      if (checkType(_d8, localObj.lineTypes) && _d8.uniqueId !== localObj.currentUniqueId) {
        var distance = getPointLineDistance({
          x: data.x,
          y: data.y
        }, {
          x: _d8.x,
          y: _d8.y
        }, {
          x: _d8.xTo,
          y: _d8.yTo
        });
        distance = Math.abs(distance);

        if (_d8.type.includes('segment') || _d8.type === 'ray') {
          if (distance < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d8.xTo,
              y: _d8.yTo
            };

            if (_d8.type === 'ray') {
              endPoint = {
                x: _d8.xOr,
                y: _d8.yOr
              };
            }

            if (!modelObj.LabComClass.Maths.pointInSegment(point, _d8, endPoint)) {
              continue;
            }
          } else {
            continue;
          }
        }

        if (data.distance === null || data.distance > distance) {
          data.distance = distance;
          data.line = _d8.uniqueId;
          data.slope = modelObj.LabComClass.Maths.getAngle(_d8.x, _d8.y, _d8.xTo, _d8.yTo);

          if (isPerpendicular) {
            data.slope += Math.PI / 2;
          }

          var newP = modelObj.LabComClass.Maths.getPoint({
            x: data.x,
            y: data.y
          }, data.slope, 10);
          data.xTo = newP.x;
          data.yTo = newP.y;
        }
      }
    }

    if (data.distance !== null && data.distance < getPointUnitByPixelUnit(10)) {
      return data;
    }

    return false;
  }

  function getPointLineDistance(_pt, _line1, _line2) {
    var _dist = modelObj.LabComClass.Maths.getDistance(_line1, _line2);

    var _ans = 0;

    if (_dist > 0) {
      var _num = (_line2.x - _line1.x) * (_line1.y - _pt.y) - (_line2.y - _line1.y) * (_line1.x - _pt.x);

      _ans = _num / _dist;
    }

    return _ans;
  }

  function updatePoints(shape) {
    if (shape.label) {
      // const p = findLableByPoint(shape);
      shape.labelX = shape.x;
      shape.labelY = shape.y;

      if (shape.labelDiffX === 0) {
        shape.labelDiffX = 6;
        shape.labelDiffY = -9;
      }
    }
  } // =================================================


  function updateLinePoints(curInt) {
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 10;

    var _angle = modelObj.LabComClass.Maths.getAngle(curInt.x, curInt.y, curInt.xTo, curInt.yTo);

    var _newPoint = modelObj.LabComClass.Maths.getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;

    var _angle2 = modelObj.LabComClass.Maths.getAngle(curInt.xTo, curInt.yTo, curInt.x, curInt.y);

    var _newPoint2 = modelObj.LabComClass.Maths.getPoint({
      x: curInt.xTo,
      y: curInt.yTo
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y;

    if (curInt.label) {
      var p = findLableByLine(curInt, {
        x: curInt.xTo,
        y: curInt.yTo
      });
      curInt.labelX = p.x;
      curInt.labelY = p.y;
    }

    if (curInt && curInt.connectionId && curInt.connectionId.length) {
      for (var i = 0; i < curInt.connectionId.length; i++) {
        var shapeData = findShape(curInt.connectionId[i]);

        if (shapeData && (shapeData.shape.type === 'perpendicularLine' || shapeData.shape.type === 'parallelLine')) {
          shapeData.shape.slope = _angle;

          if (shapeData.shape.type === 'perpendicularLine') {
            shapeData.shape.slope += Math.PI / 2;
          }

          updatePLinePoints(shapeData.shape);
        }
      }
    }
  }

  function findLableByPoint(p1) {
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;

    var width = _ctx.measureText(p1.label).width;

    var height = _ctx.measureText(p1.label).height;

    _ctx.restore();

    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = modelObj.LabComClass.Maths.getRandomNumber(0, Math.PI * 2, 1, 0.1);
      var dist = 5;
      p = modelObj.LabComClass.Maths.getPoint(p1, angle, dist);

      if (angle > Math.PI - 1 && angle < Math.PI + 1) {
        p.x -= width;
      }

      if (angle > Math.PI + 1 && angle < Math.PI * 2) {
        p.y -= height;
      }

      if (angle < 1 || angle > Math.PI * 2 - 1) {
        p.x += width;
      }

      if (angle < Math.PI - 1) {
        p.y += height;
      }

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = p1.x;
        p.y = p1.y - 5;
        break;
      }

      counter++;
    }

    return p;
  }

  function getSlope(_x1, _y1, _x2, _y2) {
    return (_y2 - _y1) / (_x2 - _x1);
  }

  ;

  function findLableByLine(shape, point2) {
    var _modelObj$LabComClass4 = modelObj.LabComClass.Maths,
        getRandomNumber = _modelObj$LabComClass4.getRandomNumber,
        getPoint = _modelObj$LabComClass4.getPoint,
        getAngle = _modelObj$LabComClass4.getAngle,
        getDistance = _modelObj$LabComClass4.getDistance,
        getPointLineDistance = _modelObj$LabComClass4.getPointLineDistance;

    if (shape.labelX !== undefined) {
      var pos = getPixelByPoint(shape.labelX, shape.labelY);

      if (pos.x > modelObj.x && pos.x < modelObj.x + modelObj.width && pos.y > modelObj.y && pos.y < modelObj.y + modelObj.height) {
        var dist = getPointLineDistance({
          x: shape.labelX,
          y: shape.labelY
        }, shape, {
          x: shape.xTo,
          y: shape.yTo
        });

        if (Math.abs(dist) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
          var nearbyPointFound = false;

          for (var i = 0; i < modelObj.interactionElements.length; i++) {
            var point = modelObj.interactionElements[i];

            if (point.type === 'point' && shape.label) {
              var _dist2 = getDistance({
                x: point.x + getPointUnitByPixelUnit(10),
                y: point.y - getPointUnitByPixelUnit(10)
              }, {
                x: shape.labelX,
                y: shape.labelY
              });

              if (_dist2 < getPointUnitByPixelUnit(modelObj.snappingDiff * 1.2)) {
                nearbyPointFound = true;
                break;
              }
            }
          }

          if (!nearbyPointFound) {
            return {
              x: shape.labelX,
              y: shape.labelY
            };
          }
        }
      }
    }

    var p1 = getPixelByPoint(shape.x, shape.y);
    var p2 = getPixelByPoint(point2.x, point2.y);
    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = getAngle(p1.x, p1.y, p2.x, p2.y);

      var _dist3 = getRandomNumber(-1 * (maxX - minX), maxX - minX, 1, 1);

      if (shape.type === 'ray') {
        _dist3 = Math.abs(_dist3);
      }

      p = getPoint(p1, angle, _dist3);

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        for (var _i10 = 0; _i10 < modelObj.interactionElements.length; _i10++) {
          var _shape = modelObj.interactionElements[_i10];

          if (_shape.type === 'point' && _shape.label) {
            var _dist4 = getDistance({
              x: _shape.x + getPointUnitByPixelUnit(10),
              y: _shape.y - getPointUnitByPixelUnit(10)
            }, p);

            if (_dist4 < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
              breakIt = false;
            }
          }
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = (p1.x + p2.x) / 2;
        p.y = (p1.y + p2.y) / 2;
        break;
      }

      counter++;
    }

    p = getPointByPixel(p.x, p.y);
    return p;
  }

  function updatePLinePoints(curInt) {
    var _modelObj$LabComClass5 = modelObj.LabComClass.Maths,
        getAngle = _modelObj$LabComClass5.getAngle,
        getPoint = _modelObj$LabComClass5.getPoint;
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 2;

    if (curInt.line !== undefined) {
      var shapeData = findShape(curInt.line);

      if (shapeData.shape) {
        var _d9 = shapeData.shape;
        var slope = getAngle(_d9.x, _d9.y, _d9.xTo, _d9.yTo);

        if (curInt.type === 'perpendicularLine') {
          slope += Math.PI / 2;
        }

        curInt.slope = slope;
      }
    }

    var _angle = curInt.slope;

    var _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;
    _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, 20);
    curInt.xTo = _newPoint.x;
    curInt.yTo = _newPoint.y;

    var _angle2 = curInt.slope + Math.PI;

    var _newPoint2 = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y;

    if (curInt.label) {
      var p = findLableByLine(curInt, {
        x: curInt.xTo,
        y: curInt.yTo
      });
      curInt.labelX = p.x;
      curInt.labelY = p.y;
    }
  } // =================================================


  function dispatchEventCustom(value) {
    var _obj = {};
    _obj.id = modelObj.id;
    _obj.type = 'geoInteraction';
    value = JSON.parse(JSON.stringify(value));
    value.type = modelObj.interactionType;
    _obj.data = value;

    if (typeof events[_obj.type] !== 'undefined') {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventCircleMove(value) {
    var _obj = {};
    _obj.id = modelObj.id;
    value.type = modelObj.interactionType;
    _obj.type = 'geoCircle';
    _obj.data = value;

    if (typeof events[_obj.type] !== 'undefined') {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventScale() {
    var value = {};
    value.id = modelObj.id;
    value.type = 'geoScale';
    value.length = modelObj.LabComClass.Maths.getDistance({
      x: scaleObj.x,
      y: scaleObj.y
    }, {
      x: scaleObj.xTo,
      y: scaleObj.yTo
    });

    if (typeof events[value.type] !== 'undefined') {
      events[value.type](value, true);
    }
  }
}
/*! howler.js v2.0.4 | (c) 2013-2017, James Simpson of GoldFire Studios | MIT License | howlerjs.com */
!function(){"use strict";var e=function(){this.init()};e.prototype={init:function(){var e=this||n;return e._counter=1e3,e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.mobileAutoEnable=!0,e._setup(),e},volume:function(e){var o=this||n;if(e=parseFloat(e),o.ctx||_(),void 0!==e&&e>=0&&e<=1){if(o._volume=e,o._muted)return o;o.usingWebAudio&&(o.masterGain.gain.value=e);for(var t=0;t<o._howls.length;t++)if(!o._howls[t]._webAudio)for(var r=o._howls[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._howls[t]._soundById(r[a]);u&&u._node&&(u._node.volume=u._volume*e)}return o}return o._volume},mute:function(e){var o=this||n;o.ctx||_(),o._muted=e,o.usingWebAudio&&(o.masterGain.gain.value=e?0:o._volume);for(var t=0;t<o._howls.length;t++)if(!o._howls[t]._webAudio)for(var r=o._howls[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._howls[t]._soundById(r[a]);u&&u._node&&(u._node.muted=!!e||u._muted)}return o},unload:function(){for(var e=this||n,o=e._howls.length-1;o>=0;o--)e._howls[o].unload();return e.usingWebAudio&&e.ctx&&void 0!==e.ctx.close&&(e.ctx.close(),e.ctx=null,_()),e},codecs:function(e){return(this||n)._codecs[e.replace(/^x-/,"")]},_setup:function(){var e=this||n;if(e.state=e.ctx?e.ctx.state||"running":"running",e._autoSuspend(),!e.usingWebAudio)if("undefined"!=typeof Audio)try{var o=new Audio;void 0===o.oncanplaythrough&&(e._canPlayEvent="canplay")}catch(n){e.noAudio=!0}else e.noAudio=!0;try{var o=new Audio;o.muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||n,o=null;try{o="undefined"!=typeof Audio?new Audio:null}catch(n){return e}if(!o||"function"!=typeof o.canPlayType)return e;var t=o.canPlayType("audio/mpeg;").replace(/^no$/,""),r=e._navigator&&e._navigator.userAgent.match(/OPR\/([0-6].)/g),a=r&&parseInt(r[0].split("/")[1],10)<33;return e._codecs={mp3:!(a||!t&&!o.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!t,opus:!!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!o.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),aac:!!o.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!o.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(o.canPlayType("audio/x-m4a;")||o.canPlayType("audio/m4a;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(o.canPlayType("audio/x-mp4;")||o.canPlayType("audio/mp4;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),webm:!!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),dolby:!!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(o.canPlayType("audio/x-flac;")||o.canPlayType("audio/flac;")).replace(/^no$/,"")},e},_enableMobileAudio:function(){var e=this||n,o=/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator&&e._navigator.userAgent),t=!!("ontouchend"in window||e._navigator&&e._navigator.maxTouchPoints>0||e._navigator&&e._navigator.msMaxTouchPoints>0);if(!e._mobileEnabled&&e.ctx&&(o||t)){e._mobileEnabled=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var r=function(){n._autoResume();var o=e.ctx.createBufferSource();o.buffer=e._scratchBuffer,o.connect(e.ctx.destination),void 0===o.start?o.noteOn(0):o.start(0),"function"==typeof e.ctx.resume&&e.ctx.resume(),o.onended=function(){o.disconnect(0),e._mobileEnabled=!0,e.mobileAutoEnable=!1,document.removeEventListener("touchend",r,!0)}};return document.addEventListener("touchend",r,!0),e}},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&void 0!==e.ctx.suspend&&n.usingWebAudio){for(var o=0;o<e._howls.length;o++)if(e._howls[o]._webAudio)for(var t=0;t<e._howls[o]._sounds.length;t++)if(!e._howls[o]._sounds[t]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout(function(){e.autoSuspend&&(e._suspendTimer=null,e.state="suspending",e.ctx.suspend().then(function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())}))},3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&void 0!==e.ctx.resume&&n.usingWebAudio)return"running"===e.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state?(e.ctx.resume().then(function(){e.state="running";for(var n=0;n<e._howls.length;n++)e._howls[n]._emit("resume")}),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};var n=new e,o=function(e){var n=this;if(!e.src||0===e.src.length)return void console.error("An array of source files must be passed with any new Howl.");n.init(e)};o.prototype={init:function(e){var o=this;return n.ctx||_(),o._autoplay=e.autoplay||!1,o._format="string"!=typeof e.format?e.format:[e.format],o._html5=e.html5||!1,o._muted=e.mute||!1,o._loop=e.loop||!1,o._pool=e.pool||5,o._preload="boolean"!=typeof e.preload||e.preload,o._rate=e.rate||1,o._sprite=e.sprite||{},o._src="string"!=typeof e.src?e.src:[e.src],o._volume=void 0!==e.volume?e.volume:1,o._duration=0,o._state="unloaded",o._sounds=[],o._endTimers={},o._queue=[],o._onend=e.onend?[{fn:e.onend}]:[],o._onfade=e.onfade?[{fn:e.onfade}]:[],o._onload=e.onload?[{fn:e.onload}]:[],o._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],o._onpause=e.onpause?[{fn:e.onpause}]:[],o._onplay=e.onplay?[{fn:e.onplay}]:[],o._onstop=e.onstop?[{fn:e.onstop}]:[],o._onmute=e.onmute?[{fn:e.onmute}]:[],o._onvolume=e.onvolume?[{fn:e.onvolume}]:[],o._onrate=e.onrate?[{fn:e.onrate}]:[],o._onseek=e.onseek?[{fn:e.onseek}]:[],o._onresume=[],o._webAudio=n.usingWebAudio&&!o._html5,void 0!==n.ctx&&n.ctx&&n.mobileAutoEnable&&n._enableMobileAudio(),n._howls.push(o),o._autoplay&&o._queue.push({event:"play",action:function(){o.play()}}),o._preload&&o.load(),o},load:function(){var e=this,o=null;if(n.noAudio)return void e._emit("loaderror",null,"No audio support.");"string"==typeof e._src&&(e._src=[e._src]);for(var r=0;r<e._src.length;r++){var u,i;if(e._format&&e._format[r])u=e._format[r];else{if("string"!=typeof(i=e._src[r])){e._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}u=/^data:audio\/([^;,]+);/i.exec(i),u||(u=/\.([^.]+)$/.exec(i.split("?",1)[0])),u&&(u=u[1].toLowerCase())}if(u||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),u&&n.codecs(u)){o=e._src[r];break}}return o?(e._src=o,e._state="loading","https:"===window.location.protocol&&"http:"===o.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new t(e),e._webAudio&&a(e),e):void e._emit("loaderror",null,"No codec support for selected audio sources.")},play:function(e,o){var t=this,r=null;if("number"==typeof e)r=e,e=null;else{if("string"==typeof e&&"loaded"===t._state&&!t._sprite[e])return null;if(void 0===e){e="__default";for(var a=0,u=0;u<t._sounds.length;u++)t._sounds[u]._paused&&!t._sounds[u]._ended&&(a++,r=t._sounds[u]._id);1===a?e=null:r=null}}var i=r?t._soundById(r):t._inactiveSound();if(!i)return null;if(r&&!e&&(e=i._sprite||"__default"),"loaded"!==t._state){i._sprite=e,i._ended=!1;var d=i._id;return t._queue.push({event:"play",action:function(){t.play(d)}}),d}if(r&&!i._paused)return o||setTimeout(function(){t._emit("play",i._id)},0),i._id;t._webAudio&&n._autoResume();var _=Math.max(0,i._seek>0?i._seek:t._sprite[e][0]/1e3),s=Math.max(0,(t._sprite[e][0]+t._sprite[e][1])/1e3-_),l=1e3*s/Math.abs(i._rate);i._paused=!1,i._ended=!1,i._sprite=e,i._seek=_,i._start=t._sprite[e][0]/1e3,i._stop=(t._sprite[e][0]+t._sprite[e][1])/1e3,i._loop=!(!i._loop&&!t._sprite[e][2]);var c=i._node;if(t._webAudio){var f=function(){t._refreshBuffer(i);var e=i._muted||t._muted?0:i._volume;c.gain.setValueAtTime(e,n.ctx.currentTime),i._playStart=n.ctx.currentTime,void 0===c.bufferSource.start?i._loop?c.bufferSource.noteGrainOn(0,_,86400):c.bufferSource.noteGrainOn(0,_,s):i._loop?c.bufferSource.start(0,_,86400):c.bufferSource.start(0,_,s),l!==1/0&&(t._endTimers[i._id]=setTimeout(t._ended.bind(t,i),l)),o||setTimeout(function(){t._emit("play",i._id)},0)},p="running"===n.state;if("loaded"===t._state&&p)f();else{var v=p||"loaded"!==t._state?"load":"resume";t.once(v,f,p?i._id:null),t._clearTimer(i._id)}}else{var m=function(){c.currentTime=_,c.muted=i._muted||t._muted||n._muted||c.muted,c.volume=i._volume*n.volume(),c.playbackRate=i._rate,c.play(),l!==1/0&&(t._endTimers[i._id]=setTimeout(t._ended.bind(t,i),l)),o||t._emit("play",i._id)},h="loaded"===t._state&&(window&&window.ejecta||!c.readyState&&n._navigator.isCocoonJS);if(4===c.readyState||h)m();else{var g=function(){m(),c.removeEventListener(n._canPlayEvent,g,!1)};c.addEventListener(n._canPlayEvent,g,!1),t._clearTimer(i._id)}}return i._id},pause:function(e){var n=this;if("loaded"!==n._state)return n._queue.push({event:"pause",action:function(){n.pause(e)}}),n;for(var o=n._getSoundIds(e),t=0;t<o.length;t++){n._clearTimer(o[t]);var r=n._soundById(o[t]);if(r&&!r._paused&&(r._seek=n.seek(o[t]),r._rateSeek=0,r._paused=!0,n._stopFade(o[t]),r._node))if(n._webAudio){if(!r._node.bufferSource)continue;void 0===r._node.bufferSource.stop?r._node.bufferSource.noteOff(0):r._node.bufferSource.stop(0),n._cleanBuffer(r._node)}else isNaN(r._node.duration)&&r._node.duration!==1/0||r._node.pause();arguments[1]||n._emit("pause",r?r._id:null)}return n},stop:function(e,n){var o=this;if("loaded"!==o._state)return o._queue.push({event:"stop",action:function(){o.stop(e)}}),o;for(var t=o._getSoundIds(e),r=0;r<t.length;r++){o._clearTimer(t[r]);var a=o._soundById(t[r]);a&&(a._seek=a._start||0,a._rateSeek=0,a._paused=!0,a._ended=!0,o._stopFade(t[r]),a._node&&(o._webAudio?a._node.bufferSource&&(void 0===a._node.bufferSource.stop?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),o._cleanBuffer(a._node)):isNaN(a._node.duration)&&a._node.duration!==1/0||(a._node.currentTime=a._start||0,a._node.pause())),n||o._emit("stop",a._id))}return o},mute:function(e,o){var t=this;if("loaded"!==t._state)return t._queue.push({event:"mute",action:function(){t.mute(e,o)}}),t;if(void 0===o){if("boolean"!=typeof e)return t._muted;t._muted=e}for(var r=t._getSoundIds(o),a=0;a<r.length;a++){var u=t._soundById(r[a]);u&&(u._muted=e,t._webAudio&&u._node?u._node.gain.setValueAtTime(e?0:u._volume,n.ctx.currentTime):u._node&&(u._node.muted=!!n._muted||e),t._emit("mute",u._id))}return t},volume:function(){var e,o,t=this,r=arguments;if(0===r.length)return t._volume;if(1===r.length||2===r.length&&void 0===r[1]){t._getSoundIds().indexOf(r[0])>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else r.length>=2&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var a;if(!(void 0!==e&&e>=0&&e<=1))return a=o?t._soundById(o):t._sounds[0],a?a._volume:0;if("loaded"!==t._state)return t._queue.push({event:"volume",action:function(){t.volume.apply(t,r)}}),t;void 0===o&&(t._volume=e),o=t._getSoundIds(o);for(var u=0;u<o.length;u++)(a=t._soundById(o[u]))&&(a._volume=e,r[2]||t._stopFade(o[u]),t._webAudio&&a._node&&!a._muted?a._node.gain.setValueAtTime(e,n.ctx.currentTime):a._node&&!a._muted&&(a._node.volume=e*n.volume()),t._emit("volume",a._id));return t},fade:function(e,o,t,r){var a=this,u=Math.abs(e-o),i=e>o?"out":"in",d=u/.01,_=d>0?t/d:t;if(_<4&&(d=Math.ceil(d/(4/_)),_=4),"loaded"!==a._state)return a._queue.push({event:"fade",action:function(){a.fade(e,o,t,r)}}),a;a.volume(e,r);for(var s=a._getSoundIds(r),l=0;l<s.length;l++){var c=a._soundById(s[l]);if(c){if(r||a._stopFade(s[l]),a._webAudio&&!c._muted){var f=n.ctx.currentTime,p=f+t/1e3;c._volume=e,c._node.gain.setValueAtTime(e,f),c._node.gain.linearRampToValueAtTime(o,p)}var v=e;c._interval=setInterval(function(n,t){d>0&&(v+="in"===i?.01:-.01),v=Math.max(0,v),v=Math.min(1,v),v=Math.round(100*v)/100,a._webAudio?(void 0===r&&(a._volume=v),t._volume=v):a.volume(v,n,!0),(o<e&&v<=o||o>e&&v>=o)&&(clearInterval(t._interval),t._interval=null,a.volume(o,n),a._emit("fade",n))}.bind(a,s[l],c),_)}}return a},_stopFade:function(e){var o=this,t=o._soundById(e);return t&&t._interval&&(o._webAudio&&t._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(t._interval),t._interval=null,o._emit("fade",e)),o},loop:function(){var e,n,o,t=this,r=arguments;if(0===r.length)return t._loop;if(1===r.length){if("boolean"!=typeof r[0])return!!(o=t._soundById(parseInt(r[0],10)))&&o._loop;e=r[0],t._loop=e}else 2===r.length&&(e=r[0],n=parseInt(r[1],10));for(var a=t._getSoundIds(n),u=0;u<a.length;u++)(o=t._soundById(a[u]))&&(o._loop=e,t._webAudio&&o._node&&o._node.bufferSource&&(o._node.bufferSource.loop=e,e&&(o._node.bufferSource.loopStart=o._start||0,o._node.bufferSource.loopEnd=o._stop)));return t},rate:function(){var e,o,t=this,r=arguments;if(0===r.length)o=t._sounds[0]._id;else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var i;if("number"!=typeof e)return i=t._soundById(o),i?i._rate:t._rate;if("loaded"!==t._state)return t._queue.push({event:"rate",action:function(){t.rate.apply(t,r)}}),t;void 0===o&&(t._rate=e),o=t._getSoundIds(o);for(var d=0;d<o.length;d++)if(i=t._soundById(o[d])){i._rateSeek=t.seek(o[d]),i._playStart=t._webAudio?n.ctx.currentTime:i._playStart,i._rate=e,t._webAudio&&i._node&&i._node.bufferSource?i._node.bufferSource.playbackRate.value=e:i._node&&(i._node.playbackRate=e);var _=t.seek(o[d]),s=(t._sprite[i._sprite][0]+t._sprite[i._sprite][1])/1e3-_,l=1e3*s/Math.abs(i._rate);!t._endTimers[o[d]]&&i._paused||(t._clearTimer(o[d]),t._endTimers[o[d]]=setTimeout(t._ended.bind(t,i),l)),t._emit("rate",i._id)}return t},seek:function(){var e,o,t=this,r=arguments;if(0===r.length)o=t._sounds[0]._id;else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):(o=t._sounds[0]._id,e=parseFloat(r[0]))}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));if(void 0===o)return t;if("loaded"!==t._state)return t._queue.push({event:"seek",action:function(){t.seek.apply(t,r)}}),t;var i=t._soundById(o);if(i){if(!("number"==typeof e&&e>=0)){if(t._webAudio){var d=t.playing(o)?n.ctx.currentTime-i._playStart:0,_=i._rateSeek?i._rateSeek-i._seek:0;return i._seek+(_+d*Math.abs(i._rate))}return i._node.currentTime}var s=t.playing(o);s&&t.pause(o,!0),i._seek=e,i._ended=!1,t._clearTimer(o),s&&t.play(o,!0),!t._webAudio&&i._node&&(i._node.currentTime=e),t._emit("seek",o)}return t},playing:function(e){var n=this;if("number"==typeof e){var o=n._soundById(e);return!!o&&!o._paused}for(var t=0;t<n._sounds.length;t++)if(!n._sounds[t]._paused)return!0;return!1},duration:function(e){var n=this,o=n._duration,t=n._soundById(e);return t&&(o=n._sprite[t._sprite][1]/1e3),o},state:function(){return this._state},unload:function(){for(var e=this,o=e._sounds,t=0;t<o.length;t++){if(o[t]._paused||e.stop(o[t]._id),!e._webAudio){/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent)||(o[t]._node.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"),o[t]._node.removeEventListener("error",o[t]._errorFn,!1),o[t]._node.removeEventListener(n._canPlayEvent,o[t]._loadFn,!1)}delete o[t]._node,e._clearTimer(o[t]._id);var a=n._howls.indexOf(e);a>=0&&n._howls.splice(a,1)}var u=!0;for(t=0;t<n._howls.length;t++)if(n._howls[t]._src===e._src){u=!1;break}return r&&u&&delete r[e._src],n.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},on:function(e,n,o,t){var r=this,a=r["_on"+e];return"function"==typeof n&&a.push(t?{id:o,fn:n,once:t}:{id:o,fn:n}),r},off:function(e,n,o){var t=this,r=t["_on"+e],a=0;if("number"==typeof n&&(o=n,n=null),n||o)for(a=0;a<r.length;a++){var u=o===r[a].id;if(n===r[a].fn&&u||!n&&u){r.splice(a,1);break}}else if(e)t["_on"+e]=[];else{var i=Object.keys(t);for(a=0;a<i.length;a++)0===i[a].indexOf("_on")&&Array.isArray(t[i[a]])&&(t[i[a]]=[])}return t},once:function(e,n,o){var t=this;return t.on(e,n,o,1),t},_emit:function(e,n,o){for(var t=this,r=t["_on"+e],a=r.length-1;a>=0;a--)r[a].id&&r[a].id!==n&&"load"!==e||(setTimeout(function(e){e.call(this,n,o)}.bind(t,r[a].fn),0),r[a].once&&t.off(e,r[a].fn,r[a].id));return t},_loadQueue:function(){var e=this;if(e._queue.length>0){var n=e._queue[0];e.once(n.event,function(){e._queue.shift(),e._loadQueue()}),n.action()}return e},_ended:function(e){var o=this,t=e._sprite;if(!o._webAudio&&o._node&&!o._node.ended)return setTimeout(o._ended.bind(o,e),100),o;var r=!(!e._loop&&!o._sprite[t][2]);if(o._emit("end",e._id),!o._webAudio&&r&&o.stop(e._id,!0).play(e._id),o._webAudio&&r){o._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=n.ctx.currentTime;var a=1e3*(e._stop-e._start)/Math.abs(e._rate);o._endTimers[e._id]=setTimeout(o._ended.bind(o,e),a)}return o._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,o._clearTimer(e._id),o._cleanBuffer(e._node),n._autoSuspend()),o._webAudio||r||o.stop(e._id),o},_clearTimer:function(e){var n=this;return n._endTimers[e]&&(clearTimeout(n._endTimers[e]),delete n._endTimers[e]),n},_soundById:function(e){for(var n=this,o=0;o<n._sounds.length;o++)if(e===n._sounds[o]._id)return n._sounds[o];return null},_inactiveSound:function(){var e=this;e._drain();for(var n=0;n<e._sounds.length;n++)if(e._sounds[n]._ended)return e._sounds[n].reset();return new t(e)},_drain:function(){var e=this,n=e._pool,o=0,t=0;if(!(e._sounds.length<n)){for(t=0;t<e._sounds.length;t++)e._sounds[t]._ended&&o++;for(t=e._sounds.length-1;t>=0;t--){if(o<=n)return;e._sounds[t]._ended&&(e._webAudio&&e._sounds[t]._node&&e._sounds[t]._node.disconnect(0),e._sounds.splice(t,1),o--)}}},_getSoundIds:function(e){var n=this;if(void 0===e){for(var o=[],t=0;t<n._sounds.length;t++)o.push(n._sounds[t]._id);return o}return[e]},_refreshBuffer:function(e){var o=this;return e._node.bufferSource=n.ctx.createBufferSource(),e._node.bufferSource.buffer=r[o._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop),e._node.bufferSource.playbackRate.value=e._rate,o},_cleanBuffer:function(e){var n=this;if(n._scratchBuffer){e.bufferSource.onended=null,e.bufferSource.disconnect(0);try{e.bufferSource.buffer=n._scratchBuffer}catch(e){}}return e.bufferSource=null,n}};var t=function(e){this._parent=e,this.init()};t.prototype={init:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,o._sounds.push(e),e.create(),e},create:function(){var e=this,o=e._parent,t=n._muted||e._muted||e._parent._muted?0:e._volume;return o._webAudio?(e._node=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),e._node.gain.setValueAtTime(t,n.ctx.currentTime),e._node.paused=!0,e._node.connect(n.masterGain)):(e._node=new Audio,e._errorFn=e._errorListener.bind(e),e._node.addEventListener("error",e._errorFn,!1),e._loadFn=e._loadListener.bind(e),e._node.addEventListener(n._canPlayEvent,e._loadFn,!1),e._node.src=o._src,e._node.preload="auto",e._node.volume=t*n.volume(),e._node.load()),e},reset:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,e},_errorListener:function(){var e=this;e._parent._emit("loaderror",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener("error",e._errorFn,!1)},_loadListener:function(){var e=this,o=e._parent;o._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(o._sprite).length&&(o._sprite={__default:[0,1e3*o._duration]}),"loaded"!==o._state&&(o._state="loaded",o._emit("load"),o._loadQueue()),e._node.removeEventListener(n._canPlayEvent,e._loadFn,!1)}};var r={},a=function(e){var n=e._src;if(r[n])return e._duration=r[n].duration,void d(e);if(/^data:[^;]+;base64,/.test(n)){for(var o=atob(n.split(",")[1]),t=new Uint8Array(o.length),a=0;a<o.length;++a)t[a]=o.charCodeAt(a);i(t.buffer,e)}else{var _=new XMLHttpRequest;_.open("GET",n,!0),_.responseType="arraybuffer",_.onload=function(){var n=(_.status+"")[0];if("0"!==n&&"2"!==n&&"3"!==n)return void e._emit("loaderror",null,"Failed loading audio file with status: "+_.status+".");i(_.response,e)},_.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete r[n],e.load())},u(_)}},u=function(e){try{e.send()}catch(n){e.onerror()}},i=function(e,o){n.ctx.decodeAudioData(e,function(e){e&&o._sounds.length>0&&(r[o._src]=e,d(o,e))},function(){o._emit("loaderror",null,"Decoding audio data failed.")})},d=function(e,n){n&&!e._duration&&(e._duration=n.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},_=function(){try{"undefined"!=typeof AudioContext?n.ctx=new AudioContext:"undefined"!=typeof webkitAudioContext?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch(e){n.usingWebAudio=!1}var e=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),o=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),t=o?parseInt(o[1],10):null;if(e&&t&&t<9){var r=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());(n._navigator&&n._navigator.standalone&&!r||n._navigator&&!n._navigator.standalone&&!r)&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.value=n._muted?0:1,n.masterGain.connect(n.ctx.destination)),n._setup()};"function"==typeof define&&define.amd&&define([],function(){return{Howler:n,Howl:o}}),"undefined"!=typeof exports&&(exports.Howler=n,exports.Howl=o),"undefined"!=typeof window?(window.HowlerGlobal=e,window.Howler=n,window.Howl=o,window.Sound=t):"undefined"!=typeof global&&(global.HowlerGlobal=e,global.Howler=n,global.Howl=o,global.Sound=t)}();
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
// interactionType can be either of "point", "segment", "line", "circle".
function PlanDrawClass(_obj) {
  var events = {};
  var scaleObj = {
    x: 0,
    y: 0,
    xTo: 200,
    yTo: 200,
    pointColor: 'rgba(10,190,220,1)',
    pointRadius: 7,
    segmentColor: 'rgba(10,190,220,1)',
    segmentWidth: 3,
    visible: false
  };
  var modelObj = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    bgColor: 'rgba(255, 255, 255, 0.5)',
    state: true,
    visible: true,
    interactionType: '',
    interactionElements: [],
    pointColor: 'rgba(10,190,220,1)',
    pointLabelColor: 'rgba(51,51,51,1)',
    pointRadius: 5,
    segmentColor: 'rgba(10,190,220,1)',
    segmentWidth: 2,
    tempElements: [],
    transperent: false,
    eventsEnable: true,
    fontSize: 20,
    currentStep: 0,
    snapToGrid: false,
    snappingDiff: 10,
    // in pixel,
    deviceSnappingDiff: 25,
    shapesEditable: false,
    undoRedo: false,
    pointSnapping: false,
    finalColor: 'rgba(65,180,5,1)',
    screen: {},
    labelBGRatio: 1,
    waiting: false,
    ignorePointToColor: false,
    shapes: {
      length: {
        digit: 0
      },
      circle: {
        digit: 0
      },
      line: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        }
      },
      brush1: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        }
      },
      brush2: {
        color: {
          stroke: 'rgba(222,108,225,1)'
        }
      },
      brush3: {
        color: {
          stroke: 'rgba(255,204,0,1)'
        }
      },
      segment: {
        color: {
          stroke: 'rgba(10,190,220,1)'
        },
        label: {
          visible: false
        }
      },
      angle: {
        dotOn90: true
      }
    }
  };
  var localObj = {
    mouseDown: {
      isMouseDown: false,
      lastShapeCompleted: true
    },
    uniqueId: 0,
    currentUniqueId: 0,
    allShapesData: [],
    tempData: [],
    mouseDownData: null,
    isDevice: false,
    newPlottedShapes: [],
    lineTypes: ['line', 'ray', 'perpendicularLine', 'parallelLine', 'segment', 'segmentDash'],
    isLableSelected: false,
    arbitaryX: 1,
    onBoundary: false,
    arbitaryPoint: null,
    aOnBound: false,
    bOnBound: false,
    cOnBound: false,
    dOnBound: false,
    shapeOnBound: false,
    plotPointOnExistingPoint: false,
    isCollinear: false
  };

  var _this = this;

  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === 'object' && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === 'object' && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  }

  modelObj.centerX = modelObj.x + modelObj.width / 2;
  modelObj.centerY = modelObj.y + modelObj.height / 2;
  setScaleValues();
  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass();
  localObj.isDevice = modelObj.LabComClass.BrowserDetect.isDevice();

  if (localObj.isDevice) {
    modelObj.snappingDiff = modelObj.deviceSnappingDiff;
  } // addEvents();


  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.alpha = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.setTransperent = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.transperent = _flag;
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  }; // =================================================


  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    addEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  };

  this.editable = function (flag) {
    modelObj.shapesEditable = flag;
    return modelObj.shapesEditable;
  };

  this.selectAll = function (_flag) {
    modelObj.interactionElements.forEach(function (item) {
      item.isSelected = _flag;
    });
  };

  this.snapToGrid = function (_flag) {
    modelObj.snapToGrid = _flag;
  };

  this.redoPossible = function () {
    return localObj.tempData.length !== 0;
  };

  this.setFinalView = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.finalView = _flag;
  };

  this.setPointSnapping = function () {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    modelObj.pointSnapping = _flag;
  };

  this.setStyle = function (uniqueId, _obj) {
    var styleApproved = {
      strokeColor: true,
      fillColor: true
    };
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        if (styleApproved[i]) {
          shape.shape[i] = _obj[i];
        }
      });
    }
  };

  this.deleteSelected = function () {
    if (modelObj.shapesEditable) {
      var selectedIds = [];
      modelObj.interactionElements.forEach(function (item) {
        if (item.isSelected && (item.isDeletable === undefined || item.isDeletable)) {
          selectedIds.push(item.uniqueId);
        }
      });
      removeShapes(selectedIds);
    }
  };

  this.setScaleDefaultPos = function (x1, y1, x2, y2) {
    var updateScalePos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    scaleObj.originPos = {
      x: x1,
      y: y1,
      xTo: x2,
      yTo: y2
    };

    if (updateScalePos) {
      scaleObj.x = scaleObj.originPos.x;
      scaleObj.y = scaleObj.originPos.y;
      scaleObj.xTo = scaleObj.originPos.xTo;
      scaleObj.yTo = scaleObj.originPos.yTo;
    }
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  };

  this.getStep = function () {
    return modelObj.currentStep;
  }; // =================================================


  this.showDrawing = function (_arr, _bool) {
    if (typeof _arr !== 'undefined' && _arr !== null) {
      _arr.forEach(function (item) {
        if (typeof item !== 'undefined') {
          item.visible = _bool;
        }
      });
    }
  }; // =================================================


  this.setInteractionType = function (_type) {
    if (typeof _type !== 'undefined') {
      if (modelObj.interactionType !== _type) {
        modelObj.interactionType = _type;
        clearCache();
        addEvents();
      }
    }
  };

  this.getInteractionType = function () {
    return modelObj.interactionType;
  };

  this.setStep = function (_step) {
    if (modelObj.currentStep > _step) {
      removeShapes(modelObj.interactionElements.filter(function (e) {
        return e.step > _step;
      }).map(function (e) {
        return e.uniqueId;
      }));
    }

    modelObj.currentStep = _step;
  };

  this.getCount = function () {
    return modelObj.interactionElements.length;
  };

  this.getData = function () {
    return {
      visible: JSON.parse(JSON.stringify(modelObj.interactionElements)),
      nonVisible: modelObj.tempElements
    };
  };

  this.setWaiting = function (_bool) {
    modelObj.waiting = _bool;
  };

  this.getWaiting = function () {
    return modelObj.waiting;
  };

  this.setScreenData = function (_obj) {
    modelObj.graphValues = _obj;
    modelObj.x = _obj.x;
    modelObj.y = _obj.y;
    modelObj.width = _obj.width;
    modelObj.height = _obj.height;
    modelObj.screen = _obj.screen;
    modelObj.centerX = _obj.originX;
    modelObj.centerY = _obj.originY;
    modelObj.showQuadrants = _obj.showQuadrants;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var shape = modelObj.interactionElements[i];

      if ((shape.type === 'line' || shape.type === 'ray') && shape.label) {
        var pos = findLableByLine(shape, {
          x: shape.xTo,
          y: shape.yTo
        });
        shape.labelX = pos.x;
        shape.labelY = pos.y;
      }
    }

    setScaleValues();
    updateAllShapes();
    addEvents();
  };

  this.plotAngleSize = function (_obj) {
    if (!modelObj.waiting) {
      var angleSize = {
        type: 'angleSize',
        uniqueId: ++localObj.uniqueId,
        x: 0,
        y: 0,
        xTo: 0,
        yTo: 0,
        degree: 0,
        clockwise: true,
        connectionId: []
      };
      var rayId = ++localObj.uniqueId;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var angle = modelObj.LabComClass.Maths.getAngle(angleSize.x, angleSize.y, angleSize.xTo, angleSize.yTo);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(angleSize, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + '°';
      }

      if (angleSize.labelX === undefined) {
        var angleTextPos = modelObj.LabComClass.Maths.getPoint(angleSize, angle + angleSize.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleTextPos.x;
        angleSize.labelY = angleTextPos.y;
        angleSize.labelDiffX = angleSize.labelDiffX !== undefined ? angleSize.labelDiffX : 0;
        angleSize.labelDiffY = angleSize.labelDiffY !== undefined ? angleSize.labelDiffY : 0;
      }

      var newAngleSize = addNewShape(angleSize); // localObj.newPlottedShapes.push(angleSize.uniqueId);

      var ray = addNewShape({
        type: 'ray',
        uniqueId: rayId,
        x: angleSize.x,
        y: angleSize.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        connectionId: []
      }); // localObj.newPlottedShapes.push(rayId);

      updateLinePoints(ray);
      angleSize.connectionId.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;
      return {
        angleSize: newAngleSize,
        ray: ray
      };
    }
  };

  this.setAngleSize = function (_obj) {
    if (modelObj.waiting) {
      var rayId = ++localObj.uniqueId;
      var angleSize = findShape(_obj.uniqueId).shape;
      Object.keys(_obj).forEach(function (i) {
        angleSize[i] = _obj[i];
      });
      var firstPoint = findShape(_obj.firstPointId).shape;
      var angle = modelObj.LabComClass.Maths.getAngle(_obj.x, _obj.y, firstPoint.x, firstPoint.y);
      _obj.degree *= angleSize.clockwise ? -1 : 1;
      var rayEnd = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree * Math.PI / 180, getPointUnitByPixelUnit(10));

      if (angleSize.clockwise) {
        angleSize.startAngle = angle;
        angleSize.endAngle = angle + _obj.degree * Math.PI / 180;
      } else {
        angleSize.startAngle = angle + _obj.degree * Math.PI / 180;
        angleSize.endAngle = angle;
      }

      if (!angleSize.label) {
        angleSize.label = angleSize.degree + '°';
      }

      if (angleSize.labelX === undefined) {
        var angleText = modelObj.LabComClass.Maths.getPoint(_obj, angle + _obj.degree / 2 * Math.PI / 180, getPointUnitByPixelUnit(25));
        angleSize.labelX = angleText.x;
        angleSize.labelY = angleText.y;
        angleSize.labelDiffX = 0;
        angleSize.labelDiffY = 0;
      }

      var newShape = addNewShape({
        type: 'ray',
        uniqueId: rayId,
        firstPointId: _obj.secondPointId,
        x: _obj.x,
        y: _obj.y,
        xTo: rayEnd.x,
        yTo: rayEnd.y,
        connectionId: [_obj.secondPointId]
      });
      updateLinePoints(newShape);
      angleSize.connectionId.push(rayId);
      localObj.newPlottedShapes.push(rayId);
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  this.setSegSize = function (_obj) {
    if (modelObj.waiting) {
      var segmentId = ++localObj.uniqueId;
      var secondPointId = ++localObj.uniqueId;
      var segSize = findShape(_obj.uniqueId).shape;
      var firstPoint = findShape(segSize.firstPointId).shape;
      addNewShape({
        type: 'segment',
        uniqueId: segmentId,
        x: _obj.x,
        y: _obj.y,
        xTo: _obj.x + _obj.distance,
        yTo: _obj.y,
        connectionId: [_obj.firstPointId, secondPointId]
      });
      addNewShape({
        type: 'point',
        uniqueId: secondPointId,
        x: _obj.x + _obj.distance,
        y: _obj.y,
        connectionId: [segmentId]
      });
      segSize.connectionId.push(segmentId);
      segSize.connectionId.push(secondPointId);
      segSize.secondPointId = secondPointId;
      localObj.newPlottedShapes.push(segmentId);
      localObj.newPlottedShapes.push(secondPointId);
      segSize.segmentId = segmentId;
      segSize.distance = _obj.distance;
      localObj.mouseDown.lastShapeCompleted = true;
      var value = {
        x: _obj.x,
        y: _obj.y,
        uniqueId: _obj.uniqueId
      };
      dispatchData(value, true);
      modelObj.waiting = false;
    }
  };

  function getPointByPixel(_x, _y) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = (_x - _g.originX) / _g.unitX;
    pointY = -1 * (_y - _g.originY) / _g.unitY;
    return {
      x: pointX,
      y: pointY
    };
  }

  this.getPointByPixel = function (_x, _y) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = (_x - _g.originX) / _g.unitX;
    pointY = -1 * (_y - _g.originY) / _g.unitY;
    return {
      x: pointX,
      y: pointY
    };
  };

  function getPixelByPoint(valueX, valueY) {
    var pointX;
    var pointY;
    var _g = modelObj.graphValues;
    pointX = valueX * _g.unitX + _g.originX;
    pointY = valueY * _g.unitY / -1 + _g.originY;
    return {
      x: pointX,
      y: pointY
    };
  }

  function getPointUnitByPixelUnit(_pixelUnit) {
    return _pixelUnit / modelObj.graphValues.unitX;
  }

  function getPixelUnitByPointUnit(_pointUnit) {
    return _pointUnit * modelObj.graphValues.unitX;
  }

  this.setData = function (_data) {
    if (_data.visible !== undefined) {
      modelObj.interactionElements = JSON.parse(JSON.stringify(_data.visible));
    }

    if (_data.nonVisible !== undefined) {
      modelObj.tempElements = JSON.parse(JSON.stringify(_data.nonVisible));
    }

    clearCache();
  };

  this.getCurrentStepIndex = function (_num) {
    var arr = [];

    var _loop = typeof _num === 'undefined' ? 1 : _num;

    if (modelObj.interactionType !== 'scale') {
      for (var i = _loop; i > 0; i--) {
        arr.push(modelObj.interactionElements.length - i);
      }
    }

    return arr;
  };

  this.removeRecentShapes = function () {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (data.length) {
      removeShapes(data);
    } else {
      removeShapes(localObj.newPlottedShapes);
    }
  }; // =================================================


  this.clearAll = function () {
    modelObj.interactionElements = [];
    localObj.uniqueId = 0;
    modelObj.currentStep = 0;
    modelObj.finalView = false;

    _this.clearTemp();
  };

  this.clearTemp = function () {
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
    modelObj.tempElements = [];
    localObj.allShapesData = [];
    localObj.tempData = [];
    clearCache();
  };

  this.undo = function () {
    if (localObj.allShapesData.length) {
      localObj.tempData.push(localObj.allShapesData.pop());

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
      } else {
        modelObj.interactionElements = [];
      }
    }
  };

  this.redo = function () {
    if (localObj.tempData.length) {
      localObj.allShapesData.push(localObj.tempData.pop());

      if (localObj.allShapesData.length) {
        modelObj.interactionElements = JSON.parse(JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]));
      } else {
        modelObj.interactionElements = [];
      }
    }
  };

  function saveData() {
    if (modelObj.undoRedo) {
      var currentData = JSON.stringify(modelObj.interactionElements);
      var addData = false;

      if (localObj.allShapesData.length) {
        var lastData = JSON.stringify(localObj.allShapesData[localObj.allShapesData.length - 1]);

        if (currentData !== lastData) {
          addData = true;
        }
      } else {
        addData = true;
      }

      if (addData) {
        localObj.allShapesData.push(JSON.parse(JSON.stringify(modelObj.interactionElements)));
        localObj.tempData = [];
      }
    }
  }

  this.addShape = function (_objData) {
    clearCache();

    var _obj = JSON.parse(JSON.stringify(_objData));

    _obj.uniqueId = ++localObj.uniqueId;

    if (!modelObj.shapesEditable) {
      _obj.isDraggable = false;
      _obj.isDeletable = false;
    }

    if (_obj.label) {
      if (_obj.labelX === undefined) {
        _obj.labelX = _obj.x;
        _obj.labelY = _obj.y;
      }

      if (_obj.labelDiffX === undefined) {
        _obj.labelDiffX = 0;
        _obj.labelDiffY = 0;
      }
    }

    _obj.connectionId = [];

    switch (_obj.type) {
      case 'point':
        updatePoints(addNewShape(_obj));
        break;

      case 'circle':
        updatePoints(addNewShape(_obj));
        break;

      case 'circle_3':
        updatePoints(addNewShape(_obj));
        break;

      case 'line':
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case 'triangle':
        addNewShape(_obj);
        break;

      case 'segment':
      case 'segmentDash':
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case 'ray':
        checkForConnection(_obj);
        updateLinePoints(addNewShape(_obj));
        break;

      case 'perpendicularLine':
        updatePLinePoints(addNewShape(_obj));
        break;

      case 'parallelLine':
        updatePLinePoints(addNewShape(_obj));
        break;

      case 'length':
        _obj.labelAlign = 'center';
        checkForConnection(_obj);
        addNewShape(_obj);
        break;

      case 'polygonShape':
        addNewShape(_obj);
        break;

      case 'angle':
      case 'angleRay':
      case 'angleB':
        addNewShape(_obj);
        break;

      case 'mirrorOnLine':
        addNewShape(_obj);

      default:
        break;
    }

    updateAllShapes();
    saveData();
    return _obj.uniqueId;
  };

  function checkForConnection(_obj) {
    if (_obj.type === 'line' || _obj.type === 'ray' || _obj.type === 'length') {
      modelObj.interactionElements.forEach(function (shape) {
        if (shape.type === 'point') {
          if (shape.x === _obj.x && shape.y === _obj.y) {
            _obj.firstPointId = shape.uniqueId;

            _obj.connectionId.push(_obj.firstPointId);
          }

          if (shape.x === _obj.xTo && shape.y === _obj.yTo) {
            _obj.secondPointId = shape.uniqueId;

            _obj.connectionId.push(_obj.secondPointId);
          }
        }
      });
    }
  }

  this.removeIncompleteShape = function () {
    if (!localObj.mouseDown.lastShapeCompleted) {
      _this.removeUnplotedShapes();
    } else {
      clearScreen(false);
    }
  };

  this.removeUnplotedShapes = function () {
    removeShapes(localObj.newPlottedShapes);
    clearScreen(true);
  };

  function clearScreen(closeThePanel) {
    localObj.newPlottedShapes = [];
    localObj.mouseDown.lastShapeCompleted = true;
    modelObj.waiting = false;

    if (closeThePanel) {
      if (typeof events.angleSize !== 'undefined') {
        events.angleSize({
          id: modelObj.id,
          type: 'angleSize',
          visible: false
        }, true);
      }

      if (typeof events.segSize !== 'undefined') {
        events.segSize({
          id: modelObj.id,
          type: 'segSize',
          visible: false
        }, true);
      }
    }
  }

  function clearCache() {
    modelObj.waiting = false;

    _this.removeIncompleteShape();

    localObj.newPlottedShapes = [];

    if (modelObj.interactionType !== 'select') {
      for (var i = 0; i < modelObj.interactionElements.length; i++) {
        modelObj.interactionElements[i].isSelected = false;
      }
    }

    scaleObj.visible = modelObj.interactionType === 'scale';
  }

  function removeShapes(data) {
    for (var i = 0; i < data.length; i++) {
      var shape = findShape(data[i]);

      if (shape && shape.index !== undefined) {
        removeShape(data[i]);
      }
    }

    saveData();
  }

  function removeShape(id) {
    var shapeData = modelObj.interactionElements;
    var data = findShape(id);
    var shape = data.shape;
    var index = data.index;

    if (shape) {
      var connectionId = shape.connectionId;

      if (connectionId) {
        connectionId.forEach(function (cd) {
          shapeData.forEach(function (sd) {
            var checkingShape = sd;

            if (checkingShape && checkingShape.uniqueId === cd) {
              if (checkingShape.isDeletable === undefined || checkingShape.isDeletable === false) {
                if (checkingShape.connectionId.length > 1) {
                  var _index2 = checkingShape.connectionId.indexOf(shape.uniqueId);

                  if (_index2 > -1) {
                    checkingShape.connectionId.splice(_index2, 1);
                  }

                  if (checkType(checkingShape, ['line', 'segment', 'segmentDash', 'ray'])) {
                    if (checkingShape.firstPointId === shape.uniqueId || checkingShape.secondPointId === shape.uniqueId) {
                      checkingShape.connectionId.forEach(function (elem) {
                        var connectedShape = findShape(elem).shape;

                        if (connectedShape) {
                          var _index = connectedShape.connectionId.indexOf(checkingShape.uniqueId);

                          if (_index2 > -1) {
                            connectedShape.connectionId.splice(_index, 1);
                          }
                        }
                      });
                      sd = null;
                    }
                  }
                }
              }
            }
          });
        });
      }

      shapeData[index] = null;
      modelObj.interactionElements = shapeData.filter(function (e) {
        return e !== null;
      });
      clearCache();
      saveData();
    }
  } // =================================================


  this.updateIndex = function (_obj) {
    var value = JSON.parse(JSON.stringify(_obj.data));
    var shapeData = findShape(value.uniqueId);
    var currentShape = shapeData.shape;
    var actionType = _obj.type;

    if (actionType === 'remove') {
      removeShape(value.uniqueId);
    } else if (actionType === 'update') {
      if (currentShape) {
        Object.keys(value).forEach(function (i) {
          currentShape[i] = value[i];
        });
      }

      var type = value.type;

      if (modelObj.interactionType === 'scale') {
        scaleObj.x = isNaN(value.x) ? scaleObj.x : value.x;
        scaleObj.y = isNaN(value.y) ? scaleObj.y : value.y;
        scaleObj.xTo = isNaN(value.xTo) ? scaleObj.xTo : value.xTo;
        scaleObj.yTo = isNaN(value.yTo) ? scaleObj.yTo : value.yTo;
        dispatchEventScale();
      } else if (type === 'point') {
        currentShape.x = value.x;
        currentShape.y = value.y;

        if (typeof value.label !== 'undefined') {
          currentShape.label = value.label;
          updatePoints(currentShape);
        }
      } else if (type === 'midPoint') {
        if (typeof value.label !== 'undefined') {
          currentShape.label = value.label;
          updatePoints(currentShape);
        }
      } else if (type.includes('segment')) {
        currentShape.x = value.x;
        currentShape.y = value.y;
        currentShape.xTo = value.xTo;
        currentShape.yTo = value.yTo;
      } else if (type === 'line' || type === 'ray') {
        currentShape.x = value.x;
        currentShape.y = value.y;
        currentShape.xTo = value.xTo;
        currentShape.yTo = value.yTo;

        if (value.label) {
          currentShape.label = value.label;
        }

        if (currentShape.connectionId) {
          for (var i = 0; i < currentShape.connectionId.length; i++) {
            var _shapeData = findShape(currentShape.connectionId[i]);

            if (_shapeData.shape && _shapeData.shape.type === 'point' && _shapeData.shape.uniqueId === currentShape.firstPointId) {
              _shapeData.shape.x = currentShape.x;
              _shapeData.shape.y = currentShape.y;
            }

            if (_shapeData.shape && _shapeData.shape.type === 'point' && _shapeData.shape.uniqueId === currentShape.secondPointId) {
              _shapeData.shape.x = currentShape.xTo;
              _shapeData.shape.y = currentShape.yTo;
            }
          }
        }

        updateLinePoints(currentShape);
      } else if (type === 'circle') {
        Object.keys(value).forEach(function (i) {
          currentShape[i] = value[i];
        });
      } else if (type === 'circle_3') {} else if (type === 'perpendicularLine' || type === 'parallelLine') {
        currentShape.x = value.x;
        currentShape.y = value.y;
        currentShape.slope = value.slope;

        if (currentShape.connectionId) {
          currentShape.connectionId.forEach(function (id) {
            var shapeData = findShape(id);

            if (shapeData.shape && shapeData.shape.type === 'point') {
              shapeData.shape.x = currentShape.x;
              shapeData.shape.y = currentShape.y;
            }
          });
        }

        updatePLinePoints(currentShape);
      }
    }

    saveData();
  }; // =================================================


  this.draw = function () {
    var _ctx = modelObj.context;
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height,
        transperent = modelObj.transperent,
        interactionElements = modelObj.interactionElements,
        segmentColor = modelObj.segmentColor,
        fontSize = modelObj.fontSize,
        pointColor = modelObj.pointColor,
        interactionType = modelObj.interactionType,
        pointLabelColor = modelObj.pointLabelColor;

    if (modelObj.visible) {
      _ctx.save();

      _ctx.beginPath();

      _ctx.globalAlpha = transperent ? 0.5 : 1; // --------------------------------------

      _ctx.save();

      _ctx.fillStyle = '#000000';

      _ctx.rect(x, y, width, height);

      _ctx.clip();

      drawShapes(_ctx, modelObj);

      if (scaleObj.visible) {
        _ctx.save();

        _ctx.fillStyle = scaleObj.pointColor;
        _ctx.strokeStyle = scaleObj.segmentColor;
        _ctx.lineWidth = scaleObj.segmentWidth;

        _ctx.beginPath();

        _ctx.moveTo(scaleObj.x, scaleObj.y);

        _ctx.lineTo(scaleObj.xTo, scaleObj.yTo);

        _ctx.stroke();

        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.x, scaleObj.y, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.beginPath();

        _ctx.arc(scaleObj.xTo, scaleObj.yTo, scaleObj.pointRadius, 0, 2 * Math.PI);

        _ctx.fill(); // _ctx.stroke();


        _ctx.closePath();

        _ctx.restore();
      }

      if (localObj.mouseDown.isMouseDown && interactionType === 'select' && localObj.currentUniqueId === null) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.fillStyle = 'rgba(69,146,176,0.1)';
        _ctx.strokeStyle = 'rgba(69,146,176,0.8)';
        var _localObj$mouseDown = localObj.mouseDown,
            orignalX = _localObj$mouseDown.orignalX,
            orignalY = _localObj$mouseDown.orignalY,
            _x3 = _localObj$mouseDown.x,
            _y3 = _localObj$mouseDown.y;

        _ctx.rect(orignalX, orignalY, _x3 - orignalX, _y3 - orignalY);

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        _ctx.restore();
      }

      _ctx.restore(); // --------------------------------------


      _ctx.closePath();

      _ctx.restore(); // --------------------------------------


      _ctx.save();

      var _modelObj$screen = modelObj.screen,
          sx = _modelObj$screen.x,
          sy = _modelObj$screen.y,
          sw = _modelObj$screen.w,
          sh = _modelObj$screen.h;
      _ctx.fillStyle = '#000000';

      _ctx.beginPath();

      _ctx.moveTo(sx, sy);

      _ctx.lineTo(sx, sy + sh);

      _ctx.lineTo(sx + sw, sy + sh);

      _ctx.lineTo(sx + sw, sy);

      _ctx.closePath();

      _ctx.clip();

      drawPoints(_ctx, modelObj);

      _ctx.restore(); // --------------------------------------
      // --------------------------------------


      _ctx.save();

      _ctx.fillStyle = '#000000';

      _ctx.beginPath();

      _ctx.moveTo(x, y);

      _ctx.lineTo(x, y + height);

      _ctx.lineTo(x + width, y + height);

      _ctx.lineTo(x + width, y);

      _ctx.closePath();

      _ctx.clip();

      if (!transperent) {
        drawlabels(_ctx, modelObj);
      }

      _ctx.restore(); // --------------------------------------

    }
  };

  function drawPoints(_ctx, _ref) {
    var x = _ref.x,
        y = _ref.y,
        height = _ref.height,
        interactionElements = _ref.interactionElements;
    interactionElements.forEach(function (item) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === 'point') {
          var draw = true;

          if (modelObj.showQuadrants === '1') {
            if (_xy.x < x || _xy.y > y + height) {
              draw = false;
            }
          }

          if (draw) {
            drawPoint(_ctx, item, true, false);
          }
        }

        if (item.type === 'midPoint') {
          var _draw = true;

          if (modelObj.showQuadrants === '1') {
            if (_xy.x < x || _xy.y > y + height) {
              _draw = false;
            }
          }

          if (_draw) {
            drawPoint(_ctx, item, true, false);
          }
        }
      }
    });
  }

  function drawlabels(_ctx, _ref2) {
    var interactionElements = _ref2.interactionElements,
        pointLabelColor = _ref2.pointLabelColor,
        fontSize = _ref2.fontSize;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      if (item.visible) {
        if (item.type === 'point') {
          drawPoint(_ctx, item, false, true);
        }

        if (item.type === 'length') {
          if (item.label) {
            var center = getPixelByPoint(item.labelX, item.labelY);
            center.x += item.labelDiffX;
            center.y += item.labelDiffY;

            _ctx.save();

            _ctx.beginPath();

            _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
            var textSize = _ctx.measureText(item.distanceText).width + fontSize / 2;
            _ctx.fillStyle = 'rgba(255,255,255,1)';
            _ctx.strokeStyle = 'rgba(199,199,199,1)';

            _ctx.rect(center.x - textSize / 2, center.y - fontSize * 1.2, textSize, fontSize * (modelObj.labelBGRatio + 0.1));

            _ctx.fill();

            _ctx.stroke();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.textBaseline = 'bottom';
            _ctx.textAlign = 'center';
            _ctx.fillStyle = pointLabelColor;

            _ctx.drawStyledText(item.label, center.x, center.y, modelObj.LabComClass.polo22KlettRegular, fontSize);

            _ctx.closePath();

            _ctx.restore();
          }
        }

        if (item.type.includes('segment') || checkType(item, ['angle', 'angleSize', 'line', 'ray', 'perpendicularLine', 'parallelLine', 'angleRay'])) {
          var showLable = true;

          if (modelObj.shapes.hasOwnProperty(item.type)) {
            if (modelObj.shapes[item.type].hasOwnProperty('label') && modelObj.shapes[item.type].label.hasOwnProperty('visible') && !modelObj.shapes[item.type].label.visible) {
              showLable = false;
            }
          }

          if (showLable && item.label !== undefined && item.labelX !== undefined) {
            var p = getPixelByPoint(item.labelX, item.labelY);
            var color = item.fillLabelColor ? item.fillLabelColor : pointLabelColor;
            drawStroked({
              ctx: _ctx,
              text: item.label,
              x: p.x,
              y: p.y,
              fillColor: color,
              center: true,
              diffX: Number(item.labelDiffX),
              diffY: Number(item.labelDiffY)
            });
          }
        }
      }
    });
  }

  function reduceLineEnd(p1, p2, r) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var mag = Math.hypot(dx, dy);
    return {
      x: p2.x - r * dx / mag,
      y: p2.y - r * dy / mag
    };
  }

  function drawArrowHead(_ctx, _xy, _xTo_yTo) {
    var headlen = 10; // length of head in pixels

    var angle = modelObj.LabComClass.Maths.getAngle(_xy.x, _xy.y, _xTo_yTo.x, _xTo_yTo.y);
    var newPosition = reduceLineEnd(_xy, _xTo_yTo, modelObj.pointRadius);

    _ctx.save();

    _ctx.beginPath();

    _ctx.moveTo(newPosition.x, newPosition.y);

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle - Math.PI / 6), newPosition.y - headlen * Math.sin(angle - Math.PI / 6));

    _ctx.lineTo(newPosition.x - headlen * Math.cos(angle + Math.PI / 6), newPosition.y - headlen * Math.sin(angle + Math.PI / 6));

    _ctx.lineTo(newPosition.x, newPosition.y);

    _ctx.stroke();

    _ctx.fill();

    _ctx.closePath();

    _ctx.restore();
  }

  function drawShapes(_ctx, _ref3) {
    var interactionElements = _ref3.interactionElements,
        segmentColor = _ref3.segmentColor,
        fontSize = _ref3.fontSize,
        pointLabelColor = _ref3.pointLabelColor;
    interactionElements.forEach(function (item, i) {
      var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

      var _xTo_yTo = item.xTo !== undefined ? getPixelByPoint(item.xTo, item.yTo) : null;

      var _xOr_yOr = item.xOr !== undefined ? getPixelByPoint(item.xOr, item.yOr) : null;

      var _xOrTo_yOrTo = item.xOrTo !== undefined ? getPixelByPoint(item.xOrTo, item.yOrTo) : null;

      if (item.visible) {
        _ctx.save();

        _ctx.beginPath();

        _ctx.strokeStyle = segmentColor;
        _ctx.fillStyle = segmentColor;

        if (item.strokeColor) {
          _ctx.strokeStyle = item.strokeColor;
        }

        if (item.fillColor) {
          _ctx.fillStyle = item.fillColor;
        }

        if (item.lineWidth) {
          _ctx.lineWidth = item.lineWidth;
        }

        if (item.isSelected) {
          _ctx.lineWidth = 2;
        }

        if (modelObj.finalView) {
          _ctx.fillStyle = modelObj.finalColor;
          _ctx.strokeStyle = modelObj.finalColor;
        }

        if (item.type === 'point') {// drawPoint(_ctx, item, true, false);
        } else if (item.type.includes('segment')) {
          if (item.type.includes('segmentDash')) {
            _ctx.setLineDash([6, 4]);
          }

          _ctx.moveTo(_xy.x, _xy.y);

          _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

          _ctx.stroke();

          if (item.arrowHead) {
            if (modelObj.LabComClass.Maths.getDistance(_xy, _xTo_yTo) > modelObj.pointRadius * 3) {
              drawArrowHead(_ctx, _xy, _xTo_yTo);
            }
          }
        } else if (item.type === 'length') {
          if (item.secondPointId === undefined) {
            _ctx.save();

            _ctx.beginPath();

            _ctx.setLineDash([5, 15]);

            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xTo_yTo.x, _xTo_yTo.y);

            _ctx.stroke();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'compass') {
          if (!item.isPloted) {
            _ctx.strokeStyle = segmentColor;

            _ctx.setLineDash([3, 3]);

            _ctx.lineWidth = 2;

            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          } else {
            _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

            _ctx.stroke();
          }
        } else if (item.type === 'triangle') {
          if (item.thirdSegmentPlotted) {
            var p1 = getPixelByPoint(item.firstPoint.x, item.firstPoint.y);
            var p2 = getPixelByPoint(item.secondPoint.x, item.secondPoint.y);

            var _p = getPixelByPoint(item.thirdPoint.x, item.thirdPoint.y);

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = item.fillColor ? item.fillColor : 'rgba(112,146,190,0.5)';

            _ctx.moveTo(p1.x, p1.y);

            _ctx.lineTo(p2.x, p2.y);

            _ctx.lineTo(_p.x, _p.y);

            _ctx.lineTo(p1.x, p1.y);

            _ctx.stroke();

            _ctx.fill();

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'line') {
          _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

          _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

          _ctx.stroke();
        } else if (item.type === 'ray') {
          if (_xy.x !== _xTo_yTo.x || _xy.y !== _xTo_yTo.y) {
            _ctx.moveTo(_xy.x, _xy.y);

            _ctx.lineTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.stroke();
          }
        } else if (item.type === 'circle_3') {
          _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = 'bottom';
          _ctx.textAlign = 'left';

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

          _ctx.stroke();
        } else if (item.type === 'circle') {
          _ctx.font = fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
          _ctx.textBaseline = 'bottom';
          _ctx.textAlign = 'left';

          _ctx.arc(_xy.x, _xy.y, getPixelUnitByPointUnit(item.r), 0, 2 * Math.PI);

          _ctx.stroke();

          if (item.r && item.uniqueId === localObj.currentUniqueId && (localObj.mouseDown.isMouseDown || !localObj.mouseDown.lastShapeCompleted)) {
            var val = Number(item.r);

            if (modelObj.shapes.circle.digit !== undefined) {
              val = Number(val.toFixed(modelObj.shapes.circle.digit));
            }

            var gap = fontSize / 3;
            var x = _xy.x;
            var h = fontSize;
            var y = _xy.y + gap;

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = 'rgba(255,255,255,1)';

            _ctx.rect(x, y, _ctx.measureText(val).width + gap * 2, h);

            _ctx.fill();

            _ctx.closePath();

            _ctx.beginPath();

            _ctx.fillStyle = pointLabelColor;

            _ctx.fillText(val, x + gap, y + h * 1.05);

            _ctx.closePath();

            _ctx.restore();
          }
        } else if (item.type === 'angleRay') {
          _ctx.translate(_xy.x, _xy.y);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.stroke();
        } else if (item.type === 'angle' || item.type === 'angleSize') {
          _ctx.globalAlpha = 0.5;

          _ctx.translate(_xy.x, _xy.y);

          _ctx.beginPath();

          _ctx.moveTo(0, 0);

          _ctx.arc(0, 0, 20, -item.startAngle, -item.endAngle);

          _ctx.fill();

          _ctx.closePath();

          if ((item.angleValue === 90 || (item === null || item === void 0 ? void 0 : item.over) === 'BEC') && modelObj.shapes.angle.dotOn90) {
            var _p2 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.endAngle, 16);

            var _p3 = modelObj.LabComClass.Maths.getPoint({
              x: 0,
              y: 0
            }, -item.startAngle, 16);

            _ctx.beginPath();

            _ctx.strokeStyle = '#000000';
            _ctx.fillStyle = '#000000';

            _ctx.arc((_p3.x + _p2.x) / 2, (_p3.y + _p2.y) / 2, 2, 0, Math.PI * 2);

            _ctx.fill();

            _ctx.closePath();
          }

          _ctx.stroke();
        } else if (item.type === 'perpendicularLine' || item.type === 'parallelLine') {
          if (_xOr_yOr !== null && !isNaN(_xOr_yOr.x)) {
            _ctx.moveTo(_xOr_yOr.x, _xOr_yOr.y);

            _ctx.lineTo(_xOrTo_yOrTo.x, _xOrTo_yOrTo.y);

            _ctx.stroke();
          }
        } else if (item.type === 'polygonShape') {
          _ctx.fillStyle = item.fillColor ? item.fillColor : 'rgba(112,146,190,0.5)';
          item.path.forEach(function (elem, i) {
            var p = getPixelByPoint(elem.x, elem.y);

            if (i === 0) {
              _ctx.moveTo(p.x, p.y);
            }

            _ctx.lineTo(p.x, p.y);
          });

          _ctx.fill();
        }

        _ctx.closePath();

        _ctx.restore();
      }
    });
  }

  function drawStroked(_ref4) {
    var ctx = _ref4.ctx,
        text = _ref4.text,
        x = _ref4.x,
        y = _ref4.y,
        fillColor = _ref4.fillColor,
        _ref4$diffX = _ref4.diffX,
        diffX = _ref4$diffX === void 0 ? 0 : _ref4$diffX,
        _ref4$diffY = _ref4.diffY,
        diffY = _ref4$diffY === void 0 ? 0 : _ref4$diffY;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = 'rgba(255,255,255,1)';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'miter'; // Experiment with "bevel" & "round" for the effect you want!

    ctx.miterLimit = 2; // if (center) {
    //   x -= (ctx.measureText(text).width / 2);
    //   y -= 5;
    // }

    y += modelObj.fontSize * 0.6; // }
    // ctx.strokeText(text, x + diffX, y + diffY);
    // ctx.fillText(text, x + diffX, y + diffY);

    ctx.drawStyledText(text, x + diffX, y + diffY, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
    ctx.closePath();
    ctx.restore();
  }

  function drawPoint(_ctx, item, _drawShape, _drawText) {
    var _xy = item.x !== undefined ? getPixelByPoint(item.x, item.y) : null;

    _ctx.beginPath();

    if (_drawShape) {
      _ctx.fillStyle = modelObj.pointColor;

      if (item.fillColor) {
        _ctx.fillStyle = item.fillColor;
      }

      if (modelObj.finalView) {
        _ctx.fillStyle = modelObj.finalColor;
        _ctx.strokeStyle = modelObj.finalColor;
      }

      _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius, 0, 2 * Math.PI);

      _ctx.fill();

      _ctx.closePath();

      if (item.isSelected) {
        _ctx.beginPath();

        _ctx.strokeStyle = modelObj.pointColor;

        _ctx.arc(_xy.x, _xy.y, modelObj.pointRadius + 2, 0, 2 * Math.PI);

        _ctx.stroke();

        _ctx.closePath();
      }
    }

    if (item.label !== undefined && _drawText) {
      if (item.labelX === undefined) {
        item.labelX = item.x;
        item.labelY = item.y;
        item.labelDiffX = 0;
        item.labelDiffY = 0;
      }

      var labelPos = getPixelByPoint(item.labelX, item.labelY);
      var color = item.fillLabelColor ? item.fillLabelColor : modelObj.pointLabelColor;
      drawStroked({
        ctx: _ctx,
        text: item.label,
        x: labelPos.x,
        y: labelPos.y,
        fillColor: color,
        center: false,
        diffX: Number(item.labelDiffX),
        diffY: Number(item.labelDiffY)
      });
    }
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function addEvents() {
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });

    if (modelObj.eventsEnable) {
      if (modelObj.interactionType !== null) {
        if (modelObj.state && modelObj.visible) {
          if (modelObj.interactionType === 'scale') {
            _eventDataObj.r.push({
              id: 'scale1',
              arc: {
                x: scaleObj.x,
                y: scaleObj.y,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            }, {
              id: 'scale2',
              arc: {
                x: scaleObj.xTo,
                y: scaleObj.yTo,
                r: scaleObj.pointRadius + 3
              },
              eventListener: mouseHandle.bind(this)
            });
          } else {
            _eventDataObj.r.push({
              id: 0,
              rect: {
                x: modelObj.screen.x,
                y: modelObj.screen.y,
                w: modelObj.screen.w,
                h: modelObj.screen.h
              },
              eventListener: mouseHandle.bind(this)
            });
          }

          onViewUpdateCls.trigger('onGlobalUpdate', {
            type: 'addMouseEvent',
            data: _eventDataObj
          });
        }
      }
    }
  }

  var d;

  function checkForRightClick(e) {
    localObj.mouseDownData = null;

    if (localObj.isDevice) {
      localObj.mouseDownData = JSON.parse(JSON.stringify(e));
      localObj.mouseDownData.delayCounter = 0;
      modelObj.animClass.start({
        id: 'animation',
        fps: 1,
        frame: checkAfterDelay
      });
    } else {
      executeMouseDown(e);
    }
  }

  function rejectDelay() {
    modelObj.animClass.stop('animation');
    executeMouseDown(localObj.mouseDownData);
    localObj.mouseDownData = null;
  }

  function checkAfterDelay() {
    var mouseDownData = localObj.mouseDownData;
    mouseDownData.delayCounter++;

    if (mouseDownData.delayCounter > 2) {
      modelObj.animClass.stop('animation');

      if (typeof events.rightClick !== 'undefined') {
        events.rightClick({
          id: modelObj.id,
          type: 'rightClick',
          x: mouseDownData.pageX,
          y: mouseDownData.pageY
        }, true);
      }

      mouseDownData = null;
    }
  }

  function executeMouseDown(e) {
    var mouseDown = localObj.mouseDown;
    mouseDown.isMouseDown = true;
    mouseDown.x = e.pageX;
    mouseDown.orignalX = e.pageX;
    mouseDown.y = e.pageY;
    mouseDown.orignalY = e.pageY;
    mouseDown.objectDown = false;

    if (mouseDown.lastShapeCompleted) {
      onMouseDown(e);
    }
  } // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        checkForRightClick(e);
        break;

      case 'pressmove':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onPressMove(e);
        break;

      case 'mousemove':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseMove(e);
        break;

      case 'mouseup':
        mouseUpCall(e); // addEvents();

        break;

      case 'rightmouseup':
        if (localObj.mouseDown.isMouseDown) {
          mouseUpCall(e);
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      case 'rightmousedown':
        localObj.mouseDown.isRightMouseDown = true;

        if (typeof events.rightClick !== 'undefined') {
          events.rightClick({
            id: modelObj.id,
            type: 'rightClick',
            x: e.pageX,
            y: e.pageY
          }, true);
        }

        break;

      case 'mouseupout':
        if (localObj.mouseDownData !== null) {
          rejectDelay();
        }

        onMouseUp(e);
        localObj.mouseDown.isMouseDown = false;

        if (e.subId === 'scale1' || e.subId === 'scale2') {
          addEvents();
        }

        localObj.mouseDown.isRightMouseDown = false;
        break;

      default:
        break;
    }
  }

  function mouseUpCall(e) {
    if (localObj.mouseDownData !== null) {
      rejectDelay();
    }

    onMouseUp(e);
    localObj.mouseDown.isMouseDown = false;
    localObj.mouseDown.objectDown = false;
    localObj.mouseDown.isRightMouseDown = false;
  }

  function setScaleValues() {
    var x = modelObj.x,
        y = modelObj.y,
        width = modelObj.width,
        height = modelObj.height;
    scaleObj.originPos = {
      x: x + (width - 280),
      y: y + (height - 40),
      xTo: x + (width - 40),
      yTo: y + (height - 40)
    };
    scaleObj.x = scaleObj.originPos.x;
    scaleObj.y = scaleObj.originPos.y;
    scaleObj.xTo = scaleObj.originPos.xTo;
    scaleObj.yTo = scaleObj.originPos.yTo;
  }

  function addPoint(point, _obj) {
    var newShape = {
      type: 'point',
      x: point.x,
      y: point.y,
      label: ''
    };
    Object.keys(_obj).forEach(function (i) {
      newShape[i] = _obj[i];
    });

    if (point.isIntersection || point.isParameter) {
      Object.keys(point).forEach(function (i) {
        newShape[i] = point[i];
      });
    }

    localObj.newPlottedShapes.push(_obj.uniqueId);
    addNewShape(newShape);
  } // =================================================


  function checkSnapping(point) {
    if (modelObj.showQuadrants === '1' && (point.x < 0 || point.y < 0)) {
      if (Math.abs(point.x) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.x = 0;
      }

      if (Math.abs(point.y) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        point.y = 0;
      }

      if (point.x < 0 || point.y < 0) {
        return null;
      }
    }

    var snappingPont = JSON.parse(JSON.stringify(point));
    var snappingData = {};
    var snappingFound = false;

    if (modelObj.pointSnapping) {
      var pointMinDist = isItCloseToPlotedPoint(snappingPont, true);
      var intersectionMinDist = isItCloseToIntersectionPoint(snappingPont);
      var intersectionOfParameterMinDist = isItCloseToParameterPoint(snappingPont);
      var _snappingFound = false;

      if (pointMinDist) {
        snappingData.x = pointMinDist.plotedPoint.x;
        snappingData.y = pointMinDist.plotedPoint.y;
        _snappingFound = true;
      }

      if (intersectionMinDist && !_snappingFound) {
        var intersectionCanBeSnapped = true;

        if (pointMinDist) {
          if (intersectionMinDist.dist > pointMinDist.dist) {
            intersectionCanBeSnapped = false;
          }
        }

        if (intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionMinDist.updateKeys;
          _snappingFound = true;
        }
      }

      if (intersectionOfParameterMinDist && !_snappingFound) {
        var _intersectionCanBeSnapped = true;

        if (snappingData) {
          if (intersectionOfParameterMinDist.dist > snappingData.dist) {
            _intersectionCanBeSnapped = false;
          }
        }

        if (_intersectionCanBeSnapped) {
          snappingData = {};
          Object.keys(intersectionOfParameterMinDist.updateKeys).forEach(function (i) {
            snappingData[i] = intersectionOfParameterMinDist.updateKeys[i];
          });
          snappingData.updateKeys = intersectionOfParameterMinDist.updateKeys;
          _snappingFound = true;
        }
      }
    } // check for point, intersection, shape parameter
    // check for snapping grid point


    if (!snappingFound && modelObj.snapToGrid) {
      var _modelObj$graphValues = modelObj.graphValues,
          XunitsPerGrid = _modelObj$graphValues.XunitsPerGrid,
          YunitsPerGrid = _modelObj$graphValues.YunitsPerGrid;
      var x = Math.round(point.x / XunitsPerGrid) * XunitsPerGrid;
      var y = Math.round(point.y / YunitsPerGrid) * YunitsPerGrid;

      if (modelObj.LabComClass.Maths.getDistance(point, {
        x: x,
        y: y
      }) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
        snappingData = {};
        snappingData.x = x;
        snappingData.y = y;
        snappingFound = true;
      }
    }

    if (snappingFound) {
      Object.keys(snappingData).forEach(function (i) {
        point[i] = snappingData[i];
      });
    }

    return point;
  }

  function addNewShape(_objNew) {
    var _obj = {
      type: modelObj.interactionType,
      step: modelObj.currentStep,
      visible: true
    };
    Object.keys(_objNew).forEach(function (i) {
      _obj[i] = _objNew[i];
    });
    modelObj.interactionElements.push(_obj);
    return _obj;
  }

  function onMouseDown(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    localObj.newPlottedShapes = [];
    var newShapes = localObj.newPlottedShapes;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point);
    localObj.currentUniqueId = null;
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));

    if (clickingOnExistingPoint !== null) {
      localObj.currentUniqueId = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    localObj.newShapeStarted = false;

    if (tool === 'point' && point !== null) {
      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: ++localObj.uniqueId,
          connectionId: []
        });
        localObj.currentUniqueId = localObj.uniqueId;
      }
    } else if (tool.includes('segment') && point !== null) {
      var firstPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      var segmentId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: firstPointId,
          connectionId: [segmentId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(segmentId);
      }

      addNewShape({
        uniqueId: segmentId,
        firstPointId: firstPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [firstPointId]
      });
      localObj.currentUniqueId = segmentId;
      newShapes.push(segmentId);
    } else if (tool === 'length') {
      if (clickingOnExistingPoint !== null && point !== null) {
        var lengthId = ++localObj.uniqueId;
        var _firstPointId = localObj.currentUniqueId;
        addNewShape({
          uniqueId: lengthId,
          firstPointId: _firstPointId,
          x: point.x,
          y: point.y,
          xTo: point.x,
          yTo: point.y,
          labelAlign: 'center'
        });
        localObj.currentUniqueId = lengthId;
        newShapes.push(lengthId);
      } else {
        var selectedShapeID = selectShape(e);

        if (selectedShapeID) {
          var shapeData = findShape(selectedShapeID);

          if (shapeData.shape && shapeData.shape.type.includes('segment')) {
            var _lengthId = ++localObj.uniqueId;

            addNewShape({
              uniqueId: _lengthId,
              segmentID: selectedShapeID,
              x: shapeData.shape.x,
              y: shapeData.shape.y,
              xTo: shapeData.shape.xTo,
              yTo: shapeData.shape.yTo,
              labelAlign: 'center'
            });
            localObj.currentUniqueId = _lengthId;
            newShapes.push(_lengthId);
          } else {
            shapeData.shape.isSelected = false;
          }
        }
      }
    } else if (tool === 'compass') {
      var newShape;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId2 = localObj.currentUniqueId;
          newShape = {
            firstPointId: _firstPointId2,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _selectedShapeID = selectShape(e);

        if (_selectedShapeID) {
          var _shapeData2 = findShape(_selectedShapeID);

          if (_shapeData2.shape.visible === true) {
            if (_shapeData2.shape && _shapeData2.shape.type.includes('segment')) {
              newShape = {
                segmentID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                xTo: _shapeData2.shape.xTo,
                yTo: _shapeData2.shape.yTo
              };
            } else if (_shapeData2.shape && (_shapeData2.shape.type === 'circle' || _shapeData2.shape.type === 'compass')) {
              newShape = {
                circleID: _selectedShapeID,
                x: _shapeData2.shape.x,
                y: _shapeData2.shape.y,
                r: _shapeData2.shape.r
              };
            }
          }
        }
      }

      if (newShape) {
        var _lengthId2 = ++localObj.uniqueId;

        localObj.currentUniqueId = _lengthId2;
        newShape.connectionId = [];
        newShape.uniqueId = _lengthId2;
        newShape.isPloted = false;
        newShapes.push(_lengthId2);
        addNewShape(newShape);
      }
    } else if ((tool === 'line' || tool === 'ray') && point !== null) {
      var _firstPointId3 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var lineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId3,
          connectionId: [lineId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(lineId);
      }

      addNewShape({
        uniqueId: lineId,
        firstPointId: _firstPointId3,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [_firstPointId3]
      });
      localObj.currentUniqueId = lineId;
      newShapes.push(lineId);
    } else if (tool === 'angleRay' && point !== null) {
      var angleRayId = ++localObj.uniqueId;
      var rayId = ++localObj.uniqueId;
      var secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;
      newShapes.push(angleRayId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: secondPointId,
          connectionId: [rayId, angleRayId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(rayId);
      }

      addNewShape({
        uniqueId: angleRayId,
        firstPointId: secondPointId,
        firstRayPlotted: false,
        secondRayPlotted: false,
        x: point.x,
        y: point.y,
        connectionId: [secondPointId]
      });
      addNewShape({
        type: 'ray',
        uniqueId: rayId,
        angleRayId: angleRayId,
        secondPointId: secondPointId,
        x: point.x,
        y: point.y,
        xOr: point.x,
        yOr: point.y,
        xTo: point.x,
        yTo: point.y,
        xOrTo: point.x,
        yOrTo: point.y,
        connectionId: [secondPointId]
      });
      localObj.currentUniqueId = rayId;
      newShapes.push(rayId);
    } else if (tool === 'circle_3' && point !== null) {
      var circleId = ++localObj.uniqueId;

      var _firstPointId4 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId4,
          connectionId: [circleId],
          circleId: circleId
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(circleId);
        shapesData[clickingOnExistingPoint].circleId = circleId;
      }

      addNewShape({
        uniqueId: circleId,
        firstPointId: _firstPointId4,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId4]
      });
      localObj.currentUniqueId = _firstPointId4;
      newShapes.push(circleId);
    } else if (tool === 'angle' && point !== null) {
      var angleId = ++localObj.uniqueId;

      var _firstPointId5 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId5,
          connectionId: [angleId],
          angleId: angleId
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(angleId);
        shapesData[clickingOnExistingPoint].angleId = angleId;
      }

      addNewShape({
        uniqueId: angleId,
        firstPointId: _firstPointId5,
        firstPointPlotted: false,
        secondPointPlotted: false,
        thirdPointPloted: false,
        x: point.x,
        y: point.y,
        connectionId: [_firstPointId5]
      });
      localObj.currentUniqueId = _firstPointId5;
      newShapes.push(angleId);
    } else if (tool === 'midPoint' && point !== null) {
      var midPointId = ++localObj.uniqueId;

      var _firstPointId6 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID2 = selectShape(e);

      var _shapeData3 = findShape(_selectedShapeID2).shape;

      if (clickingOnExistingPoint === null && point !== null && _selectedShapeID2 === null) {
        addPoint(point, {
          uniqueId: _firstPointId6,
          connectionId: [midPointId],
          midPointId: midPointId
        });
        addNewShape({
          uniqueId: midPointId,
          type: "point",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId6]
        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
        if (_shapeData3) {
          _shapeData3.isSelected = false;
        }

        shapesData[clickingOnExistingPoint].connectionId.push(midPointId);
        shapesData[clickingOnExistingPoint].midPointId = midPointId;
        addNewShape({
          uniqueId: midPointId,
          type: "point",
          firstPointId: _firstPointId6,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId6],
          segmentId: _selectedShapeID2
        });
        localObj.currentUniqueId = _firstPointId6;
      } else if (_selectedShapeID2 !== null && _shapeData3.type.includes('segment')) {
        if (_shapeData3 && _shapeData3.type.includes('segment')) {
          addNewShape({
            uniqueId: midPointId,
            type: "point",
            firstPointId: _firstPointId6,
            firstPointPlotted: true,
            secondPointPlotted: true,
            x: (_shapeData3.x + _shapeData3.xTo) / 2,
            y: (_shapeData3.y + _shapeData3.yTo) / 2,
            firstPointCoords: {
              x: _shapeData3.x,
              y: _shapeData3.y
            },
            secondPointCoords: {
              x: _shapeData3.xTo,
              y: _shapeData3.yTo
            },
            segmentId: _selectedShapeID2,
            connectionId: [_firstPointId6],
            onSegment: true,
            midPointId: midPointId
          });
          localObj.currentUniqueId = midPointId;
        }
      } else {
        _shapeData3.isSelected = false;
      }

      newShapes.push(midPointId);
    } else if (tool === 'mirrorOnLine' && point !== null) {
      var mirrorOnLineId = ++localObj.uniqueId;

      var _firstPointId7 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _selectedShapeID3 = selectShape(e);

      var _shapeData4 = findShape(_selectedShapeID3).shape;

      if (_shapeData4 && _shapeData4.type === 'point' || _selectedShapeID3 === null) {
        if (_shapeData4) {
          _shapeData4.isSelected = false;
        }

        if (clickingOnExistingPoint === null) {
          addPoint(point, {
            uniqueId: _firstPointId7,
            connectionId: [mirrorOnLineId],
            mirrorOnLineId: mirrorOnLineId
          });
        } else {
          shapesData[clickingOnExistingPoint].connectionId.push(mirrorOnLineId);
          shapesData[clickingOnExistingPoint].mirrorOnLineId = mirrorOnLineId;
        }

        addNewShape({
          uniqueId: mirrorOnLineId,
          firstPointId: _firstPointId7,
          firstPointPlotted: false,
          linePlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId7]
        });
        localObj.currentUniqueId = _firstPointId7;
        newShapes.push(mirrorOnLineId);
        localObj.newShapeStarted = true;
      } else {
        _shapeData4.isSelected = false;
      }
    } else if (tool === 'triangle' && point !== null) {
      var triangleId = ++localObj.uniqueId;

      var _segmentId = ++localObj.uniqueId;

      var _secondPointId = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      newShapes.push(triangleId);

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _secondPointId,
          connectionId: [_segmentId, triangleId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(_segmentId);
      }

      addNewShape({
        uniqueId: triangleId,
        firstPointId: _secondPointId,
        firstSegmentPlotted: false,
        secondSegmentPlotted: false,
        thirdSegmentPlotted: false,
        x: point.x,
        y: point.y,
        connectionId: [_secondPointId]
      });
      addNewShape({
        type: 'segment',
        uniqueId: _segmentId,
        triangleId: triangleId,
        secondPointId: _secondPointId,
        x: point.x,
        y: point.y,
        xTo: point.x,
        yTo: point.y,
        connectionId: [_secondPointId]
      });
      localObj.currentUniqueId = _segmentId;
      newShapes.push(_segmentId);
    } else if (tool === 'perpendicularBisector' && point !== null) {
      var _selectedShapeID4 = selectShape(e);

      var selectedShapeData = findShape(_selectedShapeID4).shape;

      if (clickingOnExistingPoint !== null) {
        var perpBId = ++localObj.uniqueId;

        var _firstPointId8 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

        if (selectedShapeData) {
          selectedShapeData.isSelected = false;
        }

        shapesData[clickingOnExistingPoint].isSelected = false;
        addNewShape({
          uniqueId: perpBId,
          type: "perpendicularBisector",
          firstPointId: _firstPointId8,
          firstPointPlotted: false,
          secondPointPlotted: false,
          connectionId: [_firstPointId8],
          mode: 'point'
        });
        localObj.newShapeStarted = true;
        newShapes.push(perpBId);
        localObj.currentUniqueId = perpBId;
      } else if (_selectedShapeID4 !== null && selectedShapeData.type.includes('segment')) {
        selectedShapeData.isSelected = false;

        var _perpBId = ++localObj.uniqueId;

        var segment = selectedShapeData;
        selectedShapeData.perpBId = _perpBId;
        addNewShape({
          uniqueId: _perpBId,
          segmentId: selectedShapeData.uniqueId,
          segment: selectedShapeData,
          segmentPlotted: false,
          connectionId: [selectedShapeData.uniqueId],
          mode: 'segment'
        });
        localObj.newShapeStarted = true;
        newShapes.push(_perpBId);
        localObj.currentUniqueId = _perpBId;
      }
    } else if (tool === 'angleB' && point !== null) {
      var _selectedShapeID5 = selectShape(e);

      var _shapeData5 = findShape(_selectedShapeID5).shape;

      if (clickingOnExistingPoint !== null) {
        var angleBId = ++localObj.uniqueId;
        var _firstPointId9 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleBId);
        shapesData[clickingOnExistingPoint].angleBId = angleBId;
        addNewShape({
          uniqueId: angleBId,
          firstPointId: _firstPointId9,
          firstPointPlotted: false,
          secondPointPlotted: false,
          thirdPointPloted: false,
          x: point.x,
          y: point.y,
          mode: 'point',
          connectionId: [_firstPointId9]
        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = angleBId;
        newShapes.push(angleBId);
      } else if (_selectedShapeID5 !== null && _shapeData5.type.includes('segment')) {
        _shapeData5.isSelected = false;

        var _angleBId = ++localObj.uniqueId;

        var firstSegment = _shapeData5;
        _shapeData5.angleBId = _angleBId;
        addNewShape({
          uniqueId: _angleBId,
          firstSegmentId: _shapeData5.uniqueId,
          firstSegmentPlotted: false,
          secondSegmentPlotted: false,
          firstSegment: {
            x: firstSegment.x,
            y: firstSegment.y,
            xTo: firstSegment.xTo,
            yTo: firstSegment.yTo
          },
          x: _shapeData5.x,
          y: _shapeData5.y,
          mode: 'segment',
          connectionId: [_shapeData5.uniqueId]
        });
        localObj.newShapeStarted = true;
        localObj.currentUniqueId = _angleBId;
        newShapes.push(_angleBId);
      } else {}
    } else if (tool === 'angleSize' && point !== null) {
      localObj.mouseDown.lastShapeCompleted = false;
      var angleSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId10 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(angleSizeId);
        shapesData[clickingOnExistingPoint].angleSizeId = angleSizeId;
        addNewShape({
          uniqueId: angleSizeId,
          firstPointId: _firstPointId10,
          firstPointPlotted: false,
          secondPointPlotted: false,
          degree: 0,
          clockwise: true,
          x: point.x,
          y: point.y,
          mode: 'point',
          connectionId: [_firstPointId10]
        });
        localObj.currentUniqueId = _firstPointId10;
      } else {
        var _firstPointId11 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId11,
          angleSizeId: angleSizeId,
          connectionId: [angleSizeId]
        });
        addNewShape({
          uniqueId: angleSizeId,
          firstPointId: _firstPointId11,
          firstPointPlotted: false,
          secondPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId11],
          mode: 'point'
        });
      }

      newShapes.push(angleSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === 'segSize' && point !== null) {
      var segSizeId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        var _firstPointId12 = localObj.currentUniqueId;
        shapesData[clickingOnExistingPoint].connectionId.push(segSizeId);
        shapesData[clickingOnExistingPoint].segSizeId = segSizeId;
        addNewShape({
          uniqueId: segSizeId,
          firstPointPlotted: false,
          firstPointId: _firstPointId12,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId12]
        });
        localObj.currentUniqueId = _firstPointId12;
        newShapes.push(segSizeId);
      } else {
        var _firstPointId13 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _firstPointId13,
          segSizeId: segSizeId,
          connectionId: [segSizeId]
        });
        addNewShape({
          uniqueId: segSizeId,
          firstPointId: _firstPointId13,
          firstPointPlotted: false,
          x: point.x,
          y: point.y,
          connectionId: [_firstPointId13]
        });
        localObj.currentUniqueId = _firstPointId13;
      }

      localObj.newPlottedShapes.push(segSizeId);
      localObj.newShapeStarted = true;
    } else if (tool === 'circle' && point !== null) {
      var connectionId = [];

      var _firstPointId14 = clickingOnExistingPoint === null ? ++localObj.uniqueId : localObj.currentUniqueId;

      var _circleId = ++localObj.uniqueId;

      if (clickingOnExistingPoint === null) {
        addPoint(point, {
          uniqueId: _firstPointId14,
          connectionId: [_circleId]
        });
      } else {
        shapesData[clickingOnExistingPoint].connectionId.push(_circleId);
      }

      if (clickingOnExistingPoint === null) {
        connectionId = [localObj.currentUniqueId];
      }

      addNewShape({
        uniqueId: _circleId,
        firstPointId: _firstPointId14,
        x: point.x,
        y: point.y,
        r: 0,
        connectionId: connectionId
      });
      localObj.currentUniqueId = _circleId;
      newShapes.push(_circleId);
    } else if (tool === 'perpendicularLine' || tool === 'parallelLine') {
      var _newShape;

      var perpendLineId = ++localObj.uniqueId;

      if (clickingOnExistingPoint !== null) {
        if (point !== null) {
          var _firstPointId15 = localObj.currentUniqueId;
          _newShape = {
            firstPointId: _firstPointId15,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      } else {
        var _d2 = getPLine(e, tool === 'perpendicularLine');

        if (_d2) {
          _newShape = _d2;
          _newShape.lineToPoint = true;
          var parentLine = findShape(_newShape.line);

          if (parentLine) {
            parentLine.shape.connectionId.push(perpendLineId);
            parentLine.shape.isSelected = true;
          }
        } else {
          var _firstPointId16 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId16,
            connectionId: [perpendLineId]
          });
          newShapes.push(_firstPointId16);
          _newShape = {
            firstPointId: _firstPointId16,
            pointToLine: true,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y
          };
        }
      }

      if (_newShape.pointToLine) {
        var _point = findShape(_newShape.firstPointId).shape;
        _point.isSelected = true;
      }

      _newShape.firstPointPlotted = false;
      _newShape.connectionId = [];
      _newShape.uniqueId = perpendLineId;
      localObj.currentUniqueId = perpendLineId;
      newShapes.push(_newShape.uniqueId);
      addNewShape(_newShape);
    } else if (tool === 'brush1' || tool === 'brush2' || tool === 'brush3') {
      localObj.currentUniqueId = selectShapeBrush(e);
    } else if (tool === 'select' || tool === 'move') {
      localObj.currentUniqueId = selectShape(e);
    }
  } // =================================================


  function onMouseMove(e) {
    if (!localObj.mouseDown.lastShapeCompleted) {
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor: 'pointer'
      // });
      onPressMove(e);
    } else {// let cursor = 'default';
      // let downCursor = 'default';
      // if (isOnShape(e) !== null) {
      //   cursor = 'pointer';
      //   downCursor = 'pointer';
      // }
      // if (modelObj.interactionType === 'moveGraph') {
      //   cursor = 'grab';
      //   downCursor = 'grabbing';
      // }
      // modelObj.LabComClass.setCursor({
      //   id: modelObj.id,
      //   subId: 0,
      //   cursor,
      //   downCursor
      // });
    }
  }

  function onPressMove(e) {
    var tool = modelObj.interactionType;
    var shapesData = modelObj.interactionElements;
    var currentShape = localObj.currentUniqueId !== null ? findShape(localObj.currentUniqueId).shape : findShape(localObj.uniqueId).shape;
    var point = getPointByPixel(e.pageX, e.pageY);
    point = checkSnapping(point);
    var pointOnGraph = point !== null;

    if (pointOnGraph && onScreen(point) && localObj.cOnBound) {
      currentShape.isDraggable = true;
    }

    if (e.subId === 'scale1' || e.subId === 'scale2') {
      if (e.subId === 'scale1') {
        scaleObj.x = point.x;
        scaleObj.y = point.y;
        dispatchEventScale();
      } else if (e.subId === 'scale2') {
        scaleObj.xTo = point.x;
        scaleObj.yTo = point.y;
        dispatchEventScale();
      }
    } else {
      if (point === null || localObj.mouseDown.objectDown && !(currentShape && (currentShape.isDraggable === undefined || currentShape.isDraggable))) {
        if (!(tool === 'move' && localObj.isLableSelected)) {
          console.info('rejected');
          return false;
        }
      }

      if (tool === 'point') {
        updatePointValues(currentShape, {
          x: point.x,
          y: point.y
        });
      } else if (tool.includes('segment')) {
        currentShape.xTo = point.x;
        currentShape.yTo = point.y;
      } else if (tool === 'length') {
        if (currentShape && currentShape.type === 'length' && currentShape.secondPointId === undefined) {
          currentShape.xTo = point.x;
          currentShape.yTo = point.y;
        }
      } else if (tool === 'compass') {
        if (currentShape && currentShape.type === 'compass') {
          if (!currentShape.isPloted) {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
          } else {
            currentShape.x = point.x;
            currentShape.y = point.y;
          }
        }
      } else if (tool === 'line') {
        var line = shapesData[shapesData.length - 1];
        line.xTo = point.x;
        line.yTo = point.y;
        updateLinePoints(line);
      } else if (tool === 'ray') {
        var ray = shapesData[shapesData.length - 1];
        ray.xTo = point.x;
        ray.yTo = point.y;
        updateLinePoints(ray);
      } else if (tool === 'angleRay') {
        if (currentShape) {
          var angleRay = findShape(currentShape.angleRayId).shape;

          if (!angleRay.firstRayPlotted) {
            currentShape.x = point.x;
            currentShape.y = point.y;
            updateLinePoints(currentShape);
          } else {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
            angleRay.thirdPoint = {
              x: point.x,
              y: point.y
            };
            updateLinePoints(currentShape);
          }
        }
      } else if (tool === 'triangle') {
        if (currentShape) {
          var triangle = findShape(currentShape.triangleId).shape;

          if (!triangle.firstSegmentPlotted) {
            currentShape.x = point.x;
            currentShape.y = point.y;
          } else {
            currentShape.xTo = point.x;
            currentShape.yTo = point.y;
            triangle.thirdPoint = {
              x: point.x,
              y: point.y
            };
          }
        }
      } else if (tool === 'angle') {// if (currentShape && localObj.mouseDown.isMouseDown) {
        //   currentShape.x = point.x;
        //   currentShape.y = point.y;
        // }
      } else if (tool === 'circle_3') {
        var index;

        for (var i = shapesData.length - 1; i >= 0; i--) {
          if (shapesData[i].type === 'circle_3') {
            index = i;
            break;
          }
        }

        var _currentShape = shapesData[index];
        var cData = {};

        if (_currentShape.type === 'circle_3' && _currentShape.secondPointPlotted !== false) {
          if (_currentShape.firstPointPlotted !== undefined && _currentShape.secondPointPlotted !== undefined) {
            var fp = findShape(_currentShape.firstPointId).shape;
            var sp = findShape(_currentShape.secondPointId).shape;
            cData = circle3Handler(fp, sp, point);
          }

          _currentShape.x = cData.x;
          _currentShape.y = cData.y;
          _currentShape.r = cData.r;
        }
      } // else if( tool === 'angleB'){
      //   let angleBisectorData={};
      //   if(currentShape.type==='angleB' && currentShape.secondPointPlotted !== false){
      //     if (currentShape.firstPointPlotted !== undefined && currentShape.secondPointPlotted !== undefined) {
      //       const fp = findShape(currentShape.firstPointId).shape;
      //       const sp = findShape(currentShape.secondPointId).shape;
      //       angleBisectorData = calculateBisector({firstPoint:fp, secondPoint:sp, thirdPoint:point});
      //     }
      //     currentShape.x = angleBisectorData.bisectorLine.x;
      //     currentShape.y = angleBisectorData.bisectorLine.y;
      //     currentShape.xTo = angleBisectorData.bisectorLine.xTo;
      //     currentShape.yTo= angleBisectorData.bisectorLine.yTo;
      //   }
      // } 
      else if (tool === 'circle') {
          var lastShape = shapesData[shapesData.length - 1];
          lastShape.r = Math.abs(modelObj.LabComClass.Maths.getDistance({
            x: lastShape.x,
            y: lastShape.y
          }, point));
          dispatchEventCircleMove(lastShape);
        } else if (tool === 'perpendicularLine' || tool === 'parallelLine') {
          if (localObj.mouseDown.isMouseDown) {
            if (currentShape.pointToLine && !currentShape.firstPointPlotted && currentShape.firstPointId !== undefined) {
              if (localObj.newPlottedShapes.includes(currentShape.firstPointId)) {
                var pointShape = findShape(currentShape.firstPointId).shape;
                pointShape.x = point.x;
                pointShape.y = point.y;
              }
            }
          }

          if (currentShape.lineToPoint) {
            currentShape.x = point.x;
            currentShape.y = point.y;
            updatePLinePoints(currentShape);
          }
        } else if (tool === 'move' && !localObj.mouseDown.objectDown || tool === 'moveGraph') {
          if (localObj.mouseDown.isMouseDown) {
            var _diffX = 0;
            var _diffY = 0;
            _diffX = e.pageX - localObj.mouseDown.x;
            _diffY = e.pageY - localObj.mouseDown.y;
            localObj.mouseDown.x = e.pageX;
            localObj.mouseDown.y = e.pageY;

            if (typeof events[tool] !== 'undefined') {
              events[tool]({
                id: modelObj.id,
                type: 'moveGraph',
                data: {
                  x: _diffX,
                  y: _diffY
                }
              }, true);
            }
          }
        } else if (tool === 'select' || tool === 'move' && localObj.mouseDown.objectDown) {
          if ((modelObj.shapesEditable || localObj.isLableSelected) && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown) {
            var _diffX2 = 0;
            var _diffY2 = 0;
            _diffX2 = e.pageX - localObj.mouseDown.x;
            _diffY2 = e.pageY - localObj.mouseDown.y;
            var center = getPixelByPoint(0, 0);
            var diffValueInPoint = getPointByPixel(center.x + _diffX2, center.y + _diffY2);
            _diffX2 = diffValueInPoint.x;
            _diffY2 = diffValueInPoint.y;

            if (localObj.isLableSelected) {
              for (var _i = 0; _i < shapesData.length; _i++) {
                var _d = shapesData[_i];
                var lablePos = getPixelByPoint(_d.labelX, _d.labelY);
                var pixelDiff = {
                  x: e.pageX - lablePos.x,
                  y: e.pageY - lablePos.y
                };

                if (_d.isSelected) {
                  updateDiff(_d, pixelDiff);
                  break;
                }
              }
            } else {
              for (var _i2 = 0; _i2 < shapesData.length; _i2++) {
                shapesData[_i2].isMoved = false;
              }

              for (var _i3 = 0; _i3 < shapesData.length; _i3++) {
                var _d3 = shapesData[_i3];

                if (_d3.isDraggable !== undefined && !_d3.isDraggable) {
                  continue;
                }

                if (_d3.isSelected && !_d3.isMoved) {
                  _d3.isMoved = true;

                  if (_d3.type === 'point' && _d3.shapeType !== 'rhombus' && _d3.shapeType !== 'parallelogram') {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;

                    if (tool === 'move') {
                      _d3.x = point.x;
                      _d3.y = point.y;
                    }

                    updatePoints(_d3, {
                      x: _diffX2,
                      y: _diffY2
                    });
                  } else if (_d3.type === 'point' && _d3.shapeType === 'rhombus') {
                    localObj.isCollinear = checkIfCollinear(_d3, point); //Checks if 3 point are on same line.

                    localObj.shapeOnBound = checkIfOnBound(_d3, point); // Check if the point is on Boundary (B & D).

                    if (!localObj.isCollinear && !localObj.shapeOnBound) {
                      // if (!localObj.isCollinear) {
                      if (tool === 'move') {
                        _d3.x = point.x;
                        _d3.y = point.y;
                      }

                      updatePoints(_d3, {
                        x: _diffX2,
                        y: _diffY2
                      });
                    }
                  } else if (_d3.type === 'point' && _d3.shapeType === 'parallelogram') {
                    localObj.isCollinear = checkIfCollinear(_d3, point);

                    if (!localObj.isCollinear) {
                      if (tool === 'move') {
                        _d3.x = point.x;
                        _d3.y = point.y;
                      }

                      updatePoints(_d3, {
                        x: _diffX2,
                        y: _diffY2
                      });
                    }
                  } else if (_d3.type.includes('segment')) {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;
                    _d3.xTo += _diffX2;
                    _d3.yTo += _diffY2;
                  } else if (_d3.type === 'line' || _d3.type === 'ray') {
                    _d3.x += _diffX2;
                    _d3.y += _diffY2;
                    _d3.xTo += _diffX2;
                    _d3.yTo += _diffY2;
                    updateLinePoints(shapesData[_i3]);
                  } else if (_d3.type === 'circle') {
                    var centerPoint = findShape(_d3.firstPointId);
                    var endPoint = findShape(_d3.secondPointId);

                    if (centerPoint && endPoint) {
                      if (findDraggable([centerPoint.shape, endPoint.shape])) {
                        if (!centerPoint.shape.isMoved) {
                          updateShapeValue(centerPoint.shape, {
                            x: centerPoint.shape.x + _diffX2,
                            y: centerPoint.shape.y + _diffY2
                          });
                          centerPoint.isMoved = true;
                        }

                        if (!endPoint.shape.isMoved) {
                          updateShapeValue(endPoint.shape, {
                            x: endPoint.shape.x + _diffX2,
                            y: endPoint.shape.y + _diffY2
                          });
                          endPoint.isMoved = true;
                        }
                      }
                    }
                  } else if (_d3.type === 'compass') {
                    var _centerPoint = findShape(_d3.centerPointId);

                    if (_centerPoint) {
                      updateShapeValue(_centerPoint.shape, {
                        x: _centerPoint.shape.x + _diffX2,
                        y: _centerPoint.shape.y + _diffY2
                      });
                    }
                  } else if (_d3.type === 'perpendicularLine' || _d3.type === 'parallelLine') {// _d.x += _diffX;
                    // _d.y += _diffY;
                    // _d.xTo += _diffX;
                    // _d.yTo += _diffY;
                    // updatePLinePoints(shapesData[i]);
                  }
                }
              }

              for (var _i4 = 0; _i4 < shapesData.length; _i4++) {
                var _d4 = shapesData[_i4];

                if (_d4.isSelected) {
                  if (_d4.type === 'point') {
                    if (_d4.connectionId.length > 0) {
                      updateShapes(_d4, _diffX2, _diffY2);
                    }
                  }

                  if (_d4.type.includes('segment') || _d4.type === 'line' || _d4.type === 'ray') {
                    if (_d4.connectionId.length > 0) {
                      updateShapes(_d4, _diffX2, _diffY2);
                    }
                  }
                }
              }
            }
          } else if (tool === 'select') {
            var _localObj$mouseDown2 = localObj.mouseDown,
                orignalX = _localObj$mouseDown2.orignalX,
                orignalY = _localObj$mouseDown2.orignalY,
                x = _localObj$mouseDown2.x,
                y = _localObj$mouseDown2.y;
            selectObjectsInPixelRange(orignalX, orignalY, x, y);
          }

          localObj.mouseDown.x = e.pageX;
          localObj.mouseDown.y = e.pageY;
        }

      updateAllShapes(e);
      updateAllShapes(e);
    }

    return true;
  }

  function checkIfOnBound(shape, point) {
    // Checks if the dragged point is outside the graph, if yes, then will restrict the movement.
    var onEdgeFlag = false;

    if (!localObj.isCollinear) {
      var pointsTotal = modelObj.interactionElements.filter(function (el) {
        return el.type === 'point';
      }); //Point Id-Label 1-A,2-B,3-C,4-D.

      var minCordinates = getPointByPixel(modelObj.x, modelObj.y + modelObj.height);
      var maxCordinates = getPointByPixel(modelObj.x + modelObj.width, modelObj.y);
      var minX = minCordinates.x,
          minY = minCordinates.y,
          maxX = maxCordinates.x,
          maxY = maxCordinates.y;

      if (shape.label === 'B') {
        var flag = false; // If Dragged Point is outside Graph.

        shape.x = point.x;
        shape.y = point.y;
        var fixPoint1 = pointsTotal[0]; // A

        var fixPoint2 = pointsTotal[3]; // D

        var angleBet2Points = modelObj.LabComClass.Maths.getAngle(fixPoint1.x, fixPoint1.y, shape.x, shape.y);
        var side = modelObj.LabComClass.Maths.getDistance(fixPoint1, fixPoint2); // Point C is calculated wrt to Point D

        var newPoint = modelObj.LabComClass.Maths.getPoint(fixPoint2, angleBet2Points, side); // If points are inside graph.
        // B is calculated again as the distance needs to be same.

        var angleBet2PointsV2 = modelObj.LabComClass.Maths.getAngle(fixPoint2.x, fixPoint2.y, newPoint.x, newPoint.y);
        var newMovPoint = modelObj.LabComClass.Maths.getPoint(fixPoint1, angleBet2PointsV2, side); // If B is out of screen.

        var _onScreen = outScreen(newMovPoint);

        if (_onScreen !== undefined && (_onScreen.out === 'down' || _onScreen === 'up')) {
          flag = true;
        } else {
          flag = false; // newPoint.y = point.y;
        }

        shape.x = newMovPoint.x;
        shape.y = newMovPoint.y;
        shape.labelX = shape.x;
        shape.labelY = shape.y; // If B is out of screen, then assigning a constant value.

        if (flag) {
          var newPointB = modelObj.LabComClass.Maths.getPoint(fixPoint1, modelObj.LabComClass.Maths.getAngle(fixPoint2.x, fixPoint2.y, pointsTotal[2].x, pointsTotal[2].y), side);
          shape.x = newPointB.x;
          shape.y = minY;
          shape.labelX = shape.x;
          shape.labelY = shape.y;
          onEdgeFlag = true;
        }
      } else if (shape.label === 'C') {
        var _flag2 = false;
        shape.x = point.x;
        shape.y = point.y;
        var _fixPoint = pointsTotal[0]; // A

        var _fixPoint2 = pointsTotal[3]; //D

        var _angleBet2Points = modelObj.LabComClass.Maths.getAngle(_fixPoint2.x, _fixPoint2.y, shape.x, shape.y);

        var _side = modelObj.LabComClass.Maths.getDistance(_fixPoint, _fixPoint2); // Point B is calculated wrt to Point A


        var _newPoint3 = modelObj.LabComClass.Maths.getPoint(_fixPoint, _angleBet2Points, _side); // If points are inside graph.
        // C is calculated again as the distance needs to be same.


        var _angleBet2PointsV = modelObj.LabComClass.Maths.getAngle(_fixPoint.x, _fixPoint.y, _newPoint3.x, _newPoint3.y);

        var _newMovPoint = modelObj.LabComClass.Maths.getPoint(_fixPoint2, _angleBet2PointsV, _side);

        var _onScreen2 = outScreen(_newMovPoint); // Point C is checked if it's out of screen


        if (_onScreen2 !== undefined && (_onScreen2.out === 'down' || _onScreen2.out === 'up')) {
          _flag2 = true;
        } else {
          _flag2 = false;
        }

        shape.x = _newMovPoint.x;
        shape.y = _newMovPoint.y;
        shape.labelX = shape.x;
        shape.labelY = shape.y; // If C is out of screen, then a constant value is assogned.

        if (_flag2) {
          var newPointC = modelObj.LabComClass.Maths.getPoint(_fixPoint2, modelObj.LabComClass.Maths.getAngle(_fixPoint.x, _fixPoint.y, pointsTotal[1].x, pointsTotal[1].y), _side);
          shape.x = newPointC.x;
          shape.y = maxY;
          shape.labelX = shape.x;
          shape.labelY = shape.y;
          onEdgeFlag = true;
        }
      }
    }

    return onEdgeFlag;
  }

  function checkIfCollinear(shape, point) {
    var pointsTotal = modelObj.interactionElements.filter(function (el) {
      return el.type === 'point';
    });

    switch (shape.shapeType) {
      case 'rhombus':
        var conditionR;

        switch (shape.label) {
          case 'A':
            conditionR = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[2], pointsTotal[3], false).value < 0;
            return conditionR;

          case 'B':
            conditionR = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[0], pointsTotal[3], false).value > 0;
            return conditionR;

          case 'C':
            conditionR = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[0], pointsTotal[3], false).value > 0;
            return conditionR;

          case 'D':
            conditionR = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[0], pointsTotal[1], false).value < 0;
            return conditionR;
        }

        break;

      case 'parallelogram':
        // const pointsTotal = modelObj.interactionElements.filter(el=>el.type === 'point');
        var conditionP;

        switch (shape.label) {
          case 'A':
            conditionP = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[1], pointsTotal[3], false).value < 0;
            return conditionP;

          case 'B':
            conditionP = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[0], pointsTotal[3], false).value > 0;
            return conditionP;

          case 'C':
            conditionP = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[1], pointsTotal[3], false).value > 0;
            return conditionP;

          case 'D':
            conditionP = collinear({
              x: point.x,
              y: point.y
            }, pointsTotal[0], pointsTotal[1], false).value < 0;
            return conditionP;
        }

    }
  }

  function updateDiff(_d, newPos) {
    var max = 50;
    var min = -50;
    _d.labelDiffX = newPos.x;
    _d.labelDiffY = newPos.y; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffX = _d.labelDiffX > max ? max : _d.labelDiffX < min ? min : _d.labelDiffX; // eslint-disable-next-line no-nested-ternary

    _d.labelDiffY = _d.labelDiffY > max ? max : _d.labelDiffY < min ? min : _d.labelDiffY;
  }

  this.setSegmentColor = function (color) {
    modelObj.segmentColor = color;
  };

  this.getSegmentColor = function (color) {
    return modelObj.segmentColor;
  };

  this.updateShape = function (uniqueId, _obj) {
    var shape = findShape(uniqueId);

    if (shape) {
      Object.keys(_obj).forEach(function (i) {
        shape.shape[i] = _obj[i];
      });
    }
  };

  function updatePointValues(target, values) {
    var update = false;

    if (findDraggable([target])) {
      if (target.isIntersection) {
        if (target.circle1 !== undefined && target.circle2 !== undefined) {
          update = true;
        } else {
          update = true;
        }
      } else {
        update = true;
      }
    }

    if (target.x === values.x && target.y === values.y) {
      update = true;
    }

    if (update) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }

    return update;
  }

  function selectObjectsInPixelRange(x, y, maxX, maxY) {
    if (x > maxX) {
      var temp = x;
      x = maxX;
      maxX = temp;
      temp = y;
      y = maxY;
      maxY = temp;
    }

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var shape = modelObj.interactionElements[i];

      if (shape.type === 'point') {
        if (!shape.isSelected) {
          var pos = getPixelByPoint(shape.x, shape.y);

          if (pos.x >= x && pos.x <= maxX && pos.y >= y && pos.y <= maxY) {
            shape.isSelected = true;
          }
        }
      }
    }
  }

  function updateAllShapes(e) {
    var _modelObj$LabComClass = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass.getDistance,
        getAngle = _modelObj$LabComClass.getAngle,
        getPoint = _modelObj$LabComClass.getPoint,
        pointInSegment = _modelObj$LabComClass.pointInSegment,
        getLineintersect = _modelObj$LabComClass.getLineintersect,
        getLinePointIntersection = _modelObj$LabComClass.getLinePointIntersection;

    var _loop2 = function _loop2(i) {
      var shape = modelObj.interactionElements[i];

      if (shape.type.includes('segment') || shape.type === 'length' || shape.type === 'line' || shape.type === 'ray') {
        var firstPoint, secondPoint;
        var label = null;

        if (shape.firstPointId) {
          firstPoint = findShape(shape.firstPointId);

          if (firstPoint) {
            label = firstPoint.shape.label;
            updateShapeValue(shape, {
              x: firstPoint.shape.x,
              y: firstPoint.shape.y
            });
          }
        }

        if (shape.secondPointId) {
          secondPoint = findShape(shape.secondPointId);

          if (secondPoint) {
            if (label) {
              label += secondPoint.shape.label;

              if (shape.label === undefined) {
                shape.label = label;
              }
            }

            updateShapeValue(shape, {
              xTo: secondPoint.shape.x,
              yTo: secondPoint.shape.y
            });
          }
        }

        if (shape.type === 'line' || shape.type === 'ray') {
          updateLinePoints(shape);
        }

        if (shape.type.includes('segment')) {
          var distancePos = {
            x: (shape.x + shape.xTo) / 2,
            y: (shape.y + shape.yTo) / 2
          };
          shape.labelX = distancePos.x;
          shape.labelY = distancePos.y;
          shape.distance = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        }

        if (shape.type.includes('segment') && shape.firstPointId && shape.secondPointId) {
          if (firstPoint.shape.visible && secondPoint.shape.visible) {
            shape.visible = true;
          } else {
            shape.visible = false;
          }
        }

        if (shape.type === 'length') {
          var text = '';

          if (shape.segmentID) {
            var segment = findShape(shape.segmentID);

            if (segment && segment.shape) {
              shape.x = segment.shape.x;
              shape.xTo = segment.shape.xTo;
              shape.y = segment.shape.y;
              shape.yTo = segment.shape.yTo;

              var _firstPoint = findShape(segment.shape.firstPointId);

              var _secondPoint = findShape(segment.shape.secondPointId);

              if (_firstPoint && _firstPoint.shape && _secondPoint && _secondPoint.shape) {
                if (_firstPoint.shape.label !== '' && _secondPoint.shape.label !== '') {
                  text = _firstPoint.shape.label + '' + _secondPoint.shape.label;
                }
              } else if (segment.shape.label) {
                text = segment.shape.label;
              }
            }
          } else {
            if (!shape.labelText) {
              var _firstPoint2 = findShape(shape.firstPointId);

              var _secondPoint2 = findShape(shape.secondPointId);

              if (_firstPoint2 && _firstPoint2.shape && _secondPoint2 && _secondPoint2.shape) {
                if (_firstPoint2.shape.label !== '' && _secondPoint2.shape.label !== '') {
                  text = _firstPoint2.shape.label + '' + _secondPoint2.shape.label;
                }
              }
            } else {
              text = shape.labelText;
            }
          }

          shape.distance = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });

          if (modelObj.shapes.length.digit !== undefined) {
            shape.distance = Number(shape.distance.toFixed(modelObj.shapes.length.digit));
          }

          var _distancePos = {
            x: (shape.x + shape.xTo) / 2,
            y: (shape.y + shape.yTo) / 2
          };

          if (text) {
            shape.label = "\xA7d".concat(text, "\xA7r = ") + shape.distance;
          }

          shape.labelX = _distancePos.x;
          shape.labelY = _distancePos.y;

          if (shape.labelDiffX === undefined) {
            shape.labelDiffX = 0;
            shape.labelDiffY = 0;
          }
        }
      }

      if (shape.type === 'angleRay') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint3 = findShape(shape.firstPointId).shape;
          var _secondPoint3 = findShape(shape.secondPointId).shape;
          var thirdPoint;

          if (shape.thirdPointId !== undefined) {
            thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            thirdPoint = shape.thirdPoint;
          }

          if (thirdPoint) {
            shape.x = _secondPoint3.x;
            shape.y = _secondPoint3.y;
            var firstRay = new modelObj.LabComClass.Vector(_secondPoint3.x - _firstPoint3.x, _secondPoint3.y - _firstPoint3.y);
            var secondRay = new modelObj.LabComClass.Vector(thirdPoint.x - _firstPoint3.x, thirdPoint.y - _firstPoint3.y);
            shape.angle = secondRay.crossProduct(firstRay).z; // shape.angle *= (Math.PI / 180);
            // if (shape.angle < 0) {
            //   shape.angle += (Math.PI * 2);
            // }

            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, thirdPoint.x, thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint3.x, _secondPoint3.y, _firstPoint3.x, _firstPoint3.y);
            var angle = shape.endAngle - shape.startAngle;

            if (angle < 0) {
              angle = angle * -1 * 180 / Math.PI;
            } else if (angle > 0) {
              angle = 360 - angle * 180 / Math.PI;
            }

            shape.angleText = '' + Math.round(angle);
            shape.angleValue = Math.round(angle);
          }
        }
      }

      if (shape.type === 'angleB') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var fp = findShape(shape.firstPointId).shape;
          var sp = findShape(shape.secondPointId).shape;
          var tp;

          if (shape.thirdPointId !== undefined) {
            tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            tp = shape.thirdPoint;
          }

          if (tp) {
            var angleBisectorData = calculateBisector({
              firstPoint: fp,
              secondPoint: sp,
              thirdPoint: tp
            });
            shape.x = angleBisectorData.bisectorLine.x;
            shape.y = angleBisectorData.bisectorLine.y;
            shape.xTo = angleBisectorData.bisectorLine.xTo;
            shape.yTo = angleBisectorData.bisectorLine.yTo;
          }
        }
      }

      if (shape.type === 'mirrorOnLine') {
        if (shape.line !== undefined && shape.linePlotted) {
          var eqnLine = computeEqn(shape.line);
          var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, shape.x, shape.y);
          shape.x = mirrorPoint.x;
          shape.y = mirrorPoint.y;
        }
      }

      if (shape.type === 'circle_3') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _fp = findShape(shape.firstPointId).shape;
          var _sp = findShape(shape.secondPointId).shape;

          var _tp;

          if (shape.thirdPointId !== undefined) {
            _tp = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _tp = shape.thirdPoint;
          }

          if (_tp) {
            var cData = circle3Handler(_fp, _sp, _tp);
            shape.x = cData.x;
            shape.y = cData.y;
            shape.r = cData.r;
          }
        }
      }

      if (shape.type === 'angle') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint4 = findShape(shape.firstPointId).shape;
          var _secondPoint4 = findShape(shape.secondPointId).shape;

          var _thirdPoint;

          if (shape.thirdPointId !== undefined) {
            _thirdPoint = findShape(shape.thirdPointId).shape;
          } else if (shape.thirdPoint) {
            _thirdPoint = shape.thirdPoint;
          }

          if (_thirdPoint) {
            shape.x = _secondPoint4.x;
            shape.y = _secondPoint4.y;

            var _firstRay = new modelObj.LabComClass.Vector(_secondPoint4.x - _firstPoint4.x, _secondPoint4.y - _firstPoint4.y);

            var _secondRay = new modelObj.LabComClass.Vector(_thirdPoint.x - _firstPoint4.x, _thirdPoint.y - _firstPoint4.y);

            shape.angle = _secondRay.crossProduct(_firstRay).z;
            shape.startAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y);
            shape.endAngle = modelObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y);
            shape.angleStart = spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _firstPoint4.x, _firstPoint4.y) * 180 / Math.PI;
            shape.angleEnd = spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y) * 180 / Math.PI < 0 ? 360 + spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y) * 180 / Math.PI : spineObj.LabComClass.Maths.getAngle(_secondPoint4.x, _secondPoint4.y, _thirdPoint.x, _thirdPoint.y) * 180 / Math.PI;

            var _angle3 = shape.endAngle - shape.startAngle;

            if (_angle3 < 0) {
              _angle3 = _angle3 * -1 * 180 / Math.PI;
            } else if (_angle3 > 0) {
              _angle3 = 360 - _angle3 * 180 / Math.PI;
            }

            shape.angleText = '' + Math.round(_angle3);
            shape.angleValue = Math.round(_angle3);
            shape.labelX = _secondPoint4.x;
            shape.labelY = _secondPoint4.y;
          }
        }
      }

      if (shape.type === 'midPoint') {
        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint5 = findShape(shape.firstPointId).shape;
          var _secondPoint5 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint5.x + _secondPoint5.x) / 2;
          shape.y = (_firstPoint5.y + _secondPoint5.y) / 2;
        }
      } else if (shape.type === 'triangle') {
        var _firstPoint6 = findShape(shape.firstPointId).shape;
        var _secondPoint6 = findShape(shape.secondPointId).shape;
        var _thirdPoint2 = findShape(shape.thirdPointId).shape;

        if (shape.firstPointId !== undefined && shape.secondPointId !== undefined && shape.thirdPointId !== undefined) {
          shape.firstPoint = {
            x: _firstPoint6.x,
            y: _firstPoint6.y,
            label: _firstPoint6.label
          };
          shape.secondPoint = {
            x: _secondPoint6.x,
            y: _secondPoint6.y,
            label: _secondPoint6.label
          };
          shape.thirdPoint = {
            x: _thirdPoint2.x,
            y: _thirdPoint2.y,
            label: _thirdPoint2.label
          };
          shape.firstSegmentPlotted = true;
          shape.secondSegmentPlotted = true;
          shape.thirdSegmentPlotted = true;
        }
      } else if (shape.type === 'compass') {
        if (shape.segmentID !== undefined) {
          var _segment = findShape(shape.segmentID);

          if (_segment && _segment.shape) {
            shape.r = getDistance(_segment.shape, {
              x: _segment.shape.xTo,
              y: _segment.shape.yTo
            });
          }
        } else if (shape.circleID !== undefined) {
          var circle = findShape(shape.circleID);

          if (circle) {
            shape.r = circle.shape.r;
          }
        } else if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
          var _firstPoint7 = findShape(shape.firstPointId);

          var _secondPoint7 = findShape(shape.secondPointId);

          if (_firstPoint7 && _secondPoint7) {
            shape.r = getDistance(_firstPoint7.shape, _secondPoint7.shape);
          }
        } else {
          shape.r = getDistance(shape, {
            x: shape.xTo,
            y: shape.yTo
          });
        }

        if (shape.centerPointId !== undefined) {
          var centerPoint = findShape(shape.centerPointId).shape;

          if (centerPoint) {
            updateShapeValue(shape, {
              x: centerPoint.x,
              y: centerPoint.y
            });
          }
        } // shape.r = getDistance(shape, { x: shape.xTo, y: shape.yTo });

      } else if (shape.type === 'point') {
        if (shape.firstPointPlotted && shape.secondPointPlotted && !shape.onSegment) {
          var _firstPoint8 = findShape(shape.firstPointId).shape;
          var _secondPoint8 = findShape(shape.secondPointId).shape;
          shape.x = (_firstPoint8.x + _secondPoint8.x) / 2;
          shape.y = (_firstPoint8.y + _secondPoint8.y) / 2;
        }

        if (shape.onSegment) {
          shape.x = (shape.firstPointCoords.x + shape.secondPointCoords.x) / 2;
          shape.y = (shape.firstPointCoords.y + shape.secondPointCoords.y) / 2;
        }

        if (shape.isIntersection) {
          if (shape.l1 !== undefined && shape.l2 !== undefined) {
            var l1 = findShape(shape.l1);
            var l2 = findShape(shape.l2);

            if (l1 && l2) {
              l1 = l1.shape;
              l2 = l2.shape;
              var p = getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);

              if (!p.onLine1 && l1.type.includes('segment') || !p.onLine2 && l2.type.includes('segment')) {
                shape.visible = false;
              } else {
                shape.visible = true;
              }

              updateShapeValue(shape, {
                x: p.x,
                y: p.y
              });
            }
          }

          if (shape.circle !== undefined && shape.line !== undefined) {
            var _circle = findShape(shape.circle);

            var line = findShape(shape.line);

            if (_circle && line) {
              _circle = _circle.shape;
              line = line.shape;
              var data = getInteractionOfCircleLine(_circle, line, shape);

              if (data !== null) {
                updateShapeValue(shape, {
                  x: data.x,
                  y: data.y
                });
                shape.visible = true;
              } else {
                shape.visible = false;
              }
            }
          }

          if (shape.circle1 !== undefined && shape.circle2 !== undefined) {
            var circle1 = findShape(shape.circle1);
            var circle2 = findShape(shape.circle2);

            if (circle1 && circle2) {
              circle1 = circle1.shape;
              circle2 = circle2.shape;

              var _data2 = getInteractionOfTwoCircles(circle1, circle2, shape, false, true);

              if (_data2 && _data2.x !== undefined && !isNaN(_data2.x)) {
                shape.visible = checkForCorrectIntersection(shape, circle1, circle2, _data2);
              } else {
                shape.visible = false;
              }
            }
          }
        }

        if (shape.isParameter && modelObj.shapesEditable) {
          if (shape.line !== undefined) {
            var _line = findShape(shape.line);

            if (_line) {
              _line = _line.shape;
              var dist = getDistance(_line, {
                x: _line.xTo,
                y: _line.yTo
              });
              var lineAngle = getAngle(_line.x, _line.y, _line.xTo, _line.yTo);
              var newData = {};
              var distFromFirstPoint = shape.pointAngle ? dist * shape.percentage : dist * shape.percentage * -1;

              if (e && shape.isSelected && localObj.mouseDown.isMouseDown && localObj.mouseDown.objectDown) {
                var mouse = getPointByPixel(e.pageX, e.pageY);
                var intersection = getLinePointIntersection(_line, {
                  x: _line.xTo,
                  y: _line.yTo
                }, mouse);
                var intersectionDist = getDistance(_line, intersection);
                newData.pointAngle = getAngle(_line.x, _line.y, intersection.x, intersection.y);
                newData.pointAngle = Math.round(newData.pointAngle) === Math.round(lineAngle);
                newData.percentage = intersectionDist / dist;
                distFromFirstPoint = newData.pointAngle ? dist * newData.percentage : dist * newData.percentage * -1;
              }

              var _p4 = getPoint(_line, lineAngle, distFromFirstPoint);

              newData.x = _p4.x;
              newData.y = _p4.y;
              var setValues = true;

              if (_line.type.includes('segment') || _line.type === 'ray') {
                var endPoint = {
                  x: _line.xTo,
                  y: _line.yTo
                };

                if (_line.type === 'ray') {
                  endPoint = {
                    x: _line.xOr,
                    y: _line.yOr
                  };
                }

                setValues = pointInSegment(_p4, _line, endPoint);

                if (!setValues) {
                  var dist1 = getDistance(_p4, _line);
                  var dist2 = getDistance(_p4, endPoint);

                  if (dist1 < dist2) {
                    newData.x = _line.x;
                    newData.y = _line.y;
                  } else {
                    newData.x = endPoint.x;
                    newData.y = endPoint.y;
                  }
                }
              }

              Object.keys(newData).forEach(function (i) {
                shape[i] = newData[i];
              });
            }
          }

          if (shape.circle !== undefined) {
            var _circle2 = findShape(shape.circle);

            if (_circle2) {
              _circle2 = _circle2.shape;

              if (e && shape.isSelected && localObj.mouseDown.objectDown) {
                var _mouse = getPointByPixel(e.pageX, e.pageY);

                shape.angle = getAngle(_circle2.x, _circle2.y, _mouse.x, _mouse.y);
              }

              var newP = getPoint(_circle2, shape.angle, _circle2.r);
              updateShapeValue(shape, {
                x: newP.x,
                y: newP.y
              });
            }
          }
        }

        for (var j = 0; j < shape.connectionId.length; j++) {
          var shapeData = findShape(shape.connectionId[j]);

          if (shapeData.shape) {
            if (shapeData.shape.type === 'perpendicularLine' || shapeData.shape.type === 'parallelLine') {
              shapeData.shape.visible = shape.visible;
              updateShapeValue(shapeData.shape, {
                x: shape.x,
                y: shape.y
              });
              updatePLinePoints(shapeData.shape);
            } else if (shapeData.shape.type === 'circle') {
              updateCircle(shapeData.shape);
            }
          }
        }
      } else if (shape.type === 'perpendicularLine' || shape.type === 'parallelLine') {
        updatePLinePoints(shape);
      } else if (shape.type === 'circle') {
        updateCircle(shape);
      }

      if (shape && shape.label !== undefined) {
        if (shape.labelX === undefined) {
          shape.labelX = shape.x;
          shape.labelY = shape.y;
        }

        if (shape.labelDiffX === undefined) {
          shape.labelDiffX = 0;
          shape.labelDiffY = 0;
        }
      }
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      _loop2(i);
    }
  }

  function circle3Handler(fp, sp, tp) {
    var p1 = {},
        p2 = {},
        coords = {};
    p1.x = (fp.x + sp.x) / 2;
    p1.y = (fp.y + sp.y) / 2;
    p2.x = (sp.x + tp.x) / 2;
    p2.y = (sp.y + tp.y) / 2;
    p1.m = to2Dec((sp.y - fp.y) / (sp.x - fp.x));
    p2.m = to2Dec((tp.y - sp.y) / (tp.x - sp.x));
    p1.slope = to2Dec(-1 / p1.m);
    p2.slope = to2Dec(-1 / p2.m);
    p1.eqn = "(y-".concat(p1.y, "=").concat(p1.slope, "(x-").concat(p1.x, "))");
    p1.a = -p1.slope;
    p1.b = 1;
    p1.c = to2Dec(-p1.slope * -p1.x - p1.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    p2.eqn = "(y-".concat(p2.y, "=").concat(p2.slope, "(x-").concat(p2.x, "))");
    p2.a = -p2.slope;
    p2.b = 1;
    p2.c = to2Dec(-p2.slope * -p2.x - p2.y);
    p2.e = "".concat(p2.a, "x ").concat(p2.b, "y ").concat(p2.c);
    coords.x = (p1.b * p2.c - p2.b * p1.c) / (p1.a * p2.b - p2.a * p1.b);
    coords.y = (p1.c * p2.a - p2.c * p1.a) / (p1.a * p2.b - p2.a * p1.b);
    coords.r = modelObj.LabComClass.Maths.getDistance(coords, fp);
    return {
      x: coords.x,
      y: coords.y,
      r: coords.r
    };
  }

  function to2Dec(num) {
    return Math.round(num * 100) / 100;
  }

  function updateCircle(shape) {
    if (shape.type === 'circle') {
      if (shape.firstPointId !== undefined && shape.secondPointId !== undefined) {
        var firstPoint = findShape(shape.firstPointId);
        var secondPoint = findShape(shape.secondPointId);

        if (firstPoint && secondPoint) {
          shape.x = firstPoint.shape.x;
          shape.y = firstPoint.shape.y;
          shape.r = modelObj.LabComClass.Maths.getDistance(firstPoint.shape, secondPoint.shape);
        }
      }
    }
  }

  function checkForCorrectIntersection(currentShape, circle1, circle2, newData) {
    var Vector = modelObj.LabComClass.Vector;

    if (currentShape.visible) {
      currentShape.x = newData.x;
      currentShape.y = newData.y;

      var _centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);

      var _firstIntersectLine = new Vector(newData.x - circle1.x, newData.y - circle1.y);

      currentShape.angle1 = _centerPointsLine.crossProduct(_firstIntersectLine).z;
      return true;
    }

    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length < 2) {
      return false;
    }

    if (modelObj.LabComClass.Maths.getDistance(intersection[0], intersection[1]) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      return false;
    }

    var centerPointsLine = new Vector(circle2.x - circle1.x, circle2.y - circle1.y);
    var firstIntersectLine = new Vector(intersection[0].x - circle1.x, intersection[0].y - circle1.y); // const secondIntersectLine = new Vector(intersection[1].x - circle1.x, intersection[1].y - circle1.y);

    var angle1 = centerPointsLine.crossProduct(firstIntersectLine).z; // const angle2 = centerPointsLine.crossProduct(secondIntersectLine).z;

    if (currentShape.angle1 < 0 && angle1 < 0 || currentShape.angle1 > 0 && angle1 > 0) {
      // currentShape.intersectAngle = angle1;
      currentShape.x = intersection[0].x;
      currentShape.y = intersection[0].y;
    } else {
      // currentShape.intersectAngle = angle2;
      currentShape.x = intersection[1].x;
      currentShape.y = intersection[1].y;
    }

    return true;
  } // vertical intsectin is not getting detected in circle line intersect


  function findCircleLineIntersect(circle, line) {
    return modelObj.LabComClass.Maths.findCircleLineIntersect({
      x: circle.x,
      y: circle.y,
      r: circle.r
    }, {
      x: line.x,
      y: line.y
    }, {
      x: line.xTo,
      y: line.yTo
    });
  }

  function findDraggable(elems) {
    var draggable = true;

    if (Array.isArray(elems)) {
      for (var i = 0; i < elems.length; i++) {
        if (elems[i] === undefined || !(elems[i].isDraggable === undefined || elems[i].isDraggable)) {
          draggable = false;
          break;
        }
      }
    } else if (!(elems.isDraggable === undefined || elems.isDraggable)) {
      draggable = false;
    }

    return draggable;
  }

  function updateShapeValue(target, values) {
    if (target.isDraggable === undefined || target.isDraggable) {
      Object.keys(values).forEach(function (i) {
        target[i] = values[i];
      });
    }
  }

  function updateShapes(parentShape, _diffX, _diffY) {
    var otherShapes = parentShape.connectionId;

    for (var i = 0; i < otherShapes.length; i++) {
      var shape = findShape(otherShapes[i]).shape;

      if (shape === undefined || shape === false || shape.isMoved) {
        continue;
      }

      shape.isMoved = true;

      if (shape.type === 'point') {
        var draggable = true;

        if (!shape.isSelected && shape.connectionId.length) {
          for (var j = 0; j < shape.connectionId.length; j++) {
            var connectedShape = findShape(shape.connectionId[j]).shape;

            if (connectedShape && (connectedShape.type === 'line' || connectedShape.type === 'ray' || connectedShape.type.includes('segment'))) {
              var checkId = connectedShape.firstPointId === shape.uniqueId ? connectedShape.secondPointId : connectedShape.firstPointId;
              var connectedPoint = findShape(checkId);

              if (connectedPoint && connectedPoint.shape) {
                if (!(connectedPoint.shape.isDraggable === undefined || connectedPoint.shape.isDraggable === true)) {
                  draggable = false;
                }
              }
            }
          }
        }

        if (draggable) {
          updateShapeValue(shape, {
            x: shape.x + _diffX,
            y: shape.y + _diffY
          });
        }
      } else if (shape.type === 'line' || shape.type === 'ray' || shape.type.includes('segment')) {
        if (shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        } else {
          shape.xTo = parentShape.x;
          shape.yTo = parentShape.y;
        }

        if (shape.type === 'line' || shape.type === 'ray') {
          updateLinePoints(shape);
        }
      } else if (shape.type === 'perpendicularLine' || shape.type === 'parallelLine') {
        if (parentShape.type === 'point') {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
          updatePLinePoints(shape);
        }
      } else if (shape.type === 'circle') {
        if (parentShape.type === 'point' && shape.firstPointId === parentShape.uniqueId) {
          shape.x = parentShape.x;
          shape.y = parentShape.y;
        }
      }
    }
  }

  function findShape(uniqueId) {
    var shapesData = modelObj.interactionElements;

    for (var i = shapesData.length - 1; i >= 0; i--) {
      if (shapesData[i] && shapesData[i].uniqueId === uniqueId) {
        return {
          index: i,
          shape: shapesData[i]
        };
      }
    }

    return false;
  } // =================================================


  function onMouseUp(e) {
    var shapesData = modelObj.interactionElements;
    var tool = modelObj.interactionType;
    var _ctx = modelObj.context;
    _ctx.font = "".concat(modelObj.fontSize, "px ").concat(modelObj.LabComClass.polo22KlettRegular);
    var value = {
      type: tool
    };
    var _it = tool;
    var dataAvailable = false;
    var point = getPointByPixel(e.pageX, e.pageY);
    var currentShape = localObj.currentUniqueId !== null && findShape(localObj.currentUniqueId).shape;

    if (!localObj.mouseDown.lastShapeCompleted && localObj.currentUniqueId == null) {
      currentShape = findShape(localObj.uniqueId).shape;
    }

    point = checkSnapping(point);
    var clickingOnExistingPoint = checkPoint(getPointByPixel(e.pageX, e.pageY));
    var clickingOnExistingPointID = null;

    if (clickingOnExistingPoint !== null) {
      clickingOnExistingPointID = shapesData[clickingOnExistingPoint].uniqueId;
      point = shapesData[clickingOnExistingPoint];
    }

    if (clickingOnExistingPointID !== null) {
      if (_it !== 'select' && _it !== 'move' && _it !== 'moveGraph' && currentShape) {
        currentShape.isSelected = false;
      }
    }

    var pointOnGraph = point !== null;

    if (_it === 'point' && currentShape && pointOnGraph) {
      if (findDraggable([currentShape])) {
        if (updatePointValues(currentShape, {
          x: point.x,
          y: point.y
        })) {
          if (!modelObj.shapesEditable) {
            currentShape.isDraggable = false;
            value.isDraggable = currentShape.isDraggable;
          }

          dataAvailable = true;
          value.x = point.x;
          value.y = point.y;
          value.uniqueId = currentShape.uniqueId;

          if (dataAvailable) {
            dataAvailable = checkDataAvailable(currentShape, ['x', 'y']);
          }
        }
      } else if (modelObj.plotPointOnExistingPoint) {
        dataAvailable = true;
        var pointId = ++localObj.uniqueId;
        value.x = currentShape.x;
        value.y = currentShape.y;
        addPoint(point, {
          uniqueId: pointId,
          connectionId: [currentShape.uniqueId]
        });
        value.uniqueId = pointId;
      }
    } else if (currentShape && (_it.includes('segment') || _it === 'length' || _it === 'line' || _it === 'ray') && pointOnGraph) {
      if (findDraggable([currentShape])) {
        currentShape.xTo = point.x;
        currentShape.yTo = point.y;
      }

      if (tool === 'line' || tool === 'ray') {
        updateLinePoints(currentShape);
      }

      value.x = currentShape.x;
      value.y = currentShape.y;
      value.xTo = currentShape.xTo;
      value.yTo = currentShape.yTo;
      value.slope = currentShape.slope;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ['x', 'y', 'xTo', 'yTo']);
      }

      if (clickingOnExistingPoint === null) {
        if (_it !== 'length') {
          var secondPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: secondPointId,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = secondPointId;
          currentShape.connectionId.push(secondPointId);
        } else if (currentShape.firstPointId !== undefined) {
          if (localObj.newPlottedShapes.length > 0) {
            shapesData.pop();
          }
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        if (_it !== 'length') {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
        }

        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (currentShape && _it === 'angleRay' && pointOnGraph) {
      var angleRay = findShape(currentShape.angleRayId).shape;

      if (!angleRay.firstRayPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var firstPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: firstPointId,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.firstPointId = firstPointId;
          currentShape.connectionId.push(firstPointId);
          angleRay.firstRayPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          angleRay.firstRayPlotted = true;
        }

        if (angleRay.firstRayPlotted) {
          angleRay.secondPointId = currentShape.firstPointId;
          addNewShape({
            type: 'ray',
            uniqueId: ++localObj.uniqueId,
            firstPointId: angleRay.secondPointId,
            angleRayId: currentShape.angleRayId,
            x: point.x,
            y: point.y,
            xOr: point.x,
            yOr: point.y,
            xTo: point.x,
            yTo: point.y,
            xOrTo: point.x,
            yOrTo: point.y,
            connectionId: [angleRay.secondPointId]
          });
          localObj.currentUniqueId = localObj.uniqueId;
          angleRay.x = point.x;
          angleRay.y = point.y;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId2 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId2,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = _secondPointId2;
          currentShape.connectionId.push(_secondPointId2);
          angleRay.secondRayPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          angleRay.secondRayPlotted = true;
        }

        if (angleRay.secondRayPlotted) {
          angleRay.thirdPointId = currentShape.secondPointId;
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleRay.secondRayPlotted) {
        var firstPoint = findShape(angleRay.firstPointId).shape;
        var secondPoint = findShape(angleRay.secondPointId).shape;
        var thirdPoint = findShape(angleRay.thirdPointId).shape;
        value.firstPoint = {
          x: firstPoint.x,
          y: firstPoint.y,
          label: firstPoint.label
        };
        value.secondPoint = {
          x: secondPoint.x,
          y: secondPoint.y,
          label: secondPoint.label
        };
        value.thirdPoint = {
          x: thirdPoint.x,
          y: thirdPoint.y,
          label: thirdPoint.label
        };
        value.x = secondPoint.x;
        value.y = secondPoint.y;
        var angleData = calculateAngle(value, 'angleRay');
        value.angle = angleData.angle;
        value.angleValue = angleData.angleValue;
        angleRay.label = angleData.angleText;
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'triangle' && pointOnGraph) {
      var triangle = findShape(currentShape.triangleId).shape;

      if (!triangle.firstSegmentPlotted) {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var _firstPointId17 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _firstPointId17,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.firstPointId = _firstPointId17;
          currentShape.connectionId.push(_firstPointId17);
          triangle.firstSegmentPlotted = true;
        } else if (currentShape.secondPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.firstPointId = clickingOnExistingPointID;
          triangle.firstSegmentPlotted = true;
        }

        if (triangle.firstSegmentPlotted) {
          triangle.secondPointId = currentShape.firstPointId;
          addNewShape({
            type: 'segment',
            uniqueId: ++localObj.uniqueId,
            firstPointId: triangle.secondPointId,
            triangleId: currentShape.triangleId,
            x: point.x,
            y: point.y,
            xTo: point.x,
            yTo: point.y,
            connectionId: [triangle.secondPointId]
          });
          localObj.newPlottedShapes.push(localObj.uniqueId);
          localObj.currentUniqueId = localObj.uniqueId;
          triangle.x = point.x;
          triangle.y = point.y;
        }
      } else {
        if (findDraggable([currentShape])) {
          currentShape.x = point.x;
          currentShape.y = point.y;
        }

        updateLinePoints(currentShape);

        if (clickingOnExistingPoint === null) {
          var _secondPointId3 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId3,
            connectionId: [currentShape.uniqueId]
          });
          currentShape.secondPointId = _secondPointId3;
          currentShape.connectionId.push(_secondPointId3);
          triangle.secondSegmentPlotted = true;
        } else if (currentShape.firstPointId === clickingOnExistingPointID || triangle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          triangle.secondSegmentPlotted = true;
        }
      }

      if (triangle.secondSegmentPlotted) {
        var _secondPoint9 = findShape(triangle.firstPointId).shape;
        triangle.thirdPointId = currentShape.secondPointId;
        addNewShape({
          type: 'segment',
          uniqueId: ++localObj.uniqueId,
          firstPointId: triangle.thirdPointId,
          secondPointId: triangle.firstPointId,
          triangleId: currentShape.triangleId,
          x: point.x,
          y: point.y,
          xTo: _secondPoint9.x,
          yTo: _secondPoint9.y,
          connectionId: [triangle.thirdPointId, triangle.firstPointId]
        });
        localObj.newPlottedShapes.push(localObj.uniqueId);
        localObj.currentUniqueId = localObj.uniqueId;
        triangle.x = point.x;
        triangle.y = point.y;
        triangle.thirdSegmentPlotted = true;
        localObj.mouseDown.lastShapeCompleted = true;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (triangle.thirdSegmentPlotted) {
        var _firstPoint9 = findShape(triangle.firstPointId).shape;
        var _secondPoint10 = findShape(triangle.secondPointId).shape;
        var _thirdPoint3 = findShape(triangle.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint9.x,
          y: _firstPoint9.y,
          label: _firstPoint9.label
        };
        value.secondPoint = {
          x: _secondPoint10.x,
          y: _secondPoint10.y,
          label: _secondPoint10.label
        };
        value.thirdPoint = {
          x: _thirdPoint3.x,
          y: _thirdPoint3.y,
          label: _thirdPoint3.label
        };
        value.x = _secondPoint10.x;
        value.y = _secondPoint10.y;
        value.uniqueId = triangle.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'circle_3' && pointOnGraph) {
      var bbb;

      if (currentShape.type !== 'circle_3') {
        bbb = findShape(currentShape.circleId).shape;
      } else {
        bbb = currentShape;
      }

      if (!bbb.firstPointPlotted) {
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var _secondPointId4 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId4,
            connectionId: [bbb.uniqueId],
            circleId: bbb.uniqueId
          });
          bbb.secondPointId = _secondPointId4;
          bbb.firstPointPlotted = true;
        } else if (bbb.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(bbb.uniqueId);
          point.bbbId = bbb.uniqueId;
          bbb.secondPointId = clickingOnExistingPointID;
          bbb.firstPointPlotted = true;
        }

        if (bbb.firstPointPlotted) {
          bbb.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          bbb.x = point.x;
          bbb.y = point.y;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var thirdPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: thirdPointId,
            connectionId: [bbb.uniqueId]
          });
          bbb.thirdPointId = thirdPointId;
          bbb.thirdPointPloted = true;
        } else if (bbb.secondPointId === clickingOnExistingPointID || bbb.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(bbb.uniqueId);
          bbb.thirdPointId = clickingOnExistingPointID;
          bbb.thirdPointPloted = true;
        }

        if (bbb.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (bbb.thirdPointPloted) {
        var _firstPoint10 = findShape(bbb.firstPointId).shape;
        var _secondPoint11 = findShape(bbb.secondPointId).shape;
        var _thirdPoint4 = findShape(bbb.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint10.x,
          y: _firstPoint10.y
        };
        value.secondPoint = {
          x: _secondPoint11.x,
          y: _secondPoint11.y
        };
        value.thirdPoint = {
          x: _thirdPoint4.x,
          y: _thirdPoint4.y
        };
        var circleData = computeCircle(value);
        value.r = circleData.r;
        value.x = circleData.x;
        value.y = circleData.y;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'angle' && pointOnGraph) {
      var angle;

      if (currentShape.type === 'point') {
        angle = findShape(currentShape.angleId).shape;
      } else {
        angle = findShape(currentShape.uniqueId).shape;
      }

      if (!angle.firstPointPlotted) {
        dataAvailable = false;

        if (clickingOnExistingPoint === null) {
          var _secondPointId5 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId5,
            connectionId: [angle.uniqueId],
            angleId: currentShape.angleId
          });
          angle.secondPointId = _secondPointId5;
          angle.firstPointPlotted = true;
        } else if (angle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(angle.uniqueId);
          point.angleId = currentShape.angleId;
          angle.secondPointId = clickingOnExistingPointID;
          angle.firstPointPlotted = true;
        }

        if (angle.firstPointPlotted) {
          angle.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          angle.x = point.x;
          angle.y = point.y;
        }
      } else {
        if (clickingOnExistingPoint === null) {
          var _thirdPointId = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _thirdPointId,
            connectionId: [angle.uniqueId],
            angleId: angle.uniqueId
          });
          angle.thirdPointId = _thirdPointId;
          angle.thirdPointPloted = true;
        } else if (angle.secondPointId === clickingOnExistingPointID || angle.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else {
          point.connectionId.push(angle.uniqueId);
          angle.thirdPointId = clickingOnExistingPointID;
          point.angleId = angle.uniqueId;
          angle.thirdPointPloted = true;
        }

        if (angle.thirdPointPloted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angle.thirdPointPloted) {
        var _firstPoint11 = findShape(angle.firstPointId).shape;
        var _secondPoint12 = findShape(angle.secondPointId).shape;
        var _thirdPoint5 = findShape(angle.thirdPointId).shape;
        value.firstPoint = {
          x: _firstPoint11.x,
          y: _firstPoint11.y,
          label: _firstPoint11.label
        };
        value.secondPoint = {
          x: _secondPoint12.x,
          y: _secondPoint12.y,
          label: _secondPoint12.label
        };
        value.thirdPoint = {
          x: _thirdPoint5.x,
          y: _thirdPoint5.y,
          label: _thirdPoint5.label
        };
        value.x = _secondPoint12.x;
        value.y = _secondPoint12.y;

        var _angleData = calculateAngle(value);

        value.angle = _angleData.angle;
        value.angleValue = _angleData.angleValue;
        angle.label = _angleData.angleText;
        angle.labelX = angle.x + getPointUnitByPixelUnit(10);
        angle.labelY = angle.y - getPointUnitByPixelUnit(10);
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
      }
    } else if (currentShape && _it === 'angleB' && pointOnGraph && localObj.newShapeStarted) {
      var angleB;

      if (currentShape.type === 'point') {
        angleB = findShape(currentShape.angleBId).shape;
      } else {
        angleB = findShape(currentShape.uniqueId).shape;
      }

      if (angleB.mode === 'point') {
        var _angleB, _angleB2;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB = angleB) === null || _angleB === void 0 ? void 0 : _angleB.firstPointPlotted)) {
          dataAvailable = false;

          if (clickingOnExistingPoint === null || angleB.firstPointId === clickingOnExistingPointID) {
            ;
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            point.angleBId = currentShape.uniqueId;
            angleB.secondPointId = clickingOnExistingPointID;
            angleB.firstPointPlotted = true;
          }

          if (angleB.firstPointPlotted) {
            angleB.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }
        } else {
          if (clickingOnExistingPoint === null || angleB.secondPointId === clickingOnExistingPointID || angleB.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            point.connectionId.push(angleB.uniqueId);
            angleB.thirdPointId = clickingOnExistingPointID;
            point.angleBId = currentShape.uniqueId;
            angleB.thirdPointPloted = true;
          }

          if (angleB.thirdPointPloted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if ((_angleB2 = angleB) === null || _angleB2 === void 0 ? void 0 : _angleB2.thirdPointPloted) {
          var _firstPoint12 = findShape(angleB.firstPointId).shape;
          var _secondPoint13 = findShape(angleB.secondPointId).shape;
          var _thirdPoint6 = findShape(angleB.thirdPointId).shape;
          value.firstPoint = {
            x: _firstPoint12.x,
            y: _firstPoint12.y,
            label: _firstPoint12.label
          };
          value.secondPoint = {
            x: _secondPoint13.x,
            y: _secondPoint13.y,
            label: _secondPoint13.label
          };
          value.thirdPoint = {
            x: _thirdPoint6.x,
            y: _thirdPoint6.y,
            label: _thirdPoint6.label
          };
          value.x = _secondPoint13.x;
          value.y = _secondPoint13.y;
          value.uniqueId = angleB.uniqueId;
          var angleBData = calculateBisector(value);
          angleB.firstPoint = value.firstPoint;
          angleB.secondPoint = value.secondPoint;
          angleB.thirdPoint = value.thirdPoint; // addNewShape(angleB.bisectorLine);

          var lineId = addNewShape({
            type: 'line',
            uniqueId: ++localObj.uniqueId,
            x: _secondPoint13.x,
            y: _secondPoint13.y,
            xTo: angleBData.x,
            yTo: angleBData.y,
            slope: getSlope(_secondPoint13.x, _secondPoint13.y, angleBData.x, angleBData.y)
          });
          value.bisectorLine = lineId;
          angleB.bisectorLine = lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(lineId.uniqueId);
          dataAvailable = true;
        }
      } else if (angleB.mode === 'segment') {
        var _angleB3;

        var selectedShapeID = isOnShape(e);
        var selectedShape = findShape(selectedShapeID).shape;

        if (angleB === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleB3 = angleB) === null || _angleB3 === void 0 ? void 0 : _angleB3.firstSegmentPlotted)) {
          dataAvailable = false;

          if (selectedShape !== undefined && selectedShape.type.includes('segment') && selectedShape.uniqueId === angleB.firstSegmentId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (selectedShape !== undefined && selectedShape.type.includes('segment')) {
            selectedShape.angleBId = angleB.uniqueId;
            angleB.secondSegmentId = selectedShape.uniqueId;
            angleB.firstSegmentPlotted = true;
            angleB.secondSegment = {
              x: selectedShape.x,
              y: selectedShape.y,
              xTo: selectedShape.xTo,
              yTo: selectedShape.yTo
            };
          }

          if (angleB.firstSegmentPlotted) {
            angleB.secondSegmentPlotted = true;
            localObj.currentUniqueId = null;
            angleB.x = point.x;
            angleB.y = point.y;
          }

          if (angleB.secondSegmentPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;

        if (angleB.secondSegmentPlotted) {
          value.firstSegment = angleB.firstSegment;
          value.secondSegment = angleB.secondSegment;
          var pCommon = findCommon(angleB.firstSegment, angleB.secondSegment);
          value.x = +pCommon.x;
          value.y = +pCommon.y;
          angleB.x = +pCommon.x;
          angleB.y = +pCommon.y;
          value.uniqueId = angleB.uniqueId;

          var _angleBData = calculateBisector(value, "segment");

          var _lineId = addNewShape({
            type: 'line',
            uniqueId: ++localObj.uniqueId,
            x: +pCommon.x,
            y: +pCommon.y,
            xTo: _angleBData.x,
            yTo: _angleBData.y,
            slope: getSlope(+pCommon.x, +pCommon.y, _angleBData.x, _angleBData.y)
          });

          value.bisectorLine = _lineId;
          angleB.bisectorLine = _lineId;
          value.mode = angleB.mode;
          localObj.newPlottedShapes.push(_lineId.uniqueId);
          dataAvailable = true;
        }
      }
    } else if (currentShape && _it === 'angleSize' && pointOnGraph && localObj.newShapeStarted) {
      var angleSize;

      if (currentShape.type === 'point') {
        angleSize = findShape(currentShape.angleSizeId).shape;
      } else {
        angleSize = findShape(currentShape.uniqueId).shape;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (angleSize.mode === 'point') {
        var _angleSize;

        if (angleSize === undefined) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          localObj.mouseDown.isMouseDown = false;
        } else if (!((_angleSize = angleSize) === null || _angleSize === void 0 ? void 0 : _angleSize.firstPointPlotted)) {
          dataAvailable = false;
          point.angleSizeId = angleSize.uniqueId;
          localObj.currentUniqueId = null;
          angleSize.firstPointPlotted = true;
          angleSize.x = point.x;
          angleSize.y = point.y;
        } else if (!angleSize.secondPointPlotted) {
          if (clickingOnExistingPointID === angleSize.firstPointId) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else {
            var _secondPointId6;

            if (clickingOnExistingPoint >= 0) {
              _secondPointId6 = clickingOnExistingPointID;
              angleSize.connectionId.push(clickingOnExistingPointID);
            } else {
              _secondPointId6 = ++localObj.uniqueId;
              addPoint(point, {
                uniqueId: _secondPointId6,
                angleSizeId: angleSize.uniqueId,
                connectionId: [angleSize.uniqueId]
              });
            }

            var _firstPoint13 = findShape(angleSize.firstPointId).shape;
            angleSize.secondPointId = _secondPointId6;
            angleSize.secondPointPlotted = true;
            angleSize.x = point.x;
            angleSize.y = point.y;
            angleSize.xTo = _firstPoint13.x;
            angleSize.yTo = _firstPoint13.y;
            modelObj.waiting = true;

            if (typeof events.angleSize !== 'undefined') {
              events.angleSize({
                id: modelObj.id,
                type: 'angleSize',
                visible: true,
                data: JSON.parse(JSON.stringify(angleSize))
              }, true);
            }

            dataAvailable = false;
          }
        } else {
          _this.removeUnplotedShapes();
        }
      } else if (angleSize.mode === 'segment') {
        var _selectedShapeID6 = isOnShape(e);

        var _selectedShape = findShape(_selectedShapeID6).shape;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === 'segSize' && pointOnGraph) {
      var _segSize;

      var segSize;

      if (currentShape.type === 'point') {
        segSize = findShape(currentShape.segSizeId).shape;
      } else {
        segSize = findShape(currentShape.uniqueId).shape;
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (segSize === undefined) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        localObj.mouseDown.isMouseDown = false;
      } else if (!((_segSize = segSize) === null || _segSize === void 0 ? void 0 : _segSize.firstPointPlotted)) {
        dataAvailable = false;
        point.segSizeId = segSize.uniqueId;
        localObj.currentUniqueId = null;
        segSize.firstPointPlotted = true;
        segSize.x = point.x;
        segSize.y = point.y;

        if (segSize.firstPointPlotted) {
          modelObj.waiting = true;

          if (typeof events.segSize !== 'undefined') {
            events.segSize({
              id: modelObj.id,
              type: 'segSize',
              visible: true,
              data: JSON.parse(JSON.stringify(segSize))
            }, true);
          }

          dataAvailable = false;
        }
      } else {
        _this.removeUnplotedShapes();
      }
    } else if (currentShape && _it === 'midPoint' && pointOnGraph) {
      var _midPoint;

      var midPoint;

      var _selectedShapeID7 = isOnShape(e);

      var _selectedShape2 = findShape(_selectedShapeID7).shape;

      if (currentShape.type === 'point' || currentShape.type.includes('segment')) {
        midPoint = findShape(currentShape.midPointId).shape;
      } else {
        midPoint = findShape(currentShape.uniqueId).shape;
      }

      if (!((_midPoint = midPoint) === null || _midPoint === void 0 ? void 0 : _midPoint.firstPointPlotted)) {
        dataAvailable = false;

        if (_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes('segment')) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if (clickingOnExistingPoint === null && !(_selectedShape2 === null || _selectedShape2 === void 0 ? void 0 : _selectedShape2.type.includes('segment'))) {
          var _secondPointId7 = ++localObj.uniqueId;

          addPoint(point, {
            uniqueId: _secondPointId7,
            connectionId: [midPoint.uniqueId],
            midPointId: currentShape.midPointId
          });
          midPoint.secondPointId = _secondPointId7;
          midPoint.firstPointPlotted = true;
        } else if (midPoint.firstPointId === clickingOnExistingPointID) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          point.connectionId.push(midPoint.uniqueId);
          point.midPointId = currentShape.midPointId;
          midPoint.secondPointId = clickingOnExistingPointID;
          midPoint.firstPointPlotted = true;
        }

        if (midPoint.firstPointPlotted) {
          midPoint.secondPointPlotted = true;
          localObj.currentUniqueId = null;
          midPoint.x = point.x;
          midPoint.y = point.y;
        }
      } else {
        if (midPoint.secondPointPlotted) {
          localObj.mouseDown.lastShapeCompleted = true;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (midPoint.secondPointPlotted && midPoint.onSegment === undefined) {
        var _findShape;

        var _firstPoint14 = findShape(midPoint.firstPointId).shape;
        var _secondPoint14 = findShape(midPoint.secondPointId).shape;
        value.firstPoint = {
          x: _firstPoint14.x,
          y: _firstPoint14.y,
          label: _firstPoint14.label
        };
        value.secondPoint = {
          x: _secondPoint14.x,
          y: _secondPoint14.y,
          label: _secondPoint14.label
        };
        value.x = (_firstPoint14.x + _secondPoint14.x) / 2;
        value.y = (_firstPoint14.y + _secondPoint14.y) / 2;
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
        var segment = (_findShape = findShape(midPoint.segmentId)) === null || _findShape === void 0 ? void 0 : _findShape.shape;

        if (segment) {
          segment.isMouseDown = false;
          segment.isSelected = false;
        }
      } else if (midPoint.secondPointPlotted && midPoint.onSegment !== undefined) {
        // value.x=(midPoint.x+midPoint.xTo)/2;
        // value.y=(midPoint.y+midPoint.yTo)/2;
        value.x = (midPoint.firstPointCoords.x + midPoint.secondPointCoords.x) / 2;
        value.y = (midPoint.firstPointCoords.y + midPoint.secondPointCoords.y) / 2;
        value.uniqueId = currentShape.uniqueId;
        dataAvailable = true;
        var _segment2 = findShape(midPoint.segmentId).shape;
        _segment2.isMouseDown = false;
        _segment2.isSelected = false;
      }
    } else if (currentShape && _it === 'mirrorOnLine' && pointOnGraph) {
      var _mirrorOnLine;

      var mirrorOnLine;

      var _selectedShapeID8 = isOnShape(e);

      var _selectedShape3 = findShape(_selectedShapeID8).shape;

      if (currentShape.type === 'point') {
        mirrorOnLine = findShape(currentShape.mirrorOnLineId).shape;
      } else {
        mirrorOnLine = findShape(currentShape.uniqueId).shape;
      }

      if (!((_mirrorOnLine = mirrorOnLine) === null || _mirrorOnLine === void 0 ? void 0 : _mirrorOnLine.firstPointPlotted) && _typeof(mirrorOnLine) !== undefined) {
        dataAvailable = false;

        if (clickingOnExistingPoint === null && _selectedShape3 && checkType(_selectedShape3, localObj.lineTypes)) {
          var _lineId2 = _selectedShapeID8;
          mirrorOnLine.lineId = _lineId2;
          mirrorOnLine.firstPointPlotted = true;
        } else if (mirrorOnLine.firstPointId === clickingOnExistingPointID || clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
        }

        if (mirrorOnLine.firstPointPlotted) {
          mirrorOnLine.linePlotted = true;
          localObj.currentUniqueId = null; // mirrorOnLine.x = point.x;
          // mirrorOnLine.y = point.y;
        }
      }

      localObj.mouseDown.lastShapeCompleted = false;
      dataAvailable = false;

      if (mirrorOnLine !== undefined && mirrorOnLine.linePlotted) {
        var _firstPoint15 = findShape(mirrorOnLine.firstPointId).shape;
        value.firstPoint = {
          x: _firstPoint15.x,
          y: _firstPoint15.y,
          uniqueId: _firstPoint15.uniqueId
        };
        mirrorOnLine.firstPoint = {
          x: _firstPoint15.x,
          y: _firstPoint15.y,
          uniqueId: _firstPoint15.uniqueId
        }; // const mirrorData = computeMirrorPoint(mirrorOnLine);

        var line = findShape(mirrorOnLine.lineId).shape;
        var eqnLine = computeEqn(line);
        var mirrorPoint = mirrorImage(eqnLine.a, eqnLine.b, eqnLine.c, mirrorOnLine.x, mirrorOnLine.y);
        value.x = mirrorPoint.x;
        value.y = mirrorPoint.y;
        mirrorOnLine.x = mirrorPoint.x;
        mirrorOnLine.y = mirrorPoint.y;
        value.lineId = line.uniqueId;
        value.mirrorPointId = ++localObj.uniqueId;
        addPoint(mirrorPoint, {
          uniqueId: value.mirrorPointId,
          mirrorOnLineId: mirrorOnLine.uniqueId,
          connectionId: [mirrorOnLine.uniqueId]
        });
        dataAvailable = true;
      } else {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      }
    } else if (currentShape && _it === 'perpendicularBisector' && pointOnGraph && localObj.newShapeStarted) {
      var perpShape = currentShape;

      if (perpShape.mode === 'point') {
        if (!perpShape.firstPointPlotted) {
          if (perpShape.firstPointId === clickingOnExistingPointID) {
            localObj.mouseDown.lastShapeCompleted = false;
            dataAvailable = false;
          } else if (clickingOnExistingPoint >= 0 && clickingOnExistingPoint !== null) {
            point.connectionId.push(perpShape.uniqueId);
            perpShape.secondPointId = clickingOnExistingPointID;
            perpShape.firstPointPlotted = true;
          }

          if (perpShape.firstPointPlotted) {
            perpShape.secondPointPlotted = true;
            localObj.currentUniqueId = null;
            perpShape.x = point.x;
            perpShape.y = point.y;
          }
        } else {
          if (perpShape.secondPointPlotted) {
            localObj.mouseDown.lastShapeCompleted = true;
          }
        }

        if (perpShape.firstPointPlotted && perpShape.secondPointPlotted) {
          var _firstPoint16 = findShape(currentShape.firstPointId).shape;
          var _secondPoint15 = findShape(perpShape.secondPointId).shape;
          var _midPoint2 = {
            x: (_firstPoint16.x + _secondPoint15.x) / 2,
            y: (_firstPoint16.y + _secondPoint15.y) / 2
          };
          var valueObj = computePerpBisector(perpShape, _firstPoint16, _secondPoint15, _midPoint2);
          value = _objectSpread(_objectSpread({}, value), valueObj);
          dataAvailable = true;
        }
      } else if (perpShape.mode === 'segment') {
        var _firstPoint17 = {
          x: perpShape.segment.x,
          y: perpShape.segment.y
        };
        var _secondPoint16 = {
          x: perpShape.segment.xTo,
          y: perpShape.segment.yTo
        };
        var _midPoint3 = {
          x: (_firstPoint17.x + _secondPoint16.x) / 2,
          y: (_firstPoint17.y + _secondPoint16.y) / 2
        };

        var _valueObj = computePerpBisector(perpShape, _firstPoint17, _secondPoint16, _midPoint3);

        value = _objectSpread(_objectSpread({}, value), _valueObj);
        dataAvailable = true;
      }
    } else if (currentShape && (_it === 'perpendicularLine' || _it === 'parallelLine') && pointOnGraph) {
      // updatePLinePoints(currentShape);
      dataAvailable = true;

      if (currentShape.lineToPoint) {
        var _line3 = findShape(currentShape.line).shape;

        if (clickingOnExistingPoint === null) {
          var distance = Math.abs(modelObj.LabComClass.Maths.getPointLineDistance(point, _line3, {
            x: _line3.xTo,
            y: _line3.yTo
          }));
          var accepted = distance < getPointUnitByPixelUnit(modelObj.snappingDiff) && currentShape.lineSelected;

          if (accepted || distance > getPointUnitByPixelUnit(modelObj.snappingDiff)) {
            var _secondPointId8 = ++localObj.uniqueId;

            addPoint(point, {
              uniqueId: _secondPointId8,
              connectionId: [currentShape.uniqueId]
            });
            currentShape.secondPointId = _secondPointId8;
            currentShape.connectionId.push(_secondPointId8);
            localObj.mouseDown.lastShapeCompleted = true;
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else if (clickingOnExistingPointID === currentShape.firstPointId) {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        } else {
          point.connectionId.push(currentShape.uniqueId);
          currentShape.connectionId.push(clickingOnExistingPointID);
          currentShape.secondPointId = clickingOnExistingPointID;
          localObj.mouseDown.lastShapeCompleted = true;
        }

        if (dataAvailable) {
          _line3.isSelected = false;
        }
      } else {
        var _selectedShapeID9 = isOnShape(e);

        if (_selectedShapeID9) {
          var shapeData = findShape(_selectedShapeID9).shape;

          if (shapeData && checkType(shapeData, localObj.lineTypes)) {
            var _d5 = getPLine(e, _it === 'perpendicularLine');

            if (_d5) {
              currentShape.slope = _d5.slope;
              var _firstPoint18 = findShape(currentShape.firstPointId).shape;
              _firstPoint18.isSelected = false;
              updatePLinePoints(currentShape);
              localObj.mouseDown.lastShapeCompleted = true;
            }
          } else {
            dataAvailable = false;
            localObj.mouseDown.lastShapeCompleted = false;
          }
        } else {
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = false;
        }
      }

      if (currentShape.pointToLine) {
        currentShape.firstPointPlotted = true;
      } else {
        currentShape.lineSelected = true;
      }

      if (dataAvailable) {
        dataAvailable = checkDataAvailable(currentShape, ['x', 'y', 'xTo', 'yTo']);
      }

      if (dataAvailable) {
        value.x = currentShape.x;
        value.y = currentShape.y;
        value.xTo = currentShape.xTo;
        value.yTo = currentShape.yTo;
        value.slope = currentShape.slope;
        value.uniqueId = currentShape.uniqueId;
        currentShape.visible = true;
      } else {
        dataAvailable = false;
        localObj.mouseDown.lastShapeCompleted = false;
      }
    } else if (currentShape && _it === 'compass') {
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;
      dataAvailable = true;

      if (clickingOnExistingPoint === null) {
        if (currentShape.firstPointId !== undefined && !currentShape.isPloted) {
          shapesData.pop();
          dataAvailable = false;
          localObj.mouseDown.lastShapeCompleted = true;
        } else if (!currentShape.isPloted) {
          localObj.mouseDown.lastShapeCompleted = false;
          dataAvailable = false;
          currentShape.isPloted = true;
        } else if (pointOnGraph) {
          var centerPointId = ++localObj.uniqueId;
          addPoint(point, {
            uniqueId: centerPointId,
            connectionId: [currentShape.uniqueId]
          }); //currentShape.centerPointId = centerPointId;

          currentShape.connectionId.push(centerPointId);
        }
      } else if (currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else if (!currentShape.isPloted) {
        currentShape.secondPointId = clickingOnExistingPointID;
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
        currentShape.isPloted = true;
      } else {
        point.connectionId.push(currentShape.uniqueId);
        currentShape.centerPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        localObj.mouseDown.lastShapeCompleted = true;
        var s = currentShape.firstPointId !== undefined ? findShape(currentShape.firstPointId) : findShape(currentShape.circleID);

        if (s) {
          s.shape.isSelected = false;
        }
      }
    } else if (_it === 'circle' && currentShape) {
      dataAvailable = true;
      value.x = currentShape.x;
      value.y = currentShape.y;
      value.r = currentShape.r;
      value.uniqueId = currentShape.uniqueId;

      if (clickingOnExistingPoint === null && pointOnGraph) {
        var _secondPointId9 = ++localObj.uniqueId;

        addPoint(point, {
          uniqueId: _secondPointId9,
          connectionId: [currentShape.uniqueId]
        });
        currentShape.secondPointId = _secondPointId9;
        currentShape.connectionId.push(_secondPointId9);
      } else if (!pointOnGraph || currentShape.firstPointId === clickingOnExistingPointID) {
        localObj.mouseDown.lastShapeCompleted = false;
        dataAvailable = false;
      } else {
        point.connectionId.push(currentShape.uniqueId);
        currentShape.secondPointId = clickingOnExistingPointID;
        currentShape.connectionId.push(clickingOnExistingPointID);
        localObj.mouseDown.lastShapeCompleted = true;
      }
    } else if (_it === 'scale') {
      dataAvailable = true;
      value.x = scaleObj.x;
      value.y = scaleObj.y;
      value.xTo = scaleObj.xTo;
      value.yTo = scaleObj.yTo;
      dispatchEventScale();
    } else if ((_it === 'brush1' || _it === 'brush2' || _it === 'brush3') && currentShape) {
      if (currentShape.type === 'point' || currentShape.type === 'angle') {
        switch (_it) {
          case 'brush1':
            currentShape.fillColor = modelObj.shapes.brush1.color.stroke;
            currentShape.strokeColor = modelObj.shapes.brush1.color.stroke;
            break;

          case 'brush2':
            currentShape.fillColor = modelObj.shapes.brush2.color.stroke;
            currentShape.strokeColor = modelObj.shapes.brush2.color.stroke;
            break;

          case 'brush3':
            currentShape.fillColor = modelObj.shapes.brush3.color.stroke;
            currentShape.strokeColor = modelObj.shapes.brush3.color.stroke;
            break;
        }
      } else {
        switch (_it) {
          case 'brush1':
            currentShape.strokeColor = modelObj.shapes.brush1.color.stroke;
            break;

          case 'brush2':
            currentShape.strokeColor = modelObj.shapes.brush2.color.stroke;
            break;

          case 'brush3':
            currentShape.strokeColor = modelObj.shapes.brush3.color.stroke;
            break;
        }
      }

      localObj.mouseDown.lastShapeCompleted = true;
      localObj.mouseDown.isMouseDown = false;
      currentShape.isSelected = false;
      currentShape.isMouseDown = false;
      value.type = 'colour';
      value.shapeLabel = currentShape.label;
      value.color = currentShape.strokeColor;
      value.shapeId = currentShape.uniqueId;
      value.shapeType = currentShape.type;
      dataAvailable = true;
    } else if (_it === 'select' || _it === 'move' && localObj.mouseDown.objectDown) {
      dataAvailable = false;
      selectShape(e);
    } else if (_it === 'move' || _it === 'moveGraph') {
      dataAvailable = false;
    }

    updateAllShapes(e);
    updateAllShapes(e);
    dispatchData(value, dataAvailable);
  }

  function mirrorImage(a, b, c, x1, y1) {
    var temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b);
    var x = temp * a + x1;
    var y = temp * b + y1;
    return {
      x: x,
      y: y
    };
  }

  function dispatchData(value, dataAvailable) {
    var _it = modelObj.interactionType;

    if (value.uniqueId !== undefined) {
      var target = findShape(value.uniqueId);

      if (target.shape) {
        Object.keys(target.shape).forEach(function (i) {
          if (target.shape[i] !== undefined) {
            value[i] = target.shape[i];
          }
        });
      }
    }

    saveData();

    if (_it === 'select' || _it === 'move' && localObj.mouseDown.objectDown) {
      if (typeof events[_it] !== 'undefined') {
        events[_it]({
          id: modelObj.id,
          type: 'select'
        }, true);
      }
    } else if (dataAvailable) {
      localObj.mouseDown.lastShapeCompleted = true;
      localObj.newShapeStarted = false;
      localObj.currentUniqueId = null;
      value.newPlottedShapes = localObj.newPlottedShapes;
      value.step = modelObj.currentStep;
      dispatchEventCustom(value);
    }

    localObj.isLableSelected = false;
  }

  function computePerpBisector(perpShape, firstPoint, secondPoint, midPoint) {
    var value = {};
    var angle2Point = modelObj.LabComClass.Maths.getAngle(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y);
    perpShape.x = midPoint.x;
    perpShape.y = midPoint.y;
    perpShape.angle = angle2Point + Math.PI / 2;
    perpShape.point = modelObj.LabComClass.Maths.getPoint(midPoint, perpShape.angle, getPointUnitByPixelUnit(10)); // perpShape.two=modelObj.LabComClass.Maths.getPoint(midPoint,perpShape.angle,-10);

    value.x = midPoint.x;
    value.y = midPoint.y;
    value.xTo = perpShape.point.x;
    value.yTo = perpShape.point.y;
    value.uniqueId = perpShape.uniqueId;
    value.slope = isFinite(getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y)) ? getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y) : null;
    value.firstPoint = firstPoint;
    value.secondPoint = secondPoint;
    var perpLine = addNewShape({
      type: 'line',
      uniqueId: ++localObj.uniqueId,
      x: perpShape.point.x,
      y: perpShape.point.y,
      xTo: perpShape.x,
      yTo: perpShape.y,
      slope: getSlope(perpShape.point.x, perpShape.point.y, perpShape.x, perpShape.y)
    });
    localObj.newPlottedShapes.push(perpLine.uniqueId);
    return value;
  }

  function findCommon(seg1, seg2) {
    var arr = [];
    var commArr = [];
    Object.values(seg1).forEach(function (el) {
      arr.push(el);
    });
    Object.values(seg2).forEach(function (el) {
      arr.push(el);
    });

    for (var i = 0; i < arr.length; i++) {
      if (i % 2 === 0) {
        commArr.push(arr[i] + '/' + arr[i + 1]);
      }
    }

    var duplicates = [];
    var tempArray = [].concat(commArr).sort();

    for (var _i5 = 0; _i5 < tempArray.length; _i5++) {
      if (tempArray[_i5 + 1] === tempArray[_i5]) {
        duplicates.push(tempArray[_i5]);
      }
    }

    var cords = duplicates[0].split('/');
    return {
      x: cords[0],
      y: cords[1]
    }; // return duplicates;
  }

  function calculateBisector(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'point';
    var bisector = {};
    var firstSegment, secondSegment;

    if (mode === 'point') {
      firstSegment = computeSegment(_obj.firstPoint, _obj.secondPoint);
      secondSegment = computeSegment(_obj.secondPoint, _obj.thirdPoint);
    } else if (mode === 'segment') {
      firstSegment = _obj.firstSegment;
      secondSegment = _obj.secondSegment;
    }

    bisector.eqn = computeBisectorEqn(computeEqn(firstSegment), computeEqn(secondSegment), firstSegment, secondSegment);
    bisector.formEqn = computeSolvingEqn(bisector, secondSegment);
    bisector.x = bisector.formEqn.computeX;
    bisector.y = bisector.formEqn.computeY;

    if (mode === 'point') {
      bisector.bisectorLine = {
        type: 'line',
        x: _obj.secondPoint.x,
        y: _obj.secondPoint.y,
        xTo: bisector.x,
        yTo: bisector.y // yTo:angleB.y

      };
    } else if (mode === 'segment') {
      bisector.bisectorLine = {
        type: 'line',
        x: _obj.x,
        y: _obj.y,
        xTo: bisector.x,
        yTo: bisector.y // yTo:angleB.y

      };
    }

    return bisector;
  }

  function computeBisectorEqn(first, second, m1, m2) {
    // const first={a:4,b:-3,c:4}
    // const second={a:6,b:8,c:-9};
    if (first.c < 0 && second.c >= 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
    }

    if (first.c >= 0 && second.c < 0) {
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    if (first.c < 0 && second.c < 0) {
      first.a = -first.a;
      first.b = -first.b;
      first.c = -first.c;
      second.a = -second.a;
      second.b = -second.b;
      second.c = -second.c;
    }

    var simpF = {},
        simpS = {};
    var step1LHS = "(".concat(first.a, "x+").concat(first.b, "y+").concat(first.c, ")/").concat(Math.sqrt(first.a * first.a + first.b * first.b));
    simpF.a = first.a / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.b = first.b / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.c = first.c / Math.sqrt(first.a * first.a + first.b * first.b);
    simpF.form = "".concat(simpF.a, "x+").concat(simpF.b, "y+").concat(simpF.c);
    var step1RHS = "(".concat(second.a, "x+").concat(second.b, "y+").concat(second.c, ")/").concat(Math.sqrt(second.a * second.a + second.b * second.b));
    simpS.a = second.a / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.b = second.b / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.c = second.c / Math.sqrt(second.a * second.a + second.b * second.b);
    simpS.form = "".concat(simpS.a, "x+").concat(simpS.b, "y+").concat(simpS.c);
    var answer = {};
    answer.firstCase = {};
    answer.secondCase = {};
    answer.firstCase.b = simpF.b - simpS.b;
    answer.firstCase.a = simpF.a - simpS.a;
    answer.firstCase.c = simpF.c - simpS.c;
    answer.secondCase.a = simpF.a + simpS.a;
    answer.secondCase.b = simpF.b + simpS.b;
    answer.secondCase.c = simpF.c + simpS.c;
    answer.required = {};
    var correctAnswer = checkAnswerCaseNew(first, second, answer.firstCase, answer.secondCase, m1, m2);
    answer.required = correctAnswer;
    return answer.required;
  }

  function checkAnswerCaseNew(segment1, segment2, firstCase, secondCase, m1, m2) {
    //a1a2+b1b2;
    var answer1 = findRatio(segment1, segment2, m1, m2);
    var product = {};
    var angle = answer1.degree;

    if (answer1.degree >= 270) {
      angle = answer1.degree - 270;
    }

    product.main = segment1.a * segment2.a + segment1.b * segment2.b;

    if (angle > 0 && angle < 90 && product.main < 0) {
      return firstCase;
    } else if (angle > 90 && product.main < 0) {
      return secondCase;
    } else if (angle > 90 && product.main > 0) {
      return firstCase;
    } else if (angle > 0 && angle < 90 && product.main > 0) {
      return secondCase;
    } else if (product.main === 0) {
      return secondCase;
    }
  }

  function findRatio(segment1, segment2, main1, main2) {
    var tangent = {};
    var angle = {};
    tangent.m1 = -(segment1.a / segment1.b);
    tangent.m2 = -(segment2.a / segment2.b);
    tangent.ratio = Math.abs((tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2));
    tangent.angle = Math.atan(tangent.ratio);
    tangent.degree = tangent.angle * (180 / Math.PI);
    tangent.obtuseAngle = Math.atan(-(tangent.m1 - tangent.m2) / (1 + tangent.m1 * tangent.m2)) * (180 / Math.PI);
    tangent.tanTheta = (segment2.a * segment1.b - segment1.a * segment2.b) / (segment2.a * segment1.a + segment2.b * segment1.b);
    tangent.degSlope = Math.atan(tangent.tanTheta) * (180 / Math.PI);
    angle.startAngle = modelObj.LabComClass.Maths.getAngle(main1.xTo, main1.yTo, main1.x, main1.y);
    angle.endAngle = modelObj.LabComClass.Maths.getAngle(main2.x, main2.y, main2.xTo, main2.yTo);
    angle.angleRad = angle.startAngle - angle.endAngle;
    angle.angleS = angle.angleRad * 180 / Math.PI;

    if (angle.angleRad < 0) {
      angle.scene = 1;
      angle.degree = angle.angleRad * -1 * 180 / Math.PI;
    } else if (angle.angleRad > 0) {
      angle.scene = 2;
      angle.degree = 360 - angle.angleRad * 180 / Math.PI;
    }

    return angle;
  }

  function computeSolvingEqn(_obj, segment2) {
    var eqn = {};

    if (segment2.x === localObj.arbitaryX || segment2.xTo === localObj.arbitaryX) {
      localObj.arbitaryX = localObj.arbitaryX + 1;
    }

    eqn.eqn = "".concat(_obj.eqn.a, "x +").concat(_obj.eqn.b, "y +").concat(_obj.eqn.c);
    eqn.calcY = "y=(".concat(-_obj.eqn.a, "x + ").concat(-_obj.eqn.c, ")/").concat(_obj.eqn.b);
    eqn.computeY = (-_obj.eqn.a * localObj.arbitaryX + -_obj.eqn.c) / _obj.eqn.b;
    eqn.computeX = localObj.arbitaryX;

    if (!isFinite(eqn.computeY)) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    if (Math.trunc(_obj.eqn.b * 100) == 0) {
      eqn.computeX = segment2.x;
      eqn.computeY = 0;
    }

    return eqn;
  }

  function computeEqn(segment) {
    var eqn = {};
    eqn.segment = segment.label;
    eqn.slope = isFinite(getSlope(segment.x, segment.y, segment.xTo, segment.yTo)) ? getSlope(segment.x, segment.y, segment.xTo, segment.yTo) : undefined;

    if (eqn.slope !== undefined) {
      eqn.eqn = "y-".concat(segment.y, "=").concat(eqn.slope, "*(x-").concat(segment.x, ")");
      eqn.b = 1;
      eqn.a = -eqn.slope;
      eqn.c = eqn.slope * segment.x - segment.y;
      eqn.cMod = Math.abs(eqn.slope * segment.x - segment.y);
      eqn.form = "y+".concat(eqn.a, "x+").concat(eqn.c);
    } else {
      eqn.eqn = "x=".concat(segment.x);
      eqn.form = "x-".concat(segment.x);
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -segment.x;
      eqn.cMod = Math.abs(-segment.x);
    }

    return eqn;
  }

  function computeSegment(firstPoint, secondPoint) {
    var segment = {};
    segment.x = firstPoint.x;
    segment.y = firstPoint.y;
    segment.xTo = secondPoint.x;
    segment.yTo = secondPoint.y;

    if (firstPoint.label && secondPoint.label) {
      segment.label = firstPoint.label + secondPoint.label;
    }

    return segment;
  }

  function computeCircle(_obj) {
    // Calculate Center and Raduis
    // Logic Here
    // Mid Point
    var fp = _obj.firstPoint;
    var sp = _obj.secondPoint;
    var tp = _obj.thirdPoint;
    var cData = circle3Handler(fp, sp, tp);
    return {
      r: cData.r,
      x: cData.x,
      y: cData.y
    };
  }

  function calculateAngle(_obj) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "angle";
    var firstPoint = _obj.firstPoint,
        secondPoint = _obj.secondPoint,
        thirdPoint = _obj.thirdPoint;
    var startAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, firstPoint.x, firstPoint.y);
    var endAngle = modelObj.LabComClass.Maths.getAngle(secondPoint.x, secondPoint.y, thirdPoint.x, thirdPoint.y);
    var angle = startAngle - endAngle;

    if (angle < 0) {
      angle = angle * -1 * 180 / Math.PI;
    } else if (angle > 0) {
      angle = 360 - angle * 180 / Math.PI;
    }

    var angleText;

    if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === 'angle') {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label, "=").concat(Math.round(angle), "\xB0");
    } else if ((firstPoint === null || firstPoint === void 0 ? void 0 : firstPoint.label) && (secondPoint === null || secondPoint === void 0 ? void 0 : secondPoint.label) && (thirdPoint === null || thirdPoint === void 0 ? void 0 : thirdPoint.label) && mode === 'angleRay') {
      angleText = "\xA7a  ".concat(firstPoint.label).concat(secondPoint.label).concat(thirdPoint.label);
    } else if (mode === 'angle') {
      angleText = "".concat(Math.round(angle), "\xB0");
    } else if (mode === 'angleRay') {
      angleText = "";
    }

    return {
      angleText: angleText,
      angle: angle,
      angleValue: Math.round(angle),
      startAngle: startAngle,
      endAngle: endAngle
    };
  }

  function checkDataAvailable(target, keys) {
    // eslint-disable-next-line consistent-return
    for (var i = 0; i < keys.length; i++) {
      if (target[keys[i]] === null || isNaN(target[keys[i]])) {
        return false;
      }
    }

    return true;
  }

  function checkPoint(_obj) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d = modelObj.interactionElements[i];

      if (_d.type === 'point') {
        newDist = modelObj.LabComClass.Maths.getDistance(_obj, _d);
      }

      if (dist === null && newDist !== null || dist !== null && newDist < dist) {
        dist = newDist;
        index = i;
      }
    }

    if (index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      localObj.mouseDown.objectDown = true;
      return index;
    }

    return null;
  }

  function isItCloseToPlotedPoint(point, avoidCurrentPoint) {
    var dist = null,
        newDist = null,
        index = null;

    for (var i = modelObj.interactionElements.length - 1; i >= 0; i--) {
      var _d = modelObj.interactionElements[i];

      if (!avoidCurrentPoint || _d.uniqueId !== localObj.currentUniqueId || modelObj.interactionType === 'move' && _d.uniqueId !== localObj.currentUniqueId) {
        if (_d.type === 'point' && _d.visible) {
          newDist = modelObj.LabComClass.Maths.getDistance(point, _d);
        } else {
          newDist = null;
        }

        if (newDist !== null && (dist === null || newDist < dist)) {
          dist = newDist;
          index = i;
        }
      }
    } //pass mai konsa hai uska dist and index dega


    if (newDist !== null && index !== null && dist < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
      return {
        dist: dist,
        index: index,
        plotedPoint: modelObj.interactionElements[index]
      };
    }

    return null;
  }

  function isItCloseToParameterPoint(point) {
    var dist = null,
        newDist = null;
    var _modelObj$LabComClass2 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass2.getDistance,
        getPoint = _modelObj$LabComClass2.getPoint,
        getAngle = _modelObj$LabComClass2.getAngle,
        pointInSegment = _modelObj$LabComClass2.pointInSegment,
        getLineintersect = _modelObj$LabComClass2.getLineintersect,
        getPointLineDistance = _modelObj$LabComClass2.getPointLineDistance;
    var intersectionP = null;

    for (var i = 0; i < modelObj.interactionElements.length - 1; i++) {
      var shape = modelObj.interactionElements[i];

      if (shape.type !== 'point') {
        if (checkType(shape, localObj.lineTypes)) {
          var distFromLine = getPointLineDistance(point, shape, {
            x: shape.xTo,
            y: shape.yTo
          });
          newDist = Math.abs(distFromLine);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            var lineAngle = getAngle(shape.x, shape.y, shape.xTo, shape.yTo);
            var point2 = getPoint(point, lineAngle + Math.PI / 2, 2);
            var intersection = getLineintersect(shape.x, shape.y, shape.xTo, shape.yTo, point.x, point.y, point2.x, point2.y);
            var shapeLength = getDistance(shape, {
              x: shape.xTo,
              y: shape.yTo
            });
            var intersectionDist = getDistance(shape, intersection);
            var percentage = intersectionDist / shapeLength;
            var pointAngle = getAngle(shape.x, shape.y, intersection.x, intersection.y);
            var pointAccepted = true;

            if (shape.type.includes('segment')) {
              var isInSegment = pointInSegment(intersection, shape, {
                x: shape.xTo,
                y: shape.yTo
              });

              if (!isInSegment) {
                pointAccepted = false;
              }
            }

            if (shape.type === 'ray') {
              var _isInSegment = pointInSegment(intersection, shape, {
                x: shape.xOr,
                y: shape.yOr
              });

              if (!_isInSegment) {
                pointAccepted = false;
              }
            }

            if (pointAccepted) {
              dist = newDist;

              if (checkDataAvailable(intersection, ['x', 'y'])) {
                intersectionP = intersection;
                intersectionP.dist = dist;
                intersectionP.updateKeys = {
                  x: intersectionP.x,
                  y: intersectionP.y,
                  line: shape.uniqueId,
                  pointAngle: Math.round(pointAngle) === Math.round(lineAngle),
                  percentage: percentage,
                  isParameter: true
                };
              }
            }
          }
        }

        if (shape.type === 'circle' || shape.type === 'compass') {
          var distFromCenter = getDistance(shape, point);
          newDist = Math.abs(distFromCenter - shape.r);

          if ((dist === null || newDist < dist) && newDist < getPointUnitByPixelUnit(10)) {
            dist = newDist;
            var angle = getAngle(shape.x, shape.y, point.x, point.y);
            intersectionP = getPoint(shape, angle, shape.r);

            if (checkDataAvailable(intersectionP, ['x', 'y'])) {
              intersectionP.dist = dist;
              intersectionP.updateKeys = {
                x: intersectionP.x,
                y: intersectionP.y,
                circle: shape.uniqueId,
                angle: angle,
                isParameter: true
              };
            } else {
              intersectionP = null;
            }
          }
        }
      }
    }

    return intersectionP;
  }

  function isItCloseToIntersectionPoint(point) {
    var dist = null,
        newDist = null;
    var shapesData = modelObj.interactionElements;
    var intersectionP = null;

    for (var i = 0; i < shapesData.length - 1; i++) {
      var firstShape = shapesData[i];

      if (firstShape.type !== 'point') {
        for (var j = i + 1; j < shapesData.length; j++) {
          var secondShape = shapesData[j];

          if (secondShape.type !== 'point') {
            if (checkType(firstShape, localObj.lineTypes) && checkType(secondShape, localObj.lineTypes) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var data = getInteractionOfTwoLines(firstShape, secondShape, point);

              if (data !== null) {
                if (data.dist < dist || dist === null) {
                  newDist = data.dist;
                  dist = data.dist;
                  intersectionP = data;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    l1: firstShape.uniqueId,
                    l2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if ((checkType(firstShape, localObj.lineTypes) && checkType(secondShape, ['circle', 'compass']) || checkType(secondShape, localObj.lineTypes) && checkType(firstShape, ['circle', 'compass'])) && localObj.uniqueId !== firstShape.uniqueId && localObj.uniqueId !== secondShape.uniqueId) {
              var circleShape = void 0,
                  lineShape = void 0;

              if (firstShape.type === 'circle' || firstShape.type === 'compass') {
                circleShape = firstShape;
                lineShape = secondShape;
              } else {
                circleShape = secondShape;
                lineShape = firstShape;
              }

              var _data3 = getInteractionOfCircleLine(circleShape, lineShape, point, modelObj.snappingDiff);

              if (_data3 !== null) {
                if (_data3.dist < dist || dist === null) {
                  newDist = _data3.dist;
                  dist = _data3.dist;
                  intersectionP = _data3;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    circle: circleShape.uniqueId,
                    line: lineShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            } else if (checkType(firstShape, ['circle', 'compass']) && checkType(secondShape, ['circle', 'compass']) && firstShape.visible == false && secondShape.visible == false) {
              var _data4 = getInteractionOfTwoCircles(firstShape, secondShape, point, modelObj.snappingDiff, false);

              if (_data4) {
                if (_data4.dist < dist || dist === null) {
                  newDist = _data4.dist;
                  dist = _data4.dist;
                  intersectionP = _data4;
                  intersectionP.updateKeys = {
                    x: intersectionP.x,
                    y: intersectionP.y,
                    intersectAngle: intersectionP.angle1,
                    circle1: firstShape.uniqueId,
                    circle2: secondShape.uniqueId,
                    isIntersection: true
                  };
                }
              }
            }
          }
        }
      }
    }

    return intersectionP;
  }

  function checkType(shape, types) {
    return types.includes(shape.type);
  }

  function getInteractionOfTwoCircles(circle1, circle2, point, snapDiff) {
    var intersection = modelObj.LabComClass.Maths.getIntersectOfTwoCircles(circle1.x, circle1.y, circle1.r, circle2.x, circle2.y, circle2.r);

    if (intersection.length > 1) {
      var getDist = function getDist(p1, p2) {
        var dist = modelObj.LabComClass.Maths.getDistance(p1, point);

        if (snapDiff !== false) {
          if (dist <= getPointUnitByPixelUnit(snapDiff)) {
            p1.dist = dist;
            var centerPointsLine = new modelObj.LabComClass.Vector(circle2.x - circle1.x, circle2.y - circle1.y);
            var firstIntersectLine = new modelObj.LabComClass.Vector(p1.x - circle1.x, p1.y - circle1.y);
            p1.angle = centerPointsLine.crossProduct(firstIntersectLine).z;
            return dist;
          }

          return null;
        }

        p1.angle1 = modelObj.LabComClass.Maths.getAngle(circle1.x, circle1.y, p1.x, p1.y);
        p1.dist = dist;
        return dist;
      };

      var acceptedIntersections = [];
      var p = getDist(intersection[0], intersection[1]);

      if (p !== null) {
        acceptedIntersections.push(intersection[0]);
      }

      p = getDist(intersection[1], intersection[0]);

      if (p !== null) {
        acceptedIntersections.push(intersection[1]);
      }

      if (acceptedIntersections.length) {
        var lowestIndex = 0;
        var closeDist = acceptedIntersections[0].dist;

        for (var i = 0; i < acceptedIntersections.length; i++) {
          if (acceptedIntersections[i].dist < closeDist) {
            closeDist = acceptedIntersections[i].dist;
            lowestIndex = i;
          }
        }

        return acceptedIntersections[lowestIndex];
      }

      return null;
    }

    return null;
  }

  function getInteractionOfCircleLine(circle, line, point, snapDiff) {
    var lineData = {
      x: line.x,
      y: line.y,
      xTo: line.xTo,
      yTo: line.yTo
    };

    if (line.type === 'ray') {
      lineData.xTo = line.xOr;
      lineData.yTo = line.yOr;
    }

    var intersection = findCircleLineIntersect(circle, lineData);

    if (intersection.p1 || intersection.p2) {
      var getDist = function getDist(p) {
        if ((line.type.includes('segment') || line.type === 'ray') && !p.isInSegment) {
          return null;
        }

        var dist = modelObj.LabComClass.Maths.getDistance(p, point);

        if (snapDiff !== undefined) {
          if (dist < getPointUnitByPixelUnit(snapDiff)) {
            p.dist = dist;
            return dist;
          }

          return null;
        }

        p.dist = dist;
        return dist;
      };

      var distP1 = null,
          distP2 = null;
      distP1 = getDist(intersection.p1);
      distP2 = getDist(intersection.p2);

      if (distP1 !== null && distP2 !== null) {
        if (distP1 < distP2) {
          return intersection.p1;
        }

        return intersection.p2;
      }

      if (distP1 !== null) {
        return intersection.p1;
      }

      if (distP2 !== null) {
        return intersection.p2;
      }

      return null;
    }

    return null;
  }

  function getInteractionOfTwoLines(l1, l2, point) {
    var intersection = modelObj.LabComClass.Maths.getLineintersect(l1.x, l1.y, l1.xTo, l1.yTo, l2.x, l2.y, l2.xTo, l2.yTo);

    if (intersection) {
      if (l1.type.includes('segment') && !intersection.onLine1 || l2.type.includes('segment') && !intersection.onLine2) {
        return null;
      }

      var distance = modelObj.LabComClass.Maths.getDistance(intersection, point);

      if (distance < getPointUnitByPixelUnit(10)) {
        intersection.dist = distance;
        return intersection;
      }

      return null;
    }

    return null;
  }

  function selectShapeBrush(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    } // if (index === null || modelObj.ignorePointToColor) {


    if (index === null) {
      dist = null;
      newDist = null;
      index = null;

      for (var i = 0; i < shapesData.length; i++) {
        var _d = shapesData[i];

        if (_d.type === 'circle' || _d.type === 'compass') {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === 'line' || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        } else if (_d.type.includes('segment') || _d.type === 'ray') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        } else if (_d.type === 'angle' && _d.visible) {
          var angleWithPoint = modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI < 0 ? 360 + modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI : modelObj.LabComClass.Maths.getAngle(_d.x, _d.y, p.x, p.y) * 180 / Math.PI;

          if (_d.angleStart < _d.angleEnd && angleWithPoint >= _d.angleStart && angleWithPoint <= _d.angleEnd && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          } else if (_d.angleStart > _d.angleEnd && (angleWithPoint >= _d.angleStart && angleWithPoint <= 360 || angleWithPoint >= 0 && angleWithPoint <= _d.angleEnd) && modelObj.LabComClass.Maths.getDistance(p, _d) < getPointUnitByPixelUnit(20)) {
            newDist = 0;
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i6 = 0; _i6 < shapesData.length; _i6++) {
      var _d6 = shapesData[_i6];
      var calculated = false;

      if (_d6.label !== undefined) {
        var label = getPixelByPoint(_d6.labelX, _d6.labelY);
        label.x += Number(_d6.labelDiffX);
        label.y += Number(_d6.labelDiffY);
        var w = ctx.measureText(_d6.label).width;

        if (_d6.labelAlign && _d6.labelAlign === 'center') {
          if (pxl.x > label.x - w / 2 - 5 && pxl.x < label.x + w / 2 + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5 && _d6.type !== 'segment') {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 5 && pxl.x < label.x + w + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5 && _d6.type !== 'angle' && _d6.type !== 'segment' && _d6.type !== 'point') {
          newDist = 0;
          calculated = true;
        } // else if (pxl.x > (label.x - 10) && pxl.x < (label.x + w + 10) && pxl.y > (label.y - modelObj.fontSize * 1) && pxl.y < (label.y + 10) && _d.type === 'angle' && _d.toColor) {
        //   newDist = 0;
        //   calculated = true;
        // }

      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated) {
        dist = Math.abs(newDist);
        index = _i6;
        labelId = _i6;
      }
    }

    ctx.closePath();
    ctx.restore(); // console.log('Touched',labelId,index,shapesData[index].label);

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === 'move') {
            for (var _i7 = 0; _i7 < shapesData.length; _i7++) {
              shapesData[_i7].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
        }
      }
    }

    return null;
  }

  function selectShape(e) {
    var shapesData = modelObj.interactionElements; // select shape

    var dist = null,
        newDist = null,
        index = null;
    var p = getPointByPixel(e.pageX, e.pageY);
    var pxl = {
      x: e.pageX,
      y: e.pageY
    };
    var data = isItCloseToPlotedPoint(p, false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;

      for (var i = 0; i < shapesData.length; i++) {
        var _d = shapesData[i];

        if (_d.type === 'circle' || _d.type === 'compass') {
          newDist = modelObj.LabComClass.Maths.getDistance(p, _d) - _d.r;
        } else if (_d.type === 'line' || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        } else if (_d.type.includes('segment') || _d.type === 'ray') {
          newDist = modelObj.LabComClass.Maths.getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = modelObj.LabComClass.Maths.getDistance(p, _d);
            var endPointDist = modelObj.LabComClass.Maths.getDistance(p, endPoint);
            var length = modelObj.LabComClass.Maths.getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = Math.abs(newDist);
          index = i;
        }
      }
    }

    newDist = null;
    var ctx = modelObj.context;
    ctx.save();
    ctx.beginPath();
    ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;
    ctx.textBaseline = 'bottom';
    var labelId = null;

    for (var _i8 = 0; _i8 < shapesData.length; _i8++) {
      var _d7 = shapesData[_i8];
      var calculated = false;

      if (_d7.label !== undefined) {
        var label = getPixelByPoint(_d7.labelX, _d7.labelY);
        label.x += Number(_d7.labelDiffX);
        label.y += Number(_d7.labelDiffY);
        var w = ctx.measureText(_d7.label).width;

        if (_d7.labelAlign && _d7.labelAlign === 'center') {
          if (pxl.x > label.x - w / 2 - 5 && pxl.x < label.x + w / 2 + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5) {
            newDist = 0;
            calculated = true;
          }
        } else if (pxl.x > label.x - 5 && pxl.x < label.x + w + 5 && pxl.y > label.y - modelObj.fontSize * 1.5 && pxl.y < label.y + 5 && _d7.type !== 'angle') {
          newDist = 0;
          calculated = true;
        } else if (pxl.x > label.x - 10 && pxl.x < label.x + w + 10 && pxl.y > label.y - modelObj.fontSize * 1 && pxl.y < label.y + 10 && _d7.type === 'angle' && _d7.visible) {
          newDist = 0;
          calculated = true;
        }
      }

      if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) <= Math.abs(dist) && calculated) {
        dist = Math.abs(newDist);
        index = _i8;
        labelId = _i8;
      }
    }

    ctx.closePath();
    ctx.restore();

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      if (e.type === 'mousedown') {
        localObj.mouseDown.objectDown = true;

        if (!shapesData[index].isSelected) {
          if (modelObj.interactionType === 'move') {
            for (var _i9 = 0; _i9 < shapesData.length; _i9++) {
              shapesData[_i9].isSelected = false;
            }
          }

          shapesData[index].isSelected = true;
          shapesData[index].isMouseDown = true;
        } else {
          shapesData[index].isMouseDown = false;
        }

        if (labelId === index) {
          localObj.isLableSelected = true;
        }

        return shapesData[index].uniqueId;
      } // mouse up


      if (shapesData[index].isSelected && !shapesData[index].isMouseDown) {
        if (e.pageX === localObj.mouseDown.orignalX && e.pageY === localObj.mouseDown.orignalY) {
          shapesData[index].isSelected = false;
        }
      }
    }

    return null;
  }

  function isOnShape(e) {
    // select shape
    var dist = null,
        newDist = null,
        index = null;
    var _modelObj$LabComClass3 = modelObj.LabComClass.Maths,
        getDistance = _modelObj$LabComClass3.getDistance,
        getPointLineDistance = _modelObj$LabComClass3.getPointLineDistance;
    var data = isItCloseToPlotedPoint(getPointByPixel(e.pageX, e.pageY), false);

    if (data) {
      dist = data.dist;
      index = data.index;
    }

    if (index === null) {
      dist = null;
      newDist = null;
      index = null;
      var p = getPointByPixel(e.pageX, e.pageY);
      modelObj.interactionElements.forEach(function (_d, i) {
        if (_d.type === 'circle' || _d.type === 'compass') {
          newDist = getDistance(p, _d) - _d.r;
        }

        if (_d.type === 'line' || _d.type === 'perpendicularLine' || _d.type === 'parallelLine') {
          newDist = getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });
        }

        if (_d.type.includes('segment') || _d.type === 'ray') {
          newDist = getPointLineDistance(p, _d, {
            x: _d.xTo,
            y: _d.yTo
          });

          if (Math.abs(newDist) < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d.xTo,
              y: _d.yTo
            };

            if (_d.type === 'ray') {
              endPoint = {
                x: _d.xOr,
                y: _d.yOr
              };
            }

            var startPointDist = getDistance(p, _d);
            var endPointDist = getDistance(p, endPoint);
            var length = getDistance(_d, endPoint);

            if (!(startPointDist <= length && endPointDist <= length)) {
              newDist = null;
            }
          }
        }

        if (dist === null && newDist !== null || dist !== null && newDist !== null && Math.abs(newDist) < Math.abs(dist)) {
          dist = newDist;
          index = i;
        }
      });
    }

    if (index !== null && Math.abs(dist) < getPointUnitByPixelUnit(10)) {
      return modelObj.interactionElements[index].uniqueId;
    }

    return null;
  }

  function getPLine(e, isPerpendicular) {
    var point = getPointByPixel(e.pageX, e.pageY);
    var data = {
      visible: true,
      x: point.x,
      y: point.y,
      xOr: point.x,
      yOr: point.y,
      xTo: point.x,
      yTo: point.y,
      xOrTo: point.x,
      yOrTo: point.y,
      slope: 0,
      distance: null
    };

    for (var i = 0; i < modelObj.interactionElements.length; i++) {
      var _d8 = modelObj.interactionElements[i];

      if (checkType(_d8, localObj.lineTypes) && _d8.uniqueId !== localObj.currentUniqueId) {
        var distance = getPointLineDistance({
          x: data.x,
          y: data.y
        }, {
          x: _d8.x,
          y: _d8.y
        }, {
          x: _d8.xTo,
          y: _d8.yTo
        });
        distance = Math.abs(distance);

        if (_d8.type.includes('segment') || _d8.type === 'ray') {
          if (distance < getPointUnitByPixelUnit(10)) {
            var endPoint = {
              x: _d8.xTo,
              y: _d8.yTo
            };

            if (_d8.type === 'ray') {
              endPoint = {
                x: _d8.xOr,
                y: _d8.yOr
              };
            }

            if (!modelObj.LabComClass.Maths.pointInSegment(point, _d8, endPoint)) {
              continue;
            }
          } else {
            continue;
          }
        }

        if (data.distance === null || data.distance > distance) {
          data.distance = distance;
          data.line = _d8.uniqueId;
          data.slope = modelObj.LabComClass.Maths.getAngle(_d8.x, _d8.y, _d8.xTo, _d8.yTo);

          if (isPerpendicular) {
            data.slope += Math.PI / 2;
          }

          var newP = modelObj.LabComClass.Maths.getPoint({
            x: data.x,
            y: data.y
          }, data.slope, 10);
          data.xTo = newP.x;
          data.yTo = newP.y;
        }
      }
    }

    if (data.distance !== null && data.distance < getPointUnitByPixelUnit(10)) {
      return data;
    }

    return false;
  }

  function getPointLineDistance(_pt, _line1, _line2) {
    var _dist = modelObj.LabComClass.Maths.getDistance(_line1, _line2);

    var _ans = 0;

    if (_dist > 0) {
      var _num = (_line2.x - _line1.x) * (_line1.y - _pt.y) - (_line2.y - _line1.y) * (_line1.x - _pt.x);

      _ans = _num / _dist;
    }

    return _ans;
  }

  function collinear(p1, p2, p3) {
    var roundOff = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var a = (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2;

    if (Math.round(Math.abs(a)) == 0 && roundOff) {
      return {
        collinear: true,
        value: Math.round(Math.abs(a))
      };
    } else if (Math.abs(a) == 0 && !roundOff) {
      return {
        collinear: true,
        value: Math.abs(a)
      };
    } else {
      return {
        collinear: false,
        value: a
      };
    }
  }

  function angleDirection(p1, p2, p3, p4) {
    if (p1.y < p4.y && p1.y < p3.y && p2.y < p4.y && p2.y < p3.y) {
      return true;
    } else if (p1.y > p4.y && p1.y > p3.y && p2.y > p4.y && p2.y > p3.y) {
      return false;
    }
  }

  function updatePoints(shape) {
    if (shape.label) {
      // const p = findLableByPoint(shape);
      shape.labelX = shape.x;
      shape.labelY = shape.y;
      var minCordinates = getPointByPixel(modelObj.x, modelObj.y + modelObj.height);
      var maxCordinates = getPointByPixel(modelObj.x + modelObj.width, modelObj.y);
      var minX = minCordinates.x,
          minY = minCordinates.y,
          maxX = maxCordinates.x,
          maxY = maxCordinates.y;

      if (shape.shapeType) {
        switch (shape.shapeType) {
          case 'rhombus':
            var pointsTotal = modelObj.interactionElements.filter(function (el) {
              return el.type === 'point';
            });
            var segmentsTotal = modelObj.interactionElements.filter(function (el) {
              return el.type === 'segment';
            }); //Point Id-Label 1-A,2-B,3-C,4-D
            // If A Point is Dragged.

            if (shape.label === 'A' && shape.shapeType === 'rhombus' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var fixPoint = findShape(shape.pointFix).shape; //Shape has connected pt attribute which mentions the points to be moved along with the dragged point

              shape.connectedPoints.forEach(function (pointId) {
                var point = findShape(pointId).shape;

                if (pointId === 2 && localObj.cOnBound !== 3) {
                  // Angle the angle alpha.
                  var angleBet2Points = modelObj.LabComClass.Maths.getAngle(fixPoint.x, fixPoint.y, shape.x, shape.y) - modelObj.LabComClass.Maths.getAngle(fixPoint.x, fixPoint.y, pointsTotal[2].x, pointsTotal[2].y); // Diagnol Dist is calculated.

                  var fDist = Math.cos(angleBet2Points / 2) * modelObj.LabComClass.Maths.getDistance(fixPoint, shape); // New point is calculated wrt to FixPoint D.

                  var newPoint = modelObj.LabComClass.Maths.getPoint(fixPoint, angleBet2Points / 2 + modelObj.LabComClass.Maths.getAngle(fixPoint.x, fixPoint.y, pointsTotal[2].x, pointsTotal[2].y), fDist * 2); // Checks if new point is on boundary or not

                  localObj.cOnBound = onScreen(newPoint) ? false : pointId;
                  var onBound = outScreen(newPoint);

                  if (localObj.cOnBound) {
                    //If OutBound is left or Right then 'x' cords are changed to maxX or minX accordingly.
                    if (onBound.out === 'right' || onBound.out === 'left') {
                      point.x = onBound.out === 'right' ? maxX : minX;
                    } //If OutBound is up or down then 'y' cords are changed to maxY or minY accordingly.
                    else if (onBound.out === 'up' || onBound.out === 'down') {
                        point.y = onBound.out === 'up' ? maxY : minY;
                      }

                    localObj.cOnBound = pointId;
                    var pointC = pointsTotal[2]; // Angle Gama

                    var angleAtC = findShape(pointC.aId).shape; //Angle Delta

                    var angleAtD = Math.PI - angleAtC.angleValue * Math.PI / 180; // Angle B/w diagnol is calculated.

                    var angleBetDig = modelObj.LabComClass.Maths.getAngle(fixPoint.x, fixPoint.y, point.x, point.y);
                    var finalAngle = angleBetDig - angleAtD / 2;
                    var side = (modelObj.LabComClass.Maths.getDistance(pointC, point) + modelObj.LabComClass.Maths.getDistance(pointC, fixPoint)) / 2; // Pt A is calculated.

                    var newMovPoint = modelObj.LabComClass.Maths.getPoint(fixPoint, finalAngle, side);
                    shape.x = newMovPoint.x;
                    shape.y = newMovPoint.y;
                    var newMovPointV2 = modelObj.LabComClass.Maths.getPoint(pointsTotal[4], modelObj.LabComClass.Maths.getAngle(pointsTotal[4].x, pointsTotal[4].y, pointC.x, pointC.y) + Math.PI, modelObj.LabComClass.Maths.getDistance(pointsTotal[4], pointC));
                    shape.x = newMovPointV2.x;
                    shape.y = newMovPointV2.y;
                    shape.labelX = shape.x;
                    shape.labelY = shape.y;
                  } else {
                    // If all points are inside.
                    point.x = newPoint.x;
                    point.y = newPoint.y;
                    localObj.cOnBound = false;
                    shape.isDraggable = true;
                    point.labelX = point.x;
                    point.labelY = point.y;
                  }
                } else if (pointId === 3 && localObj.cOnBound !== 2) {
                  // Angle b/2 fixPoint D and C.
                  var _angleBet2Points2 = modelObj.LabComClass.Maths.getAngle(fixPoint.x, fixPoint.y, pointsTotal[2].x, pointsTotal[2].y); // New Point calculated wrt to Fix pt D.


                  var _newPoint4 = modelObj.LabComClass.Maths.getPoint(fixPoint, _angleBet2Points2, modelObj.LabComClass.Maths.getDistance(fixPoint, shape)); // Checks if Newpoint is outside graph.


                  localObj.cOnBound = onScreen(_newPoint4) ? false : pointId;

                  var _onBound = outScreen(_newPoint4);

                  if (localObj.cOnBound) {
                    // //If OutBound is left or Right then 'x' cords are changed to maxX or minX accordingly.
                    var offSet = 0; //0.13

                    if (_onBound.out === 'right' || _onBound.out === 'left') {
                      point.x = _onBound.out === 'right' ? maxX - offSet : minX + offSet;
                    } //If OutBound is up or down then 'y' cords are changed to maxY or minY accordingly.
                    else if (_onBound.out === 'up' || _onBound.out === 'down') {
                        point.y = _onBound.out === 'up' ? maxY - offSet : minY + offSet;
                      }

                    localObj.cOnBound = pointId;

                    var _side2 = modelObj.LabComClass.Maths.getDistance(fixPoint, point); // Gama Angle


                    var gamaAngle = findShape(point.aId).shape;
                    var delAngle = findShape(pointsTotal[3].aId).shape; // Angle At D

                    var angleAtFixPoint = Math.PI - gamaAngle.angleValue * Math.PI / 180; // New Point A is calculated.

                    var angle = modelObj.LabComClass.Maths.getAngle(fixPoint.x, fixPoint.y, point.x, point.y) - delAngle.angleValue * Math.PI / 180; // const newMovPoint = modelObj.LabComClass.Maths.getPoint(fixPoint,angle,side);
                    // const newMovPoint = modelObj.LabComClass.Maths.getPoint(fixPoint,-angleAtFixPoint,side);
                    // shape.x = newMovPoint.x;
                    // shape.y = newMovPoint.y;
                    // shape.labelX = shape.x;
                    // shape.labelY = shape.y;
                    // console.log('N<P',newMovPoint);

                    var _pointC = pointsTotal[2]; // const dist = (2 * )

                    var _newMovPointV = modelObj.LabComClass.Maths.getPoint(pointsTotal[4], modelObj.LabComClass.Maths.getAngle(pointsTotal[4].x, pointsTotal[4].y, _pointC.x, _pointC.y) + Math.PI, modelObj.LabComClass.Maths.getDistance(pointsTotal[4], _pointC));

                    shape.x = _newMovPointV.x;
                    shape.y = _newMovPointV.y;
                    shape.labelX = shape.x;
                    shape.labelY = shape.y; // const pointB = pointsTotal[1];
                    // const angleDC = modelObj.LabComClass.Maths.getAngle(fixPoint.x,fixPoint.y,point.x,point.y);
                    // const distDC = modelObj.LabComClass.Maths.getDistance(fixPoint,point);
                    // const newPointB = modelObj.LabComClass.Maths.getPoint(shape,angleDC,distDC);
                    // console.log(newPointB);
                    // pointB.x = newPointB.x;
                    // pointB.y = newPointB.y;
                    // pointB.labelX = pointB.x;
                    // pointB.labelY = pointB.y;
                  } else {
                    // If all the points are inside graph.
                    point.x = _newPoint4.x;
                    point.y = _newPoint4.y;
                    localObj.cOnBound = false;
                    shape.isDraggable = true;
                  }

                  point.labelX = point.x;
                  point.labelY = point.y;
                }

                if (point.label === 'B') {
                  var pointE = findShape(11).shape;
                  var newPointE = modelObj.LabComClass.Maths.getPoint(fixPoint, modelObj.LabComClass.Maths.getAngle(fixPoint.x, fixPoint.y, point.x, point.y), modelObj.LabComClass.Maths.getDistance(fixPoint, point) / 2);
                  pointE.x = newPointE.x;
                  pointE.y = newPointE.y;
                } else if (point.label === 'C') {// const segAC = segmentsTotal[4];
                  // const segBD = segmentsTotal[5];
                  // const newPointE = modelObj.LabComClass.Maths.getLineintersect(segAC.x,segAC.y,segAC.xTo,segAC.yTo,segBD.x,segBD.y,segBD.xTo,segBD.yTo);
                  // console.log('inter',newPointE);
                  // var pointE = findShape(11).shape;
                  // pointE.x = newPointE.x;
                  // pointE.y = newPointE.y;
                }
              });
            } else if (shape.label === 'B' && shape.shapeType === 'rhombus' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var fixPoint1 = findShape(shape.pointFix[0]).shape;
              var fixPoint2 = findShape(shape.pointFix[1]).shape;
              var connectedPt = findShape(shape.connectedPoints).shape;
              var pointId = connectedPt.uniqueId; // Fix Point 1 -> A , Fix Point 2 -> D, Connected Pt -> C

              if (connectedPt) {
                // Angle b/w A and B.
                var angleBet2Points = modelObj.LabComClass.Maths.getAngle(fixPoint1.x, fixPoint1.y, shape.x, shape.y);
                var side = modelObj.LabComClass.Maths.getDistance(fixPoint1, fixPoint2); // Point C is calculated wrt to Point D

                var newPoint = modelObj.LabComClass.Maths.getPoint(fixPoint2, angleBet2Points, side); // If new point is outside graph.

                localObj.cOnBound = onScreen(newPoint) ? false : pointId;
                var onBound = outScreen(newPoint);

                if (localObj.cOnBound) {
                  //If OutBound is left or Right then 'x' cords are changed to maxX or minX accordingly.
                  if (onBound.out === 'right' || onBound.out === 'left') {
                    connectedPt.x = onBound.out === 'right' ? maxX : minX;
                  } //If OutBound is up or down then 'y' cords are changed to maxY or minY accordingly.
                  else if (onBound.out === 'up' || onBound.out === 'down') {
                      connectedPt.y = onBound.out === 'up' ? maxY : minY;
                    }

                  localObj.cOnBound = pointId; // Angle b/w D and C.

                  var _angleBet2Points3 = modelObj.LabComClass.Maths.getAngle(fixPoint2.x, fixPoint2.y, connectedPt.x, connectedPt.y); // Pt B is calculated wrt to A.


                  var newMovPoint = modelObj.LabComClass.Maths.getPoint(fixPoint1, _angleBet2Points3, side);
                  shape.x = newMovPoint.x;
                  shape.y = newMovPoint.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                } else {
                  // If points are inside graph.
                  // B is calculated again as the distance needs to be same.
                  connectedPt.x = newPoint.x;
                  connectedPt.y = newPoint.y;
                  connectedPt.labelX = connectedPt.x;
                  connectedPt.labelY = connectedPt.y;

                  var _angleBet2Points4 = modelObj.LabComClass.Maths.getAngle(fixPoint2.x, fixPoint2.y, connectedPt.x, connectedPt.y);

                  var _newMovPoint2 = modelObj.LabComClass.Maths.getPoint(fixPoint1, _angleBet2Points4, side);

                  shape.x = _newMovPoint2.x;
                  shape.y = _newMovPoint2.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                }
              }

              if (connectedPt.label === 'C') {
                var pointE = findShape(11).shape;
                var newPointE = modelObj.LabComClass.Maths.getPoint(fixPoint1, modelObj.LabComClass.Maths.getAngle(fixPoint1.x, fixPoint1.y, connectedPt.x, connectedPt.y), modelObj.LabComClass.Maths.getDistance(fixPoint1, connectedPt) / 2);
                pointE.x = newPointE.x;
                pointE.y = newPointE.y;
              }
            } else if (shape.label === 'D' && shape.shapeType === 'rhombus' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var _fixPoint3 = findShape(shape.pointFix).shape; //Shape has connected pt attribute which mentions the points to be moved aling with the dragged point

              shape.connectedPoints.forEach(function (pointId) {
                var point = findShape(pointId).shape;

                if (pointId === 2 && localObj.cOnBound !== 3) {
                  // Angle b/w D and B.
                  var _angleBet2Points5 = modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, pointsTotal[1].x, pointsTotal[1].y); // Point B is calculated wrt to Point A.


                  var _newPoint5 = modelObj.LabComClass.Maths.getPoint(_fixPoint3, _angleBet2Points5, modelObj.LabComClass.Maths.getDistance(_fixPoint3, shape)); // If new point is out of boundary.


                  localObj.cOnBound = onScreen(_newPoint5) ? false : pointId;

                  var _onBound2 = outScreen(_newPoint5);

                  if (localObj.cOnBound) {
                    //If OutBound is left or Right then 'x' cords are changed to maxX or minX accordingly.
                    if (_onBound2.out === 'right' || _onBound2.out === 'left') {
                      point.x = _onBound2.out === 'right' ? maxX : minX;
                    } //If OutBound is up or down then 'y' cords are changed to maxY or minY accordingly.
                    else if (_onBound2.out === 'up' || _onBound2.out === 'down') {
                        point.y = _onBound2.out === 'up' ? maxY : minY;
                      }

                    localObj.cOnBound = pointId; // Side is calculated b/w Point B and Point A.

                    var _side3 = modelObj.LabComClass.Maths.getDistance(point, _fixPoint3);

                    var angleAtPoint = findShape(point.aId).shape;
                    var angleAtFixPoint = modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, point.x, point.y) + (Math.PI - angleAtPoint.angleValue * Math.PI / 180); // Point D is recalculated as Point B is on boundary.

                    var _newMovPoint3 = modelObj.LabComClass.Maths.getPoint(_fixPoint3, angleAtFixPoint, _side3);

                    shape.x = _newMovPoint3.x;
                    shape.y = _newMovPoint3.y;
                    shape.labelX = shape.x;
                    shape.labelY = shape.y;
                  } else {
                    // If all the points are inside graph.
                    point.x = _newPoint5.x;
                    point.y = _newPoint5.y;
                    localObj.cOnBound = false;
                    shape.isDraggable = true;
                  }

                  point.labelX = point.x;
                  point.labelY = point.y;
                } else if (pointId === 3 && localObj.cOnBound !== 2) {
                  // Angle Delta
                  var _angleBet2Points6 = modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, shape.x, shape.y) - modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, pointsTotal[1].x, pointsTotal[1].y); // Diagnol distance is calculated.


                  var eDist = Math.cos(_angleBet2Points6 / 2) * modelObj.LabComClass.Maths.getDistance(_fixPoint3, shape); // New Point is calculated Point C wrt to Point A.

                  var _newPoint6 = modelObj.LabComClass.Maths.getPoint(_fixPoint3, _angleBet2Points6 / 2 + modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, pointsTotal[1].x, pointsTotal[1].y), eDist * 2); // Checks if new point is out of boundary.


                  localObj.cOnBound = onScreen(_newPoint6) ? false : pointId;

                  var _onBound3 = outScreen(_newPoint6);

                  if (localObj.cOnBound) {
                    //If OutBound is left or Right then 'x' cords are changed to maxX or minX accordingly.
                    if (_onBound3.out === 'right' || _onBound3.out === 'left') {
                      point.x = _onBound3.out === 'right' ? maxX : minX;
                    } //If OutBound is up or down then 'y' cords are changed to maxY or minY accordingly.
                    else if (_onBound3.out === 'up' || _onBound3.out === 'down') {
                        point.y = _onBound3.out === 'up' ? maxY : minY;
                      }

                    localObj.cOnBound = pointId;

                    var _side4 = modelObj.LabComClass.Maths.getDistance(_fixPoint3, pointsTotal[1]);

                    var _angleBet2Points7 = modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, point.x, point.y) * 2 - modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, pointsTotal[1].x, pointsTotal[1].y); // Dragged Point D is Restricted as Point C is on boundary.


                    var _newMovPoint4 = modelObj.LabComClass.Maths.getPoint(_fixPoint3, _angleBet2Points7, _side4);

                    shape.x = _newMovPoint4.x;
                    shape.y = _newMovPoint4.y;
                    shape.labelX = shape.x;
                    shape.labelY = shape.y;
                    var pointB = pointsTotal[1];
                    var newMovPointV2 = modelObj.LabComClass.Maths.getPoint(pointsTotal[4], modelObj.LabComClass.Maths.getAngle(pointB.x, pointB.y, pointsTotal[4].x, pointsTotal[4].y), modelObj.LabComClass.Maths.getDistance(pointsTotal[4], pointB));
                    shape.x = newMovPointV2.x;
                    shape.y = newMovPointV2.y;
                    shape.labelX = shape.x;
                    shape.labelY = shape.y;
                  } else {
                    // If all points are inside graph.
                    point.x = _newPoint6.x;
                    point.y = _newPoint6.y;
                    localObj.cOnBound = false;
                    shape.isDraggable = true;
                    point.labelX = point.x;
                    point.labelY = point.y;
                  }
                }

                if (point.label === 'C') {
                  var pointE = findShape(11).shape;
                  var newPointE = modelObj.LabComClass.Maths.getPoint(_fixPoint3, modelObj.LabComClass.Maths.getAngle(_fixPoint3.x, _fixPoint3.y, point.x, point.y), modelObj.LabComClass.Maths.getDistance(_fixPoint3, point) / 2);
                  pointE.x = newPointE.x;
                  pointE.y = newPointE.y;
                }
              });
            } else if (shape.label === 'C' && shape.shapeType === 'rhombus' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var _fixPoint4 = findShape(shape.pointFix[0]).shape; // A

              var _fixPoint5 = findShape(shape.pointFix[1]).shape; // D

              var _connectedPt = findShape(shape.connectedPoints).shape; //B

              var _pointId = _connectedPt.uniqueId;

              if (_connectedPt) {
                // Angle b/w D and C.
                var _angleBet2Points8 = modelObj.LabComClass.Maths.getAngle(_fixPoint5.x, _fixPoint5.y, shape.x, shape.y);

                var _side5 = modelObj.LabComClass.Maths.getDistance(_fixPoint4, _fixPoint5); // Point B is calculated wrt to A.


                var _newPoint7 = modelObj.LabComClass.Maths.getPoint(_fixPoint4, _angleBet2Points8, _side5);

                if (!localObj.cOnBound || localObj.cOnBound === 3) {
                  _connectedPt.x = _newPoint7.x;
                  _connectedPt.y = _newPoint7.y;
                  _connectedPt.labelX = _connectedPt.x;
                  _connectedPt.labelY = _connectedPt.y;
                }

                localObj.cOnBound = onScreen(_newPoint7) ? false : _pointId;

                var _onBound4 = outScreen(_newPoint7); // If new point is on Boundary.


                if (localObj.cOnBound) {
                  //If OutBound is left or Right then 'x' cords are changed to maxX or minX accordingly.
                  if (_onBound4.out === 'right' || _onBound4.out === 'left') {
                    _connectedPt.x = _onBound4.out === 'right' ? maxX : minX;
                  } //If OutBound is up or down then 'y' cords are changed to maxY or minY accordingly.
                  else if (_onBound4.out === 'up' || _onBound4.out === 'down') {
                      _connectedPt.y = _onBound4.out === 'up' ? maxY : minY;
                    }

                  localObj.cOnBound = _pointId; // C point is restricted with same distance.

                  var _angleBet2Points9 = modelObj.LabComClass.Maths.getAngle(_fixPoint4.x, _fixPoint4.y, _connectedPt.x, _connectedPt.y);

                  var _newMovPoint5 = modelObj.LabComClass.Maths.getPoint(_fixPoint5, _angleBet2Points9, _side5);

                  shape.x = _newMovPoint5.x;
                  shape.y = _newMovPoint5.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                } else {
                  // C is restricted with the length, if all points are inside graph.
                  var _angleBet2Points10 = modelObj.LabComClass.Maths.getAngle(_fixPoint4.x, _fixPoint4.y, _connectedPt.x, _connectedPt.y);

                  var _newMovPoint6 = modelObj.LabComClass.Maths.getPoint(_fixPoint5, _angleBet2Points10, _side5);

                  shape.x = _newMovPoint6.x;
                  shape.y = _newMovPoint6.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                }
              }

              if (_connectedPt.label === 'B') {
                var pointE = findShape(11).shape;
                var newPointE = modelObj.LabComClass.Maths.getPoint(_fixPoint5, modelObj.LabComClass.Maths.getAngle(_fixPoint5.x, _fixPoint5.y, _connectedPt.x, _connectedPt.y), modelObj.LabComClass.Maths.getDistance(_fixPoint5, _connectedPt) / 2);
                pointE.x = newPointE.x;
                pointE.y = newPointE.y;
              }
            }

            break;

          case 'kite':
            // if A point is dragged then A is moved only vertically.
            var angleAt = findShape(shape.aId).shape;
            var points = modelObj.interactionElements.filter(function (el) {
              return el.type === 'point';
            }); //Points 0->A, 1->B, 2->C, 3->D.

            if (shape.label === 'A' && shape.shapeType === 'kite' && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var collinearCondition = collinear(shape, points[1], points[3]).collinear && collinear(shape, points[1], points[3]).value >= 0 || collinear(shape, points[1], points[3]).value < 0;

              if (collinearCondition) {
                shape.x = shape.fixX;
                shape.y = points[1].y;
                shape.labelX = shape.x;
                shape.labelY = shape.y; // localObj.pointOnDiagnol = true;  
              } else {
                shape.x = shape.fixX;
                shape.y = shape.y;
                shape.labelX = shape.x;
                shape.labelY = shape.y;
              }
            } //if B Point is dragged then C is moved symetrically.
            else if (shape.label === 'B' && shape.shapeType === 'kite' && modelObj.interactionElements.length > 4) {
                var connPoint = findShape(shape.connectedPoints).shape;

                var _collinearCondition = collinear(shape, points[0], points[2]).collinear && collinear(shape, points[0], points[2]).value <= 0 || collinear(shape, points[0], points[2]).value > 0;

                var collinearCondition2 = collinear(shape, points[0], points[3]).collinear && collinear(shape, points[0], points[3]).value <= 0 || collinear(shape, points[0], points[3]).value > 0;
                var collinearCondition3 = collinear(shape, points[2], points[3]).collinear || collinear(shape, points[2], points[3]).value < 0;

                if (_collinearCondition) {
                  connPoint.x = points[2].x;
                  connPoint.y = shape.y;
                  shape.x = connPoint.x;
                  shape.y = shape.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                  connPoint.labelX = connPoint.x;
                  connPoint.labelY = connPoint.y;
                } else if (collinearCondition2 || collinearCondition3) {
                  connPoint.x = -shape.x;
                  connPoint.y = collinearCondition2 ? points[0].y : points[2].y;
                  shape.x = shape.x;
                  shape.y = connPoint.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                  connPoint.labelX = connPoint.x;
                  connPoint.labelY = connPoint.y;
                } else {
                  connPoint.x = -shape.x;
                  connPoint.y = shape.y;
                  connPoint.labelX = connPoint.x;
                  connPoint.labelY = connPoint.y;
                }
              } // if C point is dragged then it is moved only vertically.
              else if (shape.label === 'C' && shape.shapeType === 'kite' && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
                  var _collinearCondition2 = collinear(shape, points[1], points[3]).collinear && collinear(shape, points[1], points[3]).value <= 0 || collinear(shape, points[1], points[3]).value > 0;

                  if (_collinearCondition2) {
                    shape.x = shape.fixX;
                    shape.y = points[1].y;
                    shape.labelX = shape.x;
                    shape.labelY = shape.y; // localObj.pointOnDiagnol = true;  
                  } else {
                    shape.x = shape.fixX;
                    shape.y = shape.y;
                    shape.labelX = shape.x;
                    shape.labelY = shape.y;
                  }
                } // if D point is dragged then B point is moved simontanoeusly.
                else if (shape.label === 'D' && shape.shapeType === 'kite' && modelObj.interactionElements.length > 4) {
                    var _connPoint = findShape(shape.connectedPoints).shape;

                    var _collinearCondition3 = collinear(shape, points[0], points[2]).collinear && collinear(shape, points[0], points[2]).value >= 0 || collinear(shape, points[0], points[2]).value < 0;

                    var _collinearCondition4 = collinear(points[1], points[0], shape).collinear && collinear(points[1], points[0], shape).value <= 0 || collinear(points[1], points[0], shape).value > 0;

                    var _collinearCondition5 = collinear(points[1], points[2], shape).collinear || collinear(points[1], points[2], shape).value < 0;

                    if (_collinearCondition3) {
                      _connPoint.x = points[2].x;
                      _connPoint.y = shape.y;
                      shape.x = _connPoint.x;
                      shape.y = shape.y;
                      shape.labelX = shape.x;
                      shape.labelY = shape.y;
                      _connPoint.labelX = _connPoint.x;
                      _connPoint.labelY = _connPoint.y;
                    } else if (_collinearCondition4 || _collinearCondition5) {
                      _connPoint.x = -shape.x;
                      _connPoint.y = _collinearCondition4 ? points[0].y : points[2].y;
                      shape.x = shape.x;
                      shape.y = _connPoint.y;
                      shape.labelX = shape.x;
                      shape.labelY = shape.y;
                      _connPoint.labelX = _connPoint.x;
                      _connPoint.labelY = _connPoint.y;
                    } else {
                      _connPoint.x = -shape.x;
                      _connPoint.y = shape.y;
                      _connPoint.labelX = _connPoint.x;
                      _connPoint.labelY = _connPoint.y;
                    }
                  }

            break;

          case 'triangle':
            if (modelObj.interactionElements.length > 4) {
              // Angle ID (aId) needs to be passed in Math Class eg. Point A should be linked With alpha angle.
              var _angleAt = findShape(shape.aId).shape; //Points are filtered out , there are only 3 points.

              var _points = modelObj.interactionElements.filter(function (el) {
                return el.type === 'point';
              }); // If angle is less than 180
              // if((+angleAt.angleValue<180 && !collinear(points[0],points[1],points[2]).collinear  && collinear(points[0],points[1],points[2]).value>0) || (angleAt.angleValue >= 180 && collinear(points[0],points[1],points[2]).value>0)){


              if (collinear(_points[0], _points[1], _points[2]).value > 0 && _angleAt.angleValue < 180) {
                //angles without reflex prop
                var angles1 = modelObj.interactionElements.filter(function (el) {
                  return el.type === 'angle' && el.reflexProp === undefined;
                }); //angles with reflex prop

                var angles2 = modelObj.interactionElements.filter(function (el) {
                  return el.type === 'angle' && el.reflexProp !== undefined;
                }); // If is less than 180 so angles w/o reflex prop is shown

                angles1.forEach(function (angShape) {
                  angShape.visible = true;
                }); //As If is less than 180 so angles with reflex prop is hidden

                angles2.forEach(function (angShape) {
                  angShape.visible = false;
                });
              } // If angle is greater than 180
              // else if((+angleAt.angleValue>180 && !collinear(points[0],points[1],points[2]).collinear  && collinear(points[0],points[1],points[2]).value<0) || (angleAt.angleValue <= 180 && collinear(points[0],points[1],points[2]).value<0)){
              else if (collinear(_points[0], _points[1], _points[2]).value < 0 && _angleAt.angleValue > 180) {
                  //angles without reflex prop
                  var _angles = modelObj.interactionElements.filter(function (el) {
                    return el.type === 'angle' && el.reflexProp === undefined;
                  }); //angles with reflex prop


                  var _angles2 = modelObj.interactionElements.filter(function (el) {
                    return el.type === 'angle' && el.reflexProp !== undefined;
                  }); // If is greater than 180 so angles w/o reflex prop is hidden.


                  _angles.forEach(function (angShape) {
                    angShape.visible = false;
                  }); // As If is greater than 180 so angles with reflex prop is shown.


                  _angles2.forEach(function (angShape) {
                    angShape.visible = true;
                  });
                } else {
                  var _angles3 = modelObj.interactionElements.filter(function (el) {
                    return el.type === 'angle' && el.reflexProp === undefined;
                  }); //angles with reflex prop


                  var _angles4 = modelObj.interactionElements.filter(function (el) {
                    return el.type === 'angle' && el.reflexProp !== undefined;
                  }); // If is greater than 180 so angles w/o reflex prop is hidden.


                  _angles3.forEach(function (angShape) {
                    angShape.visible = false;
                  }); // As If is greater than 180 so angles with reflex prop is shown.


                  _angles4.forEach(function (angShape) {
                    angShape.visible = false;
                  });
                }
            }

            break;

          case 'trapezoid':
            if (shape.label === 'A' && shape.shapeType === 'trapezoid' && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var b = findShape(shape.second).shape;
              b.y = shape.y;
              b.labelY = b.y; //.. Remove comment to restrict point movement

              if (shape.x > b.x - 1) {
                shape.x = b.x - 1;
                shape.y = b.y;
                shape.labelX = b.x;
                shape.labelY = b.y;
              }
            } else if (shape.label === 'B' && shape.shapeType === 'trapezoid' && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var a = findShape(shape.second).shape;
              a.y = shape.y;
              a.labelY = a.y; //.. Remove comment to restrict point movement

              if (shape.x < a.x + 1) {
                shape.x = a.x + 1;
                shape.y = a.y;
                shape.labelX = a.x;
                shape.labelY = a.y;
              }
            } else if (shape.label === 'C' && shape.shapeType === 'trapezoid' && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var _d9 = findShape(shape.second).shape;
              _d9.y = shape.y;
              _d9.labelY = _d9.y; //.. Remove comment to restrict point movement

              if (shape.x < _d9.x + 1) {
                shape.x = _d9.x + 1;
                shape.y = _d9.y;
                shape.labelX = _d9.x;
                shape.labelY = _d9.y;
              }
            } else if (shape.label === 'D' && shape.shapeType === 'trapezoid' && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              var c = findShape(shape.second).shape;
              c.y = shape.y;
              c.labelY = c.y; //.. Remove comment to restrict point movement

              if (shape.x > c.x - 1) {
                shape.x = c.x - 1;
                shape.y = c.y;
                shape.labelX = c.x;
                shape.labelY = c.y;
              }
            }

            if (modelObj.interactionElements.length > 4) {
              var _angleAt2 = findShape(shape.aId).shape;

              var _points2 = modelObj.interactionElements.filter(function (el) {
                return el.type === 'point';
              });

              if (angleDirection(_points2[0], _points2[1], _points2[2], _points2[3])) {
                var _angles5 = modelObj.interactionElements.filter(function (el) {
                  return el.type === 'angle' && el.reflexProp === undefined;
                });

                var _angles6 = modelObj.interactionElements.filter(function (el) {
                  return el.type === 'angle' && el.reflexProp !== undefined;
                });

                _angles5.forEach(function (angShape) {
                  angShape.visible = true;
                });

                _angles6.forEach(function (angShape) {
                  angShape.visible = false;
                }); // // ... Comment this if condition to restrict point movement
                // if(points[0].x > points[1].x){
                //   const angles1 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp === undefined);
                //   const angles2 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp !== undefined);
                //   angles1.forEach(angShape=>{
                //     if(angShape.label == 'α' || angShape.label == 'β'){
                //       angShape.visible = false;
                //     } 
                //   });
                //   angles2.forEach(angShape=>{
                //     if(angShape.label == 'α' || angShape.label == 'β'){
                //       angShape.visible = true;
                //     }
                //   });
                // } 
                //  // ... Comment this if condition to restrict point movement
                // if(points[2].x < points[3].x){
                //   const angles1 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp === undefined);
                //   const angles2 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp !== undefined);
                //   angles1.forEach(angShape=>{
                //     if(angShape.label == 'γ' || angShape.label == 'δ'){
                //       angShape.visible = false;
                //     } 
                //   });
                //   angles2.forEach(angShape=>{
                //     if(angShape.label == 'γ' || angShape.label == 'δ'){
                //       angShape.visible = true;
                //     }
                //   });
                // }

              } else {
                var _angles7 = modelObj.interactionElements.filter(function (el) {
                  return el.type === 'angle' && el.reflexProp === undefined;
                });

                var _angles8 = modelObj.interactionElements.filter(function (el) {
                  return el.type === 'angle' && el.reflexProp !== undefined;
                });

                _angles7.forEach(function (angShape) {
                  angShape.visible = false;
                });

                _angles8.forEach(function (angShape) {
                  angShape.visible = true;
                }); // ... Comment this if condition to restrict point movement
                // if(points[0].x > points[1].x){
                //   const angles1 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp === undefined);
                //   const angles2 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp !== undefined);
                //   angles1.forEach(angShape=>{
                //     if(angShape.label == 'α' || angShape.label == 'β'){
                //       angShape.visible = true;
                //     } 
                //   });
                //   angles2.forEach(angShape=>{
                //     if(angShape.label == 'α' || angShape.label == 'β'){
                //       angShape.visible = false;
                //     }
                //   });
                // } 
                //  // ... Comment this if condition to restrict point movement
                // if(points[2].x < points[3].x){
                //   const angles1 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp === undefined);
                //   const angles2 = modelObj.interactionElements.filter(el=>el.type === 'angle' && el.reflexProp !== undefined);
                //   angles1.forEach(angShape=>{
                //     if(angShape.label == 'γ' || angShape.label == 'δ'){
                //       angShape.visible = true;
                //     } 
                //   });
                //   angles2.forEach(angShape=>{
                //     if(angShape.label == 'γ' || angShape.label == 'δ'){
                //       angShape.visible = false;
                //     }
                //   });
                // }

              }
            }

            break;

          case 'parallelogram':
            //Point Id-Label 1-A,2-B,3-C,4-D
            // If A Point is Dragged.
            if (shape.label === 'A' && shape.shapeType === 'parallelogram' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              //Shape has connected pt attribute which mentions the points to be moved aling with the dragged point
              if (shape.connectedPoints === 3) {
                var point = findShape(shape.connectedPoints).shape; // Point B

                var _fixPoint6 = findShape(shape.pointFix[0]).shape; //Point D

                var _fixPoint7 = findShape(shape.pointFix[1]).shape; //Angle Between B and A

                var _angleBet2Points11 = Math.PI - modelObj.LabComClass.Maths.getAngle(_fixPoint6.x, _fixPoint6.y, shape.x, shape.y); // Dist of 'a'


                var aDist = modelObj.LabComClass.Maths.getDistance(shape, _fixPoint6); // New point calculated from 'D'

                var _newPoint8 = modelObj.LabComClass.Maths.getPoint(_fixPoint7, -_angleBet2Points11, aDist); // onBound returns true if the calculated point is outside graph 


                localObj.cOnBound = onScreen(_newPoint8) ? false : point.uniqueId; //OutBound tells in which direction the point has leaved the graph like left,right,up,down.

                var _onBound5 = outScreen(_newPoint8);

                if (localObj.cOnBound) {
                  //According to outBound the points are updated accordingly
                  if (_onBound5.out === 'right' || _onBound5.out === 'left') {
                    point.x = _onBound5.out === 'right' ? maxX : minX;
                  } else if (_onBound5.out === 'up' || _onBound5.out === 'down') {
                    point.y = _onBound5.out === 'up' ? maxY : minY;
                  } // Side of the Rhombus is calculated.


                  var cDist = modelObj.LabComClass.Maths.getDistance(_fixPoint7, point); // // Dragged Point is calculated accordingly to keep it static.

                  var angleWithLockedPt = modelObj.LabComClass.Maths.getAngle(_fixPoint7.x, _fixPoint7.y, point.x, point.y);

                  var _newMovPoint7 = modelObj.LabComClass.Maths.getPoint(_fixPoint6, Math.PI + angleWithLockedPt, cDist); // Dragged Point is updated accordingly.


                  shape.x = _newMovPoint7.x;
                  shape.y = _newMovPoint7.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                } else {
                  // if all the points are inside the graph.
                  point.x = _newPoint8.x;
                  point.y = _newPoint8.y;
                  localObj.cOnBound = false;
                  shape.isDraggable = true;
                }

                point.labelX = point.x;
                point.labelY = point.y;
              }
            } else if (shape.label === 'B' && shape.shapeType === 'parallelogram' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              //Shape has connected pt attribute which mentions the points to be moved aling with the dragged point
              if (shape.connectedPoints === 3) {
                var _point2 = findShape(shape.connectedPoints).shape; // point A

                var _fixPoint8 = findShape(shape.pointFix[0]).shape; // point D

                var _fixPoint9 = findShape(shape.pointFix[1]).shape; // Angle between A and B.

                var _angleBet2Points12 = modelObj.LabComClass.Maths.getAngle(_fixPoint8.x, _fixPoint8.y, shape.x, shape.y); // Distance of 'a'


                var _aDist = modelObj.LabComClass.Maths.getDistance(shape, _fixPoint8); // C point calculated from point D


                var _newPoint9 = modelObj.LabComClass.Maths.getPoint(_fixPoint9, _angleBet2Points12, _aDist); // onBound returns true if the calculated point is outside graph 


                localObj.cOnBound = onScreen(_newPoint9) ? false : _point2.uniqueId; //OutBound tells in which direction the point has leaved the graph like left,right,up,down.

                var _onBound6 = outScreen(_newPoint9);

                if (localObj.cOnBound) {
                  //According to outBound the points are updated accordingly
                  if (_onBound6.out === 'right' || _onBound6.out === 'left') {
                    _point2.x = _onBound6.out === 'right' ? maxX : minX;
                  } else if (_onBound6.out === 'up' || _onBound6.out === 'down') {
                    _point2.y = _onBound6.out === 'up' ? maxY : minY;
                  } // Side of the Rhombus is calculated.


                  var _cDist = modelObj.LabComClass.Maths.getDistance(_fixPoint9, _point2); // // Dragged Point is calculated accordingly to keep it static.


                  var _angleWithLockedPt = modelObj.LabComClass.Maths.getAngle(_fixPoint9.x, _fixPoint9.y, _point2.x, _point2.y);

                  var _newMovPoint8 = modelObj.LabComClass.Maths.getPoint(_fixPoint8, _angleWithLockedPt, _cDist); // Dragged Point is updated accordingly.


                  shape.x = _newMovPoint8.x;
                  shape.y = _newMovPoint8.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                } else {
                  // if all the points are inside the graph.
                  _point2.x = _newPoint9.x;
                  _point2.y = _newPoint9.y;
                  localObj.cOnBound = false;
                  shape.isDraggable = true;
                }

                _point2.labelX = _point2.x;
                _point2.labelY = _point2.y;
              }
            } else if (shape.label === 'C' && shape.shapeType === 'parallelogram' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              //Shape has connected pt attribute which mentions the points to be moved aling with the dragged point
              if (shape.connectedPoints === 1) {
                var _point3 = findShape(shape.connectedPoints).shape; //point B

                var _fixPoint10 = findShape(shape.pointFix[0]).shape; //point D

                var _fixPoint11 = findShape(shape.pointFix[1]).shape; // Angle Between B and C.

                var _angleBet2Points13 = Math.PI + modelObj.LabComClass.Maths.getAngle(_fixPoint10.x, _fixPoint10.y, shape.x, shape.y); // Distance 'a'


                var _aDist2 = modelObj.LabComClass.Maths.getDistance(shape, _fixPoint10); // point A calculated from Point D 


                var _newPoint10 = modelObj.LabComClass.Maths.getPoint(_fixPoint11, _angleBet2Points13, _aDist2); // onBound returns true if the calculated point is outside graph 


                localObj.cOnBound = onScreen(_newPoint10) ? false : _point3.uniqueId; //OutBound tells in which direction the point has leaved the graph like left,right,up,down.

                var _onBound7 = outScreen(_newPoint10);

                if (localObj.cOnBound) {
                  //According to outBound the points are updated accordingly
                  if (_onBound7.out === 'right' || _onBound7.out === 'left') {
                    _point3.x = _onBound7.out === 'right' ? maxX : minX;
                  } else if (_onBound7.out === 'up' || _onBound7.out === 'down') {
                    _point3.y = _onBound7.out === 'up' ? maxY : minY;
                  } // Side of the Rhombus is calculated.


                  var _cDist2 = modelObj.LabComClass.Maths.getDistance(_fixPoint11, _point3); // // Dragged Point is calculated accordingly to keep it static.


                  var _angleWithLockedPt2 = modelObj.LabComClass.Maths.getAngle(_fixPoint11.x, _fixPoint11.y, _point3.x, _point3.y);

                  var _newMovPoint9 = modelObj.LabComClass.Maths.getPoint(_fixPoint10, Math.PI + _angleWithLockedPt2, _cDist2); // Dragged Point is updated accordingly.


                  shape.x = _newMovPoint9.x;
                  shape.y = _newMovPoint9.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                } else {
                  // if all the points are inside the graph.
                  _point3.x = _newPoint10.x;
                  _point3.y = _newPoint10.y;
                  localObj.cOnBound = false;
                  shape.isDraggable = true;
                }

                _point3.labelX = _point3.x;
                _point3.labelY = _point3.y;
              }
            } else if (shape.label === 'D' && shape.shapeType === 'parallelogram' && shape.connectedPoints && modelObj.interactionElements.length > 4 && !localObj.onBoundary) {
              //Shape has connected pt attribute which mentions the points to be moved aling with the dragged point
              if (shape.connectedPoints === 3) {
                var _point4 = findShape(shape.connectedPoints).shape; // Point A

                var _fixPoint12 = findShape(shape.pointFix[0]).shape; // Point B

                var _fixPoint13 = findShape(shape.pointFix[1]).shape; // Angle Between A and D.

                var _angleBet2Points14 = modelObj.LabComClass.Maths.getAngle(_fixPoint12.x, _fixPoint12.y, shape.x, shape.y); // 'b' dist is calculated .


                var bDist = modelObj.LabComClass.Maths.getDistance(shape, _fixPoint12); // Point C is calculated from Point B.

                var _newPoint11 = modelObj.LabComClass.Maths.getPoint(_fixPoint13, _angleBet2Points14, bDist); // onBound returns true if the calculated point is outside graph 


                localObj.cOnBound = onScreen(_newPoint11) ? false : _point4.uniqueId; //OutBound tells in which direction the point has leaved the graph like left,right,up,down.

                var _onBound8 = outScreen(_newPoint11);

                if (localObj.cOnBound) {
                  //According to outBound the points are updated accordingly
                  if (_onBound8.out === 'right' || _onBound8.out === 'left') {
                    _point4.x = _onBound8.out === 'right' ? maxX : minX;
                  } else if (_onBound8.out === 'up' || _onBound8.out === 'down') {
                    _point4.y = _onBound8.out === 'up' ? maxY : minY;
                  } // Side of the Rhombus is calculated.


                  var dDist = modelObj.LabComClass.Maths.getDistance(_fixPoint13, _point4); // // Dragged Point is calculated accordingly to keep it static.

                  var _angleWithLockedPt3 = modelObj.LabComClass.Maths.getAngle(_fixPoint13.x, _fixPoint13.y, _point4.x, _point4.y);

                  var _newMovPoint10 = modelObj.LabComClass.Maths.getPoint(_fixPoint12, _angleWithLockedPt3, dDist); // Dragged Point is updated accordingly.


                  shape.x = _newMovPoint10.x;
                  shape.y = _newMovPoint10.y;
                  shape.labelX = shape.x;
                  shape.labelY = shape.y;
                } else {
                  // if all the points are inside the graph.
                  _point4.x = _newPoint11.x;
                  _point4.y = _newPoint11.y;
                  localObj.cOnBound = false;
                  shape.isDraggable = true;
                }

                _point4.labelX = _point4.x;
                _point4.labelY = _point4.y;
              }
            }

            break;
        }
      } // const minX = -0.42, minY = -0.46, maxX = 5.45, maxY = 3.37;
      // const minX = -2.95, minY = -0.3, maxX = 2.95, maxY = 3.54;


      if (shape.shapeType && modelObj.interactionElements.length > 4) {
        switch (shape.shapeType) {
          case 'rhombus':
          case 'kite':
          case 'triangle':
          case 'trapezoid':
          case 'parallelogram':
            //checks if all the 4 points are inside graph, if outside then flag variable is switched on.
            var totalPoints = shape.shapeType === 'triangle' ? 3 : 4;

            for (var i = 1; i <= totalPoints; i++) {
              var pId = i;
              var _point5 = findShape(pId).shape; // If point is on right of graph.

              if (_point5.x > maxX) {
                localObj.onBoundary = true;
                localObj.cOnBound = pId;
                _point5.isDraggable = false;
                _point5.x = maxX;
                break;
              } else if (_point5.y > maxY) {
                // If point is on top of graph.
                localObj.onBoundary = true;
                _point5.y = maxY;
                localObj.cOnBound = pId;
                _point5.isDraggable = false;
                break;
              } else if (_point5.x < minX) {
                // If point is on left of graph.
                localObj.onBoundary = true;
                _point5.x = minX;
                localObj.cOnBound = pId;
                _point5.isDraggable = false;
                break;
              } else if (_point5.y < minY) {
                // If point is on bottom of graph.
                localObj.onBoundary = true;
                _point5.y = minY;
                localObj.cOnBound = pId;
                _point5.isDraggable = false;
                break;
              } else {
                // if all points inside graph.
                localObj.onBoundary = false;
                _point5.isDraggable = true;
              }
            } // if Dragged point inside Graph.


            if (shape.x > minX && shape.y > minY && shape.x < maxX && shape.y < maxY) {
              shape.isDraggable = localObj.cOnBound ? false : true;
              localObj.onBoundary = false;
            }

            break;
        }
      }

      if (shape.labelDiffX === 0) {
        shape.labelDiffX = 6;
        shape.labelDiffY = -9;
      } //Left Bottom -0.42,-0.46
      //Right up 5.45,3.37
      //Left up -0.42,3.37
      //Right Bottom 5.45,-0.46

    }
  }

  function toFixedNum(num) {
    var precison = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    var numVal = +num.toFixed(precison);
    return numVal;
  } // Returns True if point is inside graph.


  function onScreen(point) {
    var onScreenFlag = false;
    var minCordinates = getPointByPixel(modelObj.x, modelObj.y + modelObj.height);
    var maxCordinates = getPointByPixel(modelObj.x + modelObj.width, modelObj.y);
    var minX = minCordinates.x,
        minY = minCordinates.y,
        maxX = maxCordinates.x,
        maxY = maxCordinates.y; // const minX = -0.42, minY = -0.46, maxX = 5.45, maxY = 3.37;
    // const minX = -2.95, minY = -0.3, maxX = 2.95, maxY = 3.54;

    if (point.x < maxX && point.x > minX && point.y > minY && point.y < maxY) {
      onScreenFlag = true;
    }

    return onScreenFlag;
  }

  function onEdge(point) {
    // let onEdgeFlag = true;
    var onEdgeFlag = false;
    var pointsTotal = modelObj.interactionElements.filter(function (el) {
      return el.type === 'point';
    });
    var minCordinates = getPointByPixel(modelObj.x, modelObj.y + modelObj.height);
    var maxCordinates = getPointByPixel(modelObj.x + modelObj.width, modelObj.y);
    var minX = minCordinates.x,
        minY = minCordinates.y,
        maxX = maxCordinates.x,
        maxY = maxCordinates.y;

    if (modelObj.LabComClass.Maths.getDistance(point, pointsTotal[0]) < modelObj.LabComClass.Maths.getDistance(pointsTotal[0], pointsTotal[3])) {
      onEdgeFlag = true;
    }

    return onEdgeFlag;
  } // Returns the direction in which the point cordinates has exceeded graph.


  function outScreen(point) {
    var onScreenFlag = false;
    var minCordinates = getPointByPixel(modelObj.x, modelObj.y + modelObj.height);
    var maxCordinates = getPointByPixel(modelObj.x + modelObj.width, modelObj.y);
    var minX = minCordinates.x,
        minY = minCordinates.y,
        maxX = maxCordinates.x,
        maxY = maxCordinates.y; // const minX = -0.42, minY = -0.46, maxX = 5.45, maxY = 3.37;
    // const minX = -2.95, minY = -0.3, maxX = 2.95, maxY = 3.54;

    if (point.x > maxX) {
      onScreenFlag = {
        out: 'right'
      };
    } else if (point.x < minX) {
      onScreenFlag = {
        out: 'left'
      };
    } else if (point.y < minY) {
      onScreenFlag = {
        out: 'down'
      };
    } else if (point.y > maxY) {
      onScreenFlag = {
        out: 'up'
      };
    }

    return onScreenFlag;
  }

  function sudatePointss(shape) {
    var diff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (shape.label) {
      shape.labelX = shape.x;
      shape.labelY = shape.y;

      if (shape.connectedPoints && modelObj.interactionElements.length > 4) {
        shape.connectedPoints.forEach(function (pointId) {
          var point = findShape(pointId).shape;
          var yCondition;

          switch (shape.label) {
            case 'A':
              yCondition = point.y - Math.tan(point.pointIncline) * diff.x;
              break;

            case 'B':
              yCondition = point.y + Math.tan(point.pointIncline) * diff.x;
              break;
            // case 'C':
            //   yCondition = point.y - Math.tan(point.pointIncline) * diff.x ;
            //   break;
            // case 'D':
            //   yCondition = point.y + Math.tan(point.pointIncline) * diff.x;
            //   break; 
          }

          if (point.pointIncline) {
            point.x = shape.label == point.pointRev && point.label === 'C' ? point.x - diff.x : point.x + diff.x;
            point.y = diff.x == 0 ? point.y + diff.y : yCondition;
          } else {
            point.x += diff.x;
            point.y += diff.y;
          }

          point.labelX = point.x;
          point.labelY = point.y;
        });
      }

      if (shape.labelDiffX === 0) {
        shape.labelDiffX = 6;
        shape.labelDiffY = -9;
      }
    }
  }

  function findNewMovPoint(p1, p2) {
    var a = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);
  } // =================================================


  function updateLinePoints(curInt) {
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 10;

    var _angle = modelObj.LabComClass.Maths.getAngle(curInt.x, curInt.y, curInt.xTo, curInt.yTo);

    var _newPoint = modelObj.LabComClass.Maths.getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;

    var _angle2 = modelObj.LabComClass.Maths.getAngle(curInt.xTo, curInt.yTo, curInt.x, curInt.y);

    var _newPoint2 = modelObj.LabComClass.Maths.getPoint({
      x: curInt.xTo,
      y: curInt.yTo
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y;

    if (curInt.label) {
      var p = findLableByLine(curInt, {
        x: curInt.xTo,
        y: curInt.yTo
      });
      curInt.labelX = p.x;
      curInt.labelY = p.y;
    }

    if (curInt && curInt.connectionId && curInt.connectionId.length) {
      for (var i = 0; i < curInt.connectionId.length; i++) {
        var shapeData = findShape(curInt.connectionId[i]);

        if (shapeData && (shapeData.shape.type === 'perpendicularLine' || shapeData.shape.type === 'parallelLine')) {
          shapeData.shape.slope = _angle;

          if (shapeData.shape.type === 'perpendicularLine') {
            shapeData.shape.slope += Math.PI / 2;
          }

          updatePLinePoints(shapeData.shape);
        }
      }
    }
  }

  function findLableByPoint(p1) {
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.font = modelObj.fontSize + 'px ' + modelObj.LabComClass.polo22KlettRegular;

    var width = _ctx.measureText(p1.label).width;

    var height = _ctx.measureText(p1.label).height;

    _ctx.restore();

    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = modelObj.LabComClass.Maths.getRandomNumber(0, Math.PI * 2, 1, 0.1);
      var dist = 5;
      p = modelObj.LabComClass.Maths.getPoint(p1, angle, dist);

      if (angle > Math.PI - 1 && angle < Math.PI + 1) {
        p.x -= width;
      }

      if (angle > Math.PI + 1 && angle < Math.PI * 2) {
        p.y -= height;
      }

      if (angle < 1 || angle > Math.PI * 2 - 1) {
        p.x += width;
      }

      if (angle < Math.PI - 1) {
        p.y += height;
      }

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = p1.x;
        p.y = p1.y - 5;
        break;
      }

      counter++;
    }

    return p;
  }

  function getSlope(_x1, _y1, _x2, _y2) {
    return (_y2 - _y1) / (_x2 - _x1);
  }

  ;

  function findLableByLine(shape, point2) {
    var _modelObj$LabComClass4 = modelObj.LabComClass.Maths,
        getRandomNumber = _modelObj$LabComClass4.getRandomNumber,
        getPoint = _modelObj$LabComClass4.getPoint,
        getAngle = _modelObj$LabComClass4.getAngle,
        getDistance = _modelObj$LabComClass4.getDistance,
        getPointLineDistance = _modelObj$LabComClass4.getPointLineDistance;

    if (shape.labelX !== undefined) {
      var pos = getPixelByPoint(shape.labelX, shape.labelY);

      if (pos.x > modelObj.x && pos.x < modelObj.x + modelObj.width && pos.y > modelObj.y && pos.y < modelObj.y + modelObj.height) {
        var dist = getPointLineDistance({
          x: shape.labelX,
          y: shape.labelY
        }, shape, {
          x: shape.xTo,
          y: shape.yTo
        });

        if (Math.abs(dist) < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
          var nearbyPointFound = false;

          for (var i = 0; i < modelObj.interactionElements.length; i++) {
            var point = modelObj.interactionElements[i];

            if (point.type === 'point' && shape.label) {
              var _dist2 = getDistance({
                x: point.x + getPointUnitByPixelUnit(10),
                y: point.y - getPointUnitByPixelUnit(10)
              }, {
                x: shape.labelX,
                y: shape.labelY
              });

              if (_dist2 < getPointUnitByPixelUnit(modelObj.snappingDiff * 1.2)) {
                nearbyPointFound = true;
                break;
              }
            }
          }

          if (!nearbyPointFound) {
            return {
              x: shape.labelX,
              y: shape.labelY
            };
          }
        }
      }
    }

    var p1 = getPixelByPoint(shape.x, shape.y);
    var p2 = getPixelByPoint(point2.x, point2.y);
    var minX = modelObj.x + 30;
    var minY = modelObj.y + 30;
    var maxX = modelObj.x + modelObj.width - 30;
    var maxY = modelObj.y + modelObj.height - 30;
    var p = {
      x: 0,
      y: 0
    };
    var counter = 0;

    while (true) {
      var angle = getAngle(p1.x, p1.y, p2.x, p2.y);

      var _dist3 = getRandomNumber(-1 * (maxX - minX), maxX - minX, 1, 1);

      if (shape.type === 'ray') {
        _dist3 = Math.abs(_dist3);
      }

      p = getPoint(p1, angle, _dist3);

      if (p.x > minX && p.x < maxX && p.y > minY && p.y < maxY) {
        var breakIt = true;

        if (p.x > modelObj.centerX - 20 && p.x < modelObj.centerX + 20) {
          breakIt = false;
        }

        if (p.y > modelObj.centerY - 20 && p.y < modelObj.centerY + 20) {
          breakIt = false;
        }

        for (var _i10 = 0; _i10 < modelObj.interactionElements.length; _i10++) {
          var _shape = modelObj.interactionElements[_i10];

          if (_shape.type === 'point' && _shape.label) {
            var _dist4 = getDistance({
              x: _shape.x + getPointUnitByPixelUnit(10),
              y: _shape.y - getPointUnitByPixelUnit(10)
            }, p);

            if (_dist4 < getPointUnitByPixelUnit(modelObj.snappingDiff)) {
              breakIt = false;
            }
          }
        }

        if (breakIt) {
          break;
        }
      }

      if (counter > 200) {
        p.x = (p1.x + p2.x) / 2;
        p.y = (p1.y + p2.y) / 2;
        break;
      }

      counter++;
    }

    p = getPointByPixel(p.x, p.y);
    return p;
  }

  function updatePLinePoints(curInt) {
    var _modelObj$LabComClass5 = modelObj.LabComClass.Maths,
        getAngle = _modelObj$LabComClass5.getAngle,
        getPoint = _modelObj$LabComClass5.getPoint;
    var min = getPointByPixel(modelObj.x, modelObj.y);
    var max = getPointByPixel(modelObj.x + modelObj.width, modelObj.y + modelObj.height);
    var range = Math.abs(min.x) > Math.abs(max.x) ? Math.abs(min.x) : Math.abs(max.x);
    range *= 2;

    if (curInt.line !== undefined) {
      var shapeData = findShape(curInt.line);

      if (shapeData.shape) {
        var _d10 = shapeData.shape;
        var slope = getAngle(_d10.x, _d10.y, _d10.xTo, _d10.yTo);

        if (curInt.type === 'perpendicularLine') {
          slope += Math.PI / 2;
        }

        curInt.slope = slope;
      }
    }

    var _angle = curInt.slope;

    var _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, range);

    curInt.xOr = _newPoint.x;
    curInt.yOr = _newPoint.y;
    _newPoint = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle, 20);
    curInt.xTo = _newPoint.x;
    curInt.yTo = _newPoint.y;

    var _angle2 = curInt.slope + Math.PI;

    var _newPoint2 = getPoint({
      x: curInt.x,
      y: curInt.y
    }, _angle2, range);

    curInt.xOrTo = _newPoint2.x;
    curInt.yOrTo = _newPoint2.y;

    if (curInt.label) {
      var p = findLableByLine(curInt, {
        x: curInt.xTo,
        y: curInt.yTo
      });
      curInt.labelX = p.x;
      curInt.labelY = p.y;
    }
  } // =================================================


  function dispatchEventCustom(value) {
    var _obj = {};
    _obj.id = modelObj.id;
    _obj.type = 'geoInteraction';
    value = JSON.parse(JSON.stringify(value));
    value.type = modelObj.interactionType;
    _obj.data = value;

    if (typeof events[_obj.type] !== 'undefined') {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventCircleMove(value) {
    var _obj = {};
    _obj.id = modelObj.id;
    value.type = modelObj.interactionType;
    _obj.type = 'geoCircle';
    _obj.data = value;

    if (typeof events[_obj.type] !== 'undefined') {
      events[_obj.type](_obj, true);
    }
  } // =================================================


  function dispatchEventScale() {
    var value = {};
    value.id = modelObj.id;
    value.type = 'geoScale';
    value.length = modelObj.LabComClass.Maths.getDistance({
      x: scaleObj.x,
      y: scaleObj.y
    }, {
      x: scaleObj.xTo,
      y: scaleObj.yTo
    });

    if (typeof events[value.type] !== 'undefined') {
      events[value.type](value, true);
    }
  }
}
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";var e,i;function c(){return e.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function u(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function l(e){return void 0===e}function h(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function d(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function f(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function m(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function _(e,t){for(var n in t)m(t,n)&&(e[n]=t[n]);return m(t,"toString")&&(e.toString=t.toString),m(t,"valueOf")&&(e.valueOf=t.valueOf),e}function y(e,t,n,s){return Tt(e,t,n,s,!0).utc()}function g(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function v(e){if(null==e._isValid){var t=g(e),n=i.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function p(e){var t=y(NaN);return null!=e?_(g(t),e):g(t).userInvalidated=!0,t}i=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var r=c.momentProperties=[];function w(e,t){var n,s,i;if(l(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),l(t._i)||(e._i=t._i),l(t._f)||(e._f=t._f),l(t._l)||(e._l=t._l),l(t._strict)||(e._strict=t._strict),l(t._tzm)||(e._tzm=t._tzm),l(t._isUTC)||(e._isUTC=t._isUTC),l(t._offset)||(e._offset=t._offset),l(t._pf)||(e._pf=g(t)),l(t._locale)||(e._locale=t._locale),0<r.length)for(n=0;n<r.length;n++)l(i=t[s=r[n]])||(e[s]=i);return e}var t=!1;function M(e){w(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===t&&(t=!0,c.updateOffset(this),t=!1)}function k(e){return e instanceof M||null!=e&&null!=e._isAMomentObject}function S(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function D(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=S(t)),n}function a(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&D(e[s])!==D(t[s]))&&a++;return a+r}function Y(e){!1===c.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function n(i,r){var a=!0;return _(function(){if(null!=c.deprecationHandler&&c.deprecationHandler(null,i),a){for(var e,t=[],n=0;n<arguments.length;n++){if(e="","object"==typeof arguments[n]){for(var s in e+="\n["+n+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2)}else e=arguments[n];t.push(e)}Y(i+"\nArguments: "+Array.prototype.slice.call(t).join("")+"\n"+(new Error).stack),a=!1}return r.apply(this,arguments)},r)}var s,O={};function T(e,t){null!=c.deprecationHandler&&c.deprecationHandler(e,t),O[e]||(Y(t),O[e]=!0)}function b(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function x(e,t){var n,s=_({},e);for(n in t)m(t,n)&&(u(e[n])&&u(t[n])?(s[n]={},_(s[n],e[n]),_(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)m(e,n)&&!m(t,n)&&u(e[n])&&(s[n]=_({},s[n]));return s}function P(e){null!=e&&this.set(e)}c.suppressDeprecationWarnings=!1,c.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)m(e,t)&&n.push(t);return n};var W={};function C(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e}function H(e){return"string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function R(e){var t,n,s={};for(n in e)m(e,n)&&(t=H(n))&&(s[t]=e[n]);return s}var U={};function F(e,t){U[e]=t}function L(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(0<=e?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return L(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(s){var e,i,t,r=s.match(N);for(e=0,i=r.length;e<i;e++)E[r[e]]?r[e]=E[r[e]]:r[e]=(t=r[e]).match(/\[[\s\S]/)?t.replace(/^\[|\]$/g,""):t.replace(/\\/g,"");return function(e){var t,n="";for(t=0;t<i;t++)n+=b(r[t])?r[t].call(e,s):r[t];return n}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;0<=n&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,n,s){oe[e]=b(n)?n:function(e,t){return e&&s?s:n}}function le(e,t){return m(oe,e)?oe[e](t._strict,t._locale):new RegExp(he(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function he(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var de={};function ce(e,n){var t,s=n;for("string"==typeof e&&(e=[e]),h(n)&&(s=function(e,t){t[n]=D(e)}),t=0;t<e.length;t++)de[e[t]]=s}function fe(e,i){ce(e,function(e,t,n,s){n._w=n._w||{},i(e,n._w,n,s)})}var me=0,_e=1,ye=2,ge=3,ve=4,pe=5,we=6,Me=7,ke=8;function Se(e){return De(e)?366:365}function De(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),C("year","y"),F("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],me),ce("YYYY",function(e,t){t[me]=2===e.length?c.parseTwoDigitYear(e):D(e)}),ce("YY",function(e,t){t[me]=c.parseTwoDigitYear(e)}),ce("Y",function(e,t){t[me]=parseInt(e,10)}),c.parseTwoDigitYear=function(e){return D(e)+(68<D(e)?1900:2e3)};var Ye,Oe=Te("FullYear",!0);function Te(t,n){return function(e){return null!=e?(xe(this,t,e),c.updateOffset(this,n),this):be(this,t)}}function be(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function xe(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&De(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Pe(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function Pe(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?De(e)?29:28:31-s%7%2}Ye=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),C("month","M"),F("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[_e]=D(e)-1}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[_e]=i:g(n).invalidMonth=e});var We=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Ce="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var He="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Re(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=D(t);else if(!h(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),Pe(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Ue(e){return null!=e?(Re(this,e),c.updateOffset(this,!0),this):be(this,"Month")}var Fe=ae;var Le=ae;function Ne(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=y([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=he(s[t]),i[t]=he(i[t]);for(t=0;t<24;t++)r[t]=he(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Ge(e){var t;if(e<100&&0<=e){var n=Array.prototype.slice.call(arguments);n[0]=e+400,t=new Date(Date.UTC.apply(null,n)),isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e)}else t=new Date(Date.UTC.apply(null,arguments));return t}function Ve(e,t,n){var s=7+t-n;return-((7+Ge(e,0,s).getUTCDay()-t)%7)+s-1}function Ee(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ve(e,s,i);return a=o<=0?Se(r=e-1)+o:o>Se(e)?(r=e+1,o-Se(e)):(r=e,o),{year:r,dayOfYear:a}}function Ie(e,t,n){var s,i,r=Ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+Ae(i=e.year()-1,t,n):a>Ae(e.year(),t,n)?(s=a-Ae(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function Ae(e,t,n){var s=Ve(e,t,n),i=Ve(e+1,t,n);return(Se(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),C("week","w"),C("isoWeek","W"),F("week",5),F("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=D(e)});function je(e,t){return e.slice(t,7).concat(e.slice(0,t))}I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),C("day","d"),C("weekday","e"),C("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:g(n).invalidWeekday=e}),fe(["d","e","E"],function(e,t,n,s){t[s]=D(e)});var Ze="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var $e="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var qe=ae;var Je=ae;var Be=ae;function Qe(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=y([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=he(o[t]),u[t]=he(u[t]),l[t]=he(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Xe(){return this.hours()%12||12}function Ke(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function et(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Xe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)}),I("hmmss",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)+L(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+L(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+L(this.minutes(),2)+L(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),C("hour","h"),F("hour",13),ue("a",et),ue("A",et),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],ge),ce(["k","kk"],function(e,t,n){var s=D(e);t[ge]=24===s?0:s}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),ce(["h","hh"],function(e,t,n){t[ge]=D(e),g(n).bigHour=!0}),ce("hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s)),g(n).bigHour=!0}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i)),g(n).bigHour=!0}),ce("Hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s))}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i))});var tt,nt=Te("Hours",!0),st={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Ce,monthsShort:He,week:{dow:0,doy:6},weekdays:Ze,weekdaysMin:$e,weekdaysShort:ze,meridiemParse:/[ap]\.?m?\.?/i},it={},rt={};function at(e){return e?e.toLowerCase().replace("_","-"):e}function ot(e){var t=null;if(!it[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=tt._abbr,require("./locale/"+e),ut(t)}catch(e){}return it[e]}function ut(e,t){var n;return e&&((n=l(t)?ht(e):lt(e,t))?tt=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),tt._abbr}function lt(e,t){if(null===t)return delete it[e],null;var n,s=st;if(t.abbr=e,null!=it[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=it[e]._config;else if(null!=t.parentLocale)if(null!=it[t.parentLocale])s=it[t.parentLocale]._config;else{if(null==(n=ot(t.parentLocale)))return rt[t.parentLocale]||(rt[t.parentLocale]=[]),rt[t.parentLocale].push({name:e,config:t}),null;s=n._config}return it[e]=new P(x(s,t)),rt[e]&&rt[e].forEach(function(e){lt(e.name,e.config)}),ut(e),it[e]}function ht(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return tt;if(!o(e)){if(t=ot(e))return t;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=at(e[r]).split("-")).length,n=(n=at(e[r+1]))?n.split("-"):null;0<t;){if(s=ot(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&a(i,n,!0)>=t-1)break;t--}r++}return tt}(e)}function dt(e){var t,n=e._a;return n&&-2===g(e).overflow&&(t=n[_e]<0||11<n[_e]?_e:n[ye]<1||n[ye]>Pe(n[me],n[_e])?ye:n[ge]<0||24<n[ge]||24===n[ge]&&(0!==n[ve]||0!==n[pe]||0!==n[we])?ge:n[ve]<0||59<n[ve]?ve:n[pe]<0||59<n[pe]?pe:n[we]<0||999<n[we]?we:-1,g(e)._overflowDayOfYear&&(t<me||ye<t)&&(t=ye),g(e)._overflowWeeks&&-1===t&&(t=Me),g(e)._overflowWeekday&&-1===t&&(t=ke),g(e).overflow=t),e}function ct(e,t,n){return null!=e?e:null!=t?t:n}function ft(e){var t,n,s,i,r,a=[];if(!e._d){var o,u;for(o=e,u=new Date(c.now()),s=o._useUTC?[u.getUTCFullYear(),u.getUTCMonth(),u.getUTCDate()]:[u.getFullYear(),u.getMonth(),u.getDate()],e._w&&null==e._a[ye]&&null==e._a[_e]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ct(t.GG,e._a[me],Ie(bt(),1,4).year),s=ct(t.W,1),((i=ct(t.E,1))<1||7<i)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Ie(bt(),r,a);n=ct(t.gg,e._a[me],l.year),s=ct(t.w,l.week),null!=t.d?((i=t.d)<0||6<i)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||6<t.e)&&(u=!0)):i=r}s<1||s>Ae(n,r,a)?g(e)._overflowWeeks=!0:null!=u?g(e)._overflowWeekday=!0:(o=Ee(n,s,i,r,a),e._a[me]=o.year,e._dayOfYear=o.dayOfYear)}(e),null!=e._dayOfYear&&(r=ct(e._a[me],s[me]),(e._dayOfYear>Se(r)||0===e._dayOfYear)&&(g(e)._overflowDayOfYear=!0),n=Ge(r,0,e._dayOfYear),e._a[_e]=n.getUTCMonth(),e._a[ye]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=a[t]=s[t];for(;t<7;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ge]&&0===e._a[ve]&&0===e._a[pe]&&0===e._a[we]&&(e._nextDay=!0,e._a[ge]=0),e._d=(e._useUTC?Ge:function(e,t,n,s,i,r,a){var o;return e<100&&0<=e?(o=new Date(e+400,t,n,s,i,r,a),isFinite(o.getFullYear())&&o.setFullYear(e)):o=new Date(e,t,n,s,i,r,a),o}).apply(null,a),i=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ge]=24),e._w&&void 0!==e._w.d&&e._w.d!==i&&(g(e).weekdayMismatch=!0)}}var mt=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,yt=/Z|[+-]\d\d(?::?\d\d)?/,gt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],vt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],pt=/^\/?Date\((\-?\d+)/i;function wt(e){var t,n,s,i,r,a,o=e._i,u=mt.exec(o)||_t.exec(o);if(u){for(g(e).iso=!0,t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[1])){i=gt[t][0],s=!1!==gt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=vt.length;t<n;t++)if(vt[t][1].exec(u[3])){r=(u[2]||" ")+vt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!yt.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),Yt(e)}else e._isValid=!1}var Mt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function kt(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),He.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var St={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Dt(e){var t,n,s,i=Mt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(i){var r=kt(i[4],i[3],i[2],i[5],i[6],i[7]);if(t=i[1],n=r,s=e,t&&ze.indexOf(t)!==new Date(n[0],n[1],n[2]).getDay()&&(g(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=r,e._tzm=function(e,t,n){if(e)return St[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(i[8],i[9],i[10]),e._d=Ge.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),g(e).rfc2822=!0}else e._isValid=!1}function Yt(e){if(e._f!==c.ISO_8601)if(e._f!==c.RFC_2822){e._a=[],g(e).empty=!0;var t,n,s,i,r,a,o,u,l=""+e._i,h=l.length,d=0;for(s=j(e._f,e._locale).match(N)||[],t=0;t<s.length;t++)i=s[t],(n=(l.match(le(i,e))||[])[0])&&(0<(r=l.substr(0,l.indexOf(n))).length&&g(e).unusedInput.push(r),l=l.slice(l.indexOf(n)+n.length),d+=n.length),E[i]?(n?g(e).empty=!1:g(e).unusedTokens.push(i),a=i,u=e,null!=(o=n)&&m(de,a)&&de[a](o,u._a,u,a)):e._strict&&!n&&g(e).unusedTokens.push(i);g(e).charsLeftOver=h-d,0<l.length&&g(e).unusedInput.push(l),e._a[ge]<=12&&!0===g(e).bigHour&&0<e._a[ge]&&(g(e).bigHour=void 0),g(e).parsedDateParts=e._a.slice(0),g(e).meridiem=e._meridiem,e._a[ge]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):(null!=e.isPM&&((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0)),t)}(e._locale,e._a[ge],e._meridiem),ft(e),dt(e)}else Dt(e);else wt(e)}function Ot(e){var t,n,s,i,r=e._i,a=e._f;return e._locale=e._locale||ht(e._l),null===r||void 0===a&&""===r?p({nullInput:!0}):("string"==typeof r&&(e._i=r=e._locale.preparse(r)),k(r)?new M(dt(r)):(d(r)?e._d=r:o(a)?function(e){var t,n,s,i,r;if(0===e._f.length)return g(e).invalidFormat=!0,e._d=new Date(NaN);for(i=0;i<e._f.length;i++)r=0,t=w({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],Yt(t),v(t)&&(r+=g(t).charsLeftOver,r+=10*g(t).unusedTokens.length,g(t).score=r,(null==s||r<s)&&(s=r,n=t));_(e,n||t)}(e):a?Yt(e):l(n=(t=e)._i)?t._d=new Date(c.now()):d(n)?t._d=new Date(n.valueOf()):"string"==typeof n?(s=t,null===(i=pt.exec(s._i))?(wt(s),!1===s._isValid&&(delete s._isValid,Dt(s),!1===s._isValid&&(delete s._isValid,c.createFromInputFallback(s)))):s._d=new Date(+i[1])):o(n)?(t._a=f(n.slice(0),function(e){return parseInt(e,10)}),ft(t)):u(n)?function(e){if(!e._d){var t=R(e._i);e._a=f([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ft(e)}}(t):h(n)?t._d=new Date(n):c.createFromInputFallback(t),v(e)||(e._d=null),e))}function Tt(e,t,n,s,i){var r,a={};return!0!==n&&!1!==n||(s=n,n=void 0),(u(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||o(e)&&0===e.length)&&(e=void 0),a._isAMomentObject=!0,a._useUTC=a._isUTC=i,a._l=n,a._i=e,a._f=t,a._strict=s,(r=new M(dt(Ot(a))))._nextDay&&(r.add(1,"d"),r._nextDay=void 0),r}function bt(e,t,n,s){return Tt(e,t,n,s,!1)}c.createFromInputFallback=n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),c.ISO_8601=function(){},c.RFC_2822=function(){};var xt=n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:p()}),Pt=n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:p()});function Wt(e,t){var n,s;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return bt();for(n=t[0],s=1;s<t.length;++s)t[s].isValid()&&!t[s][e](n)||(n=t[s]);return n}var Ct=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ht(e){var t=R(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||t.isoWeek||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,h=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ye.call(Ct,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<Ct.length;++s)if(e[Ct[s]]){if(n)return!1;parseFloat(e[Ct[s]])!==D(e[Ct[s]])&&(n=!0)}return!0}(t),this._milliseconds=+h+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=ht(),this._bubble()}function Rt(e){return e instanceof Ht}function Ut(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ft(e,n){I(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+L(~~(e/60),2)+n+L(~~e%60,2)})}Ft("Z",":"),Ft("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Nt(re,e)});var Lt=/([\+\-]|\d\d)/gi;function Nt(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Lt)||["-",0,0],i=60*s[1]+D(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Gt(e,t){var n,s;return t._isUTC?(n=t.clone(),s=(k(e)||d(e)?e.valueOf():bt(e).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+s),c.updateOffset(n,!1),n):bt(e).local()}function Vt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Et(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}c.updateOffset=function(){};var It=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,At=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function jt(e,t){var n,s,i,r=e,a=null;return Rt(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:h(e)?(r={},t?r[t]=e:r.milliseconds=e):(a=It.exec(e))?(n="-"===a[1]?-1:1,r={y:0,d:D(a[ye])*n,h:D(a[ge])*n,m:D(a[ve])*n,s:D(a[pe])*n,ms:D(Ut(1e3*a[we]))*n}):(a=At.exec(e))?(n="-"===a[1]?-1:1,r={y:Zt(a[2],n),M:Zt(a[3],n),w:Zt(a[4],n),d:Zt(a[5],n),h:Zt(a[6],n),m:Zt(a[7],n),s:Zt(a[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Gt(t,e),e.isBefore(t)?n=zt(e,t):((n=zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(bt(r.from),bt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Ht(r),Rt(e)&&m(e,"_locale")&&(s._locale=e._locale),s}function Zt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function zt(e,t){var n={};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function $t(s,i){return function(e,t){var n;return null===t||isNaN(+t)||(T(i,"moment()."+i+"(period, number) is deprecated. Please use moment()."+i+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),n=e,e=t,t=n),qt(this,jt(e="string"==typeof e?+e:e,t),s),this}}function qt(e,t,n,s){var i=t._milliseconds,r=Ut(t._days),a=Ut(t._months);e.isValid()&&(s=null==s||s,a&&Re(e,be(e,"Month")+a*n),r&&xe(e,"Date",be(e,"Date")+r*n),i&&e._d.setTime(e._d.valueOf()+i*n),s&&c.updateOffset(e,r||a))}jt.fn=Ht.prototype,jt.invalid=function(){return jt(NaN)};var Jt=$t(1,"add"),Bt=$t(-1,"subtract");function Qt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return-(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Xt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=ht(e))&&(this._locale=t),this)}c.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",c.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Kt=n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function en(){return this._locale}var tn=126227808e5;function nn(e,t){return(e%t+t)%t}function sn(e,t,n){return e<100&&0<=e?new Date(e+400,t,n)-tn:new Date(e,t,n).valueOf()}function rn(e,t,n){return e<100&&0<=e?Date.UTC(e+400,t,n)-tn:Date.UTC(e,t,n)}function an(e,t){I(0,[e,e.length],0,t)}function on(e,t,n,s,i){var r;return null==e?Ie(this,s,i).year:((r=Ae(e,s,i))<t&&(t=r),function(e,t,n,s,i){var r=Ee(e,t,n,s,i),a=Ge(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),an("gggg","weekYear"),an("ggggg","weekYear"),an("GGGG","isoWeekYear"),an("GGGGG","isoWeekYear"),C("weekYear","gg"),C("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=D(e)}),fe(["gg","GG"],function(e,t,n,s){t[s]=c.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),C("quarter","Q"),F("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[_e]=3*(D(e)-1)}),I("D",["DD",2],"Do","date"),C("date","D"),F("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ye),ce("Do",function(e,t){t[ye]=D(e.match(B)[0])});var un=Te("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),C("dayOfYear","DDD"),F("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=D(e)}),I("m",["mm",2],0,"minute"),C("minute","m"),F("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],ve);var ln=Te("Minutes",!1);I("s",["ss",2],0,"second"),C("second","s"),F("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],pe);var hn,dn=Te("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),C("millisecond","ms"),F("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),hn="SSSS";hn.length<=9;hn+="S")ue(hn,ne);function cn(e,t){t[we]=D(1e3*("0."+e))}for(hn="S";hn.length<=9;hn+="S")ce(hn,cn);var fn=Te("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var mn=M.prototype;function _n(e){return e}mn.add=Jt,mn.calendar=function(e,t){var n=e||bt(),s=Gt(n,this).startOf("day"),i=c.calendarFormat(this,s)||"sameElse",r=t&&(b(t[i])?t[i].call(this,n):t[i]);return this.format(r||this.localeData().calendar(i,this,bt(n)))},mn.clone=function(){return new M(this)},mn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Gt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=H(t)){case"year":r=Qt(this,s)/12;break;case"month":r=Qt(this,s);break;case"quarter":r=Qt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:S(r)},mn.endOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year()+1,0,1)-1;break;case"quarter":t=n(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":t=n(this.year(),this.month()+1,1)-1;break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":t=n(this.year(),this.month(),this.date()+1)-1;break;case"hour":t=this._d.valueOf(),t+=36e5-nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5)-1;break;case"minute":t=this._d.valueOf(),t+=6e4-nn(t,6e4)-1;break;case"second":t=this._d.valueOf(),t+=1e3-nn(t,1e3)-1;break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.format=function(e){e||(e=this.isUtc()?c.defaultFormatUtc:c.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},mn.from=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.fromNow=function(e){return this.from(bt(),e)},mn.to=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.toNow=function(e){return this.to(bt(),e)},mn.get=function(e){return b(this[e=H(e)])?this[e]():this},mn.invalidAt=function(){return g(this).overflow},mn.isAfter=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},mn.isBefore=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},mn.isBetween=function(e,t,n,s){var i=k(e)?e:bt(e),r=k(t)?t:bt(t);return!!(this.isValid()&&i.isValid()&&r.isValid())&&("("===(s=s||"()")[0]?this.isAfter(i,n):!this.isBefore(i,n))&&(")"===s[1]?this.isBefore(r,n):!this.isAfter(r,n))},mn.isSame=function(e,t){var n,s=k(e)?e:bt(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},mn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},mn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},mn.isValid=function(){return v(this)},mn.lang=Kt,mn.locale=Xt,mn.localeData=en,mn.max=Pt,mn.min=xt,mn.parsingFlags=function(){return _({},g(this))},mn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:U[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=R(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(b(this[e=H(e)]))return this[e](t);return this},mn.startOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year(),0,1);break;case"quarter":t=n(this.year(),this.month()-this.month()%3,1);break;case"month":t=n(this.year(),this.month(),1);break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":t=n(this.year(),this.month(),this.date());break;case"hour":t=this._d.valueOf(),t-=nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5);break;case"minute":t=this._d.valueOf(),t-=nn(t,6e4);break;case"second":t=this._d.valueOf(),t-=nn(t,1e3);break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.subtract=Bt,mn.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},mn.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},mn.toDate=function(){return new Date(this.valueOf())},mn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||9999<n.year()?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):b(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},mn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},mn.toJSON=function(){return this.isValid()?this.toISOString():null},mn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},mn.unix=function(){return Math.floor(this.valueOf()/1e3)},mn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},mn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},mn.year=Oe,mn.isLeapYear=function(){return De(this.year())},mn.weekYear=function(e){return on.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},mn.isoWeekYear=function(e){return on.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},mn.quarter=mn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},mn.month=Ue,mn.daysInMonth=function(){return Pe(this.year(),this.month())},mn.week=mn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},mn.isoWeek=mn.isoWeeks=function(e){var t=Ie(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},mn.weeksInYear=function(){var e=this.localeData()._week;return Ae(this.year(),e.dow,e.doy)},mn.isoWeeksInYear=function(){return Ae(this.year(),1,4)},mn.date=un,mn.day=mn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t,n,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(t=e,n=this.localeData(),e="string"!=typeof t?t:isNaN(t)?"number"==typeof(t=n.weekdaysParse(t))?t:null:parseInt(t,10),this.add(e-s,"d")):s},mn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},mn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null==e)return this.day()||7;var t,n,s=(t=e,n=this.localeData(),"string"==typeof t?n.weekdaysParse(t)%7||7:isNaN(t)?null:t);return this.day(this.day()%7?s:s-7)},mn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},mn.hour=mn.hours=nt,mn.minute=mn.minutes=ln,mn.second=mn.seconds=dn,mn.millisecond=mn.milliseconds=fn,mn.utcOffset=function(e,t,n){var s,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null==e)return this._isUTC?i:Vt(this);if("string"==typeof e){if(null===(e=Nt(re,e)))return this}else Math.abs(e)<16&&!n&&(e*=60);return!this._isUTC&&t&&(s=Vt(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==e&&(!t||this._changeInProgress?qt(this,jt(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,c.updateOffset(this,!0),this._changeInProgress=null)),this},mn.utc=function(e){return this.utcOffset(0,e)},mn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Vt(this),"m")),this},mn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Nt(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},mn.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?bt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},mn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},mn.isLocal=function(){return!!this.isValid()&&!this._isUTC},mn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},mn.isUtc=Et,mn.isUTC=Et,mn.zoneAbbr=function(){return this._isUTC?"UTC":""},mn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},mn.dates=n("dates accessor is deprecated. Use date instead.",un),mn.months=n("months accessor is deprecated. Use month instead",Ue),mn.years=n("years accessor is deprecated. Use year instead",Oe),mn.zone=n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),mn.isDSTShifted=n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!l(this._isDSTShifted))return this._isDSTShifted;var e={};if(w(e,this),(e=Ot(e))._a){var t=e._isUTC?y(e._a):bt(e._a);this._isDSTShifted=this.isValid()&&0<a(e._a,t.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted});var yn=P.prototype;function gn(e,t,n,s){var i=ht(),r=y().set(s,t);return i[n](r,e)}function vn(e,t,n){if(h(e)&&(t=e,e=void 0),e=e||"",null!=t)return gn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=gn(e,s,n,"month");return i}function pn(e,t,n,s){t=("boolean"==typeof e?h(t)&&(n=t,t=void 0):(t=e,e=!1,h(n=t)&&(n=t,t=void 0)),t||"");var i,r=ht(),a=e?r._week.dow:0;if(null!=n)return gn(t,(n+a)%7,s,"day");var o=[];for(i=0;i<7;i++)o[i]=gn(t,(i+a)%7,s,"day");return o}yn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return b(s)?s.call(t,n):s},yn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},yn.invalidDate=function(){return this._invalidDate},yn.ordinal=function(e){return this._ordinal.replace("%d",e)},yn.preparse=_n,yn.postformat=_n,yn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return b(i)?i(e,t,n,s):i.replace(/%d/i,e)},yn.pastFuture=function(e,t){var n=this._relativeTime[0<e?"future":"past"];return b(n)?n(t):n.replace(/%s/i,t)},yn.set=function(e){var t,n;for(n in e)b(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},yn.months=function(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||We).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone},yn.monthsShort=function(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[We.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},yn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=y([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=y([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},yn.monthsRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsStrictRegex:this._monthsRegex):(m(this,"_monthsRegex")||(this._monthsRegex=Le),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},yn.monthsShortRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(m(this,"_monthsShortRegex")||(this._monthsShortRegex=Fe),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},yn.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},yn.firstDayOfYear=function(){return this._week.doy},yn.firstDayOfWeek=function(){return this._week.dow},yn.weekdays=function(e,t){var n=o(this._weekdays)?this._weekdays:this._weekdays[e&&!0!==e&&this._weekdays.isFormat.test(t)?"format":"standalone"];return!0===e?je(n,this._week.dow):e?n[e.day()]:n},yn.weekdaysMin=function(e){return!0===e?je(this._weekdaysMin,this._week.dow):e?this._weekdaysMin[e.day()]:this._weekdaysMin},yn.weekdaysShort=function(e){return!0===e?je(this._weekdaysShort,this._week.dow):e?this._weekdaysShort[e.day()]:this._weekdaysShort},yn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=y([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=y([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},yn.weekdaysRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(m(this,"_weekdaysRegex")||(this._weekdaysRegex=qe),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},yn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(m(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Je),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},yn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(m(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Be),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},yn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},yn.meridiem=function(e,t,n){return 11<e?n?"pm":"PM":n?"am":"AM"},ut("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===D(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),c.lang=n("moment.lang is deprecated. Use moment.locale instead.",ut),c.langData=n("moment.langData is deprecated. Use moment.localeData instead.",ht);var wn=Math.abs;function Mn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function kn(e){return e<0?Math.floor(e):Math.ceil(e)}function Sn(e){return 4800*e/146097}function Dn(e){return 146097*e/4800}function Yn(e){return function(){return this.as(e)}}var On=Yn("ms"),Tn=Yn("s"),bn=Yn("m"),xn=Yn("h"),Pn=Yn("d"),Wn=Yn("w"),Cn=Yn("M"),Hn=Yn("Q"),Rn=Yn("y");function Un(e){return function(){return this.isValid()?this._data[e]:NaN}}var Fn=Un("milliseconds"),Ln=Un("seconds"),Nn=Un("minutes"),Gn=Un("hours"),Vn=Un("days"),En=Un("months"),In=Un("years");var An=Math.round,jn={ss:44,s:45,m:45,h:22,d:26,M:11};var Zn=Math.abs;function zn(e){return(0<e)-(e<0)||+e}function $n(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Zn(this._milliseconds)/1e3,s=Zn(this._days),i=Zn(this._months);t=S((e=S(n/60))/60),n%=60,e%=60;var r=S(i/12),a=i%=12,o=s,u=t,l=e,h=n?n.toFixed(3).replace(/\.?0+$/,""):"",d=this.asSeconds();if(!d)return"P0D";var c=d<0?"-":"",f=zn(this._months)!==zn(d)?"-":"",m=zn(this._days)!==zn(d)?"-":"",_=zn(this._milliseconds)!==zn(d)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||h?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(h?_+h+"S":"")}var qn=Ht.prototype;return qn.isValid=function(){return this._isValid},qn.abs=function(){var e=this._data;return this._milliseconds=wn(this._milliseconds),this._days=wn(this._days),this._months=wn(this._months),e.milliseconds=wn(e.milliseconds),e.seconds=wn(e.seconds),e.minutes=wn(e.minutes),e.hours=wn(e.hours),e.months=wn(e.months),e.years=wn(e.years),this},qn.add=function(e,t){return Mn(this,e,t,1)},qn.subtract=function(e,t){return Mn(this,e,t,-1)},qn.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=H(e))||"quarter"===e||"year"===e)switch(t=this._days+s/864e5,n=this._months+Sn(t),e){case"month":return n;case"quarter":return n/3;case"year":return n/12}else switch(t=this._days+Math.round(Dn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},qn.asMilliseconds=On,qn.asSeconds=Tn,qn.asMinutes=bn,qn.asHours=xn,qn.asDays=Pn,qn.asWeeks=Wn,qn.asMonths=Cn,qn.asQuarters=Hn,qn.asYears=Rn,qn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*D(this._months/12):NaN},qn._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return 0<=r&&0<=a&&0<=o||r<=0&&a<=0&&o<=0||(r+=864e5*kn(Dn(o)+a),o=a=0),u.milliseconds=r%1e3,e=S(r/1e3),u.seconds=e%60,t=S(e/60),u.minutes=t%60,n=S(t/60),u.hours=n%24,o+=i=S(Sn(a+=S(n/24))),a-=kn(Dn(i)),s=S(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},qn.clone=function(){return jt(this)},qn.get=function(e){return e=H(e),this.isValid()?this[e+"s"]():NaN},qn.milliseconds=Fn,qn.seconds=Ln,qn.minutes=Nn,qn.hours=Gn,qn.days=Vn,qn.weeks=function(){return S(this.days()/7)},qn.months=En,qn.years=In,qn.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t,n,s,i,r,a,o,u,l,h,d,c=this.localeData(),f=(n=!e,s=c,i=jt(t=this).abs(),r=An(i.as("s")),a=An(i.as("m")),o=An(i.as("h")),u=An(i.as("d")),l=An(i.as("M")),h=An(i.as("y")),(d=r<=jn.ss&&["s",r]||r<jn.s&&["ss",r]||a<=1&&["m"]||a<jn.m&&["mm",a]||o<=1&&["h"]||o<jn.h&&["hh",o]||u<=1&&["d"]||u<jn.d&&["dd",u]||l<=1&&["M"]||l<jn.M&&["MM",l]||h<=1&&["y"]||["yy",h])[2]=n,d[3]=0<+t,d[4]=s,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d));return e&&(f=c.pastFuture(+this,f)),c.postformat(f)},qn.toISOString=$n,qn.toString=$n,qn.toJSON=$n,qn.locale=Xt,qn.localeData=en,qn.toIsoString=n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",$n),qn.lang=Kt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),ce("x",function(e,t,n){n._d=new Date(D(e))}),c.version="2.24.0",e=bt,c.fn=mn,c.min=function(){return Wt("isBefore",[].slice.call(arguments,0))},c.max=function(){return Wt("isAfter",[].slice.call(arguments,0))},c.now=function(){return Date.now?Date.now():+new Date},c.utc=y,c.unix=function(e){return bt(1e3*e)},c.months=function(e,t){return vn(e,t,"months")},c.isDate=d,c.locale=ut,c.invalid=p,c.duration=jt,c.isMoment=k,c.weekdays=function(e,t,n){return pn(e,t,n,"weekdays")},c.parseZone=function(){return bt.apply(null,arguments).parseZone()},c.localeData=ht,c.isDuration=Rt,c.monthsShort=function(e,t){return vn(e,t,"monthsShort")},c.weekdaysMin=function(e,t,n){return pn(e,t,n,"weekdaysMin")},c.defineLocale=lt,c.updateLocale=function(e,t){if(null!=t){var n,s,i=st;null!=(s=ot(e))&&(i=s._config),(n=new P(t=x(i,t))).parentLocale=it[e],it[e]=n,ut(e)}else null!=it[e]&&(null!=it[e].parentLocale?it[e]=it[e].parentLocale:null!=it[e]&&delete it[e]);return it[e]},c.locales=function(){return s(it)},c.weekdaysShort=function(e,t,n){return pn(e,t,n,"weekdaysShort")},c.normalizeUnits=H,c.relativeTimeRounding=function(e){return void 0===e?An:"function"==typeof e&&(An=e,!0)},c.relativeTimeThreshold=function(e,t){return void 0!==jn[e]&&(void 0===t?jn[e]:(jn[e]=t,"s"===e&&(jn.ss=t-1),!0))},c.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},c.prototype=mn,c.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},c});
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function PanelCompClass(_obj) {
  var modelObj = {
    visible: true
  };
  var events = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------

  setDefaultValues(); // --------------------

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.show = function () {
    modelObj.visible = true;
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
  }; // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================
  // =================================================


  this.draw = function () {}; // =================================================
  // PRIVATE SECTION
  // =================================================


  function setDefaultValues() {
    modelObj.LabComClass.setHeader(modelObj.LabComClass.globalLangText[modelObj.headText]);
  }
}
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
  512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
  454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
  482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
  437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
  497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
  320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
  446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
  329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
  505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
  399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
  324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
  268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
  451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
  385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
  332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
  289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];


var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
  17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
  19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
  20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
  22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
  22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];

function stackBlurImage(imageID, canvasID, radius, blurAlphaChannel, xx, yy, ww, hh) {

 	/* var img = document.getElementById( imageID );
	var w = img.naturalWidth;
    var h = img.naturalHeight; */

  var canvas = document.getElementsByClassName(canvasID)[0];

    /* canvas.style.width  = w + "px";
    canvas.style.height = h + "px";
    canvas.width = w;
    canvas.height = h; */

//   var context = canvas.getContext('2d');
    // context.clearRect( 0, 0, w, h );
    // context.drawImage( img, 0, 0 );

  if (isNaN(radius) || radius < 1) return;

  if (blurAlphaChannel) { stackBlurCanvasRGBA(canvasID, xx, yy, ww, hh, radius); } else		{ stackBlurCanvasRGB(canvasID, xx, yy, ww, hh, radius); }
}


function stackBlurCanvasRGBA(id, top_x, top_y, width, height, radius) {
  if (isNaN(radius) || radius < 1) return;
  radius |= 0;

  var canvas = document.getElementsByClassName(id);
  var context = canvas.getContext('2d');
  var imageData;

  try {
	  try {
    imageData = context.getImageData(top_x, top_y, width, height);
	  } catch (e) {

		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
    try {
      netscape.security.PrivilegeManager.enablePrivilege('UniversalBrowserRead');
      imageData = context.getImageData(top_x, top_y, width, height);
    } catch (e) {
      alert('Cannot access local image');
      throw new Error('unable to access local image data: ' + e);
      return;
    }
	  }
  } catch (e) {
	  alert('Cannot access image');
	  throw new Error('unable to access image data: ' + e);
  }

  var pixels = imageData.data;

  var x,
    y,
    i,
    p,
    yp,
    yi,
    yw,
    r_sum,
    g_sum,
    b_sum,
    a_sum,
    r_out_sum,
    g_out_sum,
    b_out_sum,
    a_out_sum,
    r_in_sum,
    g_in_sum,
    b_in_sum,
    a_in_sum,
    pr,
    pg,
    pb,
    pa,
    rbs;

  var div = radius + radius + 1;
  var w4 = width << 2;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

  var stackStart = new BlurStack();
  var stack = stackStart;
  for (i = 1; i < div; i++)	{
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1) var stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;

  yw = yi = 0;

  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];

  for (y = 0; y < height; y++)	{
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    for (i = 1; i < radiusPlus1; i++)		{
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;
      a_sum += (stack.a = (pa = pixels[p + 3])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;
    }


    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++)		{
      pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
      if (pa != 0)			{
        pa = 255 / pa;
        pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

      r_in_sum += (stackIn.r = pixels[p]);
      g_in_sum += (stackIn.g = pixels[p + 1]);
      b_in_sum += (stackIn.b = pixels[p + 2]);
      a_in_sum += (stackIn.a = pixels[p + 3]);

      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);
      a_out_sum += (pa = stackOut.a);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += 4;
    }
    yw += width;
  }


  for (x = 0; x < width; x++)	{
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    yp = width;

    for (i = 1; i <= radius; i++)		{
      yi = (yp + x) << 2;

      r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;
      a_sum += (stack.a = (pa = pixels[yi + 3])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;

      if (i < heightMinus1)			{
        yp += width;
      }
    }

    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++)		{
      p = yi << 2;
      pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
      if (pa > 0)			{
        pa = 255 / pa;
        pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
        pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
        pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
      } else {
        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

      r_sum += (r_in_sum += (stackIn.r = pixels[p]));
      g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
      b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));
      a_sum += (a_in_sum += (stackIn.a = pixels[p + 3]));

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);
      a_out_sum += (pa = stackOut.a);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += width;
    }
  }

  context.putImageData(imageData, top_x, top_y);

}


function stackBlurCanvasRGB(id, top_x, top_y, width, height, radius) {
  if (isNaN(radius) || radius < 1) return;
  radius |= 0;

  var canvas = document.getElementsByClassName(id)[0];
  var context = canvas.getContext('2d');
  var imageData;

  try {
	  try {
    imageData = context.getImageData(top_x, top_y, width, height);
	  } catch (e) {

		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
    try {
      netscape.security.PrivilegeManager.enablePrivilege('UniversalBrowserRead');
      imageData = context.getImageData(top_x, top_y, width, height);
    } catch (e) {
      alert('Cannot access local image');
      throw new Error('unable to access local image data: ' + e);
      return;
    }
	  }
  } catch (e) {
	  alert('Cannot access image');
	  throw new Error('unable to access image data: ' + e);
  }

  var pixels = imageData.data;

  var x,
    y,
    i,
    p,
    yp,
    yi,
    yw,
    r_sum,
    g_sum,
    b_sum,
    r_out_sum,
    g_out_sum,
    b_out_sum,
    r_in_sum,
    g_in_sum,
    b_in_sum,
    pr,
    pg,
    pb,
    rbs;

  var div = radius + radius + 1;
  var w4 = width << 2;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

  var stackStart = new BlurStack();
  var stack = stackStart;
  for (i = 1; i < div; i++)	{
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1) var stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;

  yw = yi = 0;

  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];

  for (y = 0; y < height; y++)	{
    r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;

    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }

    for (i = 1; i < radiusPlus1; i++)		{
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;

      stack = stack.next;
    }


    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++)		{
      pixels[yi] = (r_sum * mul_sum) >> shg_sum;
      pixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;
      pixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;

      p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

      r_in_sum += (stackIn.r = pixels[p]);
      g_in_sum += (stackIn.g = pixels[p + 1]);
      b_in_sum += (stackIn.b = pixels[p + 2]);

      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;

      stackOut = stackOut.next;

      yi += 4;
    }
    yw += width;
  }


  for (x = 0; x < width; x++)	{
    g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;

    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++)		{
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }

    yp = width;

    for (i = 1; i <= radius; i++)		{
      yi = (yp + x) << 2;

      r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
      b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;

      stack = stack.next;

      if (i < heightMinus1)			{
        yp += width;
      }
    }

    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++)		{
      p = yi << 2;
      pixels[p] = (r_sum * mul_sum) >> shg_sum;
      pixels[p + 1] = (g_sum * mul_sum) >> shg_sum;
      pixels[p + 2] = (b_sum * mul_sum) >> shg_sum;

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;

      p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

      r_sum += (r_in_sum += (stackIn.r = pixels[p]));
      g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
      b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));

      stackIn = stackIn.next;

      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;

      stackOut = stackOut.next;

      yi += width;
    }
  }

  context.putImageData(imageData, top_x, top_y);

}

function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;


}








"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function FreeToolPanelEnglishCompClass(_obj) {
  var events = {};
  var modelObj = {
    x: 21,
    y: 612,
    width: 296,
    height: 100,
    shapeTopMargin: 15,
    pointRadius: 4,
    visible: true,
    enabled: true,
    selected: 'move',
    baseColor: 'rgba(255,255,255,1)',
    textSelectedColor: 'rgba(73,124,190,1)',
    textColor: 'rgba(170,170,166,1)',
    selColor: 'rgba(73,124,190,1)',
    lineColor: 'rgba(73,124,190,1)',
    circleColor: 'rgba(73,124,190,1)',
    disableColor: 'rgba(73,124,190,1)',
    redColor: 'rgba(255,0,0,1)',
    fontSize: 16,
    maxWidth: 100,
    textPadding: 10,
    trangleW: 8,
    slidePercent: 0,
    trangleH: 9,
    sliderLeftPadding: -20,
    gap: 9,
    stepsBar: {
      currentStep: 0,
      x: 105,
      y: 313,
      h: 100,
      w: 100,
      text: 'steps'
    },
    totalHeight: 49,
    values: {
      rowCount: 1,
      height: 66,
      width: 300,
      padding: 21,
      textAlign: 'left',
      border: 'rgba(255,255,255,1)',
      data: [],
      fontColor: 'rgba(35,35,35,1)',
      fillColor: ['rgba(224,224,224,1)'],
      counterBoxW: 54,
      textW: 195,
      helpBtn: {
        x: 239,
        y: 14,
        w: 27,
        h: 26
      },
      checkBoxBtn: {
        x: 239,
        y: 14,
        w: 27,
        h: 26
      }
    },
    buttons: {
      'move': {
        text: 'move',
        info: 'moveInfo',
        maxWidth: 375
      },
      'point': {
        text: 'point',
        maxWidth: 375
      },
      'segment': {
        text: 'segment',
        maxWidth: 375
      },
      'segmentDash': {
        text: 'segment',
        maxWidth: 375
      },
      'ray': {
        text: 'ray',
        maxWidth: 375
      },
      'line': {
        text: 'line',
        maxWidth: 375
      },
      'angleRay': {
        text: 'angleRay',
        maxWidth: 375
      },
      'angle': {
        text: 'angle',
        maxWidth: 375
      },
      'triangle': {
        text: 'triangle',
        maxWidth: 375
      },
      'parallelLine': {
        text: 'parallelLine',
        maxWidth: 375
      },
      'perpendicularLine': {
        text: 'perpendicularLine',
        maxWidth: 375
      },
      'circle': {
        text: 'circle',
        maxWidth: 375
      },
      'compass': {
        text: 'compass',
        maxWidth: 375
      },
      'circle_3': {
        text: 'circle_3',
        maxWidth: 375
      },
      'length': {
        text: 'length',
        maxWidth: 375
      },
      'angleB': {
        text: 'length',
        maxWidth: 375
      },
      'midPoint': {
        text: 'length',
        maxWidth: 375
      },
      'perpendicularBisector': {
        text: 'length',
        maxWidth: 375
      },
      'angleSize': {
        text: 'angleSize',
        maxWidth: 375
      },
      'segSize': {
        text: 'angleSize',
        maxWidth: 375
      },
      'circleSize': {
        text: 'circleSize',
        maxWidth: 375
      },
      'brush1': {
        text: 'brush1',
        color: 'rgba(0,0,0,1)',
        maxWidth: 375
      },
      'delete': {
        text: 'deleteTool',
        maxWidth: 375
      },
      'mirrorOnPoint': {
        text: 'length',
        maxWidth: 375
      },
      'brush2': {
        text: 'brush2',
        color: 'rgba(222,108,225,1)',
        maxWidth: 375
      },
      'brush3': {
        text: 'brush3',
        color: 'rgba(255,204,0,1)',
        maxWidth: 375
      },
      'mirrorOnLine': {
        text: 'mirrorOnLine',
        maxWidth: 375
      },
      'square': {
        text: 'mirrorOnLine',
        maxWidth: 375
      },
      'select': {
        text: 'select',
        maxWidth: 375
      },
      'labelTool': {
        text: 'select',
        maxWidth: 375
      }
    },
    newbuttons: {
      General: {
        'move': {
          text: 'move',
          info: 'moveInfo',
          maxWidth: 375
        },
        'select': {
          text: 'select',
          maxWidth: 375
        },
        'labelTool': {
          text: 'labelTool',
          maxWidth: 375
        },
        'point': {
          text: 'point',
          maxWidth: 375
        },
        'length': {
          text: 'length',
          maxWidth: 375
        },
        'delete': {
          text: 'delete',
          maxWidth: 375
        }
      },
      Lines: {
        'segment': {
          text: 'segment',
          maxWidth: 375
        },
        'segmentDash': {
          text: 'segment',
          maxWidth: 375
        },
        'segSize': {
          text: 'angleSize',
          maxWidth: 375
        },
        'ray': {
          text: 'ray',
          maxWidth: 375
        },
        'line': {
          text: 'line',
          maxWidth: 375
        }
      },
      Circles: {
        'circle': {
          text: 'circle',
          maxWidth: 375
        },
        'circleSize': {
          text: 'circleSize',
          maxWidth: 375
        },
        'circle_3': {
          text: 'circle_3',
          maxWidth: 375
        },
        'compass': {
          text: 'compass',
          maxWidth: 375
        }
      },
      Angles: {
        'angleRay': {
          text: 'angleRay',
          maxWidth: 375
        },
        'angleSize': {
          text: 'angleSize',
          maxWidth: 375
        },
        'angle': {
          text: 'angle',
          maxWidth: 375
        }
      },
      Constructions: {
        'perpendicularLine': {
          text: 'perpendicularLine',
          maxWidth: 375
        },
        'parallelLine': {
          text: 'parallelLine',
          maxWidth: 375
        },
        'mirrorOnPoint': {
          text: 'length',
          maxWidth: 375
        },
        'mirrorOnLine': {
          text: 'mirrorOnLine',
          maxWidth: 375
        },
        'midPoint': {
          text: 'length',
          maxWidth: 375
        },
        'perpendicularBisector': {
          text: 'length',
          maxWidth: 375
        },
        'angleB': {
          text: 'length',
          maxWidth: 375
        }
      },
      Figures: {
        'triangle': {
          text: 'triangle',
          maxWidth: 375
        },
        'square': {
          text: 'mirrorOnLine',
          maxWidth: 375
        }
      },
      Dye: {
        'brush5': {
          text: 'brush5',
          color: 'rgba(10,190,220,1)',
          maxWidth: 375
        },
        'brush2': {
          text: 'brush2',
          color: 'rgba(222,108,225,1)',
          maxWidth: 375
        },
        'brush3': {
          text: 'brush3',
          color: 'rgba(255,204,0,1)',
          maxWidth: 375
        },
        'brush1': {
          text: 'brush1',
          color: 'rgba(0,0,0,1)',
          maxWidth: 375
        },
        'brush7': {
          text: 'brush5',
          color: '#CFCFCF',
          maxWidth: 375
        },
        'brush4': {
          text: 'brush4',
          color: 'rgba(50,205,50,1)',
          maxWidth: 375
        },
        'brush6': {
          text: 'brush5',
          color: 'rgba(255,0,0,1)',
          maxWidth: 375
        }
      }
    }
  };
  var localObj = {
    isPressed: false,
    isHover: false,
    padding: 20,
    toolpanelY: 0,
    hoverOn: null,
    defaultRowCount: 2,
    defaultHeight: 300,
    defaultRowHeight: 42,
    pivotPoint: {
      x: null,
      y: null
    },
    slider: {
      gap: 3,
      width: 12,
      base: {
        width: 20
      },
      knob: {
        x: null,
        y: null,
        height: 30
      }
    },
    leftArrowPos: {},
    rightArrowPos: {},
    slideArrowPos: {},
    arrowW: 15,
    leftArrowEnable: true,
    rightArrowEnable: true,
    slideArrowEnable: true,
    showSteps: false
  };

  var _this = this;

  setDefaults();
  setData(modelObj, _obj);

  function setData(source, data) {
    if (data && _typeof(data) === 'object' && !Array.isArray(data)) {
      Object.keys(data).forEach(function (i) {
        if (source.hasOwnProperty(i) && _typeof(data[i]) === 'object' && !Array.isArray(data[i])) {
          setData(source[i], data[i]);
        } else {
          source[i] = data[i];
        }
      });
    } else {
      source = data;
    }
  }

  Object.keys(modelObj.newbuttons).forEach(function (i) {
    Object.keys(modelObj.newbuttons[i]).forEach(function (j) {
      modelObj.newbuttons[i][j].toolTipInverted = false;
    });
  }); // --------------------

  calculateRows();
  modelObj.fontFamily = modelObj.LabComClass.polo22KlettRegular;
  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // --------------------

  calculatePos(); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.getVisible = function () {
    return modelObj.visible;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  };

  this.getSize = function () {
    return {
      width: modelObj.width,
      height: modelObj.height
    };
  }; // =================================================


  this.enable = function () {
    modelObj.enabled = true;
    addEvents();
  };

  this.reset = function () {
    modelObj.selected = 'move';

    _this.enable();
  };

  this.disable = function () {
    modelObj.enabled = false;
    addEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  };

  this.setPos = function (_obj) {
    updateValues(_obj, 'x', 'y');
    addEvents();
  };

  function updateValues(_data) {
    for (var _len = arguments.length, key = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      key[_key - 1] = arguments[_key];
    }

    key.forEach(function (i) {
      if (_data[i] !== undefined) {
        modelObj[i] = _data[i];
      }
    });
  } // =================================================


  this.getEnabled = function () {
    return modelObj.enabled;
  }; // =================================================


  this.setSelected = function (_bool) {
    modelObj.selected = _bool;
  }; // =================================================


  this.getSelected = function () {
    return modelObj.selected;
  }; // =================================================


  this.draw = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;

      _ctx.save(); // Object.keys(modelObj.buttons).forEach((i) => {
      //   if (modelObj.buttons[i].visible) {
      //     drawTool(_ctx, modelObj.buttons[i]);
      //     if (modelObj.buttons[i].base && modelObj.buttons[i].type === localObj.hoverOn) {
      //       drawToolTip(modelObj.buttons[i]);
      //     }
      //   }
      // });


      _ctx.save();

      _ctx.beginPath();

      _ctx.fillStyle = 'rgba(255,255,255,1)';
      _ctx.strokeStyle = 'rgba(73,124,190,1)';
      _ctx.lineWidth = 1;

      _ctx.rect(2, modelObj.y - 5, modelObj.width, modelObj.height);

      _ctx.fill();

      _ctx.stroke();

      _ctx.closePath();

      _ctx.restore();

      _ctx.clip();

      _ctx.save();

      _ctx.translate(2, -localObj.toolpanelY);

      Object.keys(modelObj.newbuttons).forEach(function (i, index) {
        Object.keys(modelObj.newbuttons[i]).forEach(function (j, key) {
          if (key == 0) {
            _ctx.save();

            _ctx.beginPath();

            if (!modelObj.enabled) {
              _ctx.globalAlpha = 0.5;
            }

            _ctx.closePath();

            _ctx.restore();

            _ctx.save();

            _ctx.beginPath();

            _ctx.fillStyle = modelObj.textColor;
            _ctx.font = 'bold ' + (modelObj.fontSize + 4) + 'px ' + modelObj.fontFamily;
            _ctx.textAlign = 'left';
            _ctx.textBaseline = 'bottom';
            _ctx.fillStyle = modelObj.fontColor;

            _ctx.drawStyledText(i, 25, modelObj.newbuttons[i][j].y - 20, _ctx.measureText(i), 20); // _ctx.drawStyledText(i,( modelObj.newbuttons[i][j].x), modelObj.newbuttons[i][j].y - 20, modelObj.newbuttons[i][j].base.textMain.width,  modelObj.newbuttons[i][j].base.textMain.height);


            _ctx.closePath();

            _ctx.restore();

            modelObj.newbuttons[i][j].x = modelObj.x;
          }

          if (modelObj.newbuttons[i][j].visible) {
            drawTool(_ctx, modelObj.newbuttons[i][j]); // if (modelObj.newbuttons[i][j].base && modelObj.newbuttons[i][j].type === localObj.hoverOn) {
            //   drawToolTip(modelObj.newbuttons[i][j],key);
            // }
          }
        });
      });
      Object.keys(modelObj.newbuttons).forEach(function (i, index) {
        Object.keys(modelObj.newbuttons[i]).forEach(function (j, key) {
          if (modelObj.newbuttons[i][j].base && modelObj.newbuttons[i][j].type === localObj.hoverOn) {
            drawToolTip(modelObj.newbuttons[i][j], key);
          }
        });
      });

      _ctx.restore();

      var heights = localObj.dataHeight;
      var minY = localObj.minY - 3.5;

      if (true) {
        _ctx.save();

        _ctx.strokeStyle = 'rgba(0,0,0,1)'; // _ctx.fillStyle = 'rgba(255,0,0,1)';

        _ctx.rect(modelObj.x + 0.5, modelObj.y - 3.5, modelObj.width - 1, modelObj.height - 1);

        _ctx.clip(); // _ctx.fill();


        _ctx.save();

        _ctx.beginPath();

        _ctx.translate(modelObj.width + modelObj.sliderLeftPadding, minY);

        _ctx.strokeStyle = 'rgba(210,210,210,1)'; // _ctx.fillStyle = 'rgba(0,255,0,1)';

        _ctx.rect(0, 0, localObj.slider.width, heights);

        _ctx.stroke(); // _ctx.fill();


        _ctx.closePath();

        _ctx.beginPath();

        _ctx.fillStyle = 'rgba(213, 213, 213, 1)';

        if (localObj.isPressed && localObj.currentTarget === 'knob') {
          _ctx.fillStyle = 'rgba(102, 102, 102, 1)';
        }

        _ctx.rect(0, localObj.slider.y, localObj.slider.width, localObj.slider.knob.height);

        _ctx.fill();

        _ctx.closePath();

        _ctx.restore();

        _ctx.restore();
      }

      _ctx.restore();
    }
  };

  function drawToolTip(_obj, index) {
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.textBaseline = 'bottom'; // base
    // roundRectToolTip({
    //   ctx: _ctx,
    //   x: _obj.base.x,
    //   y: _obj.base.y,
    //   percent: _obj.base.percent,
    //   width: _obj.base.width + modelObj.textPadding * 2,
    //   height: _obj.base.height + _obj.base.textHead.height + modelObj.textPadding * 2,
    //   radius: 0,
    //   fill: true,
    //   stroke: true
    // });
    // const updateY =  (_obj.base.y) - _obj.base.y*modelObj.slidePercent/100;
    // _obj.toolTipInverted = true;

    if (_obj.base.y < localObj.toolpanelY + 65) {
      _obj.toolTipInverted = true;
      _obj.updatedY = _obj.y + 59;
    } else if (_obj.base.y > localObj.toolpanelY + 65) {
      _obj.toolTipInverted = false;
      _obj.updatedY = _obj.base.originalY;
    }

    roundRectToolTip({
      ctx: _ctx,
      x: 2,
      y: _obj.updatedY,
      percent: _obj.base.percent,
      width: modelObj.width + modelObj.sliderLeftPadding - 6,
      height: _obj.base.height + _obj.base.textHead.height + modelObj.textPadding * 2,
      radius: 0,
      fill: true,
      stroke: true,
      index: index,
      toolTipInverted: _obj.toolTipInverted
    }); // text

    _ctx.save();

    _ctx.translate(2, _obj.updatedY);

    _ctx.beginPath();

    _ctx.fillStyle = modelObj.fontColor;

    _ctx.drawImage(_obj.base.textHead.text, modelObj.textPadding, modelObj.textPadding, _obj.base.textHead.width, _obj.base.textHead.height); // Info Drawing


    _ctx.drawImage(_obj.base.textImg, modelObj.textPadding, modelObj.textPadding + _obj.base.textHead.height, modelObj.width + modelObj.sliderLeftPadding - 6, _obj.base.height); // _ctx.drawImage(_obj.base.textImg, modelObj.textPadding, modelObj.textPadding + _obj.base.textHead.height, modelObj.width + modelObj.sliderLeftPadding - 6, _obj.base.height);


    _ctx.closePath();

    _ctx.restore();

    _ctx.restore();
  } // This function will generate text image and set positions.


  function toolTipBase(_obj) {
    // let textctx = modelObj.infoCtx
    // let textHead = modelObj.headCtx;
    var textctx;
    var textHead;
    var textMain;
    var textMainHovered; // Hover on Tool Info Text.

    textctx = modelObj.context.textWrapperClass({
      xNum: 0,
      yNum: 0,
      maxWidthNum: _obj.maxWidth - modelObj.textPadding * 2,
      textStr: _obj.info,
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: 16,
      color: 'rgba(142,142,142,1)',
      align: 'left',
      fontFormat: 'px '
    });
    textctx.text = textctx.imageObj.imageObj;
    textctx.width = textctx.imageObj.widthInt;
    textctx.height = textctx.imageObj.heightInt;
    var headText = _obj.headText ? _obj.headText : _obj.text.replaceAll("\n", " ");
    headText = headText.replaceAll('- ', '');
    textHead = modelObj.context.textWrapperClass({
      xNum: 0,
      yNum: 0,
      maxWidthNum: _obj.maxWidth - modelObj.textPadding * 2,
      textStr: '§b' + headText + '§r',
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: 17,
      color: 'rgba(130,130,130,1)',
      align: 'left',
      fontFormat: 'px '
    });
    textHead.text = textHead.imageObj.imageObj;
    textHead.width = textHead.imageObj.widthInt;
    textHead.height = textHead.imageObj.heightInt;
    textMain = modelObj.context.textWrapperClass({
      xNum: 0,
      yNum: 0,
      maxWidthNum: _obj.maxWidth - modelObj.textPadding * 2,
      textStr: _obj.text,
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: 16,
      color: 'rgba(142,142,142,1)',
      align: 'center',
      fontFormat: 'px '
    });
    textMain.text = textMain.imageObj.imageObj;
    textMain.width = textMain.imageObj.widthInt;
    textMain.height = textMain.imageObj.heightInt;
    textMainHovered = modelObj.context.textWrapperClass({
      xNum: 0,
      yNum: 0,
      maxWidthNum: _obj.maxWidth - modelObj.textPadding * 2,
      textStr: _obj.text,
      fontFamilyStr: modelObj.LabComClass.polo22KlettRegular,
      fontSizeNum: 16,
      color: modelObj.textSelectedColor,
      align: 'center',
      fontFormat: 'px '
    });
    textMainHovered.text = textMainHovered.imageObj.imageObj;
    textMainHovered.width = textMainHovered.imageObj.widthInt;
    textMainHovered.height = textMainHovered.imageObj.heightInt;
    modelObj.textCtxG = textctx;
    modelObj.textHeadG = textHead;
    _obj.base = getPosition(textctx, textHead, _obj);
    _obj.base.textHead = textHead;
    _obj.base.textMain = textMain;
    _obj.base.textMainHovered = textMainHovered;
  } // This funcction will calculate position respect to text size and position type


  function getPosition(textctx, textHead, _obj) {
    var x = _obj.x + _obj.width / 2,
        y = _obj.y + 1;
    var factor = 50 / 100;
    var w = textctx.width + modelObj.textPadding * 2;
    x -= w * factor;
    y -= textctx.height + modelObj.textPadding * 2 + modelObj.trangleH + textHead.height;

    if (x < modelObj.x) {
      x = modelObj.x;
    } // if(y<modelObj.y) {
    //   y = _obj.y + 59;  
    //   _obj.toolTipInverted = true;
    // }
    // if ((modelObj.x + w * 0.9) > _obj.x) {
    //   x = modelObj.x;
    // }


    return {
      x: x,
      y: y,
      originalY: y,
      updatedY: y,
      percent: (_obj.x + _obj.width / 2 - x) / w * 100,
      width: textctx.width,
      height: textctx.height,
      textImg: textctx.text
    };
  }

  function roundRect(ctx, x, y, width, height, radius, fill, stroke, drawUpperCorners, drawLowerCorners) {
    if (typeof stroke === 'undefined') {
      stroke = true;
    }

    if (typeof radius === 'undefined') {
      radius = 5;
    }

    if (typeof radius === 'number') {
      if (drawUpperCorners) {
        radius = {
          tl: radius,
          tr: radius,
          br: 0,
          bl: 0
        };
      } else if (drawLowerCorners) {
        radius = {
          tl: 0,
          tr: 0,
          br: radius,
          bl: radius
        };
      } else {
        radius = {
          tl: radius,
          tr: radius,
          br: radius,
          bl: radius
        };
      }
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + (width - radius.tr), y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + (height - radius.br));
    ctx.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath();
    ctx.lineWidth = modelObj.strokeWidth;

    if (fill) {
      ctx.fill();
    }

    if (stroke) {
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  function roundRectToolTip(_obj) {
    var ctx = _obj.ctx,
        x = _obj.x,
        width = _obj.width,
        height = _obj.height,
        fill = _obj.fill,
        _obj$stroke = _obj.stroke,
        stroke = _obj$stroke === void 0 ? true : _obj$stroke,
        drawUpperCorners = _obj.drawUpperCorners,
        drawLowerCorners = _obj.drawLowerCorners,
        toolTipInverted = _obj.toolTipInverted;
    var y = _obj.y;
    var radius = _obj.radius;
    var percent;

    if (_obj.index % 3 === 0) {
      percent = 0.20;
    } else if (_obj.index % 3 === 1) {
      percent = 0.5;
    } else if (_obj.index % 3 === 2) {
      percent = 0.82;
    }

    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
    ctx.strokeStyle = 'rgba(142, 142, 142, 1)';

    if (typeof radius === 'undefined') {
      radius = 5;
    }

    if (typeof radius === 'number') {
      if (drawUpperCorners) {
        radius = {
          tl: radius,
          tr: radius,
          br: 0,
          bl: 0
        };
      } else if (drawLowerCorners) {
        radius = {
          tl: 0,
          tr: 0,
          br: radius,
          bl: radius
        };
      } else {
        radius = {
          tl: radius,
          tr: radius,
          br: radius,
          bl: radius
        };
      }
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    } // if (y<modelObj.y) {
    //   y = modelObj.y;
    // }


    ctx.beginPath();

    if (!toolTipInverted) {
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + (width - radius.tr), y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.tr);
      ctx.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
      ctx.lineTo(x + width * percent + modelObj.trangleW, y + height);
      ctx.lineTo(x + width * percent, y + height + modelObj.trangleH);
      ctx.lineTo(x + width * percent - modelObj.trangleW, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    } else {
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width * percent - modelObj.trangleW, y);
      ctx.lineTo(x + width * percent, y - modelObj.trangleH);
      ctx.lineTo(x + width * percent + modelObj.trangleW, y); // ctx.lineTo(x + (width - radius.tr), y);

      ctx.lineTo(x + width, y - radius.tr);
      ctx.lineTo(x + (width - radius.tr), y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.lineTo(x, y + radius.tl);
    }

    if (fill) {
      ctx.fill();
    }

    if (stroke) {
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.closePath();
  }

  function drawTool(ctx, _obj) {
    var x = _obj.x,
        y = _obj.y,
        width = _obj.width,
        height = _obj.height;
    var r = modelObj.pointRadius;
    var maxR = r * 2.5;
    var w = 16;
    var trangleW = 5;
    var trangleH = 7;
    ctx.save();
    ctx.beginPath();

    if (!modelObj.enabled) {
      ctx.globalAlpha = 0.5;
    } // ctx.rect(x, y, width, height);
    // ctx.stroke();


    switch (_obj.type) {
      case 'move':
        ctx.translate(x, y + modelObj.shapeTopMargin / 2);
        ctx.rotate(65 * Math.PI / 180);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(10, -5);
        ctx.lineTo(10, -1);
        ctx.lineTo(15, -1);
        ctx.lineTo(15, 1);
        ctx.lineTo(10, 1);
        ctx.lineTo(10, 5);
        ctx.lineTo(0, 0);
        ctx.stroke();
        ctx.closePath();
        break;

      case 'delete':
        ctx.translate(x, y + modelObj.shapeTopMargin / 1.75); //Cap of the Bin

        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.lineWidth = 1; // ctx.moveTo(-15, 0);
        // ctx.lineTo(-15, -5);
        // ctx.lineTo(15, -5);
        // ctx.lineTo(15, 0);
        // ctx.lineTo(-15, 0);

        roundRect(ctx, -12.5, -5, 25, 5, 2.5, null, true, true, false);
        ctx.closePath(); //Dustbin

        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.lineWidth = 1; // ctx.moveTo(-10, 0);
        // ctx.lineTo(-10, 15);
        // ctx.lineTo(10, 15);
        // ctx.lineTo(10, 0);

        roundRect(ctx, -10, 0, 20, 20, 2.5, null, true, false, true);
        ctx.closePath(); // Dustbin Handle

        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.lineWidth = 1; // ctx.moveTo(-7, -5);
        // ctx.lineTo(-7, -10);
        // ctx.lineTo(7, -10);
        // ctx.lineTo(7, -5);
        // ctx.stroke();

        roundRect(ctx, -4, -9, 8, 4, 2.5, null, true, true, false);
        ctx.closePath(); //3 parallel Lines

        [{
          x: -5,
          y: 3.5
        }, {
          x: 0,
          y: 3.5
        }, {
          x: 5,
          y: 3.5
        }].forEach(function (cords) {
          ctx.beginPath();
          ctx.strokeStyle = modelObj.lineColor;
          ctx.lineCap = 'round';
          ctx.fillStyle = 'rgba(255,255,255,1)';
          ctx.lineWidth = 1;
          ctx.moveTo(cords.x, cords.y);
          ctx.lineTo(cords.x, cords.y + 12.5);
          ctx.stroke();
          ctx.closePath();
        });
        break;

      case 'point':
        drawPoint({
          ctx: ctx,
          x: x,
          y: y + modelObj.shapeTopMargin
        });
        break;

      case 'circle':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        drawPoint({
          ctx: ctx
        });
        drawPoint({
          ctx: ctx,
          r: r * 3,
          fill: false,
          stroke: true
        });
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        break;

      case 'circleSize':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(0, 0);
        ctx.lineTo(r * 3, -3);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx
        });
        drawPoint({
          ctx: ctx,
          r: r * 3,
          fill: false,
          stroke: true
        });
        break;

      case 'compass':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        drawPoint({
          ctx: ctx,
          r: r * 0.7,
          x: -2,
          y: -8
        });
        ctx.closePath();
        ctx.beginPath();
        ctx.moveTo(-2, -8);
        ctx.lineTo(0, 12);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.moveTo(-2, -8);
        ctx.lineTo(-12, 12);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath(); // ctx.ellipse(0, 12, 4, 12, Math.PI/2, 0, 2 * Math.PI);

        drawEllipse(ctx, 0, 12, 12, 4, 50);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.arc(-2, -8, r * 2, 1.47, 1.97, false);
        ctx.stroke();
        ctx.closePath();
        break;

      case 'circle_3':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        drawPoint({
          ctx: ctx,
          r: r * 3,
          fill: false,
          stroke: true
        });
        ctx.closePath(); // eslint-disable-next-line no-case-declarations

        var fixedAngle = 45 * Math.PI / 180;
        ctx.save();
        ctx.rotate(1 / 3 * (Math.PI * 2) - fixedAngle);
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        ctx.restore();
        ctx.save();
        ctx.rotate(2 / 3 * (Math.PI * 2) - fixedAngle);
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        ctx.restore();
        ctx.save();
        ctx.rotate(3 / 3 * (Math.PI * 2) - fixedAngle);
        drawPoint({
          ctx: ctx,
          x: r * 3
        });
        ctx.restore();
        break;

      case 'midPoint':
      case 'mirrorOnPoint':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        drawPoint({
          ctx: ctx,
          fillColor: _obj.type === 'midPoint' ? modelObj.redColor : modelObj.circleColor
        });
        drawPoint({
          ctx: ctx,
          x: -10,
          fillColor: _obj.type === 'midPoint' ? modelObj.circleColor : modelObj.redColor
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case 'triangle':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(0, -10);
        ctx.lineTo(-10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(0, -10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, 10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          y: -10
        });
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 10
        });
        drawPoint({
          ctx: ctx,
          x: 10,
          y: 10
        });
        break;

      case 'square':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, -10);
        ctx.lineTo(-10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, -10);
        ctx.lineTo(10, -10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(-10, 10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = modelObj.lineColor;
        ctx.moveTo(10, -10);
        ctx.lineTo(10, 10);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10,
          y: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10,
          y: -10
        });
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 10
        });
        drawPoint({
          ctx: ctx,
          x: 10,
          y: 10
        });
        break;

      case 'segment':
      case 'segmentDash':
      case 'segSize':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;

        if (_obj.type === 'segmentDash') {
          ctx.setLineDash([4, 2]);
        }

        if (_obj.type === 'segSize') {
          ctx.font = modelObj.fontSize + 'px ' + modelObj.fontFamily;
          ctx.save();
          ctx.textAlign = 'left';
          ctx.textBaseline = 'bottom';
          ctx.fillStyle = modelObj.textColor;

          if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
            ctx.fillStyle = modelObj.textSelectedColor;
          }

          ctx.rotate(-2.6);
          ctx.drawStyledText('a', -8, modelObj.fontSize * 0.2, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
          ctx.restore();
        }

        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10 // fillColor:_obj.type === 'segSize'?'red':modelObj.circleColor,

        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case 'labelTool':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.font = modelObj.fontSize + 'px ' + modelObj.fontFamily;
        ctx.save();
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillStyle = modelObj.textColor;

        if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
          ctx.fillStyle = modelObj.textSelectedColor;
        }

        ctx.rotate(-2.6);
        ctx.drawStyledText('A', -13, modelObj.fontSize, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize * 1.6);
        ctx.drawStyledText('a', 3, modelObj.fontSize, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize * 1.6);
        ctx.restore();
        break;

      case 'line':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-20, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case 'mirrorOnLine':
      case 'line':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath();
        ctx.rotate(2.3 + Math.PI / 2);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-15, 0);
        ctx.lineTo(15, 0);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
        drawPoint({
          ctx: ctx,
          x: -5,
          y: 7,
          r: 3
        });
        drawPoint({
          ctx: ctx,
          x: 5,
          y: -7,
          r: 3
        });
        break;

      case 'angleRay':
        r *= 0.6;
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.rotate(-0.58);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 12,
          r: r
        });
        ctx.restore();
        ctx.save();
        ctx.rotate(0.58);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 12,
          r: r
        });
        ctx.restore();
        drawPoint({
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          r: r * 2.2,
          startAngle: -0.58,
          endAngle: 0.58,
          fill: false,
          stroke: true
        });
        break;

      case 'angle':
        r *= 0.6;
        ctx.translate(x - modelObj.shapeTopMargin / 2, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath();
        ctx.rotate(-0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.rotate(0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        drawPoint({
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          r: r * 3.2,
          startAngle: -0.58,
          endAngle: 0.58,
          fillColor: 'rgba(112,146,190,0.5)',
          fill: true,
          stroke: true
        });
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = modelObj.textColor;

        if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
          ctx.fillStyle = modelObj.textSelectedColor;
        }

        ctx.font = modelObj.fontSize + 'px ' + modelObj.fontFamily;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.drawStyledText('α', 12, modelObj.fontSize * 0.5, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
        ctx.closePath();
        ctx.restore();
        break;

      case 'angleB':
        r *= 0.6;
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath();
        ctx.rotate(-0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.rotate(0.58);
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 20,
          r: r
        });
        ctx.restore();
        drawPoint({
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          r: r * 3.2,
          startAngle: -0.58,
          endAngle: 0.58,
          fillColor: 'rgba(112,146,190,0.5)',
          fill: true,
          stroke: true
        });
        ctx.save();
        ctx.beginPath(); // ctx.rotate(0.58);

        ctx.strokeStyle = 'rgba(255,0,0,1)';
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = modelObj.textColor;

        if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
          ctx.fillStyle = modelObj.textSelectedColor;
        }

        ctx.font = modelObj.fontSize + 'px ' + modelObj.fontFamily;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.closePath();
        ctx.restore();
        break;

      case 'perpendicularLine':
        ctx.translate(x, y + modelObj.shapeTopMargin - 3);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.moveTo(0, -6);
        ctx.lineTo(0, 13);
        ctx.stroke();
        ctx.closePath(); //Quarter Circle.

        drawPoint({
          ctx: ctx,
          r: 5.7,
          fill: false,
          stroke: true,
          startAngle: 0,
          endAngle: Math.PI / 2
        }); //Point inside.

        drawPoint({
          ctx: ctx,
          x: 2.2,
          y: 2.2,
          r: 0.7,
          fill: true
        });
        break;

      case 'perpendicularBisector':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.rotate(2.6 + Math.PI / 2);
        ctx.strokeStyle = 'rgba(255,0,0,1)';
        ctx.lineWidth = 1;
        ctx.moveTo(-15, 0);
        ctx.lineTo(15, 0);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
        break;

      case 'parallelLine':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-15, -3);
        ctx.lineTo(15, -3);
        ctx.stroke();
        ctx.moveTo(-15, 3);
        ctx.lineTo(15, 3);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: 4,
          y: -3
        });
        break;

      case 'brush1':
      case 'brush2':
      case 'brush3':
      case 'brush4':
      case 'brush5':
      case 'brush6':
      case 'brush7':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        drawBrush(ctx, modelObj.newbuttons.Dye[_obj.type].color);
        break;

      case 'select':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);
        ctx.rect(-w / 2, -w / 2, w, w);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.fillStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        drawArrow(ctx, 8, 8, 11, 15, 8, -135 * Math.PI / 180);
        ctx.closePath();
        break;

      case 'ray':
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.rotate(2.6);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-20, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10
        });
        drawPoint({
          ctx: ctx,
          x: 10
        });
        break;

      case 'angleSize':
        r *= 0.6;
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.save();
        ctx.beginPath(); // ctx.rotate(0.58);

        ctx.strokeStyle = modelObj.lineColor;
        ctx.lineWidth = 1;
        ctx.moveTo(-10, 12);
        ctx.lineTo(20, 12);
        ctx.stroke();
        ctx.closePath();
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 12,
          r: r
        });
        ctx.restore();
        drawPoint({
          x: 5,
          y: -8,
          ctx: ctx,
          r: r
        });
        drawPoint({
          ctx: ctx,
          x: -10,
          y: 12,
          r: r * 3.2,
          startAngle: -0.99,
          endAngle: 0,
          fillColor: 'rgba(112,146,190,0.5)',
          fill: true,
          stroke: true
        });
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = modelObj.textColor;

        if (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type) {
          ctx.fillStyle = modelObj.textSelectedColor;
        }

        ctx.font = modelObj.fontSize + 'px ' + modelObj.fontFamily;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.drawStyledText('α', 3, modelObj.fontSize * 0.75, modelObj.LabComClass.polo22KlettRegular, modelObj.fontSize);
        ctx.closePath();
        ctx.restore();
        break;

      case 'length':
        ctx.save();
        ctx.translate(x, y + modelObj.shapeTopMargin);
        ctx.rotate(45 * Math.PI / 180);
        ctx.beginPath();
        ctx.strokeStyle = modelObj.lineColor; // ctx.arc(0,0,5,0,3.14);
        // ctx.lineWidth = 1;

        ctx.moveTo(-12, -5);
        ctx.lineTo(12, -5);
        ctx.lineTo(12, 5);
        ctx.lineTo(-12, 5);
        ctx.lineTo(-12, -5);
        ctx.stroke();
        ctx.closePath();

        for (var i = -3; i <= 4; i++) {
          if (i % 2 !== 0) {
            ctx.beginPath();
            ctx.strokeStyle = modelObj.lineColor;
            ctx.lineWidth = 1;
            ctx.moveTo(3 * i, -5);
            ctx.lineTo(3 * i, -2);
            ctx.stroke();
            ctx.closePath();
          } else if (i % 2 === 0) {
            ctx.beginPath();
            ctx.strokeStyle = modelObj.lineColor;
            ctx.lineWidth = 1;
            ctx.moveTo(3 * i, -5);
            ctx.lineTo(3 * i, 0);
            ctx.stroke();
            ctx.closePath();
          }
        }

        ctx.restore();
        break;

      default:
    }

    ctx.closePath();
    ctx.restore();
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = modelObj.textColor;
    var _str = '';
    var isBold = false;
    var textMainImg = _obj.base.textMain;
    _str += isBold ? 'bold ' : '';
    ctx.font = _str + modelObj.fontSize + 'px ' + modelObj.fontFamily;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = modelObj.fontColor;

    if (modelObj.enabled && (modelObj.selected === _obj.type || _obj.enable && localObj.hoverOn === _obj.type)) {
      ctx.fillStyle = modelObj.textSelectedColor;
      isBold = true;
      textMainImg = _obj.base.textMainHovered;
    }

    ctx.beginPath(); // (x + width / 2) - (25 * width/100)

    ctx.drawImage(textMainImg.text, x - 177, y + height * 0.6, textMainImg.width, textMainImg.height);
    ctx.closePath();
    ctx.restore();
  }

  var drawEllipse = function drawEllipse(ctx, cx, cy, w, h, pointCount) {
    var i = 0,
        x,
        y,
        r;
    pointCount = pointCount || 100, ctx.beginPath();
    ctx.lineWidth = 0.5;

    while (i < pointCount) {
      r = Math.PI * 2 * (i / pointCount);
      x = cx + Math.cos(r) * w;
      y = cy + Math.sin(r) * h;
      ctx.lineTo(x, y);
      i += 1;
    }

    ctx.closePath();
    ctx.stroke();
  };

  function drawBrush(ctx, color) {
    ctx.rotate(2.4);
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.moveTo(4.5, 3);
    ctx.lineTo(4.5, -3);
    ctx.lineTo(6, -4);
    ctx.lineTo(9, -4);
    ctx.lineTo(15, 3);
    ctx.lineTo(12, 3);
    ctx.lineTo(9, 5);
    ctx.lineTo(4.5, 3);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.strokeStyle = modelObj.lineColor;
    ctx.lineWidth = 1;
    ctx.moveTo(-15, -3);
    ctx.lineTo(4, -3);
    ctx.stroke();
    ctx.moveTo(4, 3);
    ctx.lineTo(4, -3);
    ctx.stroke();
    ctx.moveTo(-15, 3);
    ctx.lineTo(4, 3);
    ctx.stroke();
    ctx.closePath();
    ctx.beginPath();
    ctx.strokeStyle = modelObj.lineColor;
    ctx.lineWidth = 1;
    ctx.moveTo(4, 3);
    ctx.bezierCurveTo(10, 10, 12, 1, 18, 4);
    ctx.stroke();
    ctx.moveTo(4, -3);
    ctx.bezierCurveTo(10, -8, 12, 1, 18, 4);
    ctx.stroke();
    ctx.closePath();
  }

  function drawArrow(ctx, x, y, lineW, tw, th) {
    var angle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.moveTo(0, 0);
    ctx.lineTo(lineW, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(lineW, 0);
    ctx.lineTo(lineW - tw / 2, -th / 2);
    ctx.lineTo(lineW - tw / 2, th / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.closePath();
  }

  function drawPoint(_ref) {
    var ctx = _ref.ctx,
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$r = _ref.r,
        r = _ref$r === void 0 ? modelObj.pointRadius : _ref$r,
        _ref$fill = _ref.fill,
        fill = _ref$fill === void 0 ? true : _ref$fill,
        _ref$stroke = _ref.stroke,
        stroke = _ref$stroke === void 0 ? false : _ref$stroke,
        _ref$fillColor = _ref.fillColor,
        fillColor = _ref$fillColor === void 0 ? modelObj.circleColor : _ref$fillColor,
        _ref$startAngle = _ref.startAngle,
        startAngle = _ref$startAngle === void 0 ? 0 : _ref$startAngle,
        _ref$endAngle = _ref.endAngle,
        endAngle = _ref$endAngle === void 0 ? 2 * Math.PI : _ref$endAngle;
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = modelObj.circleColor; // ctx.moveTo(x, y);

    ctx.arc(x, y, r, startAngle, endAngle);

    if (fill) {
      ctx.fill();
    }

    if (stroke) {
      ctx.stroke();
    }

    ctx.closePath();
  } // =================================================
  // =================================================


  function setDefaults() {
    // const data = modelObj.buttons;
    // Object.keys(data).forEach((i) => {
    //   data[i].type = i;
    //   data[i].visible = false;
    //   data[i].enable = true;
    //   data[i].height = 49;
    //   if (i === 'move') {
    //     data[i].visible = true;
    //   }
    // });
    var data = modelObj.newbuttons;
    Object.keys(data).forEach(function (i) {
      Object.keys(data[i]).forEach(function (j) {
        data[i][j].type = j;
        data[i][j].visible = false;
        data[i][j].enable = true;
        data[i][j].height = data[i][j].text.includes('\n') ? 69 : 49;

        if (j === 'move') {
          data[i][j].visible = true;
        }
      });
    });
  }

  function calculatePos() {
    var x = modelObj.x;
    var y = modelObj.y; // const data = modelObj.buttons;

    var data = modelObj.newbuttons;
    var _ctx = modelObj.context;

    _ctx.save();

    _ctx.font = modelObj.fontSize + 'px ' + modelObj.fontFamily;
    var index = 0;
    y = 110;
    modelObj.totalHeight = 49;
    Object.keys(data).forEach(function (i) {
      Object.keys(data[i]).forEach(function (j, idx) {
        if (data[i][j].visible) {
          data[i][j].x = x;
          data[i][j].y = y;
          data[i][j].text = findGlobalText(data[i][j].text);

          if (data[i][j].headText) {
            data[i][j].headText = findGlobalText(data[i][j].headText);
          }

          data[i][j].info = findGlobalText(data[i][j].info);

          if (data[i][j].unitText) {
            data[i][j].unitText = findGlobalText(data[i][j].unitText);
          } // if(data[i].text.indexOf('\n') === -1) {


          data[i][j].width = _ctx.measureText(data[i][j].text).width; // }
          // else {
          //   data[i].width = _ctx.measureText(data[i].text.split('\n')[0]).width;
          // }

          if (data[i][j].text.indexOf('\n') === -1) {
            data[i][j].width = _ctx.measureText(data[i][j].text).width;
          } else {
            // width is decided by comparing first line and the second line.
            data[i][j].width = _ctx.measureText(data[i][j].text.split('\n')[0]).width > _ctx.measureText(data[i][j].text.split('\n')[1]).width ? _ctx.measureText(data[i][j].text.split('\n')[0]).width : _ctx.measureText(data[i][j].text.split('\n')[1]).width;
          } // x += (data[i].width + localObj.padding);


          x += 100;
          var cond = idx + 1 === Object.keys(data[i]).length && data[i][j].text.includes('\n'); // If the tool has multiple line and is in the last of group then thos condition turns true.
          //|| (idx+1 === Object.keys(data[i]).length && data[i][j].text.includes('\n'))

          if (((idx + 1) % 3 === 0 || cond) && Object.keys(data[i]).length > 3 && data[i][j].type !== 'delete') {
            modelObj.values.rowCount++;
            x = modelObj.x;
            data[i][j].eventX = modelObj.x;

            if (!cond) {
              if (data[i][j].text.includes('\n')) {
                y = y + 79;
              } else {
                y = y + 69;
              }
            } else {
              y = y + 29;
            }

            modelObj.totalHeight = y - 110;
          } else if ((idx + 1) % 3 === 0 && Object.keys(data[i]).length <= 3 && data[i][j].text.includes('\n')) {
            y = y + 29;
          }

          index++; // if(data[i].text.indexOf('\n') !== -1 ) {
          //   y = y + 69;
          // }

          toolTipBase(data[i][j]);
        }
      });
      x = modelObj.x;
      y = y + 110;
      index = 0;
    }); // modelObj.totalHeight = y - 110;

    _ctx.restore();

    addEvents(); // Object.keys(data).forEach((i,idx) => {
    //   if (data[i].visible) {
    //     data[i].x = x;
    //     data[i].y = y;
    //     data[i].text = findGlobalText(data[i].text);
    //     if (data[i].headText) {
    //       data[i].headText = findGlobalText(data[i].headText);
    //     }
    //     data[i].info = findGlobalText(data[i].info);
    //     if (data[i].unitText) {
    //       data[i].unitText = findGlobalText(data[i].unitText);
    //     }
    //     // if(data[i].text.indexOf('\n') === -1) {
    //     data[i].width = _ctx.measureText(data[i].text).width;
    //   // }
    //   // else {
    //   //   data[i].width = _ctx.measureText(data[i].text.split('\n')[0]).width;
    //   // }
    //   if(data[i].text.indexOf('\n') === -1) {
    //     data[i].width = _ctx.measureText(data[i].text).width;
    //   }
    //   else {
    //     data[i].width = _ctx.measureText(data[i].text.split('\n')[0]).width;
    //   }
    //     // x += (data[i].width + localObj.padding);
    //     x += 100;
    //     if((index+1) % 3 === 0 ){
    //       x = modelObj.x;
    //       data[i].eventX  = modelObj.x;
    //       if(data[i].text.includes('\n')){
    //       y = y + 90;
    //       }else {
    //         y = y + 69;
    //       }
    //     }
    //     index++;
    //     // if(data[i].text.indexOf('\n') !== -1 ) {
    //     //   y = y + 69;
    //     // }
    //     toolTipBase(data[i]);
    //   }
    // });
  }

  function findGlobalText(text) {
    if (modelObj.LabComClass.globalLangText[text]) {
      return modelObj.LabComClass.globalLangText[text];
    }

    return '---';
  } // =================================================
  // PRIVATE SECTION
  // =================================================


  function calculateRows() {
    localObj.minY = modelObj.y;
    var _rc = modelObj.values.rowCount;
    var _h = modelObj.height;
    var _vh = modelObj.values.height;
    modelObj.taskHeights = modelObj.height;

    if (_rc === 'auto' && _h !== 'auto' && _vh !== 'auto') {
      modelObj.values.rowCount = Math.round(_h / (_vh + modelObj.gap));
      modelObj.taskHeights = modelObj.values.rowCount * _vh + modelObj.values.rowCount * modelObj.gap;
    } else if (_rc !== 'auto' && _h === 'auto' && _vh !== 'auto') {
      modelObj.taskHeights = _rc * _vh + (_rc - 1) * modelObj.gap;
    } else if (_rc !== 'auto' && _h !== 'auto' && _vh === 'auto') {
      modelObj.values.height = _h / _rc - modelObj.gap;
    } else {
      modelObj.values.rowCount = localObj.defaultRowCount;
      modelObj.taskHeights = localObj.defaultHeight;
      modelObj.values.height = localObj.defaultRowHeight;
    }

    modelObj.taskHeights = modelObj.height;
    localObj.pivotPoint.x = modelObj.x;
    localObj.pivotPoint.y = localObj.minY;
    localObj.unitY = modelObj.values.height + modelObj.gap;
    localObj.dataHeight = modelObj.taskHeights;
    localObj.maxY = localObj.minY + localObj.dataHeight;
    localObj.slider.x = 0;
    localObj.slider.y = 0;
    updateSlider();
    localObj.leftArrowPos = {
      x: modelObj.stepsBar.x + modelObj.stepsBar.w - 104,
      y: modelObj.stepsBar.y + modelObj.stepsBar.h / 2
    };
    localObj.rightArrowPos = {
      x: modelObj.stepsBar.x + modelObj.stepsBar.w - 75,
      y: modelObj.stepsBar.y + modelObj.stepsBar.h / 2
    };
    localObj.slideArrowPos = {
      x: modelObj.stepsBar.x + modelObj.stepsBar.w - 25,
      y: modelObj.stepsBar.y + modelObj.stepsBar.h / 2
    };

    if (modelObj.LabComClass.globalLangText[modelObj.stepsBar.text]) {
      modelObj.stepsBar.text = modelObj.LabComClass.globalLangText[modelObj.stepsBar.text];
    } else {
      modelObj.stepsBar.text = '---';
    }

    updateStepArrows();
    addEvents();
  }

  function updateSlider() {
    // modelObj.totalHeight = 1337;
    var totalHeight = 781; //741;

    totalHeight += modelObj.gap * modelObj.values.data.length - 1;

    if (localObj.minY + totalHeight - modelObj.gap > localObj.maxY) {
      localObj.slider.visible = true;
    } else {
      localObj.slider.visible = false;
    }

    var slidePercent = localObj.slider.y / (localObj.dataHeight - localObj.slider.knob.height) * 100;
    localObj.pivotPoint.y = localObj.minY - (totalHeight - localObj.dataHeight - modelObj.gap) * slidePercent / 100;
    localObj.toolpanelY = slidePercent * totalHeight / 100;
    modelObj.slidePercent = +slidePercent.toFixed(2); // Object.keys(modelObj.newbuttons).forEach(i=>{
    //   Object.keys(modelObj.newbuttons[i]).forEach(j=>{
    //     // calculatePos();
    //   })
    // })
    // console.log("totalHeight ",totalHeight);
    // console.log("slidePercent ",slidePercent );
    // console.log("localObj.pivotPoint.y",localObj.pivotPoint.y);
    // console.log("newbuttons - localObj.toolpanelY",modelObj.newbuttons.y );
  }

  function removeAllEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    var _this2 = this;

    removeAllEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];
    var extraEventArea = 5;

    if (true) {
      _eventDataObj.r.push({
        id: 'knobBase',
        rect: {
          x: modelObj.width + modelObj.sliderLeftPadding - extraEventArea,
          y: modelObj.y - extraEventArea,
          w: localObj.slider.width + extraEventArea * 2,
          h: modelObj.height + extraEventArea * 2
        },
        cursor: 'default',
        eventListener: mouseHandle.bind(this)
      });

      _eventDataObj.r.push({
        id: 'knob',
        rect: {
          x: modelObj.width + modelObj.sliderLeftPadding - extraEventArea,
          y: localObj.slider.y + localObj.minY - extraEventArea,
          w: localObj.slider.width + extraEventArea * 2,
          h: localObj.slider.knob.height + extraEventArea * 2
        },
        eventListener: mouseHandle.bind(this)
      });
    } // const data = modelObj.buttons;
    // if (modelObj.enabled && modelObj.visible) {
    //   Object.keys(data).forEach((i) => {
    //     if (data[i].visible) {
    //       // (x-width/2)   , y + height*0.6 ,_obj.base.textMain.width, _obj.base.textMain.height
    //       _eventDataObj.r.push({
    //         id: i,
    //         rect: {
    //           x: data[i].x - data[i].width/2,
    //           y: data[i].y,
    //           w: data[i].width,
    //           h: data[i].height
    //         },
    //         eventListener: mouseHandle.bind(this)
    //       });
    //     }
    //   });
    // }


    var data = modelObj.newbuttons;

    if (modelObj.enabled && modelObj.visible) {
      Object.keys(data).forEach(function (i) {
        Object.keys(data[i]).forEach(function (j) {
          if (data[i][j].visible && data[i][j].y - localObj.toolpanelY > 0) {
            _eventDataObj.r.push({
              id: j,
              rect: {
                x: data[i][j].x - data[i][j].width / 2,
                y: data[i][j].y - localObj.toolpanelY,
                w: data[i][j].width,
                h: data[i][j].text.includes('\n') ? data[i][j].height + 20 : data[i][j].height
              },
              eventListener: mouseHandle.bind(_this2)
            });
          }
        });
      });
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'addMouseEvent',
      data: _eventDataObj
    });
  } // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        localObj.isPressed = true;
        localObj.hoverOn = e.subId;
        localObj.currentTarget = e.subId;

        if (e.subId === 'knobBase') {
          localObj.slider.y = e.pageY - localObj.minY - localObj.slider.knob.height / 2;
          restrictSlider();
        }

        break;

      case 'pressmove':
        if (e.subId === 'knob') {
          localObj.slider.y = e.pageY - localObj.minY;
          restrictSlider();
          addEvents();
        }

        break;

      case 'mouseenter':
        localObj.isHover = true;
        localObj.isPressed = false;
        localObj.hoverOn = e.subId;
        break;

      case 'mouseout':
      case 'mouseupout':
        localObj.isHover = false;
        localObj.isPressed = false;
        localObj.hoverOn = null;

        if (e.type === 'mouseupout') {
          updateSlider(true);
          updateStepArrows();
        }

        break;

      case 'mouseup':
        modelObj.selected = e.subId;

        if (typeof events.click !== 'undefined') {
          events.click({
            id: modelObj.id,
            type: 'click'
          });
        }

        localObj.isPressed = false;
        localObj.hoverOn = null;
        updateStepArrows();
        break;

      default:
        break;
    }
  }

  function restrictSlider() {
    if (localObj.slider.y < 0) {
      localObj.slider.y = 0;
    }

    if (localObj.slider.y > localObj.dataHeight - localObj.slider.knob.height) {
      localObj.slider.y = localObj.dataHeight - localObj.slider.knob.height;
    }

    updateSlider();
  }

  function updateStepArrows() {
    modelObj.stepsBar.currentStep = modelObj.stepsBar.currentStep <= 0 ? 0 : modelObj.stepsBar.currentStep;
    modelObj.stepsBar.currentStep = modelObj.stepsBar.currentStep >= modelObj.values.data.length ? modelObj.values.data.length : modelObj.stepsBar.currentStep;
    localObj.rightArrowEnable = true;
    localObj.leftArrowEnable = true;

    if (modelObj.stepsBar.currentStep >= modelObj.values.data.length - 1) {
      localObj.rightArrowEnable = false;
    }

    if (modelObj.stepsBar.currentStep <= 0) {
      localObj.leftArrowEnable = false;
    }

    setControlls();
  }

  function setControlls() {
    if (!modelObj.visible) {
      localObj.leftArrowEnable = false;
      localObj.rightArrowEnable = false;
    }

    updateSlider(true);
    addEvents();
  }
}
/*
  html2canvas 0.5.0-alpha <http://html2canvas.hertzen.com>
  Copyright (c) 2014 Niklas von Hertzen

  Released under MIT License
*/

(function(window, document, module, exports, global, define, undefined){

/*
 Copyright (c) 2013 Yehuda Katz, Tom Dale, and contributors

 Permission is hereby granted, free of charge, to any person obtaining a copy of
 this software and associated documentation files (the "Software"), to deal in
 the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do
 so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
!function(){var a,b,c,d;!function(){var e={},f={};a=function(a,b,c){e[a]={deps:b,callback:c}},d=c=b=function(a){function c(b){if("."!==b.charAt(0))return b;for(var c=b.split("/"),d=a.split("/").slice(0,-1),e=0,f=c.length;f>e;e++){var g=c[e];if(".."===g)d.pop();else{if("."===g)continue;d.push(g)}}return d.join("/")}if(d._eak_seen=e,f[a])return f[a];if(f[a]={},!e[a])throw new Error("Could not find module "+a);for(var g,h=e[a],i=h.deps,j=h.callback,k=[],l=0,m=i.length;m>l;l++)"exports"===i[l]?k.push(g={}):k.push(b(c(i[l])));var n=j.apply(this,k);return f[a]=g||n}}(),a("promise/all",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to all.");return new b(function(b,c){function d(a){return function(b){f(a,b)}}function f(a,c){h[a]=c,0===--i&&b(h)}var g,h=[],i=a.length;0===i&&b([]);for(var j=0;j<a.length;j++)g=a[j],g&&e(g.then)?g.then(d(j),c):f(j,g)})}var d=a.isArray,e=a.isFunction;b.all=c}),a("promise/asap",["exports"],function(a){"use strict";function b(){return function(){process.nextTick(e)}}function c(){var a=0,b=new i(e),c=document.createTextNode("");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function d(){return function(){j.setTimeout(e,1)}}function e(){for(var a=0;a<k.length;a++){var b=k[a],c=b[0],d=b[1];c(d)}k=[]}function f(a,b){var c=k.push([a,b]);1===c&&g()}var g,h="undefined"!=typeof window?window:{},i=h.MutationObserver||h.WebKitMutationObserver,j="undefined"!=typeof global?global:this,k=[];g="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?b():i?c():d(),a.asap=f}),a("promise/cast",["exports"],function(a){"use strict";function b(a){if(a&&"object"==typeof a&&a.constructor===this)return a;var b=this;return new b(function(b){b(a)})}a.cast=b}),a("promise/config",["exports"],function(a){"use strict";function b(a,b){return 2!==arguments.length?c[a]:(c[a]=b,void 0)}var c={instrument:!1};a.config=c,a.configure=b}),a("promise/polyfill",["./promise","./utils","exports"],function(a,b,c){"use strict";function d(){var a="Promise"in window&&"cast"in window.Promise&&"resolve"in window.Promise&&"reject"in window.Promise&&"all"in window.Promise&&"race"in window.Promise&&function(){var a;return new window.Promise(function(b){a=b}),f(a)}();a||(window.Promise=e)}var e=a.Promise,f=b.isFunction;c.polyfill=d}),a("promise/promise",["./config","./utils","./cast","./all","./race","./resolve","./reject","./asap","exports"],function(a,b,c,d,e,f,g,h,i){"use strict";function j(a){if(!w(a))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof j))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._subscribers=[],k(a,this)}function k(a,b){function c(a){p(b,a)}function d(a){r(b,a)}try{a(c,d)}catch(e){d(e)}}function l(a,b,c,d){var e,f,g,h,i=w(c);if(i)try{e=c(d),g=!0}catch(j){h=!0,f=j}else e=d,g=!0;o(b,e)||(i&&g?p(b,e):h?r(b,f):a===F?p(b,e):a===G&&r(b,e))}function m(a,b,c,d){var e=a._subscribers,f=e.length;e[f]=b,e[f+F]=c,e[f+G]=d}function n(a,b){for(var c,d,e=a._subscribers,f=a._detail,g=0;g<e.length;g+=3)c=e[g],d=e[g+b],l(b,c,d,f);a._subscribers=null}function o(a,b){var c,d=null;try{if(a===b)throw new TypeError("A promises callback cannot return that same promise.");if(v(b)&&(d=b.then,w(d)))return d.call(b,function(d){return c?!0:(c=!0,b!==d?p(a,d):q(a,d),void 0)},function(b){return c?!0:(c=!0,r(a,b),void 0)}),!0}catch(e){return c?!0:(r(a,e),!0)}return!1}function p(a,b){a===b?q(a,b):o(a,b)||q(a,b)}function q(a,b){a._state===D&&(a._state=E,a._detail=b,u.async(s,a))}function r(a,b){a._state===D&&(a._state=E,a._detail=b,u.async(t,a))}function s(a){n(a,a._state=F)}function t(a){n(a,a._state=G)}var u=a.config,v=(a.configure,b.objectOrFunction),w=b.isFunction,x=(b.now,c.cast),y=d.all,z=e.race,A=f.resolve,B=g.reject,C=h.asap;u.async=C;var D=void 0,E=0,F=1,G=2;j.prototype={constructor:j,_state:void 0,_detail:void 0,_subscribers:void 0,then:function(a,b){var c=this,d=new this.constructor(function(){});if(this._state){var e=arguments;u.async(function(){l(c._state,d,e[c._state-1],c._detail)})}else m(this,d,a,b);return d},"catch":function(a){return this.then(null,a)}},j.all=y,j.cast=x,j.race=z,j.resolve=A,j.reject=B,i.Promise=j}),a("promise/race",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to race.");return new b(function(b,c){for(var d,e=0;e<a.length;e++)d=a[e],d&&"function"==typeof d.then?d.then(b,c):b(d)})}var d=a.isArray;b.race=c}),a("promise/reject",["exports"],function(a){"use strict";function b(a){var b=this;return new b(function(b,c){c(a)})}a.reject=b}),a("promise/resolve",["exports"],function(a){"use strict";function b(a){var b=this;return new b(function(b){b(a)})}a.resolve=b}),a("promise/utils",["exports"],function(a){"use strict";function b(a){return c(a)||"object"==typeof a&&null!==a}function c(a){return"function"==typeof a}function d(a){return"[object Array]"===Object.prototype.toString.call(a)}var e=Date.now||function(){return(new Date).getTime()};a.objectOrFunction=b,a.isFunction=c,a.isArray=d,a.now=e}),b("promise/polyfill").polyfill()}();

if (typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") {
    window.html2canvas = function() {
        return Promise.reject("No canvas support");
    };
    return;
}

/*! https://mths.be/punycode v1.3.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		var labels = string.split(regexSeparators);
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

var html2canvasNodeAttribute = "data-html2canvas-node";
var html2canvasCanvasCloneAttribute = "data-html2canvas-canvas-clone";
var html2canvasCanvasCloneIndex = 0;

window.html2canvas = function(nodeList, options) {
    options = options || {};
    if (options.logging) {
        window.html2canvas.logging = true;
        window.html2canvas.start = Date.now();
    }

    options.async = typeof(options.async) === "undefined" ? true : options.async;
    options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
    options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
    options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
    options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
    options.pixelRatio = typeof(options.pixelRatio) === "undefined" ? 1 : options.pixelRatio;

    if (typeof(nodeList) === "string") {
        if (typeof(options.proxy) !== "string") {
            return Promise.reject("Proxy must be used when rendering url");
        }
        return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, window.innerWidth, window.innerHeight, options).then(function(container) {
            return renderWindow(container.contentWindow.document.documentElement, container, options, window.innerWidth, window.innerHeight);
        });
    }

    var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
    node.setAttribute(html2canvasNodeAttribute, "true");
    return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight).then(function(canvas) {
        if (typeof(options.onrendered) === "function") {
            log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
            options.onrendered(canvas);
        }
        return canvas;
    });
};

window.html2canvas.punycode = this.punycode;
window.html2canvas.proxy = {};

function renderDocument(document, options, windowWidth, windowHeight) {
    return createWindowClone(document, document, windowWidth, windowHeight, options).then(function(container) {
        log("Document cloned");
        var selector = "[" + html2canvasNodeAttribute + "='true']";
        document.querySelector(selector).removeAttribute(html2canvasNodeAttribute);
        var clonedWindow = container.contentWindow;
        var node = clonedWindow.document.querySelector(selector);
        var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
        return oncloneHandler.then(function() {
            return renderWindow(node, container, options, windowWidth, windowHeight);
        });
    });
}

function renderWindow(node, container, options, windowWidth, windowHeight) {
    var clonedWindow = container.contentWindow;
    var support = new Support(clonedWindow.document);
    var imageLoader = new ImageLoader(options, support);
    var bounds = getBounds(node);
    var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
    var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
    var renderer = new CanvasRenderer(width, height, imageLoader, options, document);
    var parser = new NodeParser(node, renderer, support, imageLoader, options);
    return parser.ready.then(function() {
        log("Finished rendering");
        var canvas;

        if (options.type === "view") {
            canvas = crop(renderer.canvas, {width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0});
        } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
            canvas = renderer.canvas;
        } else {
            canvas = crop(renderer.canvas, {width:  options.width != null ? options.width : bounds.width * options.pixelRatio, height: options.height != null ? options.height : bounds.height * options.pixelRatio, top: bounds.top, left: bounds.left, x: clonedWindow.pageXOffset, y: clonedWindow.pageYOffset});
        }

        cleanupContainer(container, options);
        return canvas;
    });
}

function cleanupContainer(container, options) {
    if (options.removeContainer) {
        container.parentNode.removeChild(container);
        log("Cleaned up container");
    }
}

function crop(canvas, bounds) {
    var croppedCanvas = document.createElement("canvas");
    var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
    var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
    var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
    var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
    croppedCanvas.width = bounds.width;
    croppedCanvas.height =  bounds.height;
    log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", (x2-x1), "height:", (y2-y1));
    log("Resulting crop with width", bounds.width, "and height", bounds.height, " with x", x1, "and y", y1);
    croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, x2-x1, y2-y1, bounds.x, bounds.y, x2-x1, y2-y1);
    return croppedCanvas;
}

function documentWidth (doc) {
    return Math.max(
        Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
        Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
        Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
    );
}

function documentHeight (doc) {
    return Math.max(
        Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
        Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
        Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
    );
}

function smallImage() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
}

function createWindowClone(ownerDocument, containerDocument, width, height, options) {
    labelCanvasElements(ownerDocument);
    var documentElement = ownerDocument.documentElement.cloneNode(true),
        container = containerDocument.createElement("iframe");

    container.style.visibility = "hidden";
    container.style.position = "absolute";
    container.style.left = container.style.top = "-10000px";
    container.width = width;
    container.height = height;
    container.scrolling = "no"; // ios won't scroll without it
    containerDocument.body.appendChild(container);

    return new Promise(function(resolve) {
        var documentClone = container.contentWindow.document;
        /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
        if window url is about:blank, we can assign the url to current by writing onto the document
         */
        container.contentWindow.onload = container.onload = function() {
            var interval = setInterval(function() {
                if (documentClone.body.childNodes.length > 0) {
                    cloneCanvasContents(ownerDocument, documentClone);
                    clearInterval(interval);
                    if (options.type === "view") {
                        container.contentWindow.scrollTo(x, y);
                    }
                    resolve(container);
                }
            }, 50);
        };

        var x = ownerDocument.defaultView.pageXOffset;
        var y = ownerDocument.defaultView.pageYOffset;

        documentClone.open();
        documentClone.write("<!DOCTYPE html><html></html>");

        // Chrome scrolls the parent document for some reason after the write to the cloned window???
        if (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset) {
            ownerDocument.defaultView.scrollTo(x, y);
        }
        documentClone.replaceChild(options.javascriptEnabled === true ? documentClone.adoptNode(documentElement) : removeScriptNodes(documentClone.adoptNode(documentElement)), documentClone.documentElement);
        documentClone.close();
    });
}

function loadUrlDocument(src, proxy, document, width, height, options) {
    return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
        return createWindowClone(doc, document, width, height, options);
    });
}

function documentFromHTML(src) {
    return function(html) {
        var parser = new DOMParser(), doc;
        try {
            doc = parser.parseFromString(html, "text/html");
        } catch(e) {
            log("DOMParser not supported, falling back to createHTMLDocument");
            doc = document.implementation.createHTMLDocument("");
            try {
                doc.open();
                doc.write(html);
                doc.close();
            } catch(ee) {
                log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement
            }
        }

        var b = doc.querySelector("base");
        if (!b || !b.href.host) {
            var base = doc.createElement("base");
            base.href = src;
            doc.head.insertBefore(base, doc.head.firstChild);
        }

        return doc;
    };
}


function labelCanvasElements(ownerDocument) {
    [].slice.call(ownerDocument.querySelectorAll("canvas"), 0).forEach(function(canvas) {
        canvas.setAttribute(html2canvasCanvasCloneAttribute, "canvas-" + html2canvasCanvasCloneIndex++);
    });
}

function cloneCanvasContents(ownerDocument, documentClone) {
    [].slice.call(ownerDocument.querySelectorAll("[" + html2canvasCanvasCloneAttribute + "]"), 0).forEach(function(canvas) {
        try {
            var clonedCanvas = documentClone.querySelector('[' + html2canvasCanvasCloneAttribute + '="' + canvas.getAttribute(html2canvasCanvasCloneAttribute) + '"]');
            if (clonedCanvas) {
                clonedCanvas.width = canvas.width;
                clonedCanvas.height = canvas.height;
                clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            }
        } catch(e) {
            log("Unable to copy canvas content from", canvas, e);
        }
        canvas.removeAttribute(html2canvasCanvasCloneAttribute);
    });
}

function removeScriptNodes(parent) {
    [].slice.call(parent.childNodes, 0).filter(isElementNode).forEach(function(node) {
        if (node.tagName === "SCRIPT") {
            parent.removeChild(node);
        } else {
            removeScriptNodes(node);
        }
    });
    return parent;
}

function isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
}

function absoluteUrl(url) {
    var link = document.createElement("a");
    link.href = url;
    link.href = link.href;
    return link;
}

function DummyImageContainer(src) {
    this.src = src;
    log("DummyImageContainer for", src);
    if (!this.promise || !this.image) {
        log("Initiating DummyImageContainer");
        DummyImageContainer.prototype.image = new Image();
        var image = this.image;
        DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
            image.onload = resolve;
            image.onerror = reject;
            image.src = smallImage();
            if (image.complete === true) {
                resolve(image);
            }
        });
    }
}

function Font(family, size) {
    var container = document.createElement('div'),
        img = document.createElement('img'),
        span = document.createElement('span'),
        sampleText = 'Hidden Text',
        baseline,
        middle;

    container.style.visibility = "hidden";
    container.style.fontFamily = family;
    container.style.fontSize = size;
    container.style.margin = 0;
    container.style.padding = 0;

    document.body.appendChild(container);

    img.src = smallImage();
    img.width = 1;
    img.height = 1;

    img.style.margin = 0;
    img.style.padding = 0;
    img.style.verticalAlign = "baseline";

    span.style.fontFamily = family;
    span.style.fontSize = size;
    span.style.margin = 0;
    span.style.padding = 0;

    span.appendChild(document.createTextNode(sampleText));
    container.appendChild(span);
    container.appendChild(img);
    baseline = (img.offsetTop - span.offsetTop) + 1;

    container.removeChild(span);
    container.appendChild(document.createTextNode(sampleText));

    container.style.lineHeight = "normal";
    img.style.verticalAlign = "super";

    middle = (img.offsetTop-container.offsetTop) + 1;

    document.body.removeChild(container);

    this.baseline = baseline;
    this.lineWidth = 1;
    this.middle = middle;
}

function FontMetrics() {
    this.data = {};
}

FontMetrics.prototype.getMetrics = function(family, size) {
    if (this.data[family + "-" + size] === undefined) {
        this.data[family + "-" + size] = new Font(family, size);
    }
    return this.data[family + "-" + size];
};

function FrameContainer(container, sameOrigin, options) {
    this.image = null;
    this.src = container;
    var self = this;
    var bounds = getBounds(container);
    this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
        if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
            container.contentWindow.onload = container.onload = function() {
                resolve(container);
            };
        } else {
            resolve(container);
        }
    })).then(function(container) {
        return html2canvas(container.contentWindow.document.documentElement, {type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2});
    }).then(function(canvas) {
        return self.image = canvas;
    });
}

FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
    var container = this.src;
    return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
};

function GradientContainer(imageData) {
    this.src = imageData.value;
    this.colorStops = [];
    this.type = null;
    this.x0 = 0.5;
    this.y0 = 0.5;
    this.x1 = 0.5;
    this.y1 = 0.5;
    this.promise = Promise.resolve(true);
}

GradientContainer.prototype.TYPES = {
    LINEAR: 1,
    RADIAL: 2
};

function ImageContainer(src, cors) {
    this.src = src;
    this.image = new Image();
    var self = this;
    this.tainted = null;
    this.promise = new Promise(function(resolve, reject) {
        self.image.onload = resolve;
        self.image.onerror = reject;
        if (cors) {
            self.image.crossOrigin = "anonymous";
        }
        self.image.src = src;
        if (self.image.complete === true) {
            resolve(self.image);
        }
    });
}

function ImageLoader(options, support) {
    this.link = null;
    this.options = options;
    this.support = support;
    this.origin = this.getOrigin(window.location.href);
}

ImageLoader.prototype.findImages = function(nodes) {
    var images = [];
    nodes.reduce(function(imageNodes, container) {
        switch(container.node.nodeName) {
        case "IMG":
            return imageNodes.concat([{
                args: [container.node.src],
                method: "url"
            }]);
        case "svg":
        case "IFRAME":
            return imageNodes.concat([{
                args: [container.node],
                method: container.node.nodeName
            }]);
        }
        return imageNodes;
    }, []).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.findBackgroundImage = function(images, container) {
    container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.addImage = function(images, callback) {
    return function(newImage) {
        newImage.args.forEach(function(image) {
            if (!this.imageExists(images, image)) {
                images.splice(0, 0, callback.call(this, newImage));
                log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
            }
        }, this);
    };
};

ImageLoader.prototype.hasImageBackground = function(imageData) {
    return imageData.method !== "none";
};

ImageLoader.prototype.loadImage = function(imageData) {
    if (imageData.method === "url") {
        var src = imageData.args[0];
        if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
            return new SVGContainer(src);
        } else if (src.match(/data:image\/.*;base64,/i)) {
            return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
        } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
            return new ImageContainer(src, false);
        } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
            return new ImageContainer(src, true);
        } else if (this.options.proxy) {
            return new ProxyImageContainer(src, this.options.proxy);
        } else {
            return new DummyImageContainer(src);
        }
    } else if (imageData.method === "linear-gradient") {
        return new LinearGradientContainer(imageData);
    } else if (imageData.method === "gradient") {
        return new WebkitGradientContainer(imageData);
    } else if (imageData.method === "svg") {
        return new SVGNodeContainer(imageData.args[0], this.support.svg);
    } else if (imageData.method === "IFRAME") {
        return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
    } else {
        return new DummyImageContainer(imageData);
    }
};

ImageLoader.prototype.isSVG = function(src) {
    return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
};

ImageLoader.prototype.imageExists = function(images, src) {
    return images.some(function(image) {
        return image.src === src;
    });
};

ImageLoader.prototype.isSameOrigin = function(url) {
    return (this.getOrigin(url) === this.origin);
};

ImageLoader.prototype.getOrigin = function(url) {
    var link = this.link || (this.link = document.createElement("a"));
    link.href = url;
    link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
    return link.protocol + link.hostname + link.port;
};

ImageLoader.prototype.getPromise = function(container) {
    return this.timeout(container, this.options.imageTimeout)['catch'](function() {
        var dummy = new DummyImageContainer(container.src);
        return dummy.promise.then(function(image) {
            container.image = image;
        });
    });
};

ImageLoader.prototype.get = function(src) {
    var found = null;
    return this.images.some(function(img) {
        return (found = img).src === src;
    }) ? found : null;
};

ImageLoader.prototype.fetch = function(nodes) {
    this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
    this.images.forEach(function(image, index) {
        image.promise.then(function() {
            log("Succesfully loaded image #"+ (index+1), image);
        }, function(e) {
            log("Failed loading image #"+ (index+1), image, e);
        });
    });
    this.ready = Promise.all(this.images.map(this.getPromise, this));
    log("Finished searching images");
    return this;
};

ImageLoader.prototype.timeout = function(container, timeout) {
    var timer;
    return Promise.race([container.promise, new Promise(function(res, reject) {
        timer = setTimeout(function() {
            log("Timed out loading image", container);
            reject(container);
        }, timeout);
    })]).then(function(container) {
        clearTimeout(timer);
        return container;
    });
};

function LinearGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = this.TYPES.LINEAR;

    var hasDirection = imageData.args[0].match(this.stepRegExp) === null;

    if (hasDirection) {
        imageData.args[0].split(" ").reverse().forEach(function(position) {
            switch(position) {
                case "left":
                    this.x0 = 0;
                    this.x1 = 1;
                    break;
                case "top":
                    this.y0 = 0;
                    this.y1 = 1;
                    break;
                case "right":
                    this.x0 = 1;
                    this.x1 = 0;
                    break;
                case "bottom":
                    this.y0 = 1;
                    this.y1 = 0;
                    break;
                case "to":
                    var y0 = this.y0;
                    var x0 = this.x0;
                    this.y0 = this.y1;
                    this.x0 = this.x1;
                    this.x1 = x0;
                    this.y1 = y0;
                    break;
            }
        }, this);
    } else {
        this.y0 = 0;
        this.y1 = 1;
    }

    this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
        var colorStopMatch = colorStop.match(this.stepRegExp);
        return {
            color: colorStopMatch[1],
            stop: colorStopMatch[3] === "%" ? colorStopMatch[2] / 100 : null
        };
    }, this);

    if (this.colorStops[0].stop === null) {
        this.colorStops[0].stop = 0;
    }

    if (this.colorStops[this.colorStops.length - 1].stop === null) {
        this.colorStops[this.colorStops.length - 1].stop = 1;
    }

    this.colorStops.forEach(function(colorStop, index) {
        if (colorStop.stop === null) {
            this.colorStops.slice(index).some(function(find, count) {
                if (find.stop !== null) {
                    colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
                    return true;
                } else {
                    return false;
                }
            }, this);
        }
    }, this);
}

LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);

LinearGradientContainer.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/;

function log() {
    if (window.html2canvas.logging && window.console && window.console.log) {
        Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - window.html2canvas.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
    }
}

function NodeContainer(node, parent) {
    this.node = node;
    this.parent = parent;
    this.stack = null;
    this.bounds = null;
    this.borders = null;
    this.clip = [];
    this.backgroundClip = [];
    this.offsetBounds = null;
    this.visible = null;
    this.computedStyles = null;
    this.styles = {};
    this.backgroundImages = null;
    this.transformData = null;
    this.transformMatrix = null;
    this.isPseudoElement = false;
    this.opacity = null;
}

NodeContainer.prototype.cloneTo = function(stack) {
    stack.visible = this.visible;
    stack.borders = this.borders;
    stack.bounds = this.bounds;
    stack.clip = this.clip;
    stack.backgroundClip = this.backgroundClip;
    stack.computedStyles = this.computedStyles;
    stack.styles = this.styles;
    stack.backgroundImages = this.backgroundImages;
    stack.opacity = this.opacity;
};

NodeContainer.prototype.getOpacity = function() {
    return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
};

NodeContainer.prototype.assignStack = function(stack) {
    this.stack = stack;
    stack.children.push(this);
};

NodeContainer.prototype.isElementVisible = function() {
    return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (
        this.css('display') !== "none" &&
        // this.css('visibility') !== "hidden" && // removed by mitr
        !this.node.hasAttribute("data-html2canvas-ignore") &&
        (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden")
    );
};

NodeContainer.prototype.css = function(attribute) {
    if (!this.computedStyles) {
        this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
    }

    return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
};

NodeContainer.prototype.prefixedCss = function(attribute) {
    var prefixes = ["webkit", "moz", "ms", "o"];
    var value = this.css(attribute);
    if (value === undefined) {
        prefixes.some(function(prefix) {
            value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
            return value !== undefined;
        }, this);
    }
    return value === undefined ? null : value;
};

NodeContainer.prototype.computedStyle = function(type) {
    return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
};

NodeContainer.prototype.cssInt = function(attribute) {
    var value = parseInt(this.css(attribute), 10);
    return (isNaN(value)) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html
};

NodeContainer.prototype.cssFloat = function(attribute) {
    var value = parseFloat(this.css(attribute));
    return (isNaN(value)) ? 0 : value;
};

NodeContainer.prototype.fontWeight = function() {
    var weight = this.css("fontWeight");
    switch(parseInt(weight, 10)){
    case 401:
        weight = "bold";
        break;
    case 400:
        weight = "normal";
        break;
    }
    return weight;
};

NodeContainer.prototype.parseClip = function() {
    var matches = this.css('clip').match(this.CLIP);
    if (matches) {
        return {
            top: parseInt(matches[1], 10),
            right: parseInt(matches[2], 10),
            bottom: parseInt(matches[3], 10),
            left: parseInt(matches[4], 10)
        };
    }
    return null;
};

NodeContainer.prototype.parseBackgroundImages = function() {
    return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
};

NodeContainer.prototype.cssList = function(property, index) {
    var value = (this.css(property) || '').split(',');
    value = value[index || 0] || value[0] || 'auto';
    value = value.trim().split(' ');
    if (value.length === 1) {
        value = [value[0], value[0]];
    }
    return value;
};

NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
    var size = this.cssList("backgroundSize", index);
    var width, height;

    if (isPercentage(size[0])) {
        width = bounds.width * parseFloat(size[0]) / 100;
    } else if (/contain|cover/.test(size[0])) {
        var targetRatio = bounds.width / bounds.height, currentRatio = image.width / image.height;
        return (targetRatio < currentRatio ^ size[0] === 'contain') ?  {width: bounds.height * currentRatio, height: bounds.height} : {width: bounds.width, height: bounds.width / currentRatio};
    } else {
        width = parseInt(size[0], 10);
    }

    if (size[0] === 'auto' && size[1] === 'auto') {
        height = image.height;
    } else if (size[1] === 'auto') {
        height = width / image.width * image.height;
    } else if (isPercentage(size[1])) {
        height =  bounds.height * parseFloat(size[1]) / 100;
    } else {
        height = parseInt(size[1], 10);
    }

    if (size[0] === 'auto') {
        width = height / image.height * image.width;
    }

    return {width: width, height: height};
};

NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
    var position = this.cssList('backgroundPosition', index);
    var left, top;

    if (isPercentage(position[0])){
        left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
    } else {
        left = parseInt(position[0], 10);
    }

    if (position[1] === 'auto') {
        top = left / image.width * image.height;
    } else if (isPercentage(position[1])){
        top =  (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
    } else {
        top = parseInt(position[1], 10);
    }

    if (position[0] === 'auto') {
        left = top / image.height * image.width;
    }

    return {left: left, top: top};
};

NodeContainer.prototype.parseBackgroundRepeat = function(index) {
    return this.cssList("backgroundRepeat", index)[0];
};

NodeContainer.prototype.parseTextShadows = function() {
    var textShadow = this.css("textShadow");
    var results = [];

    if (textShadow && textShadow !== 'none') {
        var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
        for (var i = 0; shadows && (i < shadows.length); i++) {
            var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
            results.push({
                color: s[0],
                offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                blur: s[3] ? s[3].replace('px', '') : 0
            });
        }
    }
    return results;
};

NodeContainer.prototype.parseTransform = function() {
    if (!this.transformData) {
        if (this.hasTransform()) {
            var offset = this.parseBounds();
            var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
            origin[0] += offset.left;
            origin[1] += offset.top;
            this.transformData = {
                origin: origin,
                matrix: this.parseTransformMatrix()
            };
        } else {
            this.transformData = {
                origin: [0, 0],
                matrix: [1, 0, 0, 1, 0, 0]
            };
        }
    }
    return this.transformData;
};

NodeContainer.prototype.parseTransformMatrix = function() {
    if (!this.transformMatrix) {
        var transform = this.prefixedCss("transform");
        var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
        this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
    }
    return this.transformMatrix;
};

NodeContainer.prototype.parseBounds = function() {
    return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
};

NodeContainer.prototype.hasTransform = function() {
    return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
};

NodeContainer.prototype.getValue = function() {
    var value = this.node.value || "";
    value = (this.node.tagName === "SELECT") ? selectionValue(this.node) : value;
    return value.length === 0 ? (this.node.placeholder || "") : value;
};

NodeContainer.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/;
NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

function selectionValue(node) {
    var option = node.options[node.selectedIndex || 0];
    return option ? (option.text || "") : "";
}

function parseMatrix(match) {
    if (match && match[1] === "matrix") {
        return match[2].split(",").map(function(s) {
            return parseFloat(s.trim());
        });
    }
}

function isPercentage(value) {
    return value.toString().indexOf("%") !== -1;
}

function parseBackgrounds(backgroundImage) {
    var whitespace = ' \r\n\t',
        method, definition, prefix, prefix_i, block, results = [],
        mode = 0, numParen = 0, quote, args;
    var appendResult = function() {
        if(method) {
            if (definition.substr(0, 1) === '"') {
                definition = definition.substr(1, definition.length - 2);
            }
            if (definition) {
                args.push(definition);
            }
            if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1 ) + 1) > 0) {
                prefix = method.substr(0, prefix_i);
                method = method.substr(prefix_i);
            }
            results.push({
                prefix: prefix,
                method: method.toLowerCase(),
                value: block,
                args: args,
                image: null
            });
        }
        args = [];
        method = prefix = definition = block = '';
    };
    args = [];
    method = prefix = definition = block = '';
    backgroundImage.split("").forEach(function(c) {
        if (mode === 0 && whitespace.indexOf(c) > -1) {
            return;
        }
        switch(c) {
        case '"':
            if(!quote) {
                quote = c;
            } else if(quote === c) {
                quote = null;
            }
            break;
        case '(':
            if(quote) {
                break;
            } else if(mode === 0) {
                mode = 1;
                block += c;
                return;
            } else {
                numParen++;
            }
            break;
        case ')':
            if (quote) {
                break;
            } else if(mode === 1) {
                if(numParen === 0) {
                    mode = 0;
                    block += c;
                    appendResult();
                    return;
                } else {
                    numParen--;
                }
            }
            break;

        case ',':
            if (quote) {
                break;
            } else if(mode === 0) {
                appendResult();
                return;
            } else if (mode === 1) {
                if (numParen === 0 && !method.match(/^url$/i)) {
                    args.push(definition);
                    definition = '';
                    block += c;
                    return;
                }
            }
            break;
        }

        block += c;
        if (mode === 0) {
            method += c;
        } else {
            definition += c;
        }
    });

    appendResult();
    return results;
}

function removePx(str) {
    return str.replace("px", "");
}

function asFloat(str) {
    return parseFloat(str);
}

function getBounds(node) {
    if (node.getBoundingClientRect) {
        var clientRect = node.getBoundingClientRect();
        var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
        return {
            top: clientRect.top,
            bottom: clientRect.bottom || (clientRect.top + clientRect.height),
            right: clientRect.left + width,
            left: clientRect.left,
            width:  width,
            height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
        };
    }
    return {};
}

function offsetBounds(node) {
    var parent = node.offsetParent ? offsetBounds(node.offsetParent) : {top: 0, left: 0};

    return {
        top: node.offsetTop + parent.top,
        bottom: node.offsetTop + node.offsetHeight + parent.top,
        right: node.offsetLeft + parent.left + node.offsetWidth,
        left: node.offsetLeft + parent.left,
        width: node.offsetWidth,
        height: node.offsetHeight
    };
}

function NodeParser(element, renderer, support, imageLoader, options) {
    log("Starting NodeParser");
    this.renderer = renderer;
    this.options = options;
    this.range = null;
    this.support = support;
    this.renderQueue = [];
    this.stack = new StackingContext(true, 1, element.ownerDocument, null);
    var parent = new NodeContainer(element, null);
    if (element === element.ownerDocument.documentElement) {
        // http://www.w3.org/TR/css3-background/#special-backgrounds
        var canvasBackground = new NodeContainer(this.renderer.isTransparent(parent.css('backgroundColor')) ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
        renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.css('backgroundColor'));
    }
    parent.visibile = parent.isElementVisible();
    this.createPseudoHideStyles(element.ownerDocument);
    this.disableAnimations(element.ownerDocument);
    this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
        return container.visible = container.isElementVisible();
    }).map(this.getPseudoElements, this));
    this.fontMetrics = new FontMetrics();
    log("Fetched nodes, total:", this.nodes.length);
    log("Calculate overflow clips");
    this.calculateOverflowClips();
    log("Start fetching images");
    this.images = imageLoader.fetch(this.nodes.filter(isElement));
    this.ready = this.images.ready.then(bind(function() {
        log("Images loaded, starting parsing");
        log("Creating stacking contexts");
        this.createStackingContexts();
        log("Sorting stacking contexts");
        this.sortStackingContexts(this.stack);
        this.parse(this.stack);
        log("Render queue created with " + this.renderQueue.length + " items");
        return new Promise(bind(function(resolve) {
            if (!options.async) {
                this.renderQueue.forEach(this.paint, this);
                resolve();
            } else if (typeof(options.async) === "function") {
                options.async.call(this, this.renderQueue, resolve);
            } else if (this.renderQueue.length > 0){
                this.renderIndex = 0;
                this.asyncRenderer(this.renderQueue, resolve);
            } else {
                resolve();
            }
        }, this));
    }, this));
}

NodeParser.prototype.calculateOverflowClips = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container)) {
            if (isPseudoElement(container)) {
                container.appendToDOM();
            }
            container.borders = this.parseBorders(container);
            var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
            var cssClip = container.parseClip();
            if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                clip.push([["rect",
                        container.bounds.left + cssClip.left,
                        container.bounds.top + cssClip.top,
                        cssClip.right - cssClip.left,
                        cssClip.bottom - cssClip.top
                ]]);
            }
            container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
            container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
            if (isPseudoElement(container)) {
                container.cleanDOM();
            }
        } else if (isTextNode(container)) {
            container.clip = hasParentClip(container) ? container.parent.clip : [];
        }
        if (!isPseudoElement(container)) {
            container.bounds = null;
        }
    }, this);
};

function hasParentClip(container) {
    return container.parent && container.parent.clip.length;
}

NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
    asyncTimer = asyncTimer || Date.now();
    this.paint(queue[this.renderIndex++]);
    if (queue.length === this.renderIndex) {
        resolve();
    } else if (asyncTimer + 20 > Date.now()) {
        this.asyncRenderer(queue, resolve, asyncTimer);
    } else {
        setTimeout(bind(function() {
            this.asyncRenderer(queue, resolve);
        }, this), 0);
    }
};

NodeParser.prototype.createPseudoHideStyles = function(document) {
    this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' +
        '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
};

NodeParser.prototype.disableAnimations = function(document) {
    this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' +
        '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
};

NodeParser.prototype.createStyles = function(document, styles) {
    var hidePseudoElements = document.createElement('style');
    hidePseudoElements.innerHTML = styles;
    document.body.appendChild(hidePseudoElements);
};

NodeParser.prototype.getPseudoElements = function(container) {
    var nodes = [[container]];
    if (container.node.nodeType === Node.ELEMENT_NODE) {
        var before = this.getPseudoElement(container, ":before");
        var after = this.getPseudoElement(container, ":after");

        if (before) {
            nodes.push(before);
        }

        if (after) {
            nodes.push(after);
        }
    }
    return flatten(nodes);
};

function toCamelCase(str) {
    return str.replace(/(\-[a-z])/g, function(match){
        return match.toUpperCase().replace('-','');
    });
}

NodeParser.prototype.getPseudoElement = function(container, type) {
    var style = container.computedStyle(type);
    if(!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
        return null;
    }

    var content = stripQuotes(style.content);
    var isImage = content.substr(0, 3) === 'url';
    var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
    var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);

    for (var i = style.length-1; i >= 0; i--) {
        var property = toCamelCase(style.item(i));
        pseudoNode.style[property] = style[property];
    }

    pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

    if (isImage) {
        pseudoNode.src = parseBackgrounds(content)[0].args[0];
        return [pseudoContainer];
    } else {
        var text = document.createTextNode(content);
        pseudoNode.appendChild(text);
        return [pseudoContainer, new TextContainer(text, pseudoContainer)];
    }
};


NodeParser.prototype.getChildren = function(parentContainer) {
    return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
        var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
        return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
    }, this));
};

NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
    var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
    container.cloneTo(stack);
    var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
    parentStack.contexts.push(stack);
    container.stack = stack;
};

NodeParser.prototype.createStackingContexts = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
            this.newStackingContext(container, true);
        } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
            this.newStackingContext(container, false);
        } else {
            container.assignStack(container.parent.stack);
        }
    }, this);
};

NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
    return container.node.nodeName === "BODY" && this.renderer.isTransparent(container.parent.css('backgroundColor'));
};

NodeParser.prototype.isRootElement = function(container) {
    return container.parent === null;
};

NodeParser.prototype.sortStackingContexts = function(stack) {
    stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
    stack.contexts.forEach(this.sortStackingContexts, this);
};

NodeParser.prototype.parseTextBounds = function(container) {
    return function(text, index, textList) {
        if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
            if (this.support.rangeBounds && !container.parent.hasTransform()) {
                var offset = textList.slice(0, index).join("").length;
                return this.getRangeBounds(container.node, offset, text.length);
            } else if (container.node && typeof(container.node.data) === "string") {
                var replacementNode = container.node.splitText(text.length);
                var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                container.node = replacementNode;
                return bounds;
            }
        } else if(!this.support.rangeBounds || container.parent.hasTransform()){
            container.node = container.node.splitText(text.length);
        }
        return {};
    };
};

NodeParser.prototype.getWrapperBounds = function(node, transform) {
    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
    var parent = node.parentNode,
        backupText = node.cloneNode(true);

    wrapper.appendChild(node.cloneNode(true));
    parent.replaceChild(wrapper, node);
    var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
    parent.replaceChild(backupText, wrapper);
    return bounds;
};

NodeParser.prototype.getRangeBounds = function(node, offset, length) {
    var range = this.range || (this.range = node.ownerDocument.createRange());
    range.setStart(node, offset);
    range.setEnd(node, offset + length);
    return range.getBoundingClientRect();
};

function ClearTransform() {}

NodeParser.prototype.parse = function(stack) {
    // http://www.w3.org/TR/CSS21/visuren.html#z-index
    var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).
    var descendantElements = stack.children.filter(isElement);
    var descendantNonFloats = descendantElements.filter(not(isFloating));
    var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.
    var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.
    var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
    var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
    var text = stack.children.filter(isTextNode).filter(hasText);
    var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).
    negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats)
        .concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
            this.renderQueue.push(container);
            if (isStackingContext(container)) {
                this.parse(container);
                this.renderQueue.push(new ClearTransform());
            }
        }, this);
};

NodeParser.prototype.paint = function(container) {
    try {
        if (container instanceof ClearTransform) {
            this.renderer.ctx.restore();
        } else if (isTextNode(container)) {
            if (isPseudoElement(container.parent)) {
                container.parent.appendToDOM();
            }
            this.paintText(container);
            if (isPseudoElement(container.parent)) {
                container.parent.cleanDOM();
            }
        } else {
            this.paintNode(container);
        }
    } catch(e) {
        log(e);
    }
};

NodeParser.prototype.paintNode = function(container) {
    if (isStackingContext(container)) {
        this.renderer.setOpacity(container.opacity);
        this.renderer.ctx.save();
        if (container.hasTransform()) {
            this.renderer.setTransform(container.parseTransform());
        }
    }

    var bounds = container.parseBounds();
    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
    }, this);

    this.renderer.clip(container.clip, function() {
        this.renderer.renderBorders(container.borders.borders);
    }, this);

    this.renderer.clip(container.backgroundClip, function() {
        switch (container.node.nodeName) {
        case "svg":
        case "IFRAME":
            var imgContainer = this.images.get(container.node);
            if (imgContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imgContainer);
            } else {
                log("Error loading <" + container.node.nodeName + ">", container.node);
            }
            break;
        case "IMG":
            var imageContainer = this.images.get(container.node.src);
            if (imageContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imageContainer);
            } else {
                log("Error loading <img>", container.node.src);
            }
            break;
        case "CANVAS":
            this.renderer.renderImage(container, bounds, container.borders, {image: container.node});
            break;
        case "SELECT":
        case "INPUT":
        case "TEXTAREA":
            this.paintFormValue(container);
            break;
        }
    }, this);
};

NodeParser.prototype.paintFormValue = function(container) {
    if (container.getValue().length > 0) {
        var document = container.node.ownerDocument;
        var wrapper = document.createElement('html2canvaswrapper');
        var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color',
            'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom',
            'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth',
            'boxSizing', 'whiteSpace', 'wordWrap'];

        properties.forEach(function(property) {
            try {
                wrapper.style[property] = container.css(property);
            } catch(e) {
                // Older IE has issues with "border"
                log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
            }
        });
        var bounds = container.parseBounds();
        wrapper.style.position = "fixed";
        wrapper.style.left = bounds.left + "px";
        wrapper.style.top = bounds.top + "px";
        wrapper.textContent = container.getValue();
        document.body.appendChild(wrapper);
        this.paintText(new TextContainer(wrapper.firstChild, container));
        document.body.removeChild(wrapper);
    }
};

NodeParser.prototype.paintText = function(container) {
    container.applyTextTransform();
    var characters = window.html2canvas.punycode.ucs2.decode(container.node.data);
    var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
        return window.html2canvas.punycode.ucs2.encode([character]);
    });

    var weight = container.parent.fontWeight();
    var size = container.parent.css('fontSize');
    var family = container.parent.css('fontFamily');
    var shadows = container.parent.parseTextShadows();

    this.renderer.font(container.parent.css('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
    if (shadows.length) {
        // TODO: support multiple text shadows
        this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
    } else {
        this.renderer.clearShadow();
    }

    this.renderer.clip(container.parent.clip, function() {
        textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
            if (bounds) {
                this.renderer.text(textList[index], bounds.left, bounds.bottom);
                this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
            }
        }, this);
    }, this);
};

NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
    switch(container.css("textDecoration").split(" ")[0]) {
    case "underline":
        // Draws a line at the baseline of the font
        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
        this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.css("color"));
        break;
    case "overline":
        this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.css("color"));
        break;
    case "line-through":
        // TODO try and find exact position for line-through
        this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.css("color"));
        break;
    }
};

NodeParser.prototype.parseBorders = function(container) {
    var nodeBounds = container.parseBounds();
    var radius = getBorderRadiusData(container);
    var borders = ["Top", "Right", "Bottom", "Left"].map(function(side) {
        return {
            width: container.cssInt('border' + side + 'Width'),
            color: container.css('border' + side + 'Color'),
            args: null
        };
    });
    var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);

    return {
        clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
        borders: borders.map(function(border, borderSide) {
            if (border.width > 0) {
                var bx = nodeBounds.left;
                var by = nodeBounds.top;
                var bw = nodeBounds.width;
                var bh = nodeBounds.height - (borders[2].width);

                switch(borderSide) {
                case 0:
                    // top border
                    bh = borders[0].width;
                    border.args = drawSide({
                        c1: [bx, by],
                        c2: [bx + bw, by],
                        c3: [bx + bw - borders[1].width, by + bh],
                        c4: [bx + borders[3].width, by + bh]
                    }, radius[0], radius[1],
                    borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                    break;
                case 1:
                    // right border
                    bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
                    bw = borders[1].width;

                    border.args = drawSide({
                        c1: [bx + bw, by],
                        c2: [bx + bw, by + bh + borders[2].width],
                        c3: [bx, by + bh],
                        c4: [bx, by + borders[0].width]
                    }, radius[1], radius[2],
                    borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                    break;
                case 2:
                    // bottom border
                    by = (by + nodeBounds.height) - (borders[2].width);
                    bh = borders[2].width;
                    border.args = drawSide({
                        c1: [bx + bw, by + bh],
                        c2: [bx, by + bh],
                        c3: [bx + borders[3].width, by],
                        c4: [bx + bw - borders[3].width, by]
                    }, radius[2], radius[3],
                    borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                    break;
                case 3:
                    // left border
                    bw = borders[3].width;
                    border.args = drawSide({
                        c1: [bx, by + bh + borders[2].width],
                        c2: [bx, by],
                        c3: [bx + bw, by + borders[0].width],
                        c4: [bx + bw, by + bh]
                    }, radius[3], radius[0],
                    borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                    break;
                }
            }
            return border;
        })
    };
};

NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
    var backgroundClip = container.css('backgroundClip'),
        borderArgs = [];

    switch(backgroundClip) {
    case "content-box":
    case "padding-box":
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
        break;

    default:
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
        break;
    }

    return borderArgs;
};

function getCurvePoints(x, y, r1, r2) {
    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
    var ox = (r1) * kappa, // control point offset horizontal
        oy = (r2) * kappa, // control point offset vertical
        xm = x + r1, // x-middle
        ym = y + r2; // y-middle
    return {
        topLeft: bezierCurve({x: x, y: ym}, {x: x, y: ym - oy}, {x: xm - ox, y: y}, {x: xm, y: y}),
        topRight: bezierCurve({x: x, y: y}, {x: x + ox,y: y}, {x: xm, y: ym - oy}, {x: xm, y: ym}),
        bottomRight: bezierCurve({x: xm, y: y}, {x: xm, y: y + oy}, {x: x + ox, y: ym}, {x: x, y: ym}),
        bottomLeft: bezierCurve({x: xm, y: ym}, {x: xm - ox, y: ym}, {x: x, y: y + oy}, {x: x, y:y})
    };
}

function calculateCurvePoints(bounds, borderRadius, borders) {
    var x = bounds.left,
        y = bounds.top,
        width = bounds.width,
        height = bounds.height,

        tlh = borderRadius[0][0],
        tlv = borderRadius[0][1],
        trh = borderRadius[1][0],
        trv = borderRadius[1][1],
        brh = borderRadius[2][0],
        brv = borderRadius[2][1],
        blh = borderRadius[3][0],
        blv = borderRadius[3][1];

    var topWidth = width - trh,
        rightHeight = height - brv,
        bottomWidth = width - brh,
        leftHeight = height - blv;

    return {
        topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
        topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
        topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
        topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
        bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
        bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width),  brv - borders[2].width).bottomRight.subdivide(0.5),
        bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
        bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
    };
}

function bezierCurve(start, startControl, endControl, end) {
    var lerp = function (a, b, t) {
        return {
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t
        };
    };

    return {
        start: start,
        startControl: startControl,
        endControl: endControl,
        end: end,
        subdivide: function(t) {
            var ab = lerp(start, startControl, t),
                bc = lerp(startControl, endControl, t),
                cd = lerp(endControl, end, t),
                abbc = lerp(ab, bc, t),
                bccd = lerp(bc, cd, t),
                dest = lerp(abbc, bccd, t);
            return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
        },
        curveTo: function(borderArgs) {
            borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
        },
        curveToReversed: function(borderArgs) {
            borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
        }
    };
}

function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
    var borderArgs = [];

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
        outer1[1].curveTo(borderArgs);
    } else {
        borderArgs.push([ "line", borderData.c1[0], borderData.c1[1]]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
        outer2[0].curveTo(borderArgs);
        borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
        inner2[0].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
        borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
    }

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
        inner1[1].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
    }

    return borderArgs;
}

function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
        corner1[0].curveTo(borderArgs);
        corner1[1].curveTo(borderArgs);
    } else {
        borderArgs.push(["line", x, y]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
    }
}

function negativeZIndex(container) {
    return container.cssInt("zIndex") < 0;
}

function positiveZIndex(container) {
    return container.cssInt("zIndex") > 0;
}

function zIndex0(container) {
    return container.cssInt("zIndex") === 0;
}

function inlineLevel(container) {
    return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function isStackingContext(container) {
    return (container instanceof StackingContext);
}

function hasText(container) {
    return container.node.data.trim().length > 0;
}

function noLetterSpacing(container) {
    return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
}

function getBorderRadiusData(container) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
        var value = container.css('border' + side + 'Radius');
        var arr = value.split(" ");
        if (arr.length <= 1) {
            arr[1] = arr[0];
        }
        return arr.map(asInt);
    });
}

function renderableNode(node) {
    return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
}

function isPositionedForStacking(container) {
    var position = container.css("position");
    var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
    return zIndex !== "auto";
}

function isPositioned(container) {
    return container.css("position") !== "static";
}

function isFloating(container) {
    return container.css("float") !== "none";
}

function isInlineBlock(container) {
    return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function not(callback) {
    var context = this;
    return function() {
        return !callback.apply(context, arguments);
    };
}

function isElement(container) {
    return container.node.nodeType === Node.ELEMENT_NODE;
}

function isPseudoElement(container) {
    return container.isPseudoElement === true;
}

function isTextNode(container) {
    return container.node.nodeType === Node.TEXT_NODE;
}

function zIndexSort(contexts) {
    return function(a, b) {
        return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
    };
}

function hasOpacity(container) {
    return container.getOpacity() < 1;
}

function bind(callback, context) {
    return function() {
        return callback.apply(context, arguments);
    };
}

function asInt(value) {
    return parseInt(value, 10);
}

function getWidth(border) {
    return border.width;
}

function nonIgnoredElement(nodeContainer) {
    return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
}

function flatten(arrays) {
    return [].concat.apply([], arrays);
}

function stripQuotes(content) {
    var first = content.substr(0, 1);
    return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
}

function getWords(characters) {
    var words = [], i = 0, onWordBoundary = false, word;
    while(characters.length) {
        if (isWordBoundary(characters[i]) === onWordBoundary) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(window.html2canvas.punycode.ucs2.encode(word));
            }
            onWordBoundary =! onWordBoundary;
            i = 0;
        } else {
            i++;
        }

        if (i >= characters.length) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(window.html2canvas.punycode.ucs2.encode(word));
            }
        }
    }
    return words;
}

function isWordBoundary(characterCode) {
    return [
        32, // <space>
        13, // \r
        10, // \n
        9, // \t
        45 // -
    ].indexOf(characterCode) !== -1;
}

function hasUnicode(string) {
    return (/[^\u0000-\u00ff]/).test(string);
}

function Proxy(src, proxyUrl, document) {
    var callback = createCallback(supportsCORS);
    var url = createProxyUrl(proxyUrl, src, callback);

    return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
        return decode64(response.content);
    }));
}
var proxyCount = 0;

var supportsCORS = ('withCredentials' in new XMLHttpRequest());
var supportsCORSImage = ('crossOrigin' in new Image());

function ProxyURL(src, proxyUrl, document) {
    var callback = createCallback(supportsCORSImage);
    var url = createProxyUrl(proxyUrl, src, callback);
    return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
        return "data:" + response.type + ";base64," + response.content;
    }));
}

function jsonp(document, url, callback) {
    return new Promise(function(resolve, reject) {
        var s = document.createElement("script");
        var cleanup = function() {
            delete window.html2canvas.proxy[callback];
            document.body.removeChild(s);
        };
        window.html2canvas.proxy[callback] = function(response) {
            cleanup();
            resolve(response);
        };
        s.src = url;
        s.onerror = function(e) {
            cleanup();
            reject(e);
        };
        document.body.appendChild(s);
    });
}

function createCallback(useCORS) {
    return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
}

function createProxyUrl(proxyUrl, src, callback) {
    return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
}

function ProxyImageContainer(src, proxy) {
    var script = document.createElement("script");
    var link = document.createElement("a");
    link.href = src;
    src = link.href;
    this.src = src;
    this.image = new Image();
    var self = this;
    this.promise = new Promise(function(resolve, reject) {
        self.image.crossOrigin = "Anonymous";
        self.image.onload = resolve;
        self.image.onerror = reject;

        new ProxyURL(src, proxy, document).then(function(url) {
            self.image.src = url;
        })['catch'](reject);
    });
}

function PseudoElementContainer(node, parent, type) {
    NodeContainer.call(this, node, parent);
    this.isPseudoElement = true;
    this.before = type === ":before";
}

PseudoElementContainer.prototype.cloneTo = function(stack) {
    PseudoElementContainer.prototype.cloneTo.call(this, stack);
    stack.isPseudoElement = true;
    stack.before = this.before;
};

PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);

PseudoElementContainer.prototype.appendToDOM = function() {
    if (this.before) {
        this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
    } else {
        this.parent.node.appendChild(this.node);
    }
    this.parent.node.className += " " + this.getHideClass();
};

PseudoElementContainer.prototype.cleanDOM = function() {
    this.node.parentNode.removeChild(this.node);
    this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
};

PseudoElementContainer.prototype.getHideClass = function() {
    return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
};

PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

function Renderer(width, height, images, options, document) {
    this.width = width;
    this.height = height;
    this.images = images;
    this.options = options;
    this.document = document;
}

Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
    var paddingLeft = container.cssInt('paddingLeft'),
        paddingTop = container.cssInt('paddingTop'),
        paddingRight = container.cssInt('paddingRight'),
        paddingBottom = container.cssInt('paddingBottom'),
        borders = borderData.borders;

    var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
    var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
    this.drawImage(
        imageContainer,
        0,
        0,
        imageContainer.image.width || width,
        imageContainer.image.height || height,
        bounds.left + paddingLeft + borders[3].width,
        bounds.top + paddingTop + borders[0].width,
        width,
        height
    );
};

Renderer.prototype.renderBackground = function(container, bounds, borderData) {
    if (bounds.height > 0 && bounds.width > 0) {
        this.renderBackgroundColor(container, bounds);
        this.renderBackgroundImage(container, bounds, borderData);
    }
};

Renderer.prototype.renderBackgroundColor = function(container, bounds) {
    var color = container.css("backgroundColor");
    if (!this.isTransparent(color)) {
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, container.css("backgroundColor"));
    }
};

Renderer.prototype.renderBorders = function(borders) {
    borders.forEach(this.renderBorder, this);
};

Renderer.prototype.renderBorder = function(data) {
    if (!this.isTransparent(data.color) && data.args !== null) {
        this.drawShape(data.args, data.color);
    }
};

Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
    var backgroundImages = container.parseBackgroundImages();
    backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
        switch(backgroundImage.method) {
            case "url":
                var image = this.images.get(backgroundImage.args[0]);
                if (image) {
                    this.renderBackgroundRepeating(container, bounds, image, arr.length - (index+1), borderData);
                } else {
                    log("Error loading background-image", backgroundImage.args[0]);
                }
                break;
            case "linear-gradient":
            case "gradient":
                var gradientImage = this.images.get(backgroundImage.value);
                if (gradientImage) {
                    this.renderBackgroundGradient(gradientImage, bounds, borderData);
                } else {
                    log("Error loading background-image", backgroundImage.args[0]);
                }
                break;
            case "none":
                break;
            default:
                log("Unknown background-image type", backgroundImage.args[0]);
        }
    }, this);
};

Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
    var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
    var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
    var repeat = container.parseBackgroundRepeat(index);
    switch (repeat) {
    case "repeat-x":
    case "repeat no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
        break;
    case "repeat-y":
    case "no-repeat repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
        break;
    case "no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
        break;
    default:
        this.renderBackgroundRepeat(imageContainer, position, size, {top: bounds.top, left: bounds.left}, borderData[3], borderData[0]);
        break;
    }
};

Renderer.prototype.isTransparent = function(color) {
    return (!color || color === "transparent" || color === "rgba(0, 0, 0, 0)");
};

function StackingContext(hasOwnStacking, opacity, element, parent) {
    NodeContainer.call(this, element, parent);
    this.ownStacking = hasOwnStacking;
    this.contexts = [];
    this.children = [];
    this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
}

StackingContext.prototype = Object.create(NodeContainer.prototype);

StackingContext.prototype.getParentStack = function(context) {
    var parentStack = (this.parent) ? this.parent.stack : null;
    return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
};

function Support(document) {
    this.rangeBounds = this.testRangeBounds(document);
    this.cors = this.testCORS();
    this.svg = this.testSVG();
}

Support.prototype.testRangeBounds = function(document) {
    var range, testElement, rangeBounds, rangeHeight, support = false;

    if (document.createRange) {
        range = document.createRange();
        if (range.getBoundingClientRect) {
            testElement = document.createElement('boundtest');
            testElement.style.height = "123px";
            testElement.style.display = "block";
            document.body.appendChild(testElement);

            range.selectNode(testElement);
            rangeBounds = range.getBoundingClientRect();
            rangeHeight = rangeBounds.height;

            if (rangeHeight === 123) {
                support = true;
            }
            document.body.removeChild(testElement);
        }
    }

    return support;
};

Support.prototype.testCORS = function() {
    return typeof((new Image()).crossOrigin) !== "undefined";
};

Support.prototype.testSVG = function() {
    var img = new Image();
    var canvas = document.createElement("canvas");
    var ctx =  canvas.getContext("2d");
    img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";

    try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
    } catch(e) {
        return false;
    }
    return true;
};

function SVGContainer(src) {
    this.src = src;
    this.image = null;
    var self = this;

    this.promise = this.hasFabric().then(function() {
        return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
    }).then(function(svg) {
        return new Promise(function(resolve) {
            html2canvas.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
        });
    });
}

SVGContainer.prototype.hasFabric = function() {
    return !html2canvas.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
};

SVGContainer.prototype.inlineFormatting = function(src) {
    return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
};

SVGContainer.prototype.removeContentType = function(src) {
    return src.replace(/^data:image\/svg\+xml(;base64)?,/,'');
};

SVGContainer.prototype.isInline = function(src) {
    return (/^data:image\/svg\+xml/i.test(src));
};

SVGContainer.prototype.createCanvas = function(resolve) {
    var self = this;
    return function (objects, options) {
        var canvas = new html2canvas.fabric.StaticCanvas('c');
        self.image = canvas.lowerCanvasEl;
        canvas
            .setWidth(options.width)
            .setHeight(options.height)
            .add(html2canvas.fabric.util.groupSVGElements(objects, options))
            .renderAll();
        resolve(canvas.lowerCanvasEl);
    };
};

SVGContainer.prototype.decode64 = function(str) {
    return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
};

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function decode64(base64) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var len = base64.length, i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;

    var output = "";

    for (i = 0; i < len; i+=4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i+1]);
        encoded3 = chars.indexOf(base64[i+2]);
        encoded4 = chars.indexOf(base64[i+3]);

        byte1 = (encoded1 << 2) | (encoded2 >> 4);
        byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        byte3 = ((encoded3 & 3) << 6) | encoded4;
        if (encoded3 === 64) {
            output += String.fromCharCode(byte1);
        } else if (encoded4 === 64 || encoded4 === -1) {
            output += String.fromCharCode(byte1, byte2);
        } else{
            output += String.fromCharCode(byte1, byte2, byte3);
        }
    }

    return output;
}

function SVGNodeContainer(node, native) {
    this.src = node;
    this.image = null;
    var self = this;

    this.promise = native ? new Promise(function(resolve, reject) {
        self.image = new Image();
        self.image.onload = resolve;
        self.image.onerror = reject;
        self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
        if (self.image.complete === true) {
            resolve(self.image);
        }
    }) : this.hasFabric().then(function() {
        return new Promise(function(resolve) {
            html2canvas.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
        });
    });
}

SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

function TextContainer(node, parent) {
    NodeContainer.call(this, node, parent);
}

TextContainer.prototype = Object.create(NodeContainer.prototype);

TextContainer.prototype.applyTextTransform = function() {
    this.node.data = this.transform(this.parent.css("textTransform"));
};

TextContainer.prototype.transform = function(transform) {
    var text = this.node.data;
    switch(transform){
        case "lowercase":
            return text.toLowerCase();
        case "capitalize":
            return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
        case "uppercase":
            return text.toUpperCase();
        default:
            return text;
    }
};

function capitalize(m, p1, p2) {
    if (m.length > 0) {
        return p1 + p2.toUpperCase();
    }
}

function WebkitGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = (imageData.args[0] === "linear") ? this.TYPES.LINEAR : this.TYPES.RADIAL;
}

WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

function XHR(url) {
    return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url);

        xhr.onload = function() {
            if (xhr.status === 200) {
                resolve(xhr.responseText);
            } else {
                reject(new Error(xhr.statusText));
            }
        };

        xhr.onerror = function() {
            reject(new Error("Network Error"));
        };

        xhr.send();
    });
}

function CanvasRenderer(width, height) {
    Renderer.apply(this, arguments);
    this.canvas = this.options.canvas || this.document.createElement("canvas");
    if (!this.options.canvas) {
        this.canvas.width = width * this.options.pixelRatio;
        this.canvas.height = height * this.options.pixelRatio;
    }
    this.ctx = this.canvas.getContext("2d");
    if (this.options.background) {
        this.rectangle(0, 0, width, height, this.options.background);
    }
    this.taintCtx = this.document.createElement("canvas").getContext("2d");
    this.ctx.textBaseline = "bottom";
    this.variables = {};
    log("Initialized CanvasRenderer with size", width, "x", height);
}

CanvasRenderer.prototype = Object.create(Renderer.prototype);

CanvasRenderer.prototype.setFillStyle = function(color) {
    this.ctx.fillStyle = color;
    return this.ctx;
};

CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
    this.setFillStyle(color).fillRect(left, top, width, height);
};

CanvasRenderer.prototype.drawShape = function(shape, color) {
    this.shape(shape);
    this.setFillStyle(color).fill();
};

CanvasRenderer.prototype.taints = function(imageContainer) {
    if (imageContainer.tainted === null) {
        this.taintCtx.drawImage(imageContainer.image, 0, 0);
        try {
            this.taintCtx.getImageData(0, 0, 1, 1);
            imageContainer.tainted = false;
        } catch(e) {
            this.taintCtx = document.createElement("canvas").getContext("2d");
            imageContainer.tainted = true;
        }
    }

    return imageContainer.tainted;
};

CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (!this.taints(imageContainer) || this.options.allowTaint) {
        this.ctx.save();
        this.ctx.scale(this.options.pixelRatio, this.options.pixelRatio);
        this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
        this.ctx.restore();
    }
};

CanvasRenderer.prototype.clip = function(shapes, callback, context) {
    this.ctx.save();
    shapes.filter(hasEntries).forEach(function(shape) {
        this.shape(shape).clip();
    }, this);
    callback.call(context);
    this.ctx.restore();
};

CanvasRenderer.prototype.shape = function(shape) {
    this.ctx.save();
    this.ctx.scale(this.options.pixelRatio, this.options.pixelRatio);
    this.ctx.beginPath();
    shape.forEach(function(point, index) {
        if (point[0] === "rect") {
            this.ctx.rect.apply(this.ctx, point.slice(1));
        } else {
            this.ctx[(index === 0) ? "moveTo" : point[0] + "To" ].apply(this.ctx, point.slice(1));
        }
    }, this);
    this.ctx.closePath();
    this.ctx.restore();
    return this.ctx;
};

CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
    this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
};

CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
    this.setVariable("shadowColor", color)
        .setVariable("shadowOffsetY", offsetX)
        .setVariable("shadowOffsetX", offsetY)
        .setVariable("shadowBlur", blur);
};

CanvasRenderer.prototype.clearShadow = function() {
    this.setVariable("shadowColor", "rgba(0,0,0,0)");
};

CanvasRenderer.prototype.setOpacity = function(opacity) {
    this.ctx.globalAlpha = opacity;
};

CanvasRenderer.prototype.setTransform = function(transform) {
    this.ctx.translate(transform.origin[0], transform.origin[1]);
    this.ctx.transform.apply(this.ctx, transform.matrix);
    this.ctx.translate(-transform.origin[0], -transform.origin[1]);
};

CanvasRenderer.prototype.setVariable = function(property, value) {
    if (this.variables[property] !== value) {
        this.variables[property] = this.ctx[property] = value;
    }

    return this;
};

CanvasRenderer.prototype.text = function(text, left, bottom) {
    this.ctx.save();
    this.ctx.scale(this.options.pixelRatio, this.options.pixelRatio);
    this.ctx.fillText(text, left, bottom);
    this.ctx.restore();
};

CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
    var shape = [
        ["line", Math.round(left), Math.round(top)],
        ["line", Math.round(left + width), Math.round(top)],
        ["line", Math.round(left + width), Math.round(height + top)],
        ["line", Math.round(left), Math.round(height + top)]
    ];
    this.clip([shape], function() {
        this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
    }, this);
};

CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
    var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft), offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
    this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
};

CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
    if (gradientImage instanceof LinearGradientContainer) {
        var gradient = this.ctx.createLinearGradient(
            bounds.left + bounds.width * gradientImage.x0,
            bounds.top + bounds.height * gradientImage.y0,
            bounds.left +  bounds.width * gradientImage.x1,
            bounds.top +  bounds.height * gradientImage.y1);
        gradientImage.colorStops.forEach(function(colorStop) {
            gradient.addColorStop(colorStop.stop, colorStop.color);
        });
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
    }
};

CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
    var image = imageContainer.image;
    if(image.width === size.width && image.height === size.height) {
        return image;
    }

    var ctx, canvas = document.createElement('canvas');
    canvas.width = size.width;
    canvas.height = size.height;
    ctx = canvas.getContext("2d");
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height );
    return canvas;
};

function hasEntries(array) {
    return array.length > 0;
}

}).call({}, window, document);

"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function All_LogicClass(_obj) {
  var modelObj = {
    currentStep: 0,
    checkingAnsCounter: 0,
    correctData: {
      step0: 'AB',
      step1: 'BC',
      step2: 'CD',
      step3: 'DA'
    },
    aPlotted: false,
    bPlotted: false,
    cPlotted: false,
    dPlotted: false,
    snappingDiff: 1,
    colorCount: 0,
    currentStepData: null,
    order: null,
    nStep: 0,
    nPlanStep: 0,
    planSegColor: false,
    planAngleColor: false,
    c1Plotted: false,
    c2Plotted: false,
    s1Plotted: false,
    s2Plotted: false,
    p1Plotted: false,
    p2Plotted: false
  };
  var mathObj, Maths;
  var brainObj = {}; // --------------------

  var events = {}; // --------------------

  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------
  // --------------------

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.init = function (_objMain) {
    Object.keys(_objMain).forEach(function (i) {
      brainObj[i] = _objMain[i];
    });
  };

  this.setMathObj = function (_mathObj, _Maths) {
    mathObj = _mathObj;
    Maths = _Maths;
  }; // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.updateRender = function (_obj) {
    Object.keys(_obj).forEach(function (i) {
      brainObj[i] = _obj[i];
    });
  };

  this.getCurrentStep = function () {
    return modelObj.currentStep;
  };

  this.getCorrectData = function () {
    return modelObj.correctData;
  };

  this.setSegmentOrder = function (_obj) {
    // console.log("CCCCCCCCCCCCCCCCC",_obj);
    modelObj.order = _obj;
  };

  this.setSnappingDiff = function (_val) {
    modelObj.snappingDiff = _val;
  };

  this.resetLogicFlag = function (_bool) {
    modelObj.planSegColor = _bool;
    modelObj.planAngleColor = _bool;
    modelObj.colorCount = 0;
    modelObj.nStep = 0;
    modelObj.c1Plotted = _bool;
    modelObj.c2Plotted = _bool;
    modelObj.s1Plotted = _bool;
    modelObj.s2Plotted = _bool;
    modelObj.p1Plotted = _bool;
    modelObj.p2Plotted = _bool;
  };

  this.getStepsText = function () {
    // console.log(brainObj.currentQuestion.variant);
    switch (brainObj.currentQuestion.variant) {
      case 1:
      case 2:
        return {
          steps: ['stepData1', 'stepData1_1', 'stepData1_2', 'stepData1_3', 'stepData1_4', 'stepData1_5', 'stepData1_6']
        };

      case 3:
      case 4:
        return {
          steps: ['stepData1', 'stepData1_1', 'stepData3_2', 'stepData3_3', 'stepData3_4', 'stepData3_5', 'stepData1_6']
        };

      case 5:
        return {
          steps: ['stepData1', 'stepData1_1', 'stepData5_2', 'stepData5_3', 'stepData5_4', 'stepData5_5', 'stepData1_6']
        };
    }
  };

  this.getQuestionText = function () {
    var task = modelObj.LabComClass.globalLangText.question_1;
    task = task.replace('$aVal', brainObj.currentQuestion.a);
    task = task.replace('$bVal', brainObj.currentQuestion.b);
    task = brainObj.currentQuestion.situation !== 3 ? task.replace('$angleVal', brainObj.currentQuestion.degree) : task.replace('$angleVal', 180 - brainObj.currentQuestion.degree);
    task = task.replace('$angleSym', modelObj.LabComClass.globalLangText[brainObj.currentQuestion.given[2]]);
    return task;
  }; // =================================================


  this.draw = function () {}; // =================================================


  this.resetAll = function (_fullReset) {
    modelObj.currentStep = 0;

    if (_fullReset) {
      modelObj.correctData = {};
    }
  }; // ================================================


  this.setGivenValues = function (_obj) {
    modelObj.given = _toConsumableArray(_obj);
  };

  this.moveToNextStep = function (_step) {
    setStep({
      step: _step
    });
  };

  function nextStep() {
    modelObj.currentStep++;
    setStep({
      step: modelObj.currentStep
    });
  }

  this.addDefaultData = function (d) {
    var shapes = [];

    for (var i = 0; i < 1; i++) {
      var _obj2 = JSON.parse(JSON.stringify(d[i])); // _obj.step = 0;


      shapes.push(_obj2);
    }

    return shapes;
  };

  this.checkPlanInteraction = function (_objD, question) {
    // /// console.log(modelObj.LabComClass.globalLangText.alpha);
    var angleLabels = [];
    Object.keys(modelObj.LabComClass.globalLangText).forEach(function (el) {
      if (question.given.includes(el)) {
        angleLabels.push(modelObj.LabComClass.globalLangText[el]);
      }
    }); /// console.log(angleLabels);
    /// console.log('In pLAn Inter',_objD,question.given,modelObj.given);
    /// console.log(question.given.includes(_objD.shapeLabel));
    /// console.log(Object.values(modelObj.LabComClass.globalLangText).includes(_objD.shapeLabel));

    var flag = -1; // console.log(flag,modelObj.colorCount,question.given.length);

    modelObj.given.forEach(function (el, i) {
      if (el === _objD.shapeLabel || modelObj.LabComClass.globalLangText[el] === _objD.shapeLabel) {
        flag = i;
        modelObj.colorCount++;
        modelObj.given.splice(i, 1);
      }
    });

    if (flag >= 0 && modelObj.colorCount === question.given.length) {
      return {
        match: true,
        completed: true,
        drawnD: _objD
      };
    }

    if (flag >= 0 && modelObj.colorCount !== question.given.length || question.given.includes(_objD.shapeLabel) || angleLabels.includes(_objD.shapeLabel)) {
      /// console.log('HEREE');
      flag = -1;
      return {
        match: true,
        completed: {
          partial: true
        },
        drawnD: _objD
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: _objD
      };
    }
  }; // =================================================


  this.checkPlanInteractions = function (_objD, question) {
    // console.log(modelObj.LabComClass.globalLangText.alpha);
    // console.log(_objD);
    if (_objD.shapeLabel === question.given[0]) {
      modelObj.planSegColor = _objD.type === 'brush2' ? true : false;
    } else if (_objD.shapeLabel === modelObj.LabComClass.globalLangText[question.given[1]]) {
      modelObj.planAngleColor = _objD.type === 'brush2' ? true : false;
    } else if (_objD.shapeLabel === question.given[1]) {
      modelObj.planAngleColor = _objD.type === 'brush2' ? true : false;
    } else {
      return {
        match: false,
        completed: false,
        drawnD: _objD
      };
    }

    if (modelObj.planSegColor && !modelObj.planAngleColor) {
      return {
        match: true,
        completed: {
          partial: true,
          segColor: true,
          angleColor: false
        },
        drawnD: _objD
      };
    } else if (!modelObj.planSegColor && modelObj.planAngleColor) {
      return {
        match: true,
        completed: {
          partial: true,
          segColor: false,
          angleColor: true
        },
        drawnD: _objD
      };
    } else if (modelObj.planSegColor && modelObj.planAngleColor) {
      return {
        match: true,
        completed: true,
        drawnD: _objD
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: _objD
      };
    }
  };

  this.checkInteraction = function (_objD, step, question, visible) {
    if (question.situation === 1 || question.situation === 2 || true) {
      var match = false;

      switch (step) {
        case 1:
          //Segment Size
          match = checkSegmentStep1(_objD, question);
          break;

        case 2:
          //check Angle
          match = checkAngle(_objD, question);
          break;

        case 3:
          //check Step 3
          match = checkStep3(_objD, question);
          break;

        case 4:
          match = checkSegment(_objD, question);
          break;

        case 5:
          //check step 4
          match = checkStep4(_objD, question);
          break;

        case 6:
          //check Final Step
          match = checkFinalStep(_objD, question);
          break;
      }

      return match;
    }
  };

  function checkForMirrorPoint(data, question) {
    var actualPoint = question["point".concat(question.pointToCheckStep3)]; // console.log(actualPoint);

    if (data.type === 'mirrorOnLine' && +data.x.toFixed(2) === +actualPoint.x.toFixed(2) && +data.y.toFixed(2) === +actualPoint.y.toFixed(2)) {
      data.label = question.pointToCheckStep3;
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkForStep2(data, question) {
    var match;

    if (modelObj.nStep === 0) {
      match = checkSegmentSize(data, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 1) {
      match = checkFor2Circles(data, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 2) {
      match = checkForOtherCircle(data, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 3) {
      match = checkPoint(data, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 4) {
      match = checkFor2Segments(data, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 5) {
      match = checkForOtherSegment(data, question);

      if (match.match) {
        modelObj.nStep = 0;
        return match;
      } else {
        return match;
      }
    }
  }

  function getSegmentLabel(label) {
    var newLabel;

    switch (label) {
      case 'BC':
      case 'CB':
        newLabel = 'b';
        break;

      case 'AD':
      case 'DA':
        newLabel = 'd';
        break;

      case 'AC':
      case 'CA':
        newLabel = 'e';
        break;

      case 'BD':
      case 'DB':
        newLabel = 'f';
        break;
    }

    return newLabel;
  }

  function checkForOtherSegment(data, question) {
    var segmentsToCheck = question.diagnol === 'AC' ? ['AC', 'BC'] : ['BD', 'AD'];
    var segmentToCheck = modelObj.s1Plotted ? segmentsToCheck[1] : segmentsToCheck[0]; // console.log('STC',segmentToCheck);

    if (data.type === 'segment' && (data.label === segmentToCheck || data.label === segmentToCheck.split("").reverse().join(""))) {
      data.label = getSegmentLabel(data.label);
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkFor2Segments(data, question) {
    var segmentsToCheck = question.diagnol === 'AC' ? ['AC', 'BC'] : ['BD', 'AD'];
    var flag = -1; // console.log(segmentsToCheck);

    for (var i = 0; i <= 1; i++) {
      if (data.type === 'segment' && (data.label === segmentsToCheck[i] || data.label === segmentsToCheck[i].split("").reverse().join(""))) {
        data.label = getSegmentLabel(data.label);
        flag = i;

        if (i === 0) {
          modelObj.s1Plotted = true;
        } else if (i === 1) {
          modelObj.s2Plotted = true;
        }

        break;
      }
    }

    if (flag >= 0) {
      // console.log( modelObj.s1Plotted, modelObj.s2Plotted);
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkFor2Circles(data, question) {
    var flag = -1;

    for (var i = 1; i <= 2; i++) {
      var circleCenter = "c".concat(i);
      var centerPoint = "point".concat(question[circleCenter]);
      var actualR = circleCenter === 'c1' ? question.dVal : question.side; // console.log('CENTER',i,centerPoint,actualR);

      if (data.type === 'circleSize' && data.x === question[centerPoint].x && data.y === question[centerPoint].y && data.r.toFixed(2) >= actualR - 0.5 && data.r.toFixed(2) <= actualR + 0.5) {
        data.r = actualR;
        flag = i;

        if (i === 1) {
          modelObj.c1Plotted = true;
        } else if (i === 2) {
          modelObj.c2Plotted = true;
        }

        break;
      }
    }

    if (flag >= 1) {
      // console.log( modelObj.c1Plotted, modelObj.c2Plotted);
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkForOtherCircle(data, question) {
    var circleCenter = modelObj.c1Plotted ? "c2" : "c1";
    var centerPoint = "point".concat(question[circleCenter]);
    var actualR = circleCenter === 'c1' ? question.dVal : question.side;
    return checkCircleFn(data, question, centerPoint, actualR);
  }

  function checkFinalStep(data, question) {
    var flag = -1;
    var last = false;

    for (var i = 0; i < modelObj.order.length; i++) {
      var reverseLabel = modelObj.order[i].split('').reverse().join(''); // console.log(modelObj.order,data.label);

      if ((data.label === modelObj.order[i] || data.label === reverseLabel) && modelObj.order.length == 1) {
        modelObj.order = mathObj.getOrder(question);
        flag = i;
        last = true;
        break;
      } else if ((data.label === modelObj.order[i] || data.label === reverseLabel) && modelObj.order.length !== 1) {
        modelObj.order.splice(i, 1);
        flag = i;
        break;
      }
    }

    if (flag >= 0 && last) {
      last = false;
      flag = -1;
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else if (flag >= 0) {
      return {
        match: true,
        completed: {
          partial: true,
          segPlotted: data.label
        },
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkFinalStepx(data, correctData) {
    var reverseLabel = modelObj.order[0].split('').reverse().join(''); // console.log(modelObj.order,data.label);

    if ((data.label === modelObj.order[0] || data.label === reverseLabel) && modelObj.order.length !== 1) {
      modelObj.order.shift();
      return {
        match: true,
        completed: {
          partial: true,
          segPlotted: data.label
        },
        drawnD: data
      };
    }

    if ((data.label === modelObj.order[0] || data.label === reverseLabel) && modelObj.order.length == 1) {
      modelObj.order = correctData.order;
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkStep4Old(data, question) {
    var match;
    var pointIntersection = question.variant === 1 || question.variant === 3 ? 'C' : 'D';

    if (modelObj.nStep === 0) {
      match = checkParallel(data, modelObj.nStep, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 1) {
      match = checkParallel(data, modelObj.nStep, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 2) {
      match = checkPoint(data, question, pointIntersection);

      if (match.match) {
        modelObj.nStep = 0;
        return match;
      } else {
        return match;
      }
    }
  }

  function checkStep4(data, question) {
    var match;
    var pointIntersection = question.situation === 1 || question.situation === 3 ? 'D' : 'C';

    if (modelObj.nStep === 0) {
      match = check2Parallel(data, modelObj.nStep, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 1) {
      match = checkOtherParallel(data, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 2) {
      match = checkPoint(data, question, pointIntersection);

      if (match.match) {
        modelObj.nStep = 0;
        return match;
      } else {
        return match;
      }
    }
  }

  function checkStep3(data, question) {
    var match;

    if (modelObj.nStep === 0) {
      match = checkCircle(data, question);

      if (match.match) {
        return lastStepTrue(data);
      } else {
        return match;
      }
    } else if (modelObj.nStep === 1) {
      match = checkPoint(data, question);

      if (match.match) {
        modelObj.nStep = 0;
        return match;
      } else {
        return match;
      }
    }
  }

  function lastStepTrue(data) {
    modelObj.nStep++;
    return {
      match: true,
      completed: {
        partial: true,
        step: modelObj.nStep
      },
      drawnD: data
    };
  }

  function checkAngle(data, question) {
    if (data.type === 'angleSize' && data.degree === question.degree && data.clockwise === question.angClockWise && data.x === question["point".concat(question.angleOver)].x && data.y === question["point".concat(question.angleOver)].y) {
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkSegmentStep1(data, question) {
    // console.log(data,question);
    var angle = modelObj.LabComClass.Maths.getAngle(data.x, data.y, data.xTo, data.yTo); /// console.log(angle);
    // if(data.type === 'segment' && data.x === question.pointA.x && data.y === question.pointA.y && data.distance >= question.a - 0.2 && data.distance <= question.a + 0.2 ) {
    // if(data.type === 'segment' && data.x === question.pointA.x && data.y === question.pointA.y && data.distance >= question.a - 0.04 && data.distance <= question.a + 0.04 ) {

    if (data.type === 'segment' && data.x === question.pointA.x && data.y === question.pointA.y && +data.distance.toFixed(1) === question.a) {
      // if(data.type === 'segment' && data.distance === question.side ) {
      /// console.log('XX',modelObj.LabComClass.Maths.getPoint({x:data.x,y:data.y},angle,question.side));
      var updatedPoint = modelObj.LabComClass.Maths.getPoint({
        x: data.x,
        y: data.y
      }, angle, question.a);
      data.xTo = updatedPoint.x;
      data.yTo = updatedPoint.y;
      data.distance = question.side;
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    }

    return {
      match: false,
      completed: false,
      drawnD: data
    };
  }

  function checkSegmentSize(data, correctData) {
    // console.log(data);
    if (data.type === 'segSize' && data.x === correctData.pointA.x && data.y === correctData.pointA.y && data.distance === correctData.a) {
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkSegment(data, question) {
    var label = question.segmentToCheckStep4 === 'AD' ? 'd' : 'b'; // console.log(data.label,question.segmentToCheckStep4);

    if (data.type === 'segment' && (data.label === question.segmentToCheckStep4 || data.label === question.segmentToCheckStep4.split("").reverse().join(""))) {
      data.label = label;
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function isPointOnLine(x, y, eqn) {
    if (eqn.slope !== undefined) {
      var LHS = y - eqn.y1;
      var RHS = eqn.slope * (x - eqn.x1); // console.log('LHS',LHS,'RHS',RHS);

      if (+LHS.toFixed(3) === +RHS.toFixed(3)) {
        return true;
      } else {
        return false;
      }
    } else {
      if (x === eqn.x1) {
        return true;
      } else {
        return false;
      }
    }
  }

  function computeEqn(segment) {
    var eqn = {};
    eqn.segment = segment.label;
    eqn.slope = isFinite(getSlope(segment.x, segment.y, segment.xTo, segment.yTo)) ? getSlope(segment.x, segment.y, segment.xTo, segment.yTo) : undefined;

    if (eqn.slope !== undefined) {
      eqn.eqn = "y-".concat(segment.y, "=").concat(eqn.slope, "*(x-").concat(segment.x, ")");
      eqn.b = 1;
      eqn.a = -eqn.slope;
      eqn.c = eqn.slope * segment.x - segment.y;
      eqn.cMod = Math.abs(eqn.slope * segment.x - segment.y);
      eqn.form = "y+".concat(eqn.a, "x+").concat(eqn.c);
      eqn.y1 = segment.y;
      eqn.x1 = segment.x;
    } else {
      eqn.eqn = "x=".concat(segment.x);
      eqn.form = "x-".concat(segment.x);
      eqn.a = 1;
      eqn.b = 0;
      eqn.c = -segment.x;
      eqn.cMod = Math.abs(-segment.x);
      eqn.slope = undefined;
      eqn.x1 = -eqn.c;
    }

    return eqn;
  }

  function check2Parallel(data, step, question) {
    var mainFlag = -1,
        flag = -1;
    var eqn = computeEqn(data); // console.log(eqn);

    var pointToCheckLabel = question["pointToCheckForOverlap"];
    var pointToCheck = question["point".concat(pointToCheckLabel)]; // console.log('PTC',pointToCheck);

    for (var i = 0; i < question.pointsToValidate.length; i++) {
      var pointToV = question.pointsToValidate[i][i];

      for (var j = 0; j < pointToV.length; j++) {
        var point = "point".concat(pointToV[j]); // console.log('------',point,i,j);
        // if (
        //   data.type === 'parallelLine' &&
        //   +data.x.toFixed(2) >= question[point].x - 0.2 &&
        //   +data.x.toFixed(2) <= question[point].x + 0.2 &&
        //   +data.y.toFixed(2) >= question[point].y - 0.2 &&
        //   +data.y.toFixed(2) <= question[point].y + 0.2 &&
        //   !isPointOnLine(pointToCheck.x,pointToCheck.y,eqn)
        // )
        // console.log('----',+data.x.toFixed(2) , question[point].x ,
        // +data.y.toFixed(2) , question[point].y  );

        if (data.type === 'parallelLine' && +data.x.toFixed(2) === +question[point].x.toFixed(2) && +data.y.toFixed(2) === +question[point].y.toFixed(2) && !isPointOnLine(pointToCheck.x, pointToCheck.y, eqn)) {
          data.x = question[point].x;
          data.y = question[point].y;
          data.yTo = question[point].y;
          data.yOr = question[point].y;
          data.yOrTo = question[point].y;
          flag = i;

          if (flag === 0) {
            modelObj.p1Plotted = true;
          } else if (flag === 1) {
            modelObj.p2Plotted = true;
          }

          return {
            match: true,
            completed: true,
            drawnD: data,
            flag: flag
          };
        }
      }
    }

    if (flag === -1) {
      return {
        match: false,
        completed: false,
        drawnD: data,
        flag: flag
      };
    }
  }

  function getSlope(_x1, _y1, _x2, _y2) {
    return (_y2 - _y1) / (_x2 - _x1);
  }

  ;

  function checkOtherParallel(data, question) {
    var step = modelObj.p1Plotted ? 1 : 0;
    var flag = -1,
        mainFlag = -1;
    var eqn = computeEqn(data);
    var pointToV = question.pointsToValidate[step][step];
    var pointToCheckLabel = question["pointToCheckForOverlap"];
    var pointToCheck = question["point".concat(pointToCheckLabel)]; // console.log('OOOOOPPPPPPPP',pointToV);

    for (var i = 0; i < pointToV.length; i++) {
      var point = "point".concat(pointToV[i]); // console.log('Other Parallel -------',point);
      // if (
      //   data.type === 'parallelLine' &&
      //   +data.x.toFixed(2) >= question[point].x - 0.2 &&
      //   +data.x.toFixed(2) <= question[point].x + 0.2 &&
      //   +data.y.toFixed(2) >= question[point].y - 0.2 &&
      //   +data.y.toFixed(2) <= question[point].y + 0.2 &&
      //   !isPointOnLine(pointToCheck.x,pointToCheck.y,eqn)
      // ) {

      if (data.type === 'parallelLine' && +data.x.toFixed(2) === +question[point].x.toFixed(2) && +data.y.toFixed(2) === +question[point].y.toFixed(2) && !isPointOnLine(pointToCheck.x, pointToCheck.y, eqn)) {
        data.x = question[point].x;
        data.y = question[point].y;
        data.yTo = question[point].y;
        data.yOr = question[point].y;
        data.yOrTo = question[point].y;
        flag = i;
        return {
          match: true,
          completed: true,
          drawnD: data,
          flag: flag
        };
      }
    }

    if (flag === -1) {
      return {
        match: false,
        completed: false,
        drawnD: data,
        flag: flag
      };
    }
  }

  function checkParallel(data, step, question) {
    var flag = -1,
        mainFlag = -1;
    var pointToV = question.pointsToValidate[step][step]; // console.log(pointToV);

    for (var i = 0; i < pointToV.length; i++) {
      var point = "point".concat(pointToV[i]); // console.log('-------',point);

      if (data.type === 'parallelLine' && +data.x.toFixed(2) >= question[point].x - 0.2 && +data.x.toFixed(2) <= question[point].x + 0.2 && +data.y.toFixed(2) >= question[point].y - 0.2 && +data.y.toFixed(2) <= question[point].y + 0.2) {
        data.x = question[point].x;
        data.y = question[point].y;
        data.yTo = question[point].y;
        data.yOr = question[point].y;
        data.yOrTo = question[point].y;
        flag = i;
        return {
          match: true,
          completed: true,
          drawnD: data,
          flag: flag
        };
      }
    }

    if (flag === -1) {
      return {
        match: false,
        completed: false,
        drawnD: data,
        flag: flag
      };
    }
  }

  function checkParallelOld(data, step, question) {
    var flag = -1;
    var pointToV = question.pointsToValidate[step][step]; // console.log(pointToV);

    for (var i = 0; i < pointToV.length; i++) {
      var point = "point".concat(pointToV[i]); // console.log('-------',point);

      if (data.type === 'parallelLine' && +data.x.toFixed(2) >= question[point].x - 0.2 && +data.x.toFixed(2) <= question[point].x + 0.2 && +data.y.toFixed(2) >= question[point].y - 0.2 && +data.y.toFixed(2) <= question[point].y + 0.2) {
        data.x = question[point].x;
        data.y = question[point].y;
        data.yTo = question[point].y;
        data.yOr = question[point].y;
        data.yOrTo = question[point].y;
        flag = i;
        return {
          match: true,
          completed: true,
          drawnD: data
        };
      }
    }

    if (flag === -1) {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function checkCircle(data, question) {
    var centerPoint = "point".concat(question.angleOver);
    var actualR = question.r;
    return checkCircleFn(data, question, centerPoint, actualR);
  }

  function checkCircleFn(data, question, centerPoint, actualR) {
    if (data.type === 'circleSize' && data.x === question[centerPoint].x && data.y === question[centerPoint].y && data.r.toFixed(2) >= actualR - 0.5 && data.r.toFixed(2) <= actualR + 0.5) {
      data.r = actualR;
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }

  function checkPoint(data, question, label) {
    var pointLabel;
    pointLabel = label === undefined ? question.pointToCheckStep3 : label;
    var dist = distance(question["point".concat(pointLabel)], data);

    if (data.type === 'point' && Math.trunc(dist * 10) === 0) {
      data.x = question["point".concat(pointLabel)].x;
      data.y = question["point".concat(pointLabel)].y;
      data.label = pointLabel;
      return {
        match: true,
        completed: true,
        drawnD: data
      };
    } else {
      return {
        match: false,
        completed: false,
        drawnD: data
      };
    }
  }

  var distance = function distance(a, b) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  }; // =================================================

  /*
   * This function is used to update the Lab with the Updated Value
   */


  function setStep(_step) {
    dispatchEventCustom('setStep', _step);
  } // =================================================


  this.setCurrentStep = function (val) {
    modelObj.currentStep = val;
  }; // =================================================


  function updateIndex(data) {
    dispatchEventCustom('onUpdateIndex', data);
  } // =================================================
  // =================================================


  function dispatchEventCustom(event, data) {
    if (typeof events[event] !== 'undefined') {
      events[event]({
        type: event,
        data: data
      }, false);
    }
  }
}
"use strict";

function ContainerCompClass(_obj) {
  var events = {};
  var modelObj = {
    x: 0,
    y: 0,
    width: 326,
    height: 177,
    dragMinX: 0,
    dragMinY: 0,
    dragMaxX: 1280,
    dragMaxY: 720,
    visible: true,
    enable: true,
    headText: '',
    padding: 16,
    fontSize: 16,
    fontColor: 'rgba(0,0,0,1)',
    bgColor: 'rgba(112,146,190,0.5)'
  };
  var localObj = {
    headLine: null,
    mouseEventData: {
      mouseMove: false,
      diffX: 0,
      diffY: 0
    }
  };
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });
  createHeadLine();
  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  };

  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    addEvents();
  };

  this.setText = function (_text) {
    modelObj.headText = _text;
    createTextWrapper();
    addEvents();
  };

  this.getPos = function () {
    var data = {
      x: modelObj.x + modelObj.padding,
      y: modelObj.y + modelObj.padding
    };

    if (localObj.headLine !== null) {
      data.bodyX = modelObj.x + modelObj.padding;
      data.bodyY = modelObj.y + modelObj.padding * 2 + localObj.headLine.imageObj.heightInt;
    } else {
      data.bodyX = modelObj.x + modelObj.padding;
      data.bodyY = modelObj.y + modelObj.padding;
    }

    return data;
  };

  this.setHeight = function (_val) {
    modelObj.height = _val;
  };

  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  };

  this.enable = function () {
    modelObj.enable = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.enable = false;
    addEvents();
  };

  this.draw = function () {
    var _ctx = modelObj.context;

    if (modelObj.visible) {
      _ctx.save();

      _ctx.lineWidth = 1;

      _ctx.beginPath();

      _ctx.strokeStyle = 'rgba(255,255,255,1)';
      _ctx.fillStyle = modelObj.bgColor;

      _ctx.rect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

      _ctx.fill();

      _ctx.stroke();

      _ctx.closePath();

      if (localObj.headLine !== null) {
        _ctx.beginPath();

        _ctx.fillStyle = modelObj.fontColor;
        _ctx.textBaseline = 'middle';

        _ctx.drawImage(localObj.headLine.imageObj.imageObj, modelObj.x + modelObj.padding, modelObj.y + modelObj.padding, localObj.headLine.imageObj.widthInt, localObj.headLine.imageObj.heightInt);

        _ctx.closePath();
      }

      _ctx.restore();
    }
  }; // =================================================
  // PRIVATE SECTION
  // ================================================


  function removeMouseEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeMouseEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.visible) {
      if (modelObj.enable) {
        _eventDataObj.r.push({
          id: 'base_' + modelObj.id,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: 'grab',
          downCursor: 'grabbing',
          eventListener: mouseHandle.bind(this)
        });
      } else {
        _eventDataObj.r.push({
          id: 'baseNonDrag_' + modelObj.id,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: 'default',
          eventListener: mouseHandle.bind(this)
        });
      }
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'addMouseEvent',
      data: _eventDataObj
    });
  } // =================================================


  function mouseHandle(e) {
    if (modelObj.enable) {
      switch (e.type) {
        case 'mousedown':
          localObj.mouseEventData.diffX = e.pageX - modelObj.x;
          localObj.mouseEventData.diffY = e.pageY - modelObj.y;
          break;

        case 'mouseenter':
          break;

        case 'mouseup':
        case 'mouseupout':
          addEvents();
          break;

        case 'mouseout':
          break;

        case 'pressmove':
          modelObj.x = e.pageX - localObj.mouseEventData.diffX;
          modelObj.y = e.pageY - localObj.mouseEventData.diffY;
          var minX = modelObj.dragMinX;
          var minY = modelObj.dragMinY;
          var maxX = modelObj.dragMaxX - modelObj.width;
          var maxY = modelObj.dragMaxY - modelObj.height;
          modelObj.x = modelObj.x < minX ? minX : modelObj.x;
          modelObj.x = modelObj.x > maxX ? maxX : modelObj.x;
          modelObj.y = modelObj.y < minY ? minY : modelObj.y;
          modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;

          if (typeof events.change !== 'undefined') {
            events.change({
              id: modelObj.id
            });
          }

          break;

        case 'stageevent':
          break;

        default:
          break;
      }
    }
  }

  function createHeadLine() {
    if (modelObj.headText !== '' && modelObj.LabComClass.globalLangText[modelObj.headText]) {
      modelObj.headText = modelObj.LabComClass.globalLangText[modelObj.headText];
      createTextWrapper();
    } else {
      modelObj.headText = '';
    }

    addEvents();
  }

  function createTextWrapper() {
    localObj.headLine = modelObj.context.textWrapperClass({
      xNum: 0,
      // modelCls.cPropObj.xInt,
      yNum: 0,
      // modelCls.cPropObj.yInt,
      fontFormat: 'px ',
      maxWidthNum: modelObj.width - modelObj.padding * 2,
      textStr: modelObj.headText,
      fontFamilyStr: modelObj.LabComClass.klettFontRegular,
      fontSizeNum: modelObj.fontSize,
      color: modelObj.fontColor
    });
  }
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function LabelNewCompClass(_obj) {
  var modelObj = {
    x: 0,
    y: 0,
    width: 2000,
    visible: true,
    text: '',
    maxWidth: 0,
    fontSize: 16,
    fontColor: 'rgba(0,0,0,1)',
    align: 'left',
    isItalic: false,
    isBold: false,
    rotation: 0,
    // bgWidth: 100,
    // bgHeight: 50,
    textY: 0,
    textX: 0,
    bgColor: '#ffffff',
    textW: 'old' // new for if requirement is for partial colored label.

  };
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------
  // if(typeof(modelObj.bgWidth)!=='undefined') {
  //   modelObj.textX =
  // }

  modelObj.fontFamilyStr = modelObj.LabComClass.polo22KlettRegular; // --------------------

  if (modelObj.text !== '') {
    modelObj.text = modelObj.LabComClass.globalLangText[modelObj.text]; // this.setValue(modelObj.text);
  }

  parseText(); // --------------------

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.setValue = function (_txt) {
    modelObj.text = _txt;
    parseText();
  };

  function parseText() {
    if (modelObj.maxWidth > 0) {
      var data = modelObj.text;

      if (modelObj.isBold && modelObj.isItalic) {
        data = modelObj.LabComClass.italicbold + data + modelObj.LabComClass.end;
      } else {
        if (modelObj.isItalic) {
          data = modelObj.LabComClass.italic + data + modelObj.LabComClass.end;
        }

        if (modelObj.isBold) {
          data = modelObj.LabComClass.bold + data + modelObj.LabComClass.end;
        }
      }

      if (modelObj.textW === 'old') {
        modelObj.text = modelObj.context.textWrapperClass({
          xNum: 0,
          // modelCls.cPropObj.xInt,
          yNum: 0,
          // modelCls.cPropObj.yInt,
          fontFormat: 'px ',
          maxWidthNum: modelObj.maxWidth,
          textStr: data,
          fontFamilyStr: modelObj.fontFamilyStr,
          fontSizeNum: modelObj.fontSize,
          color: modelObj.fontColor
        });
      } else {
        modelObj.text = modelObj.context.textWrapperV2Class({
          xNum: 0,
          // modelCls.cPropObj.xInt,
          yNum: 0,
          // modelCls.cPropObj.yInt,
          maxWidthNum: modelObj.maxWidth,
          textStr: '' + data,
          fontFamilyStr: modelObj.fontFamilyStr,
          fontSizeNum: modelObj.fontSize,
          color: modelObj.fontColor
        }, false);
      }
    }
  } // =================================================


  this.getValue = function () {
    return modelObj.text;
  }; // =================================================


  this.setBGColor = function (_col) {
    modelObj.bgColor = _col;
  }; // =================================================


  this.getVisble = function () {
    return modelObj.visible;
  }; // =================================================


  this.setVisible = function (_bool) {
    modelObj.visible = _bool;
  }; // =================================================


  this.getBGColor = function () {
    return modelObj.bgColor;
  }; // =================================================


  this.setTextColor = function (_col) {
    modelObj.fontColor = _col;
  }; // =================================================


  this.getTextColor = function () {
    return modelObj.fontColor;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
  }; // =================================================


  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
  }; // =================================================


  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.setStyle = function (_obj) {
    Object.keys(_obj).forEach(function (i) {
      modelObj[i] = _obj[i];
    });
  }; // =================================================


  this.draw = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;
      var _str = '';
      var _xTxt = modelObj.x;

      var _yTxt = modelObj.y + modelObj.fontSize; // --------------------


      _ctx.save();

      var textAlign;

      if (typeof modelObj.bgWidth !== 'undefined') {
        _ctx.beginPath();

        _ctx.fillStyle = modelObj.bgColor;

        _ctx.fillRect(modelObj.x, modelObj.y, modelObj.bgWidth, modelObj.bgHeight);

        _ctx.closePath();

        textAlign = 'middle';
      } else {
        textAlign = 'bottom';
      }

      _ctx.beginPath();

      _ctx.fillStyle = modelObj.fontColor;
      _str += modelObj.isItalic ? 'italic ' : '';
      _str += modelObj.isBold ? 'bold ' : '';
      _ctx.font = _str + modelObj.fontSize + 'px ' + modelObj.fontFamilyStr;
      _ctx.textAlign = modelObj.align;
      _ctx.textBaseline = textAlign;

      if (textAlign === 'middle') {
        _xTxt = modelObj.x + modelObj.bgWidth / 2;
        _yTxt = modelObj.y + modelObj.bgHeight / 2 + 1;
      }

      _ctx.translate(_xTxt, _yTxt);

      _ctx.rotate(modelObj.rotation);

      if (modelObj.text && typeof modelObj.text === 'string' && modelObj.maxWidth === 0) {
        var data = modelObj.text;

        if (modelObj.isBold && modelObj.isItalic) {
          data = modelObj.LabComClass.italicbold + data + modelObj.LabComClass.end;
        } else {
          if (modelObj.isItalic) {
            data = modelObj.LabComClass.italic + data + modelObj.LabComClass.end;
          }

          if (modelObj.isBold) {
            data = modelObj.LabComClass.bold + data + modelObj.LabComClass.end;
          }
        }

        _ctx.drawStyledText(data, modelObj.textX, modelObj.textY, modelObj.fontFamilyStr, modelObj.fontSize);
      } else if (modelObj.text && modelObj.text.imageObj && modelObj.text.imageObj.imageObj) {
        if (modelObj.textW === 'old') {
          _ctx.drawImage(modelObj.text.imageObj.imageObj, 0, 0, modelObj.text.imageObj.widthInt, modelObj.text.imageObj.heightInt);
        } else {
          _ctx.drawImage(modelObj.text.imageObj.imageObj, 0, -modelObj.fontSize, modelObj.text.imageObj.widthInt, modelObj.text.imageObj.heightInt);
        }
      }

      _ctx.closePath();

      _ctx.restore();
    }
  };
}
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function InputBoxClass(_dataObj) {
  var self = this; // -- Configurable required props starts here --

  var idStr = _dataObj.id;
  var contextObj = _dataObj.context;
  var typeStr = getConfigurableVal(_dataObj.type, 'inputBox'); // -- Configurable required props ends here --
  // -- Configurable optional props starts here --

  var xInt = getConfigurableVal(_dataObj.x, 0);
  var yInt = getConfigurableVal(_dataObj.y, 0);
  var widthInt = getConfigurableVal(_dataObj.width, 56);
  var heightInt = getConfigurableVal(_dataObj.height, 30);
  var radiusInt = getConfigurableVal(_dataObj.radius, 0);
  var strokeStyleStr = getConfigurableVal(_dataObj.strokeStyle, 'auto');
  var fillStyleStr = getConfigurableVal(_dataObj.fillStyle, 'rgba(255,255,255,1)');
  var borderWidthInt = getConfigurableVal(_dataObj.borderWidth, 1);
  var shadowVisibleBool = getConfigurableVal(_dataObj.shadowVisible, false);
  var shadowColorStr = getConfigurableVal(_dataObj.shadowColor, 'rgba(0,0,0,0.5)');
  var shadowOffsetXInt = getConfigurableVal(_dataObj.shadowOffsetX, 2);
  var shadowOffsetYInt = getConfigurableVal(_dataObj.shadowOffsetY, 2);
  var shadowBlurInt = getConfigurableVal(_dataObj.shadowBlur, 10);
  var fontSizeNum = getConfigurableVal(_dataObj.fontSize, 16);
  var fontFamilyStr = getConfigurableVal(_dataObj.fontFamily, _dataObj.LabComClass.klettFontRegular);
  var fontColorStr = getConfigurableVal(_dataObj.fontColor, 'rgba(0,0,0,1)');
  var fontDisableColorStr = getConfigurableVal(_dataObj.disableFillStyle, 'rgba(0,0,0,0.5)');
  var valueStr = getConfigurableVal(_dataObj.value, '');
  var filterTypeInt = getConfigurableVal(_dataObj.filterType, 1);
  var maxLengthInt = getConfigurableVal(_dataObj.maxLength, 2);
  var maxLengthFilterInt = getConfigurableVal(_dataObj.maxLengthFilter, 1);
  var textAlignStr = getConfigurableVal(_dataObj.textAlign, 'center');
  var textPadInt = getConfigurableVal(_dataObj.textPadding, 5);
  var cursorColorStr = getConfigurableVal(_dataObj.cursorColor, 'rgba(0, 0, 0, 1)');
  var showComponent = getConfigurableVal(_dataObj.showComponent, false);
  var showEnter = getConfigurableVal(_dataObj.showEnter, false);
  var enterSize = getConfigurableVal(_dataObj.enterSize, 16);
  var enterToSubmit = getConfigurableVal(_dataObj.enterToSubmit, false);
  var useCommaAsDecimal = getConfigurableVal(_dataObj.useCommaAsDecimal, false);
  var germanUmlaute = getConfigurableVal(_dataObj.useCommaAsDecimal, false); // -- Configurable optional props ends here --

  var preTxt = getConfigurableVal(_dataObj.LabComClass.globalLangText[_dataObj.preTxt], '');
  var postTxt = getConfigurableVal(_dataObj.LabComClass.globalLangText[_dataObj.postTxt], '');
  var staticMode = getConfigurableVal(_dataObj.staticMode, false);
  var showEventBool = getConfigurableVal(_dataObj.showEventBool, true);
  var isNumeric = getConfigurableVal(_dataObj.isNumeric, true); // -- Configurable optional props ends here --

  var leftMinDecimalCountInt = _dataObj.leftMinDecimalCountInt;
  var rightMaxDecimalCountInt = _dataObj.rightMaxDecimalCountInt;
  var modelObj = {
    outsidePreTxt: '',
    // text []
    outsidePreTxtPadding: 10,
    outsidePreTxtAlign: 'right',
    outsidePostTxt: '',
    // [] text
    outsidePostTxtPadding: 10,
    outsidePostTxtAlign: 'left',
    allowEmptyState: true
  };
  var localObj = {
    strokeStyle: 'rgba(170,170,166,1)'
  };
  Object.keys(_dataObj).forEach(function (i) {
    modelObj[i] = _dataObj[i];
  });
  getGlobalText(['outsidePreTxt', 'outsidePostTxt']); // -- Configurable optional props ends here --

  var disableBool = false;
  var showCursorBool = false;
  var isCorrect = null;
  var addEventBool = false;
  var mouseEntered = false;
  var drawCursor = false;
  var cursorIndex = 0;
  var cursorPositiontoText = 0;
  var addedDecimal = false;
  var enabledBeforeHide;
  var cursorIntervalObj;
  var eventListeners = {};
  var eventsToListen = ['focusIn', 'focusOut', 'click', 'keyup', 'mouseenter', 'mouseout'];
  var numberPadCompId = null;
  var tabCompId = null;
  var BrowserDetect = _dataObj.LabComClass.BrowserDetect;

  if (strokeStyleStr === 'auto') {
    strokeStyleStr = 'rgba(170, 170, 166,1)';
  }

  var defaultMaxLength = maxLengthInt;
  Object.defineProperties(this, {
    compId: {
      get: function get() {
        return idStr;
      }
    },
    hasFocus: {
      get: function get() {
        return showCursorBool;
      }
    },
    isVisible: {
      get: function get() {
        return showComponent;
      }
    },
    numberPadCompId: {
      set: function set(value) {
        numberPadCompId = value;
      }
    }
  });

  this.focusIn = function () {
    drawCursor = true;

    if (BrowserDetect.isDevice() === false) {
      document.getElementById('inputFieldDummyDiv').focus();
    } // cursorIndex = valueStr.length;


    setCursorPosition();
    toggleKeyEvents(true);
    showCursorBool = true;
    animateCursor();
    doRender();
    dispatchEvent('focusIn');
    self.setState('normal');
    updateStage();
  };

  this.focusOut = function () {
    if (BrowserDetect.isDevice() === false) {
      document.getElementById('inputFieldDummyDiv').blur();
    }

    toggleKeyEvents(false);

    if (showCursorBool === true) {
      showCursorBool = false;
      animateCursor(); //filtertype added for filter 14 as it has brackets.

      if (isNumeric && filterTypeInt !== 14 && isNaN(Number(valueStr)) && !valueStr.includes(',')) {
        valueStr = '0';
      }

      dispatchEvent('focusOut');
    }

    checkForTrailingDot();
    updateStage();
  };

  this.enable = function () {
    var updateInteractionStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (showComponent) {
      toggleMouseEvents(true);
    }

    if (!showEnter && getConfigurableVal(_dataObj.showEnter, false)) {
      showEnter = true;
    }

    disableBool = false;

    if (updateInteractionStatus) {
      enabledBeforeHide = true;
    } // showComponent = true;

  };

  this.disable = function () {
    var updateInteractionStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    self.focusOut(true);

    if (showEnter) {
      showEnter = false;
    } // showComponent = false;


    toggleMouseEvents(false);
    disableBool = true;

    if (updateInteractionStatus) {
      enabledBeforeHide = false;
    } // showComponent = false;

  };

  this.isEnabled = function () {
    return !disableBool;
  };

  this.show = function () {
    showComponent = true;

    if (enabledBeforeHide) {
      this.enable(false);
    }
  };

  this.hide = function () {
    showComponent = false;
    this.disable(false);
  };

  this.getVisble = function () {
    return showComponent;
  };

  this.getEnterToSubmit = function () {
    return enterToSubmit;
  };

  this.setPos = function (_x, _y) {
    xInt = _x;
    yInt = _y;

    if (!disableBool) {
      toggleMouseEvents(showComponent);
    }
  };

  this.getState = function () {
    return addEventBool;
  };

  this["static"] = function (_flag) {
    if (_flag !== undefined) {
      staticMode = _flag;
    }

    return staticMode;
  }; // =================================================


  this.setVisible = function (_bool) {
    if (_bool) {
      this.show();
    } else {
      this.hide();
    }
  };

  this.on = function (event, callback) {
    if (isValidEvent(event)) {
      if (!eventListeners[event]) {
        eventListeners[event] = [];
      }

      eventListeners[event].push(callback);
    }
  };

  this.off = function (event, callback) {
    if (isValidEvent(event)) {
      if (isListenerRegister(event)) {
        var index = eventListeners[event].indexOf(callback);
        eventListeners[event].splice(index, 1);

        if (eventListeners[event].length === 0) {
          delete eventListeners[event];
        }
      }
    }
  };

  this.getValue = function () {
    if (useCommaAsDecimal) {
      var valueStrCopy = valueStr;
      return valueStrCopy.replace(',', '.');
    } else {
      return valueStr;
    }
  };

  this.setValue = function (value) {
    valueStr = value.toString();
    cursorIndex = valueStr.length;
    checkForTrailingDot();

    if (valueStr.indexOf('.') !== -1 && typeof rightMaxDecimalCountInt !== 'undefined') {
      if (maxLengthInt < defaultMaxLength + rightMaxDecimalCountInt) {
        maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt;
      }
    }

    setCursorPosition();
    updateStage();
  };

  this.decimalCount = function (_count) {
    rightMaxDecimalCountInt = _count;

    if (valueStr.indexOf('.') !== -1 && typeof rightMaxDecimalCountInt !== 'undefined') {
      // maxLengthInt -= rightMaxDecimalCountInt;
      maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt;
    }

    return rightMaxDecimalCountInt;
  };

  this.getCorrect = function () {
    return isCorrect;
  };

  this.setNumberPadValue = function (value) {
    processCallback(value);

    if (value !== 'enter' || value === 'enter' && !modelObj.enterToSubmit) {
      dispatchEvent('keyup');
    } else {
      dispatchEventForEnter('keyup');
    }
  };

  this.draw = function () {
    if (showComponent) {
      contextObj.save(); // -- Set shadow

      if (shadowVisibleBool === true) {
        contextObj.shadowColor = shadowColorStr;
        contextObj.shadowOffsetX = shadowOffsetXInt;
        contextObj.shadowOffsetY = shadowOffsetYInt;
        contextObj.shadowBlur = shadowBlurInt;
      } // -- Draw bg


      contextObj.fillStyle = fillStyleStr;
      contextObj.strokeStyle = strokeStyleStr;

      if ((showCursorBool || mouseEntered) && isCorrect === null) {
        // if (showCursorBool && isCorrect === null) {
        contextObj.strokeStyle = 'rgba(170, 170, 166,1)';
      }

      if (!showCursorBool && isCorrect === null && !mouseEntered) {
        contextObj.strokeStyle = 'rgba(170, 170, 166,1)';
      }

      if (!showCursorBool && mouseEntered) {// contextObj.strokeStyle = 'rgba(237, 237, 237,1)';
      }

      var fontColor = fontColorStr;

      if (valueStr !== '' && modelObj.allowEmptyState || !modelObj.allowEmptyState) {
        if (!isCorrect && isCorrect !== null) {
          contextObj.fillStyle = 'rgba(255, 0, 0, 1)';
          fontColor = 'rgba(255, 255, 255, 1)';
        } else if (isCorrect && isCorrect !== null) {
          contextObj.fillStyle = 'rgba(65, 180, 5, 1)';
          fontColor = 'rgba(255, 255, 255, 1)';
        }
      }

      contextObj.lineWidth = 1; // contextObj.fillStyle =  'rgba(255, 255, 255, 1)';

      roundRect(contextObj, xInt, yInt, widthInt, heightInt, radiusInt, true, true); // -- Reset shadow so border doesnt draw shadow

      contextObj.shadowColor = 'transparent';
      contextObj.shadowOffsetX = 0;
      contextObj.shadowOffsetY = 0;
      contextObj.shadowBlur = 0; // -- Draw text

      if (valueStr !== '') {
        contextObj.textBaseline = 'bottom';
        contextObj.font = fontSizeNum + 'px ' + fontFamilyStr;

        if (disableBool && !staticMode) {
          contextObj.fillStyle = fontDisableColorStr;

          if (isCorrect !== null) {
            contextObj.fillStyle = 'rgba(255,255,255,0.7)';
          }
        } else {
          contextObj.fillStyle = fontColor;
        }

        contextObj.strokeStyle = 'rgba(255,255,255,1)';

        var _tempYInt = yInt + heightInt / 2 + fontSizeNum / 2 + fontSizeNum * 0.125;

        if (fontFamilyStr.indexOf('league') !== -1) {
          _tempYInt += fontSizeNum * 4 / 28;
        }

        var text = preTxt + valueStr + postTxt;

        switch (textAlignStr) {
          case 'left':
            contextObj.textAlign = 'left';
            contextObj.drawStyledText(text, xInt + textPadInt, _tempYInt);
            break;

          case 'right':
            contextObj.textAlign = 'right';
            contextObj.drawStyledText(text, xInt + widthInt - (textPadInt + 4), _tempYInt);
            break;

          case 'center':
          default:
            contextObj.textAlign = 'center';
            contextObj.drawStyledText(text, xInt + widthInt / 2, _tempYInt);
            break;
        }
      } // -- Draw cursor


      if (drawCursor === true && showCursorBool === true) {
        var cursorXInt;
        var cursorYInt;
        var newValStr = valueStr.substring(0, cursorIndex);
        contextObj.font = fontSizeNum + 'px ' + fontFamilyStr;

        switch (textAlignStr) {
          case 'left':
            // cursorXInt = valueStr === '' ? xInt + textPadInt + 2 : xInt + textPadInt + contextObj.measureText(valueStr).width + 2;
            cursorXInt = valueStr === '' ? xInt + textPadInt + 2 : xInt + textPadInt + contextObj.measureText(newValStr).width + 2;
            break;

          case 'right':
            // cursorXInt = (xInt + widthInt) - (textPadInt + 2);
            newValStr = valueStr.substring(cursorIndex, valueStr.length);
            cursorXInt = xInt + widthInt - contextObj.measureText(newValStr).width - (textPadInt + 2);
            break;

          case 'center':
          default:
            // cursorXInt = valueStr === '' ? xInt + (widthInt / 2) : xInt + (widthInt / 2) + (contextObj.measureText(valueStr).width / 2) + 2;
            cursorXInt = cursorPositiontoText;
            break;
        }

        cursorYInt = yInt + (heightInt - fontSizeNum) / 2;
        contextObj.beginPath();
        contextObj.moveTo(cursorXInt, cursorYInt);
        contextObj.lineTo(cursorXInt, cursorYInt + fontSizeNum);
        contextObj.closePath();
        contextObj.lineWidth = 1;
        contextObj.strokeStyle = cursorColorStr;
        contextObj.stroke();
      }

      if (!showCursorBool && valueStr === '' && showEnter) {
        contextObj.fillStyle = 'rgba(0, 0, 0, 1)';
        contextObj.textAlign = 'start';
        contextObj.textBaseline = 'alphabetic';
        contextObj.drawStyledText('Enter', xInt + 8, yInt + heightInt / 2 + fontSizeNum / 2 - 2, 'Alef-Regular', enterSize);
      }

      if (disableBool && !staticMode) {
        contextObj.strokeStyle = 'rgba(237, 237, 237,1)';
        contextObj.fillStyle = 'rgba(255, 255, 255, 0.03)';
        roundRect(contextObj, xInt, yInt, widthInt, heightInt, radiusInt, true, true);
      }

      if (modelObj.outsidePostTxt !== '') {
        contextObj.save();
        contextObj.beginPath();
        contextObj.fillStyle = fontColorStr;
        contextObj.textAlign = modelObj.outsidePostTxtAlign;
        contextObj.textBaseline = 'bottom';
        contextObj.drawStyledText(modelObj.outsidePostTxt, xInt + widthInt + modelObj.outsidePostTxtPadding, yInt + heightInt / 2 + fontSizeNum * 0.65, modelObj.LabComClass.klettFontRegular, fontSizeNum);
        contextObj.closePath();
        contextObj.restore();
      }

      if (modelObj.outsidePreTxt !== '') {
        contextObj.save();
        contextObj.beginPath();
        contextObj.fillStyle = fontColorStr;
        contextObj.textAlign = modelObj.outsidePreTxtAlign;
        contextObj.textBaseline = 'bottom';
        contextObj.drawStyledText(modelObj.outsidePreTxt, xInt - modelObj.outsidePreTxtPadding, yInt + heightInt / 2 + fontSizeNum * 0.65, modelObj.LabComClass.klettFontRegular, fontSizeNum);
        contextObj.closePath();
        contextObj.restore();
      }

      contextObj.restore();
    }
  };

  this.destroy = function () {
    self.disable();
  };

  this.setState = function (str) {
    if (str === 'correct') {
      isCorrect = true;
    } else if (str === 'incorrect') {
      isCorrect = false;
    } else if (str === 'normal') {
      isCorrect = null;
    }
  };

  function checkForTrailingDot() {
    if (valueStr.charAt(valueStr.length - 1) === '.') {
      valueStr = valueStr.substring(0, valueStr.length - 1);
    }
  }

  function isValidEvent(eventType) {
    if (eventsToListen.indexOf(eventType) !== -1) {
      return true;
    }

    throw new Error("Invalid event ".concat(eventType, " provided, following events ").concat(eventListeners, " are allowed"));
  }

  function isListenerRegister(eventType) {
    return eventListeners[eventType] && eventListeners[eventType].length > 0;
  }

  function dispatchEvent(type) {
    if (isListenerRegister(type)) {
      eventListeners[type].forEach(function (callback) {
        callback({
          type: type,
          id: idStr
        });
      });
    }
  }

  function dispatchEventForEnter(type) {
    if (isListenerRegister(type)) {
      eventListeners[type].forEach(function (callback) {
        callback({
          type: type,
          enterPressed: true,
          id: idStr
        });
      });
    }
  }
  /**
   * Draws a rounded rectangle using the current state of the canvas.
   * If you omit the last three params, it will draw a rectangle
   * outline with a 5 pixel border radius
   * @param {CanvasRenderingContext2D} contextObj
   * @param {Number} x The top left x coordinate
   * @param {Number} y The top left y coordinate
   * @param {Number} width The width of the rectangle
   * @param {Number} height The height of the rectangle
   * @param {Number} [radius = 5] The corner radius; It can also be an object
   *                 to specify different radii for corners
   * @param {Number} [radius.tl = 0] Top left
   * @param {Number} [radius.tr = 0] Top right
   * @param {Number} [radius.br = 0] Bottom right
   * @param {Number} [radius.bl = 0] Bottom left
   * @param {Boolean} [fill = false] Whether to fill the rectangle.
   * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
   */


  function roundRect(contextObj, x, y, width, height, radius, fill, stroke) {
    if (typeof stroke === 'undefined') {
      stroke = true;
    }

    if (typeof radius === 'undefined') {
      radius = 5;
    }

    if (typeof radius === 'number') {
      radius = {
        tl: radius,
        tr: radius,
        br: radius,
        bl: radius
      };
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    contextObj.beginPath();
    contextObj.moveTo(x + radius.tl, y);
    contextObj.lineTo(x + (width - radius.tr), y);
    contextObj.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    contextObj.lineTo(x + width, y + (height - radius.br));
    contextObj.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
    contextObj.lineTo(x + radius.bl, y + height);
    contextObj.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
    contextObj.lineTo(x, y + radius.tl);
    contextObj.quadraticCurveTo(x, y, x + radius.tl, y);
    contextObj.closePath();
    contextObj.lineWidth = borderWidthInt;

    if (fill) {
      contextObj.fill();
    }

    if (stroke) {
      contextObj.lineWidth = 1;
      contextObj.stroke();
    }
  }

  function getGlobalText(keys) {
    for (var i = 0; i < keys.length; i++) {
      if (modelObj.LabComClass.globalLangText[modelObj[keys[i]]]) {
        modelObj[keys[i]] = modelObj.LabComClass.globalLangText[modelObj[keys[i]]];
      } else {
        modelObj[keys[i]] = '';
      }
    }
  }

  function animateCursor() {
    clearTimeout(cursorIntervalObj);

    if (showCursorBool === true) {
      cursorIntervalObj = setTimeout(function () {
        drawCursor = !drawCursor;
        updateStage();
        setCursorPosition();
        animateCursor();
      }, 530);
    } else {
      updateStage();
    }
  }

  function doRender() {
    if (showCursorBool) {
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'rendererUpdate'
      });
      requestAnimationFrame(doRender);
    }
  }

  function toggleMouseEvents(interactive) {
    var eventDataObj = {};
    var _removeArr = [];
    eventDataObj.id = idStr;
    eventDataObj.r = [];
    eventDataObj.r.push({
      id: 0,
      rect: {
        x: xInt,
        y: yInt,
        w: widthInt,
        h: heightInt
      },
      eventListener: mouseEventHandler
    });

    if (interactive) {
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'addMouseEvent',
        data: eventDataObj
      });
    } else {
      showCursorBool = false;
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'removeMouseEvent',
        data: {
          id: idStr
        }
      });
    }

    addEventBool = interactive;
    animateCursor();
  }

  function toggleKeyEvents(interactive) {
    if (interactive) {
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'addKeyEvent',
        data: {
          id: idStr,
          callback: keyEventHandler
        }
      });
    } else {
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'removeKeyEvent',
        data: {
          id: idStr,
          callback: keyEventHandler
        }
      });
    }
  }

  function processCallback(_key, _dataObj) {
    var _bool = false;

    var _keyCodeObj = getKeyCodeObj();

    if (typeof _dataObj !== 'undefined') {
      if (_dataObj.ctrlKey === true) {
        _dataObj.preventDefault();

        return false;
      }

      if (_dataObj.key === 'Tab') {
        if (tabCompId !== null) {
          tabCompId.onTabEvent(self.compId);
        }

        _dataObj.preventDefault();

        return false;
      }

      if (_dataObj.key === 'ArrowLeft' || _dataObj.key === 'ArrowRight' || _dataObj.key === 'Left' || _dataObj.key === 'Right') {
        setCursorPosition(_dataObj.key);

        _dataObj.preventDefault();

        return false;
      } // -- Input from keyboard


      if (typeof _keyCodeObj[_dataObj.keyCode] !== 'undefined') {
        _bool = true;
        _key = _keyCodeObj[_dataObj.keyCode].toString();

        if (_key === 'ö' || _key === 'ü' || _key === 'ä') {
          _key = _dataObj.key.toString();
        }

        if (_key === '?') {
          _key = 'ß';
        }
      }
    } else {
      // -- Input from keypad (devices)
      _key = _key.toString();
      Object.keys(_keyCodeObj).forEach(function (_keyCodeObjKey) {
        if (_key === _keyCodeObj[_keyCodeObjKey].toString() && filterTypeInt !== 13) {
          _bool = true;
        } else if ((_key === _keyCodeObj[_keyCodeObjKey].toString() || _key.toLowerCase() === _keyCodeObj[_keyCodeObjKey].toString()) && filterTypeInt == 13) {
          _bool = true;
        }
      });
    }

    if (_bool === true) {
      switch (_key) {
        case 'diff':
          if (valueStr === '' || cursorIndex === 0 || valueStr[cursorIndex - 1] === '(') {
            // valueStr += '-';
            updateValueStr('-');
          }

          break;

        case 'Ö':
        case 'ö':
          if (valueStr.length < getMaxLength()) {
            updateValueStr(_key);
          }

          break;

        case '(':
          if (_dataObj === undefined || _dataObj.shiftKey) {
            updateValueStr(_key);
          } else {
            updateValueStr('8');
          }

          break;

        case ')':
          if (valueStr.length < getMaxLength() && (_dataObj === undefined || _dataObj.shiftKey)) {
            var strArray = valueStr.split('');
            var count = strArray.reduce(function (a, v) {
              return v === '(' ? a + 1 : a;
            }, 0);

            if (count && (_dataObj === undefined || _dataObj.shiftKey)) {
              updateValueStr(')');
            }
          } else if (!_dataObj.shiftKey) {
            updateValueStr('9');
          }

          break;

        case 'Ä':
        case 'ä':
          if (valueStr.length < getMaxLength()) {
            updateValueStr(_key);
          }

          break;

        case 'Ü':
        case 'ü':
        case 'ß':
          if (valueStr.length < getMaxLength()) {
            updateValueStr(_key);
          }

          break;

        case 'dot':
          if ((_dataObj === null || _dataObj === void 0 ? void 0 : _dataObj.shiftKey) === true && valueStr.length < getMaxLength()) {
            updateValueStr('>');
          } else if (valueStr.indexOf('.') === -1 && valueStr.length <= getMaxLength() && rightMaxDecimalCountInt) {
            maxLengthInt = defaultMaxLength + rightMaxDecimalCountInt;
            addedDecimal = true;

            if (typeof leftMinDecimalCountInt !== 'undefined') {
              if (valueStr.length >= leftMinDecimalCountInt) {
                // valueStr += '.';
                updateValueStr('.');
              }
            } else {
              // valueStr += '.';
              updateValueStr('.');
            }
            /*
             if (valueStr === '') {
             if (allowFirstDecimalBool === true) {
             valueStr += '.';
             } else {
             playSfx('error');
             }
             } else {
             valueStr += '.';
             }
             */

          }

          break;

        case 'back':
          if (addedDecimal && valueStr.charAt(valueStr.length - 1) === '.') {
            maxLengthInt = defaultMaxLength;
            addedDecimal = false;
          } // valueStr = valueStr.substring(0, valueStr.length - 1);


          updateValueStr('back');
          break;

        case 'clear':
          // valueStr = '';
          updateValueStr('clear');
          break;

        case 'comma':
          if ((_dataObj === null || _dataObj === void 0 ? void 0 : _dataObj.shiftKey) === true && valueStr.length < getMaxLength() && filterTypeInt !== 12 && filterTypeInt !== 14) {
            updateValueStr('<');
          } else if (!useCommaAsDecimal && valueStr.length < getMaxLength() && valueStr !== '' && valueStr.charAt(valueStr.length - 1) !== '.' && valueStr.charAt(valueStr.length - 1) !== ',' && valueStr.charAt(valueStr.length - 1) !== '/' || useCommaAsDecimal && valueStr.indexOf(',') === -1 && valueStr !== '' && valueStr.charAt(valueStr.length - 1) !== ',') {
            // valueStr += ',';
            updateValueStr(',');
          }

          break;

        case 'equal':
          if (valueStr.length < getMaxLength()) {
            updateValueStr('=');
          }

          break;

        case 'space':
          if (valueStr.length < getMaxLength() && valueStr !== '' && valueStr.charAt(valueStr.length - 1) !== '.' && valueStr.charAt(valueStr.length - 1) !== ',' && valueStr.charAt(valueStr.length - 1) !== '/') {
            // valueStr += ',';
            updateValueStr(' ');
          }

          break;

        case 'slash':
          if (valueStr.length < getMaxLength() && valueStr !== '' && valueStr.charAt(valueStr.length - 1) !== '.' && valueStr.charAt(valueStr.length - 1) !== ',' && valueStr.charAt(valueStr.length - 1) !== '/') {
            // valueStr += '/';
            updateValueStr('/');
          }

          break;

        default:
          if (valueStr.length < getMaxLength()) {
            // valueStr += _key;
            if (filterTypeInt !== 13) {
              updateValueStr(_key.toUpperCase(), true);
            } else {
              if ((_dataObj === null || _dataObj === void 0 ? void 0 : _dataObj.key) !== undefined) {
                //keyborad case
                updateValueStr(_dataObj.key, true);
              } else {
                //numPad case
                updateValueStr(_key, true);
              }
            } // if (valueStr.indexOf('.') !== -1 && typeof (rightMaxDecimalCountInt) !== 'undefined' && valueStr.split('.')[1].length > rightMaxDecimalCountInt) {
            //   valueStr = valueStr.substring(0, valueStr.length - 1);
            // }
            // if (!isNaN(Number(valueStr)) && valueStr !== '') {
            //   if (minVal !== null && Number(valueStr) < minVal) {
            //     valueStr = minVal.toString();
            //   }
            //   if (maxVal !== null && Number(valueStr) > maxVal) {
            //     valueStr = maxVal.toString();
            //   }
            // }
            // updateValueStr('reset');

          }

          break;
      }

      updateStage();
    }

    if (_dataObj && _dataObj.keyCode === 8) {
      // Prevent the backspace key from navigating back.
      _dataObj.preventDefault();

      return false;
    }

    return 1;
  }

  function getKeyCodeObj() {
    var _obj = {
      48: 0,
      49: 1,
      50: 2,
      51: 3,
      52: 4,
      53: 5,
      54: 6,
      55: 7,
      56: 8,
      57: 9,
      96: 0,
      97: 1,
      98: 2,
      99: 3,
      100: 4,
      101: 5,
      102: 6,
      103: 7,
      104: 8,
      105: 9,
      8: 'back',
      46: 'clear',
      32: 'space'
    };
    var letters = {
      65: 'a',
      66: 'b',
      67: 'c',
      68: 'd',
      69: 'e',
      70: 'f',
      71: 'g',
      72: 'h',
      73: 'i',
      74: 'j',
      75: 'k',
      76: 'l',
      77: 'm',
      78: 'n',
      79: 'o',
      80: 'p',
      81: 'q',
      82: 'r',
      83: 's',
      84: 't',
      85: 'u',
      86: 'v',
      87: 'w',
      88: 'x',
      89: 'y',
      90: 'z'
    };

    if (!isNumeric) {
      Object.keys(letters).forEach(function (i) {
        _obj[i] = letters[i];
      });
    }

    switch (filterTypeInt) {
      case 14:
        // -- 0 to 9, Comma,Backspace, Clear, (,)
        _obj[188] = 'comma';
        _obj[8] = 'back';
        _obj[46] = 'clear';
        _obj[189] = 'diff';
        _obj[109] = 'diff';
        _obj[173] = 'diff';
        _obj[56] = '('; // For German 

        _obj[57] = ')'; // For German

        break;

      case 13:
        // All Gamar
        var firefoxAg = modelObj.LabComClass.BrowserDetect.browserUserAgentName().indexOf("Firefox") > -1; // -- 0 to 9,backspace,clear,ö,ü,ä.

        if (!firefoxAg) {
          _obj[8] = 'back'; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = 'ö'; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = 'ä'; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[186] = 'ü'; // Toggle Comment for using Ü on German Keybaord.

          _obj[219] = 'ß';
        } else {
          _obj[8] = 'back'; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = 'ö'; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = 'ä'; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[59] = 'ü'; // Toggle Comment for using Ü on German Keybaord.

          _obj[63] = 'ß';
        }

        _obj[188] = 'comma';
        break;

      case 12:
        // -- 0 to 9, Comma,Backspace, Clear
        _obj[188] = 'comma';
        _obj[8] = 'back';
        _obj[46] = 'clear';
        _obj[189] = 'diff';
        _obj[109] = 'diff';
        _obj[173] = 'diff';
        break;

      case 11:
        var firefoxAgent = modelObj.LabComClass.BrowserDetect.browserUserAgentName().indexOf("Firefox") > -1; // -- 0 to 9,backspace,clear,ö,ü,ä.

        if (!firefoxAgent) {
          _obj[8] = 'back'; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = 'ö'; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = 'ä'; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[186] = 'ü'; // Toggle Comment for using Ü on German Keybaord.
        } else {
          _obj[8] = 'back'; // _obj[186] = 'ö'; // Toggle Comment for using Ö on English Keybaord.

          _obj[192] = 'ö'; // Toggle comment for using Ö on German Keyboard.

          _obj[222] = 'ä'; // Ä
          // _obj[219] = 'ü'; // Toggle Comment for using Ü on English Keybaord.

          _obj[59] = 'ü'; // Toggle Comment for using Ü on German Keybaord.
        }

        break;

      case 10:
        // -- 0 to 9, Comma,Backspace, Clear
        _obj[188] = 'comma';
        _obj[8] = 'back';
        _obj[46] = 'clear';
        break;

      case 9:
        _obj = [];
        _obj[187] = 'equal';
        _obj[188] = 'comma';
        _obj[190] = 'dot';
        _obj[8] = 'back';
        _obj[46] = 'clear';
        break;

      case 8:
        // -- 0 to 9, Comma, Negation, Slash, Decimal Point
        _obj[188] = 'comma';
        _obj[189] = 'diff';
        _obj[109] = 'diff';
        _obj[173] = 'diff';
        _obj[191] = 'slash';
        _obj[111] = 'slash';
        _obj[190] = 'dot';
        _obj[110] = 'dot';
        break;

      case 7:
        // -- 0 to 9, Backspace, Clear, Decimal Point
        _obj[190] = 'dot';
        _obj[110] = 'dot';
        break;

      case 6:
        // -- 0 to 9, Backspace, Clear, Comma
        _obj[188] = 'comma';
        _obj[189] = 'space';
        break;

      case 5:
        // -- 0 to 9, Backspace, Clear, Slash
        _obj[191] = 'slash';
        _obj[111] = 'slash';
        break;

      case 4:
        // -- 0 to 9, Backspace, Clear
        break;

      case 3:
        // -- 0 to 9, Backspace, Clear, Negation
        _obj[189] = 'diff';
        _obj[109] = 'diff';
        _obj[173] = 'diff';
        break;

      case 2:
        // -- 0 to 9, Backspace, Clear, Decimal Point, Negation
        _obj[189] = 'diff';
        _obj[109] = 'diff';
        _obj[173] = 'diff';
        _obj[190] = 'dot';
        _obj[110] = 'dot';
        break;

      case 1:
      default:
        // -- 0 to 9, Backspace, Clear, Decimal Point, Negation, Comma
        _obj[189] = 'diff';
        _obj[109] = 'diff';
        _obj[173] = 'diff';
        _obj[190] = 'dot';
        _obj[110] = 'dot';
        _obj[188] = 'comma';
        break;
    }

    return _obj;
  }

  function updateStage() {
    if (addedDecimal && valueStr.indexOf('.') === -1) {
      addedDecimal = false;
      maxLengthInt = defaultMaxLength;
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'updateView'
    });
  }

  function updateValueStr(__str, __reset) {
    if (__str === 'back') {
      valueStr = valueStr.substring(0, cursorIndex - 1) + valueStr.substring(cursorIndex, valueStr.length);
      cursorIndex--;
    } else if (__str === 'clear') {
      valueStr = '';
      cursorIndex = 0;
    } else {
      // valueStr += __str;
      var txt = valueStr.substring(0, cursorIndex) + __str + valueStr.substring(cursorIndex, valueStr.length);

      if (contextObj.measureText(txt).width < modelObj.width) {
        valueStr = valueStr.substring(0, cursorIndex) + __str + valueStr.substring(cursorIndex, valueStr.length);
        cursorIndex++;

        if (__reset) {
          if (valueStr.indexOf('.') !== -1 && typeof rightMaxDecimalCountInt !== 'undefined' && valueStr.split('.')[1].length > rightMaxDecimalCountInt) {
            valueStr = valueStr.substring(0, valueStr.length - 1);
            cursorIndex = valueStr.length;
          }

          if (!isNaN(Number(valueStr)) && valueStr !== '') {// if (minVal !== null && Number(valueStr) < minVal) {
            //   valueStr = minVal.toString();
            //   cursorIndex = valueStr.length;
            // }
            // if (maxVal !== null && Number(valueStr) > maxVal) {
            //   valueStr = maxVal.toString();
            //   cursorIndex = valueStr.length;
            // }
          }
        }
      }
    }

    if (cursorIndex < 0) cursorIndex = 0;

    if (valueStr.indexOf('.') === -1) {
      maxLengthInt = defaultMaxLength;
    }

    setCursorPosition();
  }

  function setCursorPosition(__key) {
    if (__key === 'ArrowLeft' || __key === 'Left') {
      cursorIndex--;

      if (cursorIndex < 0) {
        cursorIndex = 0;
      }
    } else if (__key === 'ArrowRight' || __key === 'Right') {
      cursorIndex++;

      if (cursorIndex > valueStr.length) {
        cursorIndex = valueStr.length;
      }
    }

    contextObj.font = fontSizeNum + 'px ' + fontFamilyStr; // valueStr === '' ? xInt + (widthInt / 2) : xInt + (widthInt / 2) + (cursorPositiontoText / 2) + 2;

    var clippedText = valueStr.substring(cursorIndex, valueStr.length);
    var clippedWidth = 0;

    if (clippedText !== '') {
      clippedWidth = contextObj.measureText(clippedText).width + 2;
    } // cursorPositiontoText = contextObj.measureText(valueStr).width - contextObj.measureText(clippedText).width;


    cursorPositiontoText = valueStr === '' ? xInt + widthInt / 2 : xInt + widthInt / 2 + contextObj.measureText(valueStr).width / 2 + 2 - clippedWidth;
  }

  function getMaxLength() {
    var lengthInt = maxLengthInt;

    switch (maxLengthFilterInt) {
      case 2:
        // -- Inlcude - . / , in maxLengthInt;
        break;

      case 1:
      default:
        // -- Exclude - . / , from maxLengthInt;
        if (valueStr.charAt(0) === '-') {
          lengthInt += 1;
        }

        if (valueStr.indexOf('.') !== -1) {
          lengthInt += 1;
        }

        if (valueStr.indexOf('/') !== -1) {
          lengthInt += 1;
        }

        if (valueStr.indexOf(',') !== -1) {
          lengthInt += valueStr.split(',').length - 1;
        }

        break;
    }

    return lengthInt;
  }

  function getIndex(text, diff) {
    contextObj.save();
    contextObj.textBaseline = 'bottom';
    contextObj.font = fontSizeNum + 'px ' + fontFamilyStr;
    var index = text.length;
    diff = diff < 0 ? 0 : diff;
    var minDiff = diff;

    for (var i = 0; i < text.length; i++) {
      var w = contextObj.measureText(valueStr.substring(0, i)).width;

      if (Math.abs(diff - w) <= minDiff) {
        minDiff = Math.abs(diff - w);
        index = i;
      }
    }

    var total = contextObj.measureText(valueStr).width;

    if (diff >= total) {
      index = text.length;
    }

    contextObj.restore();
    return index;
  }

  function changeCursorPossitionByMouse(_dataObj) {
    contextObj.save();
    contextObj.textBaseline = 'bottom';
    contextObj.font = fontSizeNum + 'px ' + fontFamilyStr;
    var total = contextObj.measureText(valueStr).width;
    contextObj.restore();
    var startX = xInt + textPadInt; // eslint-disable-next-line default-case

    switch (textAlignStr) {
      case 'left':
        cursorIndex = getIndex(valueStr, _dataObj.pageX - startX);
        break;

      case 'right':
        cursorIndex = getIndex(valueStr, _dataObj.pageX - (xInt + widthInt - total - textPadInt));
        break;

      case 'center':
      case 'default':
        cursorIndex = getIndex(valueStr, _dataObj.pageX - (xInt + widthInt / 2 - total / 2));
        break;
    }
  }

  function mouseEventHandler(_dataObj) {
    switch (_dataObj.type) {
      case 'mouseupout':
        mouseEntered = false;
        break;

      case 'mousedown':
        if (!self.hasFocus) {
          self.focusIn();
        }

        changeCursorPossitionByMouse(_dataObj);
        setCursorPosition();
        break;

      case 'mouseup':
        if (!self.hasFocus) {
          self.focusIn();
        }

        changeCursorPossitionByMouse(_dataObj);
        mouseEntered = false;
        dispatchEvent('click');
        break;

      case 'mouseenter':
        dispatchEvent('mouseenter');
        mouseEntered = true;
        break;

      case 'mouseout':
        dispatchEvent('mouseout');
        mouseEntered = false;
        break;

      case 'stageevent':
        if (!mouseEntered && showCursorBool && (numberPadCompId === null || [numberPadCompId, idStr].indexOf(_dataObj.id) === -1)) {
          self.focusOut(_dataObj.id);
        }

        break;

      default:
        break;
    }
  }

  function keyEventHandler(_ref) {
    var nativeEvent = _ref.nativeEvent,
        compId = _ref.compId;

    if (compId === idStr) {
      switch (nativeEvent.type) {
        case 'keyup':
          switch (nativeEvent.key) {
            case 'Enter':
              self.focusOut();
              break;

            default:
              // if (nativeEvent.key !== 'shift') {
              processCallback(nativeEvent.key, nativeEvent); // }

              break;
          }

          if (nativeEvent.type === 'keyup' && nativeEvent.key === 'Enter' && modelObj.enterToSubmit) {
            dispatchEventForEnter('keyup');
          } else {
            dispatchEvent('keyup');
          }

          break;

        default:
          if (nativeEvent.type === 'keydown' && nativeEvent.key === 'Backspace') {
            nativeEvent.preventDefault();
          }

          break;
      }
    }
  }

  function getConfigurableVal(_argVal, _defaultVal) {
    if (_typeof(_argVal) === _typeof(_defaultVal)) {
      return _argVal;
    }

    return _defaultVal;
  }

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: idStr
    }
  });
}
"use strict";

function RadioButtonCompClass(_obj) {
  var events = {};
  var modelObj = {
    disableColor: 'rgba(193, 170, 155, 1)',
    bgColor: 'rgba(112,146,190,0.5)',
    whitebgColor: 'rgba(255,255,255,0)',
    circleBGColor: 'rgba(255, 255, 255, 1)',
    downColor: 'rgba(255, 102, 0, 1)',
    borderColor: 'rgba(170, 170, 170, 1)',
    show: true,
    state: true,
    selected: null,
    selectedArr: [],
    x: 0,
    y: 0,
    bgTopPadding: 0,
    bgLeftPadding: 0,
    width: 200,
    height: 50,
    margin: 10,
    topMargin: 0,
    leftMargin: 0,
    padding: 10,
    radius: 13,
    textMaxWidth: 200,
    isItalic: false,
    isBold: false,
    fontSize: 15,
    data: [],
    fontColor: '#000000',
    orientation: 'v',
    isDraggable: false,
    bgVisible: false,
    correctOption: null
  };
  var localObj = {
    mouseEventData: {
      mouseMove: false,
      diffX: 0,
      diffY: 0
    }
  };
  var elements = [];
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });
  var isPressed = false;
  var baseWid = modelObj.playerConfigObj.baseWidth;
  var baseHgt = modelObj.playerConfigObj.baseHeight;
  setGlobalTexts();
  calPosition();
  addEvents();
  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  };

  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    updatePositions();
    addEvents();
  };

  this.setText = function (_textData) {
    modelObj.data = _textData;
    calPosition();
    addEvents();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  };

  this.getValue = function () {
    return modelObj.selected;
  };

  this.setCorrectOption = function (_val) {
    modelObj.correctOption = _val;
  };

  this.setValue = function (_val) {
    modelObj.selected = _val;
    modelObj.selectedArr = []; //Making Selected Arr Empty

    calPosition();
  };

  this.setMulVal = function (_val) {
    modelObj.selected = null; //Making Selected Empty

    modelObj.selectedArr = [];

    if (_val !== null) {
      _val.forEach(function (el) {
        modelObj.selectedArr.push(el);
      });
    }

    calPosition();
  };

  this.show = function () {
    modelObj.show = true;
    addEvents();
  };

  this.getVisible = function () {
    return modelObj.show;
  };

  this.hide = function () {
    modelObj.show = false;
    addEvents();
  };

  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  };

  this.draw = function () {
    var _ctx = modelObj.context;

    if (modelObj.show) {
      _ctx.save();

      _ctx.lineWidth = 1;

      if (modelObj.bgVisible) {
        _ctx.beginPath();

        _ctx.strokeStyle = 'rgba(255,255,255,1)';
        _ctx.fillStyle = modelObj.whitebgColor;

        _ctx.rect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

        _ctx.fill();

        _ctx.stroke();

        _ctx.fillStyle = modelObj.bgColor;

        _ctx.fillRect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

        _ctx.closePath();
      }

      for (var _i = 0; _i < elements.length; _i++) {
        _ctx.beginPath();

        _ctx.beginPath();

        _ctx.fillStyle = elements[_i].baseColor;

        _ctx.arc(elements[_i].circleX, elements[_i].circleY, 13, 0, 2 * Math.PI);

        _ctx.fill();

        _ctx.closePath(); // if (_i === modelObj.correctOption) {
        //   drawCheckMark(_ctx, true, elements[_i].circleX + 5, elements[_i].circleY - 25, 18, 18);
        // } else if (_i === modelObj.selected) {
        //   drawCrossMark(_ctx, true, elements[_i].circleX + 5, elements[_i].circleY - 25, 18, 18);
        // }


        _ctx.beginPath();

        _ctx.fillStyle = elements[_i].fillColor;

        if (modelObj.selectedArr !== null && modelObj.selectedArr.length > 1) {
          modelObj.selectedArr.forEach(function (selected) {
            if (_i === selected && !modelObj.state) {
              _ctx.fillStyle = modelObj.disableColor;
            }
          });
        } else if (_i === modelObj.selected && !modelObj.state) {
          _ctx.fillStyle = modelObj.disableColor;
        }

        _ctx.arc(elements[_i].circleX, elements[_i].circleY, 6, 0, 2 * Math.PI);

        _ctx.fill();

        _ctx.closePath();

        _ctx.closePath();

        if (elements[_i].text) {
          _ctx.beginPath();

          var _str = '';
          var _xTxt = elements[_i].textX;
          var _yTxt = elements[_i].textY;
          _ctx.fillStyle = modelObj.fontColor;
          _str += elements[_i].isHeadItalic ? 'italic ' : '';
          _str += elements[_i].isHeadBold ? 'bold ' : '';
          _ctx.font = _str + "".concat(modelObj.fontSize, "px ") + modelObj.LabComClass.klettFontRegular;
          _ctx.textBaseline = 'middle';

          _ctx.drawImage(elements[_i].text, _xTxt, _yTxt, elements[_i].textWidth, elements[_i].textHeight);

          _ctx.closePath();
        }
      }

      _ctx.restore();
    }
  };

  function drawCheckMark(ctx) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var x = arguments.length > 2 ? arguments[2] : undefined;
    var y = arguments.length > 3 ? arguments[3] : undefined;
    var w = arguments.length > 4 ? arguments[4] : undefined;
    var h = arguments.length > 5 ? arguments[5] : undefined;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.closePath();

    if (status !== null) {
      if (status) {
        ctx.beginPath();
        ctx.fillStyle = 'rgba(112,188,38,1)';
        ctx.rect(x, y, w, h);
        ctx.fill();
        ctx.closePath();
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.moveTo(x + 2, y + 10);
        ctx.lineTo(x + 8, y + 14);
        ctx.lineTo(x + w - 2, y + 3);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }
    }
  }

  function drawCrossMark(ctx) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var x = arguments.length > 2 ? arguments[2] : undefined;
    var y = arguments.length > 3 ? arguments[3] : undefined;
    var w = arguments.length > 4 ? arguments[4] : undefined;
    var h = arguments.length > 5 ? arguments[5] : undefined;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.rect(x, y, w, h);
    ctx.fill();
    ctx.closePath();

    if (status !== null) {
      if (status) {
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,0,0,1)';
        ctx.rect(x, y, w, h);
        ctx.fill();
        ctx.closePath();
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.moveTo(x + w / 2 - 5, y + w / 2 - 5);
        ctx.lineTo(x + w / 2 + 5, y + w / 2 + 5);
        ctx.stroke();
        ctx.moveTo(x + w / 2 + 5, y + w / 2 - 5);
        ctx.lineTo(x + w / 2 - 5, y + w / 2 + 5);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }
    }
  } // =================================================
  // PRIVATE SECTION
  // ================================================


  function removeMouseEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeMouseEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.show) {
      if (modelObj.isDraggable) {
        _eventDataObj.r.push({
          id: 'base_' + modelObj.id,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: 'grab',
          downCursor: 'grabbing',
          eventListener: mouseHandle.bind(this)
        });
      }

      if (modelObj.state) {
        for (var _i = 0; _i < elements.length; _i++) {
          _eventDataObj.r.push({
            id: 'circle_' + _i,
            arc: {
              x: elements[_i].circleX,
              y: elements[_i].circleY,
              r: elements[_i].circleRadius
            },
            eventListener: mouseHandle.bind(this)
          });

          _eventDataObj.r.push({
            id: 'box_' + _i,
            rect: {
              x: elements[_i].textX,
              y: elements[_i].textY,
              w: elements[_i].textWidth,
              h: elements[_i].textHeight
            },
            eventListener: mouseHandle.bind(this)
          });
        }
      }
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'addMouseEvent',
      data: _eventDataObj
    });
  } // =================================================


  function mouseHandle(e) {
    var oldX, oldY;

    switch (e.type) {
      case 'mousedown':
        isPressed = true;
        localObj.mouseEventData.mouseMove = false;
        localObj.mouseEventData.diffX = e.pageX - modelObj.x;
        localObj.mouseEventData.diffY = e.pageY - modelObj.y;
        break;

      case 'mouseenter':
        break;

      case 'mouseup':
        if (e.subId !== 'base_' + modelObj.id && !localObj.mouseEventData.mouseMove) {
          if (e.subId.indexOf('box_') >= 0 || e.subId.indexOf('circle_') >= 0) {
            var _str = e.subId.split('_');

            modelObj.selected = _str[1] * 1;
            calPosition();

            if (typeof events.change !== 'undefined') {
              events.change({
                id: modelObj.id,
                value: modelObj.selected
              });
            }
          }
        }

        localObj.mouseEventData.mouseMove = false;
        isPressed = false;
        break;

      case 'mouseupout':
        isPressed = false;
        break;

      case 'mouseout':
        break;

      case 'pressmove':
        if (modelObj.isDraggable) {
          oldX = modelObj.x;
          oldY = modelObj.y;
          localObj.mouseEventData.mouseMove = true;
          modelObj.x = e.pageX - localObj.mouseEventData.diffX;
          modelObj.y = e.pageY - localObj.mouseEventData.diffY;
          var maxX = baseWid - modelObj.width;
          var maxY = baseHgt - modelObj.height;
          var minY = 0;
          var minX = 0;
          modelObj.x = modelObj.x < minX ? minX : modelObj.x;
          modelObj.x = modelObj.x > maxX ? maxX : modelObj.x;
          modelObj.y = modelObj.y < minY ? minY : modelObj.y;
          modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;

          if (oldX === modelObj.x && oldY === modelObj.y) {
            localObj.mouseEventData.mouseMove = false;
          }

          updatePositions();
        }

        addEvents();
        break;

      case 'stageevent':
        break;

      default:
        break;
    }
  }

  function setGlobalTexts() {
    for (var _i = 0; _i < modelObj.data.length; _i++) {
      modelObj.data[_i] = modelObj.LabComClass.globalLangText[modelObj.data[_i]];
    }
  }

  function calPosition() {
    var _ctx = modelObj.context;
    var _str = '';

    _ctx.save();

    _str += modelObj.isItalic ? 'italic ' : '';
    _str += modelObj.isBold ? 'bold ' : '';
    _ctx.font = _str + "".concat(modelObj.fontSize, "px ") + modelObj.LabComClass.klettFontRegular;
    _ctx.textBaseline = 'top';
    elements.length = 0;
    var textParam = 0;

    for (var _i = 0; _i < modelObj.data.length; _i++) {
      textParam = _ctx.measureText(modelObj.data[_i]);
      var data = modelObj.context.textWrapperClass({
        xNum: 0,
        // modelCls.cPropObj.xInt,
        yNum: 0,
        // modelCls.cPropObj.yInt,
        fontFormat: 'px ',
        maxWidthNum: modelObj.textMaxWidth,
        textStr: modelObj.data[_i],
        fontFamilyStr: modelObj.LabComClass.klettFontRegular,
        fontSizeNum: modelObj.fontSize,
        color: modelObj.fontColor
      });
      elements.push({
        circleRadius: modelObj.radius,
        text: modelObj.data[_i] ? data.imageObj.imageObj : undefined,
        borderColor: modelObj.borderColor,
        baseColor: modelObj.circleBGColor,
        fillColor: _i === modelObj.selected ? modelObj.downColor : 'rgba(0,0,0,0)',
        textWidth: data.imageObj.widthInt,
        textHeight: data.imageObj.heightInt,
        textParam: textParam
      });
    }

    _ctx.restore();

    updatePositions();
  }

  function updatePositions() {
    var _x = modelObj.x + modelObj.bgLeftPadding;

    var _y = modelObj.y + modelObj.bgTopPadding;

    for (var i = 0; i < modelObj.data.length; i++) {
      elements[i].circleX = _x + modelObj.radius;
      elements[i].circleY = _y + modelObj.radius;
      elements[i].textX = _x + modelObj.padding + modelObj.radius * 2;
      elements[i].textY = _y + modelObj.radius - elements[i].textHeight / 2.5;

      if (modelObj.orientation === 'v') {
        _y += modelObj.radius * 2 + (modelObj.topMargin > 0 ? modelObj.topMargin : modelObj.margin);
      } else if (modelObj.orientation === 'h') {
        _x += modelObj.radius * 2 + (modelObj.leftMargin > 0 ? modelObj.leftMargin : modelObj.margin) + modelObj.padding + elements[i].textParam.width;
      } else if (modelObj.orientation === 'box') {
        var odd = i % 2;

        if (odd === 1) {
          _y = modelObj.y;
          _x += modelObj.radius * 2 + (modelObj.leftMargin > 0 ? modelObj.leftMargin : modelObj.margin) + modelObj.padding + elements[i].textParam.width;
        } else {
          _y += modelObj.radius * 2 + (modelObj.topMargin > 0 ? modelObj.topMargin : modelObj.margin);
        }
      }
    }
  }
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function ButtonCompClass(_obj) {
  var events = {};
  var modelObj = {
    x: 105,
    y: 313,
    width: 44,
    height: 30,
    visible: true,
    state: true,
    imgList: [],
    text: '',
    isItalic: false,
    isBold: false,
    fontSize: 16,
    textColor: '#ffffff',
    curveR: 15,
    imageAlign: 'left',
    paddingLeft: 10,
    textPadding: 0,
    toggleMode: false,
    toggleState: false,
    shape: [],
    type: 1,
    // 1 for firstOrder blue & 2 for secondOrder light gray
    // -----------▼ do not use below keys without any supervisor permission ▼------------------------
    bgColorState: {
      normal: 'rgba(170, 170, 166, 1)',
      // #4592b0
      secondOrderNormal: 'rgba(170, 170, 166, 1)',
      // #aaaaaa
      hover: 'rgba(96, 96, 96, 1)',
      // #606060
      down: 'rgba(96, 96, 96, 1)',
      // #606060
      disable: 'rgba(233, 233, 233, 1)' // #e9e9e9

    },
    textColorState: {
      normal: 'rgba(255, 255, 255, 1)',
      // #FFFFFF
      secondOrderNormal: 'rgba(255, 255, 255, 1)',
      // #FFFFFF
      hover: 'rgba(255, 255, 255, 1)',
      // #FFFFFF
      down: 'rgba(255, 255, 255, 1)',
      // #FFFFFF
      disable: 'rgba(142, 142, 142, 1)' // #8e8e8e

    }
  };
  var isPressed = false;
  var isHover = false;
  var imgObj = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });

  if (modelObj.type === 2) {
    modelObj.bgColorState.normal = modelObj.bgColorState.secondOrderNormal;
  }

  var _wd = modelObj.imageWidth > 0 ? modelObj.imageWidth : 27;

  var _ht = modelObj.imageHeight > 0 ? modelObj.imageHeight : 27;

  var _xTxt = modelObj.x + modelObj.width / 2 - _wd / 2;

  var _yTxt = modelObj.y + modelObj.height / 2 - _ht / 2;

  if (modelObj.LabComClass.globalLangText[modelObj.text]) {
    modelObj.text = modelObj.LabComClass.globalLangText[modelObj.text];
  } else {
    modelObj.text = '';
  }

  addEvents();

  if (modelObj.imgList[0]) {
    modelObj.LabComClass.requestGlobalImage(modelObj.imgList, onImagesLoaded, onImagesLoadingError);
  } else {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'componentLoaded',
      data: {
        id: modelObj.id
      }
    });
  } // =================================================
  // PUBLIC SECTION
  // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.setValue = function (_val) {
    modelObj.text = _val;
  };

  this.getVisible = function () {
    return modelObj.visible;
  };

  this.getValue = function () {
    return modelObj.text;
  };

  this.getSize = function () {
    return {
      width: modelObj.width,
      height: modelObj.height
    };
  };

  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.hide = function () {
    modelObj.visible = false;
    isPressed = false;
    addEvents();
  };

  this.setPos = function (_obj) {
    updateValues(_obj, 'x', 'y');
    addEvents();
  };

  function updateValues(_data) {
    for (var _len = arguments.length, key = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      key[_key - 1] = arguments[_key];
    }

    key.forEach(function (i) {
      if (_data[i] !== undefined) {
        modelObj[i] = _data[i];
      }
    });
  }

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  };

  this.setToggleState = function (_flag) {
    modelObj.toggleState = _flag;
  };

  this.getToggleState = function () {
    return modelObj.toggleState;
  }; // =================================================


  this.draw = function () {
    var _ctx = modelObj.context;

    var _x = modelObj.x + modelObj.paddingLeft;

    var _y = modelObj.y + modelObj.height / 2 - _ht / 2;

    if (modelObj.imageAlign === 'center') {
      _x = modelObj.x + modelObj.width / 2 - _wd / 2;
    } // --------------------


    _ctx.save();

    var textColor = modelObj.textColor;

    if (modelObj.visible) {
      var img;
      var fillColor;
      var strokeColor;

      if (modelObj.state) {
        if (isPressed || modelObj.toggleState) {
          fillColor = modelObj.bgColorState.down;
          textColor = modelObj.textColorState.down;
          strokeColor = modelObj.bgColorState.down; // normal

          if (modelObj.imgList[1]) {
            img = imgObj[modelObj.imgList[1]];
          } else if (modelObj.imgList[0]) {
            // check image available or not
            img = imgObj[modelObj.imgList[0]];
          }
        } else {
          if (isHover) {
            fillColor = modelObj.bgColorState.normal; // hover

            textColor = modelObj.textColorState.normal;
          } else {
            fillColor = modelObj.bgColorState.normal;
            textColor = modelObj.textColorState.normal;
          }

          if (modelObj.imgList[0]) {
            img = imgObj[modelObj.imgList[0]];
          }
        }
      } else {
        fillColor = modelObj.bgColorState.disable;
        strokeColor = modelObj.bgColorState.disable;
        textColor = modelObj.textColorState.disable;

        if (modelObj.imgList[0]) {
          img = imgObj[modelObj.imgList[0]];
        }
      }

      if (modelObj.state && isPressed) {
        if (modelObj.imgList[1]) {
          img = imgObj[modelObj.imgList[1]];
        } else if (modelObj.imgList[0]) {
          img = imgObj[modelObj.imgList[0]];
        }
      } else if (modelObj.imgList[0]) {
        img = imgObj[modelObj.imgList[0]];
      }

      if (fillColor) {
        _ctx.fillStyle = fillColor;
      }

      if (strokeColor) {
        _ctx.strokeStyle = strokeColor;
      }

      roundRect(_ctx, modelObj.x, modelObj.y, modelObj.width, modelObj.height, modelObj.curveR, true, isPressed);

      if (img) {
        _ctx.drawImage(img, _x, _y, _wd, _ht);
      }
    } // To add text on button


    if (modelObj.text && modelObj.visible) {
      _ctx.beginPath();

      _xTxt = modelObj.x + modelObj.textPadding + (modelObj.width - modelObj.textPadding) / 2;

      if (modelObj.imgList.length) {
        _xTxt = modelObj.x + modelObj.paddingLeft + _wd + (modelObj.width - modelObj.paddingLeft - _wd) / 2;
      }

      _yTxt = modelObj.y + modelObj.height / 2 + modelObj.fontSize * 0.6;
      _ctx.fillStyle = textColor;
      var _str = '';
      _str += modelObj.isItalic ? 'italic ' : '';
      _str += modelObj.isBold ? 'bold ' : '';
      _ctx.font = _str + "".concat(modelObj.fontSize, "px ") + modelObj.LabComClass.klettFontRegular;
      _ctx.textBaseline = 'bottom';
      _ctx.textAlign = 'center';

      _ctx.fillText(modelObj.text, _xTxt, _yTxt);

      _ctx.closePath();
    }

    if (modelObj.shape.length) {
      _ctx.save();

      _ctx.translate(modelObj.x + modelObj.paddingLeft, modelObj.y + modelObj.height / 2);

      for (var i = 0; i < modelObj.shape.length; i++) {
        // multiple shapes in different arrays
        for (var j = 0; j < modelObj.shape[i].length; j++) {
          // single shape
          eval('_ctx.' + modelObj.shape[i][j]);
        }
      }

      _ctx.restore();
    }

    _ctx.restore();
  };

  function onImagesLoaded(_dataObj) {
    imgObj = _dataObj;
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'componentLoaded',
      data: {
        id: modelObj.id
      }
    });
  }

  function onImagesLoadingError(_error) {
    console.log('Images Loading Error...');
  }

  function removeAllEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  } // =================================================


  function addEvents() {
    removeAllEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.state && modelObj.visible) {
      _eventDataObj.r.push({
        id: modelObj.id,
        rect: {
          x: modelObj.x,
          y: modelObj.y,
          w: modelObj.width,
          h: modelObj.height
        },
        eventListener: mouseHandle.bind(this)
      });

      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'addMouseEvent',
        data: _eventDataObj
      });
    }
  } // =================================================
  // PRIVATE SECTION
  // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        isPressed = true;
        isHover = false;
        break;

      case 'mouseup':
        onKeyPressed();
        addEvents();
        isPressed = false;
        break;

      case 'mouseenter':
        isHover = true;
        isPressed = false;
        break;

      case 'mouseout':
      case 'mouseupout':
        isHover = false;
        isPressed = false;
        break;

      default:
        break;
    }
  }

  function onKeyPressed() {
    if (modelObj.toggleMode) {
      modelObj.toggleState = !modelObj.toggleState;
    }

    if (typeof events.click !== 'undefined') {
      events.click({
        id: modelObj.id,
        value: isPressed,
        toggleState: modelObj.toggleState
      });
    }
  }

  function roundRect(ctx, x, y, width, height, radius, fill, stroke, drawUpperCorners, drawLowerCorners) {
    if (typeof stroke === 'undefined') {
      stroke = true;
    }

    if (typeof radius === 'undefined') {
      radius = 5;
    }

    if (typeof radius === 'number') {
      if (drawUpperCorners) {
        radius = {
          tl: radius,
          tr: radius,
          br: 0,
          bl: 0
        };
      } else if (drawLowerCorners) {
        radius = {
          tl: 0,
          tr: 0,
          br: radius,
          bl: radius
        };
      } else {
        radius = {
          tl: radius,
          tr: radius,
          br: radius,
          bl: radius
        };
      }
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + (width - radius.tr), y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + (height - radius.br));
    ctx.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath();
    ctx.lineWidth = modelObj.strokeWidth;

    if (fill) {
      ctx.fill();
    }

    if (stroke) {
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function ZoomControlsCompClass(_obj) {
  var events = {};
  var modelObj = {
    visible: true,
    state: true,
    imgList: [],
    x: 1068,
    y: 573,
    buttonWidth: 30,
    buttonHeight: 30,
    movementInPxl: {
      moveLeft: {
        x: 10
      },
      moveRight: {
        x: -10
      },
      moveTop: {
        y: 10
      },
      moveBottom: {
        y: -10
      }
    },
    buttons: [{
      type: 'zoomOut',
      enable: true
    }, {
      type: 'zoomReset',
      enable: true
    }, {
      type: 'zoomIn',
      enable: true
    }, {
      type: 'moveLeft',
      enable: true
    }, {
      type: 'moveBottom',
      enable: true
    }, {
      type: 'moveTop',
      enable: true
    }, {
      type: 'moveRight',
      enable: true
    }],
    resetVal: 1,
    currentBtn: null,
    isHover: false,
    isDown: false
  };
  var imgObj = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });

  if (modelObj.imgList.length) {
    modelObj.LabComClass.requestGlobalImage(modelObj.imgList, onImagesLoaded, onImagesLoadingError);
  } else {
    onImagesLoaded({});
  }

  var baseCube = 32;
  var zoomFactor = 1.5;
  var data = [{
    pixelQube: baseCube * (zoomFactor / 1477.8918800354004),
    tick: 5000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 985.2612533569336),
    tick: 2000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 656.8408355712891),
    tick: 1000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 437.8938903808594),
    tick: 1000,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 291.92926025390625),
    tick: 500,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 194.6195068359375),
    tick: 500,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 129.746337890625),
    tick: 200,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 86.49755859375),
    tick: 200,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 57.6650390625),
    tick: 100,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 38.443359375),
    tick: 100,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 25.62890625),
    tick: 50,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 17.0859375),
    tick: 50,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 11.390625),
    tick: 20,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 7.59375),
    tick: 20,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 5.0625),
    tick: 10,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 3.375),
    tick: 5,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor / 2.25),
    tick: 2,
    toFixed: 0
  }, {
    pixelQube: baseCube,
    tick: 1,
    toFixed: 0,
    reset: true
  }, {
    pixelQube: baseCube * (zoomFactor * 1),
    tick: 1,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor * 1.5),
    tick: 1,
    toFixed: 0
  }, {
    pixelQube: baseCube * (zoomFactor * 2.25),
    tick: 0.5,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 3.375),
    tick: 0.5,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 5.0625),
    tick: 0.2,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 7.59375),
    tick: 0.2,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 11.390625),
    tick: 0.1,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 17.0859375),
    tick: 0.1,
    toFixed: 1
  }, {
    pixelQube: baseCube * (zoomFactor * 25.62890625),
    tick: 0.05,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 38.443359375),
    tick: 0.05,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 57.6650390625),
    tick: 0.02,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 86.49755859375),
    tick: 0.02,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 129.746337890625),
    tick: 0.01,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 194.6195068359375),
    tick: 0.01,
    toFixed: 2
  }, {
    pixelQube: baseCube * (zoomFactor * 291.92926025390625),
    tick: 0.005,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 437.8938903808594),
    tick: 0.005,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 550),
    tick: 0.002,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 1800),
    tick: 0.001,
    toFixed: 3
  }, {
    pixelQube: baseCube * (zoomFactor * 3600),
    tick: 0.0005,
    toFixed: 4
  }, {
    pixelQube: baseCube * (zoomFactor * 7200),
    tick: 0.0002,
    toFixed: 4
  }, {
    pixelQube: baseCube * (zoomFactor * 15000),
    tick: 0.0001,
    toFixed: 4
  }, {
    pixelQube: baseCube * (zoomFactor * 30000),
    tick: 0.00005,
    toFixed: 5
  }, {
    pixelQube: baseCube * (zoomFactor * 80000),
    tick: 0.00002,
    toFixed: 5
  }, {
    pixelQube: baseCube * (zoomFactor * 190000),
    tick: 0.00001,
    toFixed: 5
  }];

  for (var i = 0; i < data.length; i++) {
    if (data[i].reset) {
      modelObj.resetVal = i;
      break;
    }
  }

  modelObj.animClass = new modelObj.LabComClass.GlobalAnimClass(); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.setValue = function (_val) {
    modelObj.zoomVal = _val;
    updateStates();
    var _obj = {
      id: modelObj.id,
      value: 'zoomIn',
      data: data[modelObj.zoomVal]
    };

    if (typeof events.click !== 'undefined') {
      events.click(_obj);
    }
  };

  this.getValue = function () {
    return {
      zoomVal: modelObj.zoomVal,
      resetVal: modelObj.resetVal
    };
  };

  this.setText = function (_val) {
    modelObj.text = _val;
  };

  this.getText = function () {
    return modelObj.text;
  };

  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  };

  this.reset = function () {
    modelObj.zoomVal = modelObj.resetVal;
    updateControls({
      subId: 'zoomReset',
      forceReset: true
    });
    updateStates();
  };

  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    setPositions();
  };

  this.getPos = function () {
    return {
      x: modelObj.x,
      y: modelObj.y
    };
  }; // =================================================


  this.enable = function () {
    modelObj.state = true;
    addEvents();
  };

  this.disable = function () {
    modelObj.state = false;
    addEvents();
  }; // =================================================


  this.getState = function () {
    return modelObj.state;
  }; // =================================================


  this.draw = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;
      var i; // --------------------

      _ctx.save();

      _ctx.beginPath();

      _ctx.strokeStyle = 'rgba(35,35,35,0.2)';

      _ctx.rect(modelObj.x - 0.5, modelObj.y - 0.5, modelObj.buttonWidth * modelObj.buttons.length + 1, modelObj.buttonHeight + 1);

      _ctx.stroke();

      _ctx.closePath();

      for (i = 0; i < modelObj.buttons.length; i++) {
        if (modelObj.currentBtn !== modelObj.buttons[i].type) {
          drawShape(_ctx, modelObj.buttons[i]);
        }
      }

      for (i = 0; i < modelObj.buttons.length; i++) {
        if (modelObj.currentBtn === modelObj.buttons[i].type) {
          drawShape(_ctx, modelObj.buttons[i]);
        }
      }

      _ctx.restore();
    }
  };

  function drawShape(ctx, _obj) {
    ctx.save();
    var length = 5;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,1)';

    if (_obj.enable && modelObj.isDown && modelObj.currentBtn === _obj.type) {
      ctx.fillStyle = 'rgba(96, 96, 96, 1)';
    }

    ctx.rect(_obj.x, _obj.y, modelObj.buttonWidth, modelObj.buttonHeight);

    if (_obj.enable && modelObj.isHover && !modelObj.isDown && modelObj.currentBtn === _obj.type) {
      ctx.strokeStyle = 'rgba(96, 96, 96, 1)';
      ctx.stroke();
    }

    ctx.fill();
    ctx.closePath();
    ctx.strokeStyle = 'rgba(53,53,53,1)';

    if (!_obj.enable) {
      ctx.strokeStyle = 'rgba(144,144,144,1)';
    }

    ctx.lineWidth = 1;

    if (_obj.enable && (modelObj.isHover || modelObj.isDown) && modelObj.currentBtn === _obj.type) {
      if (modelObj.isHover) {
        ctx.strokeStyle = 'rgba(96, 96, 96, 1)';
      }

      if (modelObj.isDown) {
        ctx.strokeStyle = 'rgba(255,255,255,1)';
      }

      ctx.lineWidth = 2;
    }

    switch (_obj.type) {
      case 'zoomIn':
        ctx.beginPath();
        ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
        ctx.moveTo(-length, 0);
        ctx.lineTo(length, 0);
        ctx.stroke();
        ctx.moveTo(0, -length);
        ctx.lineTo(0, length);
        ctx.stroke();
        ctx.closePath();
        break;

      case 'zoomReset':
        ctx.beginPath();
        ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
        ctx.arc(0, 0, length, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        break;

      case 'zoomOut':
        ctx.beginPath();
        ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
        ctx.moveTo(-length, 0);
        ctx.lineTo(length, 0);
        ctx.stroke();
        ctx.closePath();
        break;

      case 'moveLeft':
        drawArrow(ctx, _obj, 180 * Math.PI / 180);
        break;

      case 'moveRight':
        drawArrow(ctx, _obj, 0);
        break;

      case 'moveBottom':
        drawArrow(ctx, _obj, 90 * Math.PI / 180);
        break;

      case 'moveTop':
        drawArrow(ctx, _obj, 270 * Math.PI / 180);
        break;

      default:
    }

    ctx.restore();
  }

  function drawArrow(ctx, _obj, angle) {
    var length = 7;
    var arrowHeight = 5;
    var arrowWidth = 6;
    ctx.save();
    ctx.beginPath();
    ctx.translate(_obj.x + modelObj.buttonWidth / 2, _obj.y + modelObj.buttonHeight / 2);
    ctx.rotate(angle);
    ctx.moveTo(-length, 0);
    ctx.lineTo(length, 0);
    ctx.stroke();
    ctx.moveTo(length - arrowWidth, -arrowHeight);
    ctx.lineTo(length, 0);
    ctx.lineTo(length - arrowWidth, arrowHeight);
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
  }

  function onImagesLoaded(_dataObj) {
    imgObj = _dataObj;
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'componentLoaded',
      data: {
        id: modelObj.id
      }
    });
    setPositions();
  }

  function setPositions() {
    for (var i = 0; i < modelObj.buttons.length; i++) {
      modelObj.buttons[i].x = modelObj.x + modelObj.buttonWidth * i;
      modelObj.buttons[i].y = modelObj.y;
    }

    addEvents();
  }

  function onImagesLoadingError(_error) {
    console.log('Images Loading Error...');
  }

  function updateStates() {
    modelObj.buttons[0].enable = true;
    modelObj.buttons[1].enable = true;
    modelObj.buttons[2].enable = true;

    if (modelObj.zoomVal <= 0) {
      modelObj.buttons[0].enable = false;
    }

    if (modelObj.zoomVal >= data.length - 1) {
      modelObj.buttons[2].enable = false;
    }

    addEvents();
  } // =================================================


  function removeAllEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeAllEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    _eventDataObj.r.push({
      id: 'base',
      rect: {
        x: modelObj.x,
        y: modelObj.y,
        w: modelObj.buttonWidth * 3,
        h: modelObj.buttonHeight
      },
      cursor: 'default',
      eventListener: mouseHandle.bind(this)
    });

    if (modelObj.state && modelObj.visible) {
      for (var i = 0; i < modelObj.buttons.length; i++) {
        if (modelObj.buttons[i].enable) {
          _eventDataObj.r.push({
            id: modelObj.buttons[i].type,
            rect: {
              x: modelObj.buttons[i].x,
              y: modelObj.buttons[i].y,
              w: modelObj.buttonWidth,
              h: modelObj.buttonHeight
            },
            eventListener: mouseHandle.bind(this)
          });
        }
      }
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'addMouseEvent',
      data: _eventDataObj
    });
  } // =================================================
  // PRIVATE SECTION
  // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    if (e.subId && e.subId !== 'base') {
      if (e.subId && e.subId !== 'base') {
        modelObj.currentBtn = e.subId;
      }

      var animId = 'scroll' + modelObj.id;
      var animationStarted = false;
      var delayCounter = 0;

      switch (e.type) {
        case 'mousedown':
          modelObj.isDown = true;
          modelObj.animClass.stop(animId);

          if (!e.subId.includes('zoom')) {
            modelObj.animClass.start({
              id: animId,
              fps: 40,
              frame: function frame() {
                delayCounter++;

                if (delayCounter > 10) {
                  animationStarted = true;
                  updateControls(e);
                }
              }
            });
          }

          break;

        case 'mouseup':
          if (!animationStarted) {
            updateControls(e);
          }

          modelObj.isDown = false;
          modelObj.animClass.stop(animId);
          break;

        case 'mouseupout':
          modelObj.isDown = false;
          modelObj.isHover = false;
          modelObj.animClass.stop(animId);
          break;

        case 'mouseenter':
          if (e.subId && e.subId !== 'base') {
            modelObj.isHover = true;
          }

          break;

        case 'mouseout':
          modelObj.isHover = false;
          break;

        default:
          break;
      }
    }
  }

  function updateControls(e) {
    if (modelObj.isDown && modelObj.currentBtn !== null || e.forceReset) {
      var _obj2 = {
        id: modelObj.id,
        value: e.subId
      };

      if (e.subId.includes('move')) {
        _obj2.data = {
          x: 0,
          y: 0
        };

        if (modelObj.movementInPxl[e.subId].x) {
          _obj2.data.x = modelObj.movementInPxl[e.subId].x;
        }

        if (modelObj.movementInPxl[e.subId].y) {
          _obj2.data.y = modelObj.movementInPxl[e.subId].y;
        }
      } else if (e.subId.includes('zoom')) {
        switch (e.subId) {
          case 'zoomIn':
            modelObj.zoomVal++;
            break;

          case 'zoomReset':
            modelObj.zoomVal = modelObj.resetVal;
            break;

          case 'zoomOut':
            modelObj.zoomVal--;
            break;

          default:
        }

        if (modelObj.zoomVal < 0) {
          modelObj.zoomVal = 0;
        }

        if (modelObj.zoomVal > data.length - 1) {
          modelObj.zoomVal = data.length - 1;
        }

        _obj2.data = data[modelObj.zoomVal];
        updateStates();
      }

      if (typeof events.click !== 'undefined') {
        events.click(_obj2);
      }
    }
  }
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function TimeLineCompClass(_obj) {
  var modelObj = {
    x: 0,
    y: 0,
    width: 100,
    height: 31,
    visible: true,
    bgColor: 'rgba(255,255,255,0)',
    borderColor: 'rgba(255,255,255,0)',
    borderWidth: 1,
    currentTask: 0,
    totalTasks: 4,
    fontSize: 14,
    maxVisibleTasks: 4,
    taskStatus: [],
    priviousTask: null,
    minTaskNumber: 0
  };
  var localObj = {
    currentTaskR: 7,
    currentTaskColor: 'rgba(10,190,220,1)',
    currentTaskStrokeColor: 'rgba(10,190,220,1)',
    complitedTaskR: 8,
    complitedTaskColor: 'rgba(65,180,5,1)',
    complitedTaskStrokeColor: 'rgba(65,180,5,1)',
    normalTaskR: 6,
    normalTaskColor: 'rgba(170,170,166,1)',
    normalTaskStrokeColor: 'rgba(170,170,166,1)',
    helpTaskR: 6,
    helpTaskColor: 'rgba(240,230,140,1)',
    helpTaskStrokeColor: 'rgba(240,230,140,1)',
    failedTaskR: 6,
    failedTaskColor: 'rgba(255,0,0,1)',
    failedTaskStrokeColor: 'rgba(255,0,0,1)',
    counterPos: {},
    leftArrowPos: {},
    rightArrowPos: {},
    arrowW: 21,
    pointsPos: [],
    leftArrow: {
      enable: false,
      visible: false
    },
    rightArrow: {
      enable: false,
      visible: false
    },
    totalTask: 4
  };
  var events = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  });
  calculatePoints(); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.getTotalTasks = function () {
    return modelObj.totalTasks;
  }; // =================================================


  this.getVisble = function () {
    return modelObj.visible;
  }; // =================================================
  //= ============== ANIMATION FUNCTIONS ===============


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  };

  this.setTaskStatus = function (_data) {
    modelObj.taskStatus = _data;

    if (modelObj.taskStatus.length > 3) {
      modelObj.minTaskNumber = modelObj.taskStatus.length - 3;
    }

    if (modelObj.taskStatus.length === modelObj.totalTasks) {
      modelObj.minTaskNumber = modelObj.taskStatus.length - 4;
    }

    updateTaskDots();
  }; // =================================================


  this.draw = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;

      _ctx.save(); // background rectangle


      _ctx.beginPath();

      _ctx.fillStyle = modelObj.bgColor;
      _ctx.strokeStyle = modelObj.borderColor;
      _ctx.lineWidth = modelObj.borderWidth;

      _ctx.rect(modelObj.x, modelObj.y, modelObj.width, modelObj.height);

      _ctx.stroke();

      _ctx.fill();

      _ctx.closePath();

      var p = localObj.pointsPos;
      var w = 5; // circles

      for (var i = 0; i < p.length; i++) {
        _ctx.beginPath();

        _ctx.fillStyle = p[i].color;
        _ctx.strokeStyle = p[i].strokeColor;

        _ctx.arc(p[i].x, p[i].y, w, 0, Math.PI * 2);

        _ctx.fill();

        _ctx.stroke();

        _ctx.closePath();

        if (p[i].selected) {
          _ctx.beginPath();

          _ctx.fillStyle = 'rgba(170, 170, 166, 1)';
          _ctx.strokeStyle = 'rgba(170, 170, 166, 1)';

          _ctx.moveTo(p[i].x, p[i].y - w - 3);

          _ctx.lineTo(p[i].x + 4, p[i].y - w - 7);

          _ctx.lineTo(p[i].x - 4, p[i].y - w - 7);

          _ctx.fill();

          _ctx.stroke();

          _ctx.closePath();
        }
      }

      var arrowTrangH = 6; // left arrow

      if (localObj.leftArrow.visible) {
        _ctx.beginPath();

        _ctx.fillStyle = 'rgba(170, 170, 166, 1)';

        if (!localObj.leftArrow.enable) {
          _ctx.fillStyle = 'rgba(233,233,233,1)';
        }

        _ctx.lineWidth = 2;
        var l = localObj.leftArrowPos;

        _ctx.moveTo(l.x, l.y);

        _ctx.lineTo(l.x + arrowTrangH, l.y - arrowTrangH);

        _ctx.lineTo(l.x + arrowTrangH, l.y + arrowTrangH);

        _ctx.fill();

        _ctx.closePath();
      }

      if (localObj.rightArrow.visible) {
        _ctx.beginPath();

        _ctx.fillStyle = 'rgba(170, 170, 166, 1)';

        if (!localObj.rightArrow.enable) {
          _ctx.fillStyle = 'rgba(233,233,233,1)';
        }

        _ctx.lineWidth = 2;
        var r = localObj.rightArrowPos;

        _ctx.moveTo(r.x, r.y);

        _ctx.lineTo(r.x - arrowTrangH, r.y - arrowTrangH);

        _ctx.lineTo(r.x - arrowTrangH, r.y + arrowTrangH);

        _ctx.fill();

        _ctx.closePath();
      }

      _ctx.restore();
    }
  };

  function calculatePoints() {
    var centerY = modelObj.y;
    var gap = 18;
    var startX = modelObj.x + gap;
    localObj.pointsPos = [];
    localObj.counterPos = {
      x: startX - 90,
      y: centerY
    };
    localObj.leftArrowPos = {
      x: modelObj.x,
      y: centerY
    };
    modelObj.taskStatus = [];

    for (var i = 0; i < modelObj.maxVisibleTasks; i++) {
      localObj.pointsPos.push({
        x: startX,
        y: centerY,
        r: localObj.normalTaskR,
        color: localObj.normalTaskColor
      });
      startX += gap;
    }

    localObj.rightArrowPos = {
      x: startX,
      y: centerY
    };
    updateTaskDots();
  }

  function updateTaskDots() {
    modelObj.currentTask = modelObj.currentTask < 0 ? 0 : modelObj.currentTask;
    modelObj.currentTask = modelObj.currentTask > modelObj.totalTasks - 1 ? modelObj.totalTasks - 1 : modelObj.currentTask;
    var min = modelObj.minTaskNumber;

    for (var i = 0; i < localObj.pointsPos.length; i++) {
      var color = localObj.normalTaskColor;
      var strokeColor = localObj.normalTaskStrokeColor;
      var r = localObj.normalTaskR;
      localObj.pointsPos[i].selected = false;

      if (modelObj.taskStatus[min + i]) {
        // Red
        color = localObj.failedTaskColor;
        strokeColor = localObj.failedTaskStrokeColor;
        r = localObj.failedTaskR; // yellow

        if (modelObj.taskStatus[min + i].totalShapesByHelp || modelObj.taskStatus[min + i].totalCorrectShapes) {
          color = localObj.helpTaskColor;
          strokeColor = localObj.helpTaskStrokeColor;
          r = localObj.helpTaskR;
        } // green


        if (modelObj.taskStatus[min + i].solved || modelObj.taskStatus[min + i].solvedWithHelp) {
          color = localObj.complitedTaskColor;
          strokeColor = localObj.complitedTaskStrokeColor;
          r = localObj.complitedTaskR;
        }
      } else if (min + i === modelObj.taskStatus.length) {
        color = localObj.currentTaskColor;
        strokeColor = localObj.currentTaskStrokeColor;
        r = localObj.currentTaskR;
      }

      if (min + i === modelObj.taskStatus.length) {
        localObj.pointsPos[i].selected = true;
        color = localObj.normalTaskColor;
        strokeColor = localObj.normalTaskStrokeColor;
        localObj.pointsPos[i].pointerColor = localObj.currentTaskColor;
        localObj.pointsPos[i].pointerStrokeColor = localObj.currentTaskStrokeColor;
      }

      localObj.pointsPos[i].color = color;
      localObj.pointsPos[i].strokeColor = strokeColor;
      localObj.pointsPos[i].r = r;
    }

    localObj.rightArrow.enable = false;
    localObj.rightArrow.visible = false;
    localObj.leftArrow.enable = false;
    localObj.leftArrow.visible = false;

    if (modelObj.minTaskNumber !== 0) {
      localObj.leftArrow.enable = true;
      localObj.leftArrow.visible = true;
    }

    if (modelObj.taskStatus.length > modelObj.minTaskNumber + localObj.totalTask) {
      localObj.rightArrow.enable = true;
      localObj.rightArrow.visible = true;
    }

    addEvents();
  } // =================================================

  /*
   * This function is used to remove the mouse events.
   */


  function removeEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  } // =================================================


  function addEvents() {
    removeEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.visible) {
      var minArea = 25;

      if (localObj.leftArrow.enable) {
        _eventDataObj.r.push({
          id: 'leftArrow',
          arc: {
            x: localObj.leftArrowPos.x,
            y: localObj.leftArrowPos.y,
            r: minArea
          },
          eventListener: mouseHandle.bind(this)
        });
      }

      if (localObj.rightArrow.enable) {
        _eventDataObj.r.push({
          id: 'rightArrow',
          arc: {
            x: localObj.rightArrowPos.x,
            y: localObj.rightArrowPos.y,
            r: minArea
          },
          eventListener: mouseHandle.bind(this)
        });
      }
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'addMouseEvent',
      data: _eventDataObj
    });
  } // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        break;

      case 'mouseup':
        if (e.subId === 'leftArrow') {
          modelObj.minTaskNumber -= 1;
        } else if (e.subId === 'rightArrow') {
          modelObj.minTaskNumber += 1;
        }

        updateTaskDots();
        break;

      case 'mouseupout':
        break;

      default:
        break;
    }
  }
}
"use strict";

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function MenuCompClass(_obj) {
  var modelObj = {
    x: 1251,
    y: 113,
    width: 200,
    height: 160,
    visible: false,
    state: true,
    bgColor: 'rgba(255,255,255,1)',
    text: {},
    data: {
      showAxis: {
        visible: true,
        toggle: true,
        selected: true
      },
      showGrid: {
        visible: true,
        toggle: true,
        selected: true
      },
      snapToGrid: {
        visible: true,
        toggle: true,
        selected: true
      }
    },
    rowHeight: 40,
    fontSize: 16,
    textLeftPadding: 20
  };

  var _this = this;

  var localObj = {
    isHover: false,
    isPressed: false,
    selected: false
  };
  var events = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  });
  updateData(); // =================================================
  // PUBLIC SECTION
  // =================================================
  // =================================================
  //= ============== ANIMATION FUNCTIONS ===============

  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================
  // =================================================


  this.show = function () {
    modelObj.visible = true;
    addEvents();
  };

  this.setPos = function (_x, _y) {
    modelObj.x = _x;
    modelObj.y = _y;
    validatePos();
    addEvents();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  }; // =================================================


  this.getVisble = function () {
    return modelObj.visible;
  };

  this.getData = function () {
    return modelObj.data;
  };

  this.setData = function (_obj) {
    modelObj.data = _obj;
    updateData();
  }; // =================================================


  this.draw = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;
      var totalHeight = 0;
      Object.keys(modelObj.data).forEach(function (key, i) {
        var _op = modelObj.data[key];

        if (_op.visible) {
          totalHeight += modelObj.rowHeight;
        }
      });

      _ctx.save();

      _ctx.beginPath();

      _ctx.fillStyle = modelObj.bgColor;
      _ctx.strokeStyle = 'rgba(170,170,170,1)';

      _ctx.rect(modelObj.x, modelObj.y, modelObj.width, totalHeight);

      _ctx.fill();

      _ctx.stroke();

      _ctx.closePath();

      _ctx.save();

      _ctx.translate(modelObj.x, modelObj.y);

      Object.keys(modelObj.data).forEach(function (key, i) {
        var _op = modelObj.data[key];

        if (_op.visible) {
          _ctx.beginPath();

          _ctx.fillStyle = 'rgba(233,233,233,1)';

          if (localObj.selected === key && (localObj.isHover || localObj.isPressed)) {
            _ctx.fillStyle = 'rgba(170,170,170,1)';
          }

          _ctx.rect(_op.x, _op.y, modelObj.width, modelObj.rowHeight);

          _ctx.fill();

          _ctx.closePath();

          _ctx.fillStyle = 'rgba(51,51,51,1)';

          if (localObj.selected === key && (localObj.isHover || localObj.isPressed)) {
            _ctx.fillStyle = 'rgba(255,255,255,1)';
          }

          _ctx.textBaseline = 'bottom';

          _ctx.drawStyledText(_op.text, _op.x + modelObj.textLeftPadding, _op.y + modelObj.rowHeight / 2 + modelObj.fontSize * 0.6, modelObj.LabComClass.klettFontRegular, modelObj.fontSize);

          if (_op.selected) {
            _ctx.save();

            _ctx.translate(modelObj.width - 40, _op.y + modelObj.rowHeight / 2 - 12);

            _ctx.beginPath();

            _ctx.strokeStyle = 'rgba(170,170,170,1)';

            if (localObj.selected === key && (localObj.isHover || localObj.isPressed)) {
              _ctx.strokeStyle = 'rgba(255,255,255,1)';
            }

            _ctx.lineWidth = 2;
            _ctx.lineJoin = 'round';

            _ctx.moveTo(4, 14);

            _ctx.lineTo(10, 19);

            _ctx.lineTo(22, 5);

            _ctx.stroke();

            _ctx.restore();
          }
        }
      });

      _ctx.restore();

      _ctx.restore();
    }
  };
  /*
   * This function is used to remove the mouse events.
   */


  function removeEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  } // =================================================


  function addEvents() {
    var _this2 = this;

    removeEvents();
    var _eventDataObj = {};
    _eventDataObj.id = modelObj.id;
    _eventDataObj.r = [];

    if (modelObj.visible) {
      // _eventDataObj.r.push({
      //   id: modelObj.id,
      //   rect: {
      //     x: modelObj.x,
      //     y: modelObj.y,
      //     w: modelObj.width,
      //     h: modelObj.height
      //   },
      //   cursor: 'default',
      //   eventListener: mouseHandle.bind(this)
      // });
      Object.keys(modelObj.data).forEach(function (key, i) {
        if (modelObj.data[key].visible) {
          _eventDataObj.r.push({
            id: key,
            rect: {
              x: modelObj.x + modelObj.data[key].x,
              y: modelObj.y + modelObj.data[key].y,
              w: modelObj.width,
              h: modelObj.rowHeight
            },
            eventListener: mouseHandle.bind(_this2)
          });
        }
      });
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'addMouseEvent',
      data: _eventDataObj
    });
  } // =================================================
  // This function handles all mouse events


  function mouseHandle(e) {
    var id;

    switch (e.type) {
      case 'mousedown':
        if (e.subId !== modelObj.id) {
          localObj.isHover = true;
          localObj.isPressed = true;
          localObj.selected = e.subId;
        }

        break;

      case 'mouseenter':
        if (e.subId !== modelObj.id) {
          localObj.isHover = true;
          localObj.selected = e.subId;
        }

        break;

      case 'mouseout':
        if (e.subId !== modelObj.id) {
          localObj.isHover = false;
          localObj.selected = null;
        }

        break;

      case 'mouseup':
        if (e.subId !== modelObj.id) {
          localObj.isHover = false;
          localObj.isPressed = false;
          id = e.subId;

          if (modelObj.data[id].toggle) {
            modelObj.data[id].selected = !modelObj.data[id].selected;
          }

          if (typeof events.click !== 'undefined') {
            events.click({
              id: modelObj.id,
              value: id,
              state: modelObj.data[id].selected
            });
          }

          localObj.selected = null;
        }

        break;

      case 'mouseupout':
        if (e.subId !== modelObj.id) {
          localObj.isHover = false;
          localObj.isPressed = false;
          localObj.selected = null;
        }

        break;

      case 'stageevent':
        if (!localObj.isPressed) {
          _this.hide();
        }

        break;

      default:
        break;
    }
  }

  function validatePos() {
    if (modelObj.x < 0) {
      modelObj.x = 0;
    }

    if (modelObj.x + modelObj.width > 1280) {
      modelObj.x = 1280 - modelObj.width - 20;
    }

    if (modelObj.y + modelObj.finalY > 720) {
      modelObj.y = 720 - modelObj.finalY - 20;
    }
  }

  function updateData() {
    var y = 0;
    Object.keys(modelObj.data).forEach(function (key, i) {
      if (modelObj.data[key].visible) {
        modelObj.data[key].text = modelObj.LabComClass.globalLangText[modelObj.text[key]];
        modelObj.data[key].x = 0;
        modelObj.data[key].y = y;
        y += modelObj.rowHeight;
      }
    });
    modelObj.finalY = y;
    validatePos();
    addEvents();
  }
}
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// _dataObj holds the id sent by the JSON. This data will be passed to the Model directly to set the ID.
function MsgBoxClass(_obj) {
  var images;
  var modelObj = {
    x: null,
    y: null,
    position: 'top-left',
    prevX: null,
    prevY: null,
    width: 410,
    maxWidth: 410,
    height: 100,
    visible: false,
    bgColor: 'rgba(0, 0, 0, 0.6)',
    baseColor: '#e0e0e0',
    headHeight: 40,
    headColor: '#999999',
    headText: 'header',
    headTextX: 20,
    headTextY: 12,
    headFontSize: 20,
    headFontColor: 'rgba(255, 255, 255, 1)',
    bodyTextX: 20,
    bodyTextY: 20,
    bodyFontSize: 16,
    bodyFontColor: 'rgba(0, 0, 0, 1)',
    // radius: 5,
    radius: 0,
    strokeWidth: 1,
    isItalic: false,
    isBold: false,
    type: 'alert',
    delayCount: 0,
    totalDelayCount: 0,
    alpha: 1,
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    defaultImages: ['whiteClose_btn_nrml.png', 'whiteClose_btn_hvr.png'],
    closeBtn: {
      isHover: false,
      x: 0,
      y: 0,
      padding: 10,
      width: 24,
      radius: 24,
      height: 24
    },
    mousedown: {
      diffX: 0,
      diffY: 0
    },
    text: ''
  };
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------

  var thisObj = this;
  var textContextObjs = [];
  var events = {};
  var isPressed = false;
  var baseWid = modelObj.playerConfigObj.baseWidth;
  var baseHgt = modelObj.playerConfigObj.baseHeight; // --------------------
  // --------------------

  modelObj.text = modelObj.LabComClass.globalLangText[modelObj.bodyText];
  updateTextWrappers();
  addEvents(); // --------------------

  modelObj.LabComClass.requestGlobalImage(_toConsumableArray(modelObj.defaultImages), onImageLoaded); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.show = function () {
    modelObj.visible = true; // modelObj.x = modelObj.defaultPos.x;
    // modelObj.y = modelObj.defaultPos.y;

    addEvents();
  };

  this.isVisible = function () {
    return modelObj.visible;
  };

  this.setValue = function (_text) {
    modelObj.text = _text;
    updateTextWrappers();
  };

  this.setPosition = function (x, y) {
    modelObj.x = x;
    modelObj.y = y;
    addEvents();
  }; // =================================================


  this.hide = function () {
    modelObj.visible = false;
    addEvents();
  }; // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  }; // =================================================


  this.draw = function () {
    if (modelObj.visible) {
      var _ctx = modelObj.context;

      _ctx.save(); // _ctx.globalAlpha = modelObj.alpha;
      // _ctx.globalAlpha = 0.5;
      // --------------------
      // Black drawing
      // _ctx.beginPath();
      // _ctx.fillStyle = modelObj.bgColor;
      // _ctx.fillRect(0, 0, baseWid, baseHgt);
      // _ctx.closePath();
      // --------------------
      // Base drawing


      _ctx.beginPath();

      _ctx.fillStyle = modelObj.baseColor;
      _ctx.strokeStyle = modelObj.headColor;

      if (modelObj.type === 'correct') {
        _ctx.strokeStyle = '#7da961';
      }

      if (modelObj.type === 'incorrect') {
        _ctx.strokeStyle = '#999999';
      }

      roundRect(_ctx, modelObj.x, modelObj.y, modelObj.width, modelObj.height, modelObj.radius, true, true, false, false);

      _ctx.closePath(); // --------------------
      // Head drawing


      _ctx.beginPath();

      _ctx.fillStyle = modelObj.headColor;

      if (modelObj.type === 'correct') {
        _ctx.fillStyle = '#7da961';
      }

      if (modelObj.type === 'incorrect') {
        _ctx.fillStyle = '#999999';
      }

      roundRect(_ctx, modelObj.x, modelObj.y, modelObj.width, modelObj.headHeight, modelObj.radius, true, false, true, false);

      _ctx.closePath(); // --------------------
      // Head Text drawing


      _ctx.beginPath();

      var _xTxt = modelObj.x + modelObj.headTextX;

      var _yTxt = modelObj.y + modelObj.headTextY;

      _ctx.fillStyle = modelObj.headFontColor;

      if (modelObj.type === 'correct') {
        _ctx.fillStyle = '#ffffff';
      }

      _ctx.font = modelObj.headFontSize + 'px ' + modelObj.LabComClass.klettFontRegular;
      _ctx.textAlign = 'left';
      _ctx.textBaseline = 'bottom';
      var text = modelObj.LabComClass.globalLangText[modelObj.headText] ? modelObj.LabComClass.globalLangText[modelObj.headText] : '-';

      _ctx.fillText(text, _xTxt, _yTxt + modelObj.headFontSize);

      _ctx.closePath(); // --------------------


      if (typeof textContextObjs[0].imageObj !== 'undefined') {
        _ctx.drawImage(textContextObjs[0].imageObj.imageObj, modelObj.x + modelObj.bodyTextX, modelObj.y + modelObj.headHeight + modelObj.bodyTextY, textContextObjs[0].imageObj.widthInt, textContextObjs[0].imageObj.heightInt);
      } // --------------------


      if (!modelObj.closeBtn.isHover) {
        _ctx.drawImage(images[modelObj.defaultImages[0]], modelObj.closeBtn.x - modelObj.closeBtn.width / 2, modelObj.closeBtn.y - modelObj.closeBtn.height / 2, modelObj.closeBtn.width, modelObj.closeBtn.height);
      } else {
        _ctx.drawImage(images[modelObj.defaultImages[1]], modelObj.closeBtn.x - modelObj.closeBtn.width / 2, modelObj.closeBtn.y - modelObj.closeBtn.height / 2, modelObj.closeBtn.width, modelObj.closeBtn.height);
      }

      _ctx.restore();
    }
  }; // =================================================
  // PRIVATE SECTION
  // =================================================


  function updateSize() {
    if (modelObj.x === null || modelObj.y === null) {
      modelObj.x = baseWid / 2 - modelObj.width / 2;
      modelObj.y = baseHgt / 2 - modelObj.height / 2;
    } else if (modelObj.position === 'bottom-right') {
      modelObj.x -= modelObj.width;
      modelObj.y -= modelObj.height;
    }

    modelObj.defaultPos = {
      x: modelObj.x,
      y: modelObj.y
    };
    modelObj.closeBtn.x = modelObj.x + (modelObj.width - modelObj.closeBtn.padding - modelObj.closeBtn.width / 2);
    modelObj.closeBtn.y = modelObj.y + modelObj.headHeight / 2;
  } // =================================================


  function updateCloseBtnPosition() {
    modelObj.closeBtn.x = modelObj.x + (modelObj.width - modelObj.closeBtn.padding - modelObj.closeBtn.width / 2);
    modelObj.closeBtn.y = modelObj.y + modelObj.headHeight / 2;
    addEvents();
  } // =================================================


  function removeMouseEvents() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'removeMouseEvent',
      data: {
        id: modelObj.id
      }
    });
  }

  function addEvents() {
    removeMouseEvents();

    if (modelObj.visible === true) {
      modelObj.closeBtn.x = modelObj.x + (modelObj.width - modelObj.closeBtn.padding - modelObj.closeBtn.width / 2);
      modelObj.closeBtn.y = modelObj.y + modelObj.headHeight / 2;
      var _eventDataObj = {};
      _eventDataObj.id = modelObj.id;
      _eventDataObj.r = [];

      if (modelObj.alpha === 1) {
        _eventDataObj.r.push({
          id: 1,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.height
          },
          cursor: 'default',
          eventListener: mouseHandle.bind(this)
        });

        _eventDataObj.r.push({
          id: 2,
          rect: {
            x: modelObj.x,
            y: modelObj.y,
            w: modelObj.width,
            h: modelObj.headHeight
          },
          // cursor: 'default',
          eventListener: mouseHandle.bind(this)
        });

        _eventDataObj.r.push({
          id: 'close',
          arc: {
            x: modelObj.closeBtn.x,
            y: modelObj.closeBtn.y,
            r: modelObj.closeBtn.radius
          },
          eventListener: mouseHandle.bind(this)
        });
      }

      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'addMouseEvent',
        data: _eventDataObj
      });
    }
  } // =================================================


  function mouseHandle(e) {
    switch (e.type) {
      case 'mousedown':
        isPressed = true;
        modelObj.mousedown.diffX = e.pageX - modelObj.x;
        modelObj.mousedown.diffY = e.pageY - modelObj.y;
        break;

      case 'mouseenter':
        if (e.subId === 'close') {
          modelObj.closeBtn.isHover = true;
        }

        break;

      case 'mouseup':
        switch (e.subId) {
          case 'close':
            popupClose();
            break;

          default:
            break;
        }

        isPressed = false;
        break;

      case 'mouseupout':
        isPressed = false;

        if (e.subId === 'close') {
          modelObj.closeBtn.isHover = false;
        }

        break;

      case 'mouseout':
        if (e.subId === 'close') {
          modelObj.closeBtn.isHover = false;
        }

        break;

      case 'pressmove':
        if (e.subId === 2) {
          modelObj.x = e.pageX - modelObj.mousedown.diffX;
          modelObj.y = e.pageY - modelObj.mousedown.diffY;
          modelObj.maxX = baseWid - modelObj.width;
          var maxY = modelObj.maxY - modelObj.height;
          modelObj.x = modelObj.x < modelObj.minX ? modelObj.minX : modelObj.x;
          modelObj.x = modelObj.x > modelObj.maxX ? modelObj.maxX : modelObj.x;
          modelObj.y = modelObj.y < modelObj.minY ? modelObj.minY : modelObj.y;
          modelObj.y = modelObj.y > maxY ? maxY : modelObj.y; // var maxX = baseWid - modelObj.width;
          // var maxY = (baseHgt - modelObj.height);
          // var minY = 0;
          // var minX = 0;
          // modelObj.x = modelObj.x < minX ? minX : modelObj.x;
          // modelObj.x = modelObj.x > maxX ? maxX : modelObj.x;
          // modelObj.y = modelObj.y < minY ? minY : modelObj.y;
          // modelObj.y = modelObj.y > maxY ? maxY : modelObj.y;
        }

        addEvents();
        break;

      case 'stageevent':
        if (!isPressed) {
          popupClose();
        }

        break;

      default:
        break;
    }
  } // =================================================


  function popupClose() {
    modelObj.delayCount = 0;
    thisObj.hide();
    modelObj.closeBtn.isHover = false;

    if (typeof events.popupClose !== 'undefined') {
      events.popupClose({
        id: modelObj.id,
        type: 'popupClose'
      }, true);
    }
  } // =================================================


  function onImageLoaded(_obj) {
    images = _obj;
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'componentLoaded',
      data: {
        id: modelObj.id
      }
    });
  }

  function roundRect(contextObj, x, y, width, height, radius, fill, stroke, drawUpperCornersOnly, drawRoundedSides) {
    if (typeof stroke === 'undefined') {
      stroke = true;
    }

    if (typeof radius === 'undefined') {
      radius = 5;
    }

    if (typeof radius === 'number') {
      if (drawUpperCornersOnly) {
        radius = {
          tl: radius,
          tr: radius,
          br: 0,
          bl: 0
        };
      } else {
        radius = {
          tl: radius,
          tr: radius,
          br: radius,
          bl: radius
        };
      }
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    contextObj.beginPath();

    if (!drawRoundedSides) {
      contextObj.moveTo(x + radius.tl, y);
      contextObj.lineTo(x + (width - radius.tr), y);
      contextObj.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      contextObj.lineTo(x + width, y + (height - radius.br));
      contextObj.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
      contextObj.lineTo(x + radius.bl, y + height);
      contextObj.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
      contextObj.lineTo(x, y + radius.tl);
      contextObj.quadraticCurveTo(x, y, x + radius.tl, y);
    } else {
      contextObj.moveTo(x + radius.tl, y);
      contextObj.lineTo(x + (width - radius.tr), y);
      contextObj.arc(x + width, y + height / 2, height / 2, 3 * Math.PI / 2, Math.PI / 2);
      contextObj.lineTo(x + radius.bl, y + height);
      contextObj.arc(x, y + height / 2, height / 2, Math.PI / 2, 3 * Math.PI / 2);
    }

    contextObj.closePath();
    contextObj.lineWidth = modelObj.strokeWidth;

    if (fill) {
      contextObj.fill();
    }

    if (stroke) {
      contextObj.stroke();
    }
  }

  function updateTextWrappers() {
    textContextObjs = [];
    textContextObjs.push(modelObj.context.textWrapperClass({
      xNum: 0,
      // modelCls.cPropObj.xInt,
      yNum: 0,
      // modelCls.cPropObj.yInt,
      maxWidthNum: modelObj.maxWidth - modelObj.bodyTextX * 2,
      textStr: modelObj.text,
      fontFamilyStr: modelObj.LabComClass.klettFontRegular,
      fontSizeNum: modelObj.bodyFontSize,
      fontColor: modelObj.bodyFontColor,
      fontFormat: 'px '
    }));
    modelObj.width = modelObj.maxWidth;
    modelObj.height = modelObj.headHeight + modelObj.bodyTextY + textContextObjs[0].imageObj.heightInt + modelObj.bodyTextY;
    updateSize();
  }
}
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function NumberPadClass(dataObj) {
  var self = this;
  var id = dataObj.id,
      deviceTypeBool = dataObj.deviceTypeBool,
      context = dataObj.context;
  var model = {
    x: 0,
    y: 0,
    btnWidth: 45,
    btnHeight: 45,
    textBtnWidth: 88,
    holderBgColor: 'rgba(233, 233, 233, 1)',
    numberBtnBgColor: 'rgb(255, 102, 0)',
    numberBtnTextColor: '#FFFFFF',
    nonNumberBtnBgColor: 'rgba(246, 246, 246, 1)',
    nonNumberBtnTextColor: '#000000',
    holderPadding: [15, 15, 15, 15],
    btnVertPadding: 20,
    btnHorizPadding: 10,
    borderRadius: 0,
    fontStyle: 'normal',
    fontSize: 24,
    fontFamily: 'Arial',
    showComponent: false,
    headerText: 'Number Pad',
    headerHeight: 40,
    headerBgColor: 'rgb(255, 102, 0)',
    headerFontFamily: 'Arial',
    headerFontSize: 24,
    headerFontStyle: 'normal',
    headerTextColor: '#FFFFFF',
    caps: false
  };
  Object.keys(dataObj).forEach(function (i) {
    model[i] = dataObj[i];
  });
  var specialKeys = {
    diff: '–',
    dot: '.',
    back: 'Del',
    clear: 'Clear',
    enter: 'Enter',
    comma: ',',
    caps: 'Caps Lock'
  };
  var padkeys = [[1, 2, 3, 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'ü', 'back'], [4, 5, 6, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'ö', 'ä', 'clear'], [7, 8, 9, 'z', 'x', 'c', 'v', 'b', 'n', 'm', 'ß', 'enter', 'caps'], ['diff', 0, 'dot', 'comma', '(', ')']];
  var holderBounds = null;
  var headerBounds = null;
  var keyPosArr = null;
  var entryBoxObj = null;
  var currentEntryBox = null;
  var gap = null;
  Object.defineProperties(this, {
    enable: {
      set: function set(value) {
        toggleEvents(value);
      }
    },
    show: {
      set: function set(value) {
        toggleVisibility(value);
      }
    },
    compId: {
      get: function get() {
        return id;
      }
    },
    isCompVisible: {
      get: function get() {
        return model.showComponent;
      }
    }
  });

  function init() {
    updateBounds();

    if (!deviceTypeBool) {
      self.show = false;
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'componentLoaded',
      data: {
        id: dataObj.id
      }
    });
  }

  this.registerEntryBox = function () {
    if (deviceTypeBool) {
      entryBoxObj = {};

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      arg.forEach(function (entryBox) {
        entryBox.numberPadCompId = self.compId;
        entryBoxObj[entryBox.compId] = entryBox;
      });
      toggleEntryBoxEvents(true);
    }
  };

  this.unregisterEntryBox = function () {
    toggleEntryBoxEvents(false);
    entryBoxObj = null;
  };

  this.draw = function () {
    if (model.showComponent) {
      var holderBgColor = model.holderBgColor,
          borderRadius = model.borderRadius,
          fontStyle = model.fontStyle,
          fontSize = model.fontSize,
          fontFamily = model.fontFamily,
          headerText = model.headerText,
          headerFontFamily = model.headerFontFamily,
          headerFontSize = model.headerFontSize,
          headerFontStyle = model.headerFontStyle,
          headerBgColor = model.headerBgColor,
          headerTextColor = model.headerTextColor;
      var _holderBounds = holderBounds,
          x = _holderBounds.x,
          y = _holderBounds.y,
          width = _holderBounds.width,
          height = _holderBounds.height;
      context.save(); // bg

      context.fillStyle = holderBgColor;
      roundRect({
        x: x,
        y: y,
        width: width,
        height: height,
        radius: borderRadius,
        fill: true
      }); // header

      context.fillStyle = headerBgColor;
      roundRect({
        x: headerBounds.x,
        y: headerBounds.y,
        width: headerBounds.width,
        height: headerBounds.height,
        radius: borderRadius,
        fill: true
      });
      context.font = "".concat(headerFontStyle, " ").concat(headerFontSize, "px ").concat(headerFontFamily);
      context.textAlign = 'left';
      context.textBaseline = 'hanging';
      context.fillStyle = headerTextColor;
      context.fillText(headerText, x + (headerBounds.width - context.measureText(headerText).width) / 2, headerBounds.y + (headerBounds.height - headerFontSize) / 2 + 2); // buttons

      keyPosArr.forEach(function (keyData, i) {
        var x = keyData.x,
            y = keyData.y,
            width = keyData.width,
            height = keyData.height,
            color = keyData.color,
            fillStyle = keyData.fillStyle,
            value = keyData.value;
        context.fillStyle = fillStyle;
        roundRect({
          x: x,
          y: y,
          width: width,
          height: height,
          radius: borderRadius,
          fill: true
        });
        context.font = "".concat(fontStyle, " ").concat(fontSize, "px ").concat(fontFamily);
        context.fillStyle = color;

        if (value === 'Caps Lock') {
          context.fillStyle = model.caps ? model.numberBtnBgColor : color;
        }

        context.fillText(value, x + (width - context.measureText(value).width) / 2, y + (height - fontSize) / 2 + 4);
      });
      context.restore();
    }
  };

  function roundRect(_ref) {
    var x = _ref.x,
        y = _ref.y,
        width = _ref.width,
        height = _ref.height,
        radius = _ref.radius,
        fill = _ref.fill;

    if (typeof radius === 'undefined') {
      radius = 5;
    }

    if (typeof radius === 'number') {
      radius = {
        tl: radius,
        tr: radius,
        br: radius,
        bl: radius
      };
    } else {
      var defaultRadius = {
        tl: 0,
        tr: 0,
        br: 0,
        bl: 0
      };
      Object.keys(defaultRadius).forEach(function (side) {
        radius[side] = radius[side] || defaultRadius[side];
      });
    }

    context.beginPath();
    context.moveTo(x + radius.tl, y);
    context.lineTo(x + (width - radius.tr), y);
    context.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    context.lineTo(x + width, y + (height - radius.br));
    context.quadraticCurveTo(x + width, y + height, x + (width - radius.br), y + height);
    context.lineTo(x + radius.bl, y + height);
    context.quadraticCurveTo(x, y + height, x, y + (height - radius.bl));
    context.lineTo(x, y + radius.tl);
    context.quadraticCurveTo(x, y, x + radius.tl, y);
    context.closePath();

    if (fill) {
      context.fill();
    }
  }

  function updateBounds() {
    calculateHolderBounds();
    calculateHeaderBounds();
    calculateKeyBounds();
  }

  function calculateHolderBounds() {
    var x = model.x,
        y = model.y,
        btnWidth = model.btnWidth,
        btnHeight = model.btnHeight,
        textBtnWidth = model.textBtnWidth,
        btnVertPadding = model.btnVertPadding,
        btnHorizPadding = model.btnHorizPadding,
        holderPadding = model.holderPadding,
        headerHeight = model.headerHeight;
    var maxCol = Math.max.apply(Math, _toConsumableArray(padkeys.map(function (keyArr) {
      return keyArr.length;
    })));
    var width = (maxCol - 1) * (btnWidth + btnHorizPadding) + textBtnWidth + (holderPadding[1] + holderPadding[3]);
    var height = padkeys.length * btnHeight + (padkeys.length - 1) * btnVertPadding + (holderPadding[0] + holderPadding[2]);
    height += headerHeight + btnVertPadding;
    holderBounds = {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }

  function calculateHeaderBounds() {
    var holderPadding = model.holderPadding,
        headerHeight = model.headerHeight;
    var width = holderBounds.width; // - (holderPadding[1] + holderPadding[3]);

    headerBounds = {
      x: holderBounds.x,
      y: holderBounds.y,
      width: width,
      height: headerHeight
    };
  }

  function calculateKeyBounds() {
    var btnWidth = model.btnWidth,
        btnHeight = model.btnHeight,
        textBtnWidth = model.textBtnWidth,
        btnHorizPadding = model.btnHorizPadding,
        btnVertPadding = model.btnVertPadding,
        holderPadding = model.holderPadding,
        numberBtnBgColor = model.numberBtnBgColor,
        numberBtnTextColor = model.numberBtnTextColor,
        nonNumberBtnBgColor = model.nonNumberBtnBgColor,
        nonNumberBtnTextColor = model.nonNumberBtnTextColor;
    var _headerBounds = headerBounds,
        height = _headerBounds.height;
    var x = headerBounds.x + holderPadding[1];
    var y = headerBounds.y + height + btnVertPadding;
    keyPosArr = [];
    padkeys.forEach(function (keys, i) {
      keys.forEach(function (key, j) {
        var value = specialKeys[key] ? specialKeys[key] : key;
        var width = btnWidth;
        var condition = value.toString().length <= 2;
        /*&& value.toString() !== ',';*/

        if (!condition) {
          width = textBtnWidth;
        } else {
          width = btnWidth;
        }

        var _x;

        if (value == 'Caps Lock') {
          _x = x + (j - 1) * (btnWidth + btnHorizPadding) + textBtnWidth + btnHorizPadding;
          width = width * 1.75;
        } else {
          _x = x + j * (btnWidth + btnHorizPadding);
        }

        var _y = y + i * (btnHeight + btnVertPadding);

        var fillStyle = numberBtnBgColor;
        var color = numberBtnTextColor;

        if (isNaN(Number(value))) {
          fillStyle = nonNumberBtnBgColor;
          color = nonNumberBtnTextColor;
        }

        keyPosArr.push({
          key: key,
          value: value,
          x: _x,
          y: _y,
          width: width,
          height: btnHeight,
          fillStyle: fillStyle,
          color: color
        });
      });
    });
  }

  function toggleEvents(interactive) {
    var evetData = {
      id: self.compId
    };

    if (interactive) {
      evetData.r = [];
      var _holderBounds2 = holderBounds,
          x = _holderBounds2.x,
          y = _holderBounds2.y,
          width = _holderBounds2.width,
          height = _holderBounds2.height;
      evetData.r.push({
        id: 'Holder',
        rect: {
          x: x,
          y: y,
          w: width,
          h: height
        },
        eventListener: function eventListener() {}
      });
      evetData.r.push({
        id: 'header',
        rect: {
          x: headerBounds.x,
          y: headerBounds.y,
          w: headerBounds.width,
          h: headerBounds.height
        },
        eventListener: handleMouseEvents
      });
      keyPosArr.forEach(function (_ref2) {
        var key = _ref2.key,
            x = _ref2.x,
            y = _ref2.y,
            width = _ref2.width,
            height = _ref2.height;
        evetData.r.push({
          id: key,
          rect: {
            x: x,
            y: y,
            w: width,
            h: height
          },
          eventListener: handleMouseEvents
        });
      });
    }

    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: interactive ? 'addMouseEvent' : 'removeMouseEvent',
      data: evetData
    });
  }

  function toggleVisibility(visible) {
    model.showComponent = visible;
    self.enable = visible;
    updateStage();
  }

  function handleMouseEvents(dataObj) {
    switch (dataObj.type) {
      case 'mousedown':
        if (dataObj.subId === 'header') {
          gap = {
            x: dataObj.pageX - holderBounds.x,
            y: dataObj.pageY - holderBounds.y
          };
        }

        break;

      case 'pressmove':
        if (dataObj.subId === 'header') {
          model.x = dataObj.pageX - gap.x;
          model.y = dataObj.pageY - gap.y;
          updateBounds();
          self.enable = true;
        }

        break;

      case 'mouseup':
        {
          var subId = dataObj.subId;

          if (subId !== 'header' && currentEntryBox) {
            switch (subId) {
              case 'enter':
                if (!currentEntryBox.getEnterToSubmit()) {
                  currentEntryBox.focusOut();
                } else {
                  currentEntryBox.setNumberPadValue(subId);
                  currentEntryBox.focusOut(); // currentEntryBox = null;
                  // self.show = false; 
                }

                break;

              case 'caps':
                if (model.caps) {
                  changeCase(false);
                  model.caps = false;
                } else {
                  changeCase(true);
                  model.caps = true;
                }

                break;

              default:
                if (!model.caps) {
                  currentEntryBox.setNumberPadValue(typeof subId === 'string' ? subId.toLowerCase() : subId);
                } else {
                  if (subId.length === 1 && isNaN(subId) && subId !== 'ß') {
                    currentEntryBox.setNumberPadValue(typeof subId === 'string' ? subId.toUpperCase() : subId);
                  } else {
                    currentEntryBox.setNumberPadValue(subId);
                  }
                }

                break;
            }
          }

          break;
        }

      default:
        break;
    }

    updateStage();
  }

  function changeCase() {
    var upper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    padkeys.forEach(function (keys, i) {
      keys.forEach(function (key, j) {
        if (key.toString().length === 1 && isNaN(key) && key !== 'ß') {
          padkeys[i][j] = upper ? padkeys[i][j].toUpperCase() : padkeys[i][j].toLowerCase();
        }
      });
    });
    calculateKeyBounds();
  }

  function toggleEntryBoxEvents(interactive) {
    Object.keys(entryBoxObj).forEach(function (entryBoxCompId) {
      var entryBox = entryBoxObj[entryBoxCompId];

      if (interactive) {
        entryBox.on('focusIn', onFocusIn);
        entryBox.on('focusOut', onFocusOut);
      } else {
        entryBox.off('focusIn', onFocusIn);
        entryBox.off('focusOut', onFocusOut);
      }
    });
  }

  function onFocusIn(e) {
    currentEntryBox = entryBoxObj[e.id];
    self.show = true;
  }

  function onFocusOut(e) {
    currentEntryBox = null;
    self.show = false;
  }

  function updateStage() {
    onViewUpdateCls.trigger('onGlobalUpdate', {
      type: 'updateView'
    });
  }

  init();
}
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function All_MathClass(_obj) {
  var modelObj = {
    data: {},
    variants: [//S1
    [{
      type: 'point',
      x: 0,
      y: 0,
      label: 'A',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false,
      variant: 1,
      aVal: 7,
      bVal: 3,
      ans: 0
    }, {
      type: 'point',
      x: 7,
      y: 0,
      label: 'B',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 7,
      y: 3,
      label: 'C',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 0,
      y: 3,
      label: 'D',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false
    }], //S2
    [{
      type: 'point',
      x: 0,
      y: 0,
      label: 'A',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false,
      variant: 2,
      aVal: 3,
      bVal: 3,
      ans: 1
    }, {
      type: 'point',
      x: 3,
      y: 0,
      label: 'B',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 3,
      y: 3,
      label: 'C',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 0,
      y: 3,
      label: 'D',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false
    }], //S3
    [{
      type: 'point',
      x: 0,
      y: 0,
      label: 'A',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false,
      variant: 3,
      aVal: 14,
      bVal: 3,
      ans: 0
    }, {
      type: 'point',
      x: 14,
      y: 0,
      label: 'B',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 14,
      y: 3,
      label: 'C',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 0,
      y: 3,
      label: 'D',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false
    }], //S4
    [{
      type: 'point',
      x: 0,
      y: 0,
      label: 'A',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false,
      variant: 4,
      aVal: 4,
      bVal: 12,
      ans: 0
    }, {
      type: 'point',
      x: 4,
      y: 0,
      label: 'B',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 4,
      y: 12,
      label: 'C',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 0,
      y: 12,
      label: 'D',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false
    }], //S5
    [{
      type: 'point',
      x: 0,
      y: 0,
      label: 'A',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false,
      variant: 5,
      aVal: 13,
      bVal: 12,
      ans: 0
    }, {
      type: 'point',
      x: 13,
      y: 0,
      label: 'B',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 13,
      y: 12,
      label: 'C',
      isDraggable: false,
      isDeletable: false
    }, {
      type: 'point',
      x: 0,
      y: 12,
      label: 'D',
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: false,
      isDeletable: false
    }]],
    planVariant: [[{
      type: 'point',
      x: 0,
      y: 0,
      label: 'A',
      labelDiffX: -22,
      labelDiffY: -9,
      pointRev: 'C',
      pointFix: [2, 4],
      connectedPoints: 3,
      isDraggable: true,
      isDeletable: false
    }, {
      type: 'point',
      x: 7,
      y: 0,
      label: 'B',
      pointFix: [1, 4],
      connectedPoints: 3,
      pointRev: 'D',
      labelDiffX: 14,
      labelDiffY: -9,
      isDraggable: true,
      isDeletable: false
    }, {
      type: 'point',
      x: 9,
      y: 4,
      label: 'C',
      pointRev: 'A',
      pointFix: [2, 4],
      connectedPoints: 1,
      pointIncline: Math.PI / 4,
      isDraggable: true,
      isDeletable: false
    }, {
      type: 'point',
      x: 2,
      y: 4,
      label: 'D',
      pointRev: 'B',
      pointFix: [1, 2],
      connectedPoints: 3,
      pointIncline: Math.PI / 4,
      labelDiffX: -22,
      labelDiffY: -9,
      isDraggable: true,
      isDeletable: false
    }, {
      type: 'segment',
      x: 0,
      y: 0,
      xTo: 7,
      yTo: 0,
      label: 'a',
      labelDiffX: -5,
      labelDiffY: 8,
      firstPointId: 1,
      secondPointId: 2,
      isDraggable: true,
      isDeletable: false
    }, {
      type: 'segment',
      x: 7,
      y: 0,
      xTo: 9,
      yTo: 4,
      label: 'b',
      labelDiffX: 4,
      labelDiffY: 7,
      firstPointId: 2,
      secondPointId: 3,
      isDraggable: true,
      isDeletable: false
    }, {
      type: 'segment',
      x: 9,
      y: 4,
      xTo: 2,
      yTo: 4,
      label: 'c',
      labelDiffX: 0,
      labelDiffY: -10,
      firstPointId: 3,
      secondPointId: 4,
      isDraggable: true,
      isDeletable: false
    }, {
      type: 'segment',
      x: 2,
      y: 4,
      xTo: 0,
      yTo: 0,
      label: 'd',
      labelDiffX: -14,
      labelDiffY: -8,
      firstPointId: 4,
      secondPointId: 1,
      isDraggable: true,
      isDeletable: false
    }]],
    currentVariant: null
  };
  var MathObj;
  var defaultQuestions = [];

  this.setMathObj = function (_MathObj) {
    MathObj = _MathObj;
  }; // --------------------


  var events = {}; // --------------------

  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  }); // --------------------
  // --------------------

  onViewUpdateCls.trigger('onGlobalUpdate', {
    type: 'componentLoaded',
    data: {
      id: modelObj.id
    }
  }); // =================================================
  // PUBLIC SECTION
  // =================================================

  this.populateDefaultQuestions = function () {
    var _this = this;

    var data = [// S1
    {
      pointA: {
        x: 0,
        y: 0,
        label: 'A',
        type: 'point'
      },
      a: 10,
      b: 7,
      angle: 115,
      degree: 115,
      angleOver: 'B',
      angClockWise: true,
      situation: 1,
      variant: 1,
      r: 7,
      given: ['a', 'b', 'beta'],
      pointToCheckStep3: 'C',
      segmentToCheckStep4: 'BC',
      pointToCheckForOverlap: 'B',
      pointsToValidate: [{
        0: 'DC'
      }, {
        1: 'AD'
      }]
    }, // S2
    {
      pointA: {
        x: 0,
        y: 0,
        label: 'A',
        type: 'point'
      },
      a: 3,
      b: 6,
      angle: 153,
      degree: 153,
      angleOver: 'B',
      angClockWise: true,
      situation: 1,
      variant: 2,
      r: 6,
      given: ['a', 'b', 'beta'],
      pointToCheckStep3: 'C',
      segmentToCheckStep4: 'BC',
      pointToCheckForOverlap: 'B',
      pointsToValidate: [{
        0: 'DC'
      }, {
        1: 'AD'
      }]
    }, // S3
    {
      pointA: {
        x: 0,
        y: 0,
        label: 'A',
        type: 'point'
      },
      a: 10,
      b: 10,
      angle: 105,
      degree: 105,
      angleOver: 'A',
      angClockWise: false,
      situation: 2,
      variant: 3,
      r: 10,
      given: ['a', 'b', 'alpha'],
      pointToCheckStep3: 'D',
      segmentToCheckStep4: 'AD',
      pointToCheckForOverlap: 'A',
      pointsToValidate: [{
        0: 'DC'
      }, {
        1: 'BC'
      }]
    }, // S4
    {
      pointA: {
        x: 0,
        y: 0,
        label: 'A',
        type: 'point'
      },
      a: 12,
      b: 3,
      angle: 37,
      degree: 37,
      angleOver: 'A',
      angClockWise: false,
      situation: 2,
      variant: 4,
      r: 3,
      given: ['a', 'b', 'alpha'],
      pointToCheckStep3: 'D',
      segmentToCheckStep4: 'AD',
      pointToCheckForOverlap: 'A',
      pointsToValidate: [{
        0: 'DC'
      }, {
        1: 'BC'
      }]
    }, // S5
    {
      pointA: {
        x: 0,
        y: 0,
        label: 'A',
        type: 'point'
      },
      a: 9,
      b: 6,
      angle: 120,
      degree: 120,
      angleOver: 'B',
      angClockWise: true,
      situation: 3,
      variant: 5,
      r: 6,
      given: ['a', 'b', 'gama'],
      pointToCheckStep3: 'C',
      segmentToCheckStep4: 'BC',
      pointToCheckForOverlap: 'B',
      pointsToValidate: [{
        0: 'DC'
      }, {
        1: 'AD'
      }]
    }];
    data.forEach(function (el) {
      defaultQuestions.push(getAngleQuestion.call(_this, el, false));
    });
  };

  this.getPointAtAngle = function (p1, p2, r, angle) {
    var clockwise = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    // if(angle>90){
    //   angle=-angle;
    // }
    var angle2Points = spineObj.LabComClass.Maths.getAngle(p1.x, p1.y, p2.x, p2.y);
    var newPoint = MathObj.getPoint(p1, angle2Points + angle * Math.PI / 180, r);
    return newPoint;
  };

  function getAngleQuestion(data) {
    var clockwise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (data.situation === 1 || data.situation === 3) {
      var pointA = data.pointA,
          a = data.a,
          b = data.b,
          angle = data.angle;
      var pointB = {};
      pointB.x = pointA.x + a;
      pointB.y = pointA.y;
      pointB.label = 'B';
      var pointC = this.getPointAtAngle(_objectSpread({}, pointB), _objectSpread({}, pointA), b, -angle, true);
      pointC.label = 'C';
      var pointD = this.getPointAtAngle(_objectSpread({}, pointA), _objectSpread({}, pointB), b, 180 - angle, false);
      pointD.label = 'D';
      return _objectSpread(_objectSpread({}, data), {}, {
        pointB: pointB,
        pointC: pointC,
        pointD: pointD,
        clockwise: clockwise
      });
    } else if (data.situation === 2) {
      var _pointA = data.pointA,
          _a = data.a,
          _b = data.b,
          _angle = data.angle;
      var _pointB = {};
      _pointB.x = _pointA.x + _a;
      _pointB.y = _pointA.y;
      _pointB.label = 'B';

      var _pointC = this.getPointAtAngle(_objectSpread({}, _pointB), _objectSpread({}, _pointA), _b, -(180 - _angle), clockwise);

      _pointC.label = 'C';

      var _pointD = this.getPointAtAngle(_objectSpread({}, _pointA), _objectSpread({}, _pointB), _b, _angle, clockwise);

      _pointD.label = 'D';
      return _objectSpread(_objectSpread({}, data), {}, {
        pointB: _pointB,
        pointC: _pointC,
        pointD: _pointD,
        clockwise: clockwise
      });
    }
  }

  this.alterCurrentQuestion = function (p1, p2, question) {
    if (question.situation === 1 || question.situation === 3) {
      var pointA = question.pointA,
          a = question.a,
          b = question.b,
          angle = question.angle;
      var pointC = this.getPointAtAngle(_objectSpread({}, p2), _objectSpread({}, p1), b, -angle, true);
      pointC.label = 'C';
      var pointD = this.getPointAtAngle(_objectSpread({}, p1), _objectSpread({}, p2), b, 180 - angle, false);
      pointD.label = 'D';
      delete question.pointC;
      delete question.pointD;
      delete question.pointB;
      question.pointB = p2;
      return _objectSpread(_objectSpread({}, question), {}, {
        pointC: pointC,
        pointD: pointD
      });
    } else if (question.situation === 2) {
      var _pointA2 = question.pointA,
          _a2 = question.a,
          _b2 = question.b,
          _angle2 = question.angle;

      var _pointC2 = this.getPointAtAngle(_objectSpread({}, p2), _objectSpread({}, p1), _b2, -(180 - _angle2), false);

      _pointC2.label = 'C';

      var _pointD2 = this.getPointAtAngle(_objectSpread({}, p1), _objectSpread({}, p2), _b2, _angle2, false);

      _pointD2.label = 'D'; // console.log('C',pointC,pointD);

      delete question.pointC;
      delete question.pointD;
      delete question.pointB;
      question.pointB = p2;
      return _objectSpread(_objectSpread({}, question), {}, {
        pointC: _pointC2,
        pointD: _pointD2
      });
    }
  };

  var randomArr = [];

  while (randomArr.length < 5) {
    var r = Math.floor(Math.random() * 10);
    if (r >= 0 && r <= 4 && randomArr.indexOf(r) === -1) randomArr.push(r);
  }

  this.getQuestion = function (index) {
    // console.log(defaultQuestions);
    // console.log(defaultQuestions,randomArr[index]);
    return defaultQuestions[index]; // return defaultQuestions[randomArr[index]];
  };

  this.getOrders = function () {
    return ['AB', 'BC', 'CD', 'DA'];
  };

  this.getOrder = function (question) {
    var order;

    switch (question.situation) {
      case 1:
      case 3:
        order = ['CD', 'DA'];
        break;

      case 2:
        order = ['BC', 'CD'];
        break;
    }

    return order;
  };

  this.getNumberOfVariants = function () {
    return modelObj.variants.length;
  };

  this.generateQuestion = function (num) {
    modelObj.currentVariant = modelObj.variants[num % modelObj.variants.length][0].variant;
    return modelObj.variants[num % modelObj.variants.length];
  };

  this.generateQuestionS = function (num) {
    modelObj.currentVariant = modelObj.variants[randomArr[num]][0].variant;
    return modelObj.variants[randomArr[num]];
  };

  this.generatePlanData = function (num) {
    // modelObj.currentVariant = modelObj.variants[randomArr[num]][0].variant;
    return modelObj.planVariant[randomArr[num] * 0];
  };

  this.calculation = function (val1, val2, val3, val4) {
    return Number(val1) + Number(val2) + Number(val3) + Number(val4);
  };

  this.getCurrentShape = function (n) {
    return modelObj.shapes[n];
  }; //  Returns distance between given points


  function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  } // ================================================================================
  //  Returns angle between given points with optional parameter isRad.


  function getAngle(_x1, _y1, _x2, _y2) {
    return Math.atan2(_y2 - _y1, _x2 - _x1);
  } // ================================================================================
  //  return Point Object with given angle and radius


  function getPoint(p, angle, rad) {
    var temp = {};
    temp.x = parseFloat((p.x + rad * Math.cos(angle)).toFixed(5));
    temp.y = parseFloat((p.y + rad * Math.sin(angle)).toFixed(5));
    return temp;
  } // This function return Point C or D by passing point A, Point B and variable C or D
  // eslint-disable-next-line consistent-return


  function getPointDC(a, b, point) {
    var distance = getDistance(a, b);
    var angle = getAngle(a.x, a.y, b.x, b.y);

    if (point === 'C') {
      return getPoint(b, Math.PI / 2 + angle, distance);
    }

    if (point === 'D') {
      return getPoint(a, Math.PI / 2 + angle, distance);
    }
  } // console.log(modelObj.variants[2]);
  // =================================================


  this.addEventListener = function (_evt, _func) {
    events[_evt] = _func;
  };
}
/*
//S1
[
  {
    type: 'point',
    x: 1,
    y: 1,
    label: 'A',
    labelDiffX:-22,
    labelDiffY:-9,
    isDraggable: false,
    isDeletable: false,
    variant:1,
    aVal:7,
    bVal:3,
    ans:0,
  },
  {
    type: 'point',
    x: 8,
    y: 1,
    label: 'B',
    isDraggable: false,
    isDeletable: false,
  },
  {
    type: 'point',
    x: 8,
    y: 4,
    label: 'C',
    isDraggable: false,
    isDeletable: false,
  },
  
  {
    type: 'point',
    x: 1,
    y: 4,
    label: 'D',
    labelDiffX:-22,
    labelDiffY:-9,
    isDraggable: false,
    isDeletable: false,
  },
],*/

/**
 * const data = {
        pointA: { x: 0, y: 0, label: 'A', type: 'point' },
        side: 7,
        angle: 70,
        degree: 70, 
        angleOver: 'A',
        angClockWise: false,
        situation:1,
        variant:1,
        given:['a','alpha'],
        pointToCheckStep3: 'D',
        segmentToCheckStep3:'AD',
        pointsToValidate:[{0:'D'},{1:'BC'}],
    };
    // const data = {
    //   pointA: { x: 0, y: 0, label: 'A', type: 'point' },
    //   side: 5,
    //   angle: 80,
    //   degree: 100,
    //   angleOver: 'B',
    //   angClockWise: true,
    //   situation:1,
    //   variant:2,
    //   given:['a','beta'],
    //   pointToCheckStep3: 'C',
    //   segmentToCheckStep3:'BC',
    //   pointsToValidate:[{0:'C'},{1:'AD'}],   
    // };
    // const data = {
    //     pointA: { x: 0, y: 0, label: 'A', type: 'point' },
    //     side: 4,
    //     angle: 90,
    //     degree: 90,
    //     angleOver: 'A',
    //     angClockWise: false,
    //     situation:1,
    //     variant:3,
    //     given:['a','alpha'],
    //     pointToCheckStep3: 'D',
    //     segmentToCheckStep3:'AD',
    //     pointsToValidate:[{0:'D'},{1:'BC'}],
    // };
      // const data = {
      //   pointA: { x: 0, y: 0, label: 'A', type: 'point' },
      //   side: 5,
      //   dVal: 8,
      //   angle: 73.7398,
      //   angleOver: 'A',
      //   angClockWise: false,
      //   situation:2,
      //   variant:4,
      //   c1:'A',
      //   c2:'B',
      //   diagnol: 'AC',
      //   given:['a','e'],
      //   pointToCheckStep2: 'C',
      //   pointToCheckStep3: 'D',
      //   //215
      // };
    // const data = {
    //   pointA: { x: 0, y: 0, label: 'A', type: 'point' },
    //   side: 6,
    //   BD: 9,
    //   dVal:9,
    //   angle: 97.1129,
    //   angleOver: 'A',
    //   angClockWise: false,
    //   situation:2,
    //   variant:5,
    //   c1:'B',
    //   c2:'A',
    //   diagnol: 'BD',
    //   given:['a','f'],
    //   pointToCheckStep2: 'D',
    //   pointToCheckStep3: 'C',
    // };
 */
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable react/no-this-in-sfc */
function PlayerClass() {
  // ===================================================================================
  function ModelClass() {
    var thisObj = this;
    var hasOProp = Object.prototype.hasOwnProperty;
    this.cPropObj = {}; // controller prop

    this.vPropObj = {}; // view prop

    this.sildePropObj = {}; // slide property
    // ----------------------------

    onModelUpdateCls.on('setCProp', onSetCProp);
    onModelUpdateCls.on('setVProp', onSetVProp);
    onModelUpdateCls.on('setSlideProp', onSetSlideProp); // ----------------------------

    LabComClass.defineObject(this.cPropObj, 'playerPath', ''); // path to the player

    LabComClass.defineObject(this.cPropObj, 'playerConfigObj', {}); // html dom wrapper to append stage

    LabComClass.defineObject(this.cPropObj, 'globalTextObj', {}); // html dom wrapper to append stage

    LabComClass.defineObject(this.cPropObj, 'configObj', {}); // config to launch leeson character names

    LabComClass.defineObject(this.cPropObj, 'deviceTypeBool', false); // Is player running on devices.

    LabComClass.defineObject(this.cPropObj, 'audioContextCls', new AudioContextClass()); // Global BGs for lesson holder.

    LabComClass.defineObject(this.cPropObj, 'audioNativeCls', new AudioNativeClass()); // Global BGs for lesson holder.

    LabComClass.defineObject(this.cPropObj, 'mouseHandleCls', new MouseHandlerClass()); // Global BGs for lesson holder.

    LabComClass.defineObject(this.cPropObj, 'keyHandlerCls', new KeyHandlerClass()); // Navigation.

    LabComClass.defineObject(this.cPropObj, 'labObj', {}); // Gizmo Structure.

    LabComClass.defineObject(this.cPropObj, 'compListObj', {}); // All global component list.

    LabComClass.defineObject(this.cPropObj, 'brainObj', {}); // Brain component.

    LabComClass.defineObject(this.cPropObj, 'compCountInt', 0); // All global component list.

    LabComClass.defineObject(this.cPropObj, 'totalCompCountInt', 0); // All global component list.

    LabComClass.defineObject(this.cPropObj, 'activityObj', {}); // All global component list.

    LabComClass.defineObject(this.cPropObj, 'interactiveLayerArr', []); // All interactive elements with layer.

    LabComClass.defineObject(this.cPropObj, 'toolsUsed', []); // ----------------------------

    LabComClass.defineObject(this.vPropObj, 'domLayerObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'headerObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'headerLogoItemObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'headerLogoObj', document.createElement('img'));
    LabComClass.defineObject(this.vPropObj, 'headerTextObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'headerHelpObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'headerHelpIconObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'headerCopyRightObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'infoPopupObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'headerCopyRightIconObj', document.createElement('div'));
    LabComClass.defineObject(this.vPropObj, 'preloadObj', document.createElement('div')); // Div to show Pre-loader

    LabComClass.defineObject(this.vPropObj, 'bgCanvasObj', document.createElement('canvas')); // Canvas to show the background

    LabComClass.defineObject(this.vPropObj, 'bgContextObj', {}); // Context to show the background

    LabComClass.defineObject(this.vPropObj, 'contCanvasObj', document.createElement('canvas')); // Canvas to show the content

    LabComClass.defineObject(this.vPropObj, 'virtualCanvasObj', document.createElement('canvas')); // Virtual Canvas to calculate the content

    LabComClass.defineObject(this.vPropObj, 'contContextObj', {}); // Context to show the content

    LabComClass.defineObject(this.vPropObj, 'mouseCanvasObj', document.createElement('canvas')); // Canvas for buttons

    LabComClass.defineObject(this.vPropObj, 'mTextWrapperObj', document.createElement('canvas')); // Canvas

    LabComClass.defineObject(this.vPropObj, 'snapshotCnvObj', document.createElement('canvas')); // Canvas

    LabComClass.defineObject(this.vPropObj, 'playerImagesObj', {}); // Canvas

    LabComClass.defineObject(this.vPropObj, 'componentImagesObj', {}); // Canvas

    LabComClass.defineObject(this.vPropObj, 'resizeTimeoutObj', {}); // wait for resize.

    LabComClass.defineObject(this.vPropObj, 'scaledDataObj', {}); // Scale resize value

    LabComClass.defineObject(this.vPropObj, 'bgImageObj', {}); // Scale resize value
    // ----------------------------
    // Setter and getter for controller properties

    function onSetCProp(_dataObj, _typeStr) {
      updateProp(_dataObj, _typeStr, 'cPropObj');
    } // ----------------------------
    // Setter and getter for view properties


    function onSetVProp(_dataObj, _typeStr) {
      updateProp(_dataObj, _typeStr, 'vPropObj');
    } // ----------------------------
    // Setter and getter for slide properties


    function onSetSlideProp(_dataObj, _typeStr) {
      updateProp(_dataObj, _typeStr, 'sildePropObj');
    } // ----------------------------
    // Add/Update properties.


    function updateProp(_dataObj, _typeStr, _varRef) {
      var _tempArr = []; // Whatever properties got updated, the names will be transferred to the event.

      Object.keys(_dataObj).forEach(function (i) {
        if (hasOProp.call(thisObj[_varRef], i)) {
          _tempArr.push(i);

          LabComClass.defineObject(thisObj[_varRef], i, _dataObj[i]);
        } else {
          console.log(i + ': property doesnt exist in Model ' + _varRef + '.');
        }
      });
      onModelUpdateCls.trigger('onChange', {
        type: _typeStr,
        propList: _tempArr
      }); // Change function for any controller property update
    }
  } // ===================================================================================
  // VIEW CLASS
  // ===================================================================================


  function ViewClass() {
    var vPropObj = {};
    var hasOProp = Object.prototype.hasOwnProperty; // ---------------------------------

    function init() {} // ---------------------------------


    function onChange(_dataObj) {
      switch (_dataObj.type) {
        case 'onPlayerConfigLoad':
          createDropDowntMenu('Help');
          createDropDowntMenu('CopyRight');
          createPopup();
          break;

        case 'onActivityInited':
          modelCls.cPropObj.mouseHandleCls.updateInteractiveLayer(modelCls.cPropObj.interactiveLayerArr);
          drawBg();
          document.body.removeChild(modelCls.vPropObj.preloadObj);
          break;

        case 'mouseEventAdded':
          break;

        case 'onScaleSet':
          document.addEventListener('contextmenu', function (event) {
            return event.preventDefault();
          }); // to disable rigth click

          modelCls.cPropObj.mouseHandleCls.init({
            deviceTypeBool: modelCls.cPropObj.deviceTypeBool,
            mouseCanvasObj: modelCls.vPropObj.mouseCanvasObj
          });
          modelCls.cPropObj.mouseHandleCls.updateOnResize(modelCls.vPropObj.scaledDataObj);
          break;

        default:
          break;
      }
    } // ---------------------------------
    // ---------------------------------


    function onGlobalUpdate(_dataObj) {
      switch (_dataObj.type) {
        case 'addMouseEvent':
          modelCls.cPropObj.mouseHandleCls.addMouseEvent(_dataObj.data);
          break;

        case 'addKeyEvent':
          modelCls.cPropObj.keyHandlerCls.addKeyEvents(_dataObj.data);
          break;

        case 'removeMouseEvent':
          modelCls.cPropObj.mouseHandleCls.removeMouseEvent(_dataObj.data);
          break;

        case 'removeKeyEvent':
          modelCls.cPropObj.keyHandlerCls.removeKeyEvents(_dataObj.data);
          break;

        case 'rendererUpdate':
          requestAnimationFrame(drawFn);
          break;

        case 'onNavStageResize':
          drawBg();
          drawFn();
          break;

        default:
          break;
      }
    } // ---------------------------------


    function createDropDowntMenu(buttonType) {
      var button = modelCls.vPropObj["header".concat(buttonType, "Obj")];
      var globalTextObj = modelCls.cPropObj.globalTextObj;
      var dataKey = "".concat(buttonType[0].toLowerCase() + buttonType.slice(1), "Data");
      var menuItems = Object.keys(globalTextObj[dataKey]);
      var menuHolder = document.createElement('div');
      menuHolder.setAttribute('class', 'menuHolder');
      button.appendChild(menuHolder);
      button.menuHolder = menuHolder;
      menuItems.forEach(function (item) {
        var menuItem = document.createElement('div');
        menuItem.innerHTML = item;
        menuItem.setAttribute('class', 'menuItem');
        menuHolder.appendChild(menuItem);
        menuItem.addEventListener('click', function (e) {
          return openPopup(e, item, dataKey);
        });
      });
      button.addEventListener('click', function () {
        return openMenu(button);
      });

      if (!LabComClass.BrowserDetect.isDevice()) {
        button.addEventListener('mouseenter', function () {
          return button.classList.add('hover');
        });
        button.addEventListener('mouseleave', function () {
          return button.classList.remove('hover');
        });
      }
    }

    function createPopup() {
      var infoPopupObj = modelCls.vPropObj.infoPopupObj;
      var popupOverlay = document.createElement('div');
      popupOverlay.setAttribute('class', 'popupOverlay');
      infoPopupObj.appendChild(popupOverlay);
      var popupHolder = document.createElement('div');
      popupHolder.setAttribute('class', 'popupHolder');
      infoPopupObj.appendChild(popupHolder);
      var popupTile = document.createElement('div');
      popupTile.setAttribute('class', 'popupTitle');
      popupHolder.appendChild(popupTile);
      var titleText = document.createElement('div');
      titleText.innerHTML = 'title';
      popupTile.appendChild(titleText);
      infoPopupObj.titleDiv = titleText;
      var closeButton = document.createElement('div');
      closeButton.innerHTML = 'X';
      popupTile.appendChild(closeButton);
      var popupContent = document.createElement('div');
      popupContent.setAttribute('class', 'popupContent');
      popupHolder.appendChild(popupContent);
      infoPopupObj.contentDiv = popupContent;
      closeButton.addEventListener('click', closePopup);
      popupOverlay.addEventListener('click', closePopup);
    }

    function openMenu(button) {
      var buttonSelected = document.querySelector('.headerButton.selected');
      closeMenu();

      if (button !== buttonSelected) {
        button.classList.add('selected');
        button.menuHolder.classList.add('show');
        onViewUpdateCls.trigger('onGlobalUpdate', {
          type: 'menuOpened',
          data: {}
        });
      }
    }

    function closeMenu() {
      var button = document.querySelector('.headerButton.selected');

      if (!button) {
        return;
      }

      button.classList.remove('selected');
      button.menuHolder.classList.remove('show');
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'menuClosed',
        data: {}
      });
    }

    function openPopup(e, title, contentKey) {
      closeMenu();
      e.stopPropagation();
      modelCls.vPropObj.infoPopupObj.classList.add('show');
      modelCls.cPropObj.mouseHandleCls.toggleMouseEvents(false);
      modelCls.vPropObj.infoPopupObj.contentDiv.scrollTop = 0;
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'popupOpened',
        data: {
          title: title,
          contentKey: contentKey
        }
      });
    }

    function closePopup() {
      modelCls.vPropObj.infoPopupObj.classList.remove('show');
      modelCls.cPropObj.mouseHandleCls.toggleMouseEvents(true);
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'popupClosed',
        data: {}
      });
    } // ---------------------------------


    function drawFn() {
      var _contCnvObj = modelCls.vPropObj.contCanvasObj;
      var _contCtxObj = modelCls.vPropObj.contContextObj;
      var _scaledDataObj = modelCls.vPropObj.scaledDataObj; // ---------------------

      _contCtxObj.clearRect(0, 0, _contCnvObj.width, _contCnvObj.height);

      _contCtxObj.save();

      _contCtxObj.scale(_scaledDataObj.scale * _scaledDataObj.devScaleRatioInt, _scaledDataObj.scale * _scaledDataObj.devScaleRatioInt); // modelCls.cPropObj.activityObj.draw();
      // ---------------------


      var _compListObj = modelCls.cPropObj.compListObj;
      Object.keys(_compListObj).forEach(function (i) {
        if (_compListObj[i].obj.draw) {
          _compListObj[i].obj.draw();
        }
      });

      _contCtxObj.restore();
    } // ---------------------------------


    function drawBg() {
      var _bgCnvObj = modelCls.vPropObj.bgCanvasObj;
      var _bgCtxObj = modelCls.vPropObj.bgContextObj; // ---------------------

      _bgCtxObj.clearRect(0, 0, _bgCnvObj.width, _bgCnvObj.height);

      _bgCtxObj.drawImage(modelCls.vPropObj.bgImageObj, 0, 0, _bgCnvObj.width, _bgCnvObj.height);
    } // ---------------------------------
    // ---------------------------------


    onModelUpdateCls.on('onChange', onChange); // ----------------------------
    // onViewUpdateCls.on('updateView', onUpdateView);
    // onViewUpdateCls.on('getImageSlide', onGetImageSlide);

    onViewUpdateCls.on('onGlobalUpdate', onGlobalUpdate); // ---------------------------------
    // ---------------------------------
  } // ===================================================================================


  function ControllerClass() {
    var hasOProp = Object.prototype.hasOwnProperty; // ----------------------------

    function init() {
      loadGlobalText();
      modelCls.cPropObj.keyHandlerCls.init(); // =====================================================

      var inputFieldDummyDiv = document.createElement('div');
      inputFieldDummyDiv.setAttribute('id', 'inputFieldDummyDiv');
      inputFieldDummyDiv.setAttribute('contenteditable', true);
      inputFieldDummyDiv.style.position = 'absolute';
      inputFieldDummyDiv.style.width = '0px';
      inputFieldDummyDiv.style.height = '0px';
      inputFieldDummyDiv.style.top = '-100px';
      inputFieldDummyDiv.style.left = '-100px';
      inputFieldDummyDiv.addEventListener('keydown', function () {
        this.innerHTML = '';
      });
      document.body.appendChild(inputFieldDummyDiv);
    } // ---------------------------------
    // ---------------------------------


    function onChange(_dataObj) {
      // console.log('Controller onChange', _dataObj.type);
      switch (_dataObj.type) {
        case 'onGlobalTextLoad':
          setUpPlayer();
          break;

        case 'onPlayerConfigLoad':
          LabComClass.childPreloadProgress(30); // Set browser and platform type

          if (LabComClass.BrowserDetect.isDevice()) {
            onModelUpdateCls.trigger('setCProp', {
              deviceTypeBool: true
            }, 'onDeviceSelected');
          } else {
            onModelUpdateCls.trigger('setCProp', {
              deviceTypeBool: false
            }, 'onDeviceSelected');
          }

          break;

        case 'onDeviceSelected':
          setPlayerScale();
          break;

        case 'onScaleSet':
          // Load lesson structure file
          LabComClass.childPreloadProgress(48);
          var toolsUsedArr,
              toolArray = [],
              toolArrayNoDuplicate;
          httpRequest('labstructure.json', 'json', function (_httpData) {
            onModelUpdateCls.trigger('setCProp', _httpData, 'onLessonStructureLoad'); // toolsUsedArr = _httpData.labObj.components.filter(el=>(el.ref === 'ToolPanelCompClass'))[0].initdata.buttons; // Extracting Tools Object from Geo Tools.
            // toolArrayNoDuplicate = Object.keys(toolsUsedArr).filter(tool => toolsUsedArr[tool].visible); // Extracting only visible tools.
            // let count = 0; // If more than one brush only single brush is shown.
            // toolArrayNoDuplicate.forEach((el,i) => {
            //   if(el.includes('brush')) {
            //     if(count === 0){
            //       toolArray.push(el);
            //       count++;
            //     }
            //   }
            //   else {
            //     toolArray.push(el);
            //   }
            // });
            // onModelUpdateCls.trigger('setCProp', {toolsUsed:toolArray}, 'toolsUsed');
          });
          break;

        case 'onLessonStructureLoad':
          httpRequest(modelCls.cPropObj.labObj.lang + '/labtext.json', 'json', function (_httpData) {
            LabComClass.globalLangText = _httpData;

            try {
              LabComClass.urlParams = JSON.parse('{"' + location.search.substring(1).replace(/&/g, '","').replace(/=/g, '":"') + '"}');
            } catch (e) {
              LabComClass.urlParams = {};
            }

            LabComClass.klettFontRegular = modelCls.cPropObj.playerConfigObj['klettFontRegular-' + modelCls.cPropObj.labObj.lang]; // This concatenation is done to support various languauges with their respective font variation.

            LabComClass.polo22KlettRegular = modelCls.cPropObj.playerConfigObj['polo22KlettRegular-' + modelCls.cPropObj.labObj.lang]; // This concatenation is done to support various languauges with their respective font variation.

            LabComClass.bold = modelCls.cPropObj.playerConfigObj.bold;
            LabComClass.italic = modelCls.cPropObj.playerConfigObj.italic;
            LabComClass.italicbold = modelCls.cPropObj.playerConfigObj.italicbold;
            LabComClass.italicDistance = modelCls.cPropObj.playerConfigObj.italicDistance;
            LabComClass.subscript = modelCls.cPropObj.playerConfigObj.subscript;
            LabComClass.superscript = modelCls.cPropObj.playerConfigObj.superscript;
            LabComClass.end = modelCls.cPropObj.playerConfigObj.end;
            LabComClass.requestLocalImage(['background.png'], function (_bgObj) {
              onModelUpdateCls.trigger('setVProp', {
                bgImageObj: _bgObj['background.png']
              }, 'onLocaliseTextLoad');
            });
          });
          break;

        case 'onLocaliseTextLoad':
          // Load BGs
          LabComClass.childPreloadProgress(60);
          loadSFXAudio();
          break;

        case 'onSFXLoad':
          createCompList();
          break;

        case 'onCompListAdd':
          sendInstanceToAct();
          break;

        case 'onActivityInited':
          break;

        default:
          break;
      }
    } // ----------------------
    // ----------------------


    function onGlobalUpdate(_dataObj) {
      // console.log('Controller onGlobalUpdate', _dataObj.type);
      switch (_dataObj.type) {
        case 'onCheckForSubway':
          break;

        case 'componentLoaded':
          allCompLoaded(_dataObj.data);
          break;

        case 'playSFX':
          modelCls.cPropObj.audioContextCls.sfxObj.play(_dataObj.data);
          break;

        case 'popupOpened':
          updatePopupContent(_dataObj.data);
          break;

        default:
          break;
      }
    } // ===================================================================================


    function setUpPlayer() {
      LabComClass.localImagePath = 'assets/images/';
      LabComClass.globalImagePath = 'assets/images/'; // var _obj = JSON.parse('{"' + location.search.substring(1).replace(/&/g, '","').replace(/=/g, '":"') + '"}');
      // console.log('setUpPlayer', _obj);

      httpRequest(modelCls.cPropObj.playerPath + 'playerconfig.json', 'json', function (_dataObj) {
        LabComClass.childPreloadProgress(18);
        onModelUpdateCls.trigger('setCProp', _dataObj, 'onPlayerConfigLoad');
      });
    }

    function loadGlobalText() {
      httpRequest(modelCls.cPropObj.playerPath + 'globalTextV2.js', 'js', function (_dataObj) {
        var globalText;
        eval(_dataObj);
        onModelUpdateCls.trigger('setCProp', {
          globalTextObj: globalText
        }, 'onGlobalTextLoad');
      });
    } // ===================================================================================
    // Common function for loading JSON, JS
    // ===================================================================================


    function httpRequest(_urlStr, _typeStr, _callBackFn, _errorCallBackFn, _cnt) {
      var cnt = 1;
      var maxRetries = 3;

      if (typeof _cnt !== 'undefined') {
        cnt = _cnt;
      }

      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (_callBackFn) {
            if (_typeStr.toLowerCase() === 'json') {
              _callBackFn(JSON.parse(this.responseText));
            } else {
              _callBackFn(this.responseText);
            }
          }
        }
      };

      xhttp.open('GET', _urlStr, true);
      xhttp.send();
    } // ===================================================================================


    function setPlayerScale() {
      // Following timeout is given to keep some buffer for device calculation because on android app activity looks in double size because stage not rendered fully. This condition is applied only for devices.
      var _time = 0;

      if (modelCls.cPropObj.deviceTypeBool) {
        _time = 1500;
      }

      setTimeout(function () {
        window.onresize = function () {
          setStageSize();
        };

        setStageSize(true);
      }, _time);
    } // ===================================================================================


    function setStageSize(_bool) {
      clearTimeout(modelCls.vPropObj.resizeTimeoutObj);

      var _resizeTimeoutObj = setTimeout(function () {
        var _retStr = '';

        var _scaleVal = calculateScaleVal({
          w: modelCls.cPropObj.playerConfigObj.baseWidth,
          h: modelCls.cPropObj.playerConfigObj.baseHeight
        });

        _scaleVal.devScaleRatioInt = calculateDevicePixelRatio(modelCls.vPropObj.contCanvasObj);

        var _trace = _scaleVal.w + ' : ' + _scaleVal.h + ' : ' + _scaleVal.devScaleRatioInt; // alert(_trace);


        if (_bool) {
          // ----------------------------
          modelCls.vPropObj.mTextWrapperObj.className = 'mStage mTextWrapper';
          document.body.appendChild(modelCls.vPropObj.mTextWrapperObj); // ----------------------------

          modelCls.vPropObj.bgCanvasObj.className = 'mStage mStagebgCanvas';
          document.body.appendChild(modelCls.vPropObj.bgCanvasObj); // ----------------------------

          modelCls.vPropObj.contCanvasObj.className = 'mStage mStagecontCanvas';
          document.body.appendChild(modelCls.vPropObj.contCanvasObj); // ----------------------------

          modelCls.vPropObj.virtualCanvasObj.className = 'mStage mVirtualStagecontCanvas'; // ----------------------------

          modelCls.vPropObj.domLayerObj.className = 'mStage mDomLayer';
          document.body.appendChild(modelCls.vPropObj.domLayerObj);
          modelCls.vPropObj.headerObj.className = 'mStage header';
          modelCls.vPropObj.domLayerObj.appendChild(modelCls.vPropObj.headerObj);
          modelCls.vPropObj.headerLogoItemObj.className = 'logoItem';
          modelCls.vPropObj.headerObj.appendChild(modelCls.vPropObj.headerLogoItemObj);
          modelCls.vPropObj.headerLogoObj.className = 'logo';
          modelCls.vPropObj.headerLogoItemObj.appendChild(modelCls.vPropObj.headerLogoObj);
          modelCls.vPropObj.headerTextObj.className = 'header__title';
          modelCls.vPropObj.headerTextObj.innerHTML = 'header';
          modelCls.vPropObj.headerObj.appendChild(modelCls.vPropObj.headerTextObj);
          modelCls.vPropObj.headerHelpObj.className = 'helpScreenButton headerButton';
          modelCls.vPropObj.headerObj.appendChild(modelCls.vPropObj.headerHelpObj);
          modelCls.vPropObj.headerHelpIconObj.className = 'helpIcon';
          modelCls.vPropObj.headerHelpObj.appendChild(modelCls.vPropObj.headerHelpIconObj);
          modelCls.vPropObj.headerCopyRightObj.className = 'copyrightButton headerButton';
          modelCls.vPropObj.headerObj.appendChild(modelCls.vPropObj.headerCopyRightObj);
          modelCls.vPropObj.infoPopupObj.className = 'infoPopup';
          modelCls.vPropObj.domLayerObj.appendChild(modelCls.vPropObj.infoPopupObj);
          modelCls.vPropObj.headerCopyRightIconObj.className = 'verticalDotsIcon';
          modelCls.vPropObj.headerCopyRightObj.appendChild(modelCls.vPropObj.headerCopyRightIconObj); // ----------------------------

          modelCls.vPropObj.preloadObj.className = 'mStage preloadDiv';
          document.body.appendChild(modelCls.vPropObj.preloadObj); // ----------------------------
          // modelCls.vPropObj.mouseCanvasObj.className = 'mStage mStageMouseCanvas';
          // document.body.appendChild(modelCls.vPropObj.mouseCanvasObj);
          // ----------------------------

          CanvasRenderingContext2D.prototype.textWrapperClass = LabComClass.TextImgClass;
          CanvasRenderingContext2D.prototype.textWrapperV2Class = LabComClass.TextImgV2Class;
          CanvasRenderingContext2D.prototype.textWrapperNewClass = LabComClass.TextImgNewClass;
          CanvasRenderingContext2D.prototype.tweenClass = LabComClass.TweenClass;
          CanvasRenderingContext2D.prototype.drawCurveRect = LabComClass.drawCurveRect;
          CanvasRenderingContext2D.prototype.drawStyledText = LabComClass.drawStyledText;
          var drawImage = CanvasRenderingContext2D.prototype.drawImage;

          CanvasRenderingContext2D.prototype.drawImage = function () {
            try {
              drawImage.apply(this, arguments);
            } catch (e) {
              var stack = e.stack || '';
              stack = stack.split('\n').map(function (line) {
                return line.trim();
              });
              var printError = 'Failed to draw error, ';
              printError += 'trace === ' + stack.join(',') + ', ';
              printError += 'arguments === ' + JSON.stringify(arguments);

              if (typeof trackJs !== 'undefined') {
                trackJs.console.error(printError);
              }
            }
          }; // ----------------------------


          _retStr = 'onScaleSet';
        }

        var _cnvObj = {};
        _cnvObj.bgContextObj = modelCls.vPropObj.bgCanvasObj.getContext('2d'); // Context to show the background

        _cnvObj.contContextObj = modelCls.vPropObj.contCanvasObj.getContext('2d'); // Context to show the content
        // -----------

        onModelUpdateCls.trigger('setVProp', _cnvObj, ''); // ---------

        modelCls.vPropObj.bgCanvasObj.style.left = _scaleVal.x + 'px';
        modelCls.vPropObj.bgCanvasObj.style.top = _scaleVal.y + 'px';
        modelCls.vPropObj.bgCanvasObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.bgCanvasObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.bgCanvasObj.style.width = _scaleVal.w + 'px';
        modelCls.vPropObj.bgCanvasObj.style.height = _scaleVal.h + 'px'; // ---------

        modelCls.vPropObj.contCanvasObj.style.left = _scaleVal.x + 'px';
        modelCls.vPropObj.contCanvasObj.style.top = _scaleVal.y + 'px';
        modelCls.vPropObj.contCanvasObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.contCanvasObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.contCanvasObj.style.width = _scaleVal.w + 'px';
        modelCls.vPropObj.contCanvasObj.style.height = _scaleVal.h + 'px'; // ---------

        modelCls.vPropObj.virtualCanvasObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.virtualCanvasObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.virtualCanvasObj.style.width = _scaleVal.w + 'px';
        modelCls.vPropObj.virtualCanvasObj.style.height = _scaleVal.h + 'px'; // ---------

        modelCls.vPropObj.domLayerObj.style.left = _scaleVal.x + 'px';
        modelCls.vPropObj.domLayerObj.style.top = _scaleVal.y + 'px';
        modelCls.vPropObj.domLayerObj.style.width = modelCls.cPropObj.playerConfigObj.baseWidth + 'px';
        modelCls.vPropObj.domLayerObj.style.height = modelCls.cPropObj.playerConfigObj.baseHeight + 'px';
        modelCls.vPropObj.domLayerObj.style.transform = 'scale(' + _scaleVal.scale + ')'; // ---------

        modelCls.vPropObj.snapshotCnvObj.width = _scaleVal.w * _scaleVal.devScaleRatioInt;
        modelCls.vPropObj.snapshotCnvObj.height = _scaleVal.h * _scaleVal.devScaleRatioInt; // ---------
        // modelCls.vPropObj.mouseCanvasObj.style.left = _scaleVal.x + 'px';
        // modelCls.vPropObj.mouseCanvasObj.style.top = _scaleVal.y + 'px';

        modelCls.vPropObj.mouseCanvasObj.width = _scaleVal.w;
        modelCls.vPropObj.mouseCanvasObj.height = _scaleVal.h; // modelCls.vPropObj.mouseCanvasObj.style.width = _scaleVal.w + 'px';
        // modelCls.vPropObj.mouseCanvasObj.style.height = _scaleVal.h + 'px';
        // ---------

        modelCls.vPropObj.mTextWrapperObj.style.display = 'none';
        modelCls.vPropObj.mTextWrapperObj.setAttribute('data-scale', _scaleVal.scale); // ----------------------------

        modelCls.vPropObj.preloadObj.style.left = _scaleVal.x + 'px';
        modelCls.vPropObj.preloadObj.style.top = _scaleVal.y + 'px';
        modelCls.vPropObj.preloadObj.style.width = _scaleVal.w + 'px';
        modelCls.vPropObj.preloadObj.style.height = _scaleVal.h + 'px'; // ----------------------------

        modelCls.cPropObj.mouseHandleCls.updateOnResize(_scaleVal); // ----------------------------

        LabComClass.setVirtualCnv(modelCls.vPropObj.virtualCanvasObj); // ----------------------------

        LabComClass.setSnapshotCnv({
          snapshotCnvObj: modelCls.vPropObj.snapshotCnvObj,
          bgCanvasObj: modelCls.vPropObj.bgCanvasObj,
          contCanvasObj: modelCls.vPropObj.contCanvasObj,
          devScaleRatioInt: _scaleVal.devScaleRatioInt,
          scale: _scaleVal.scale
        }); // ----------------------------

        onModelUpdateCls.trigger('setVProp', {
          scaledDataObj: _scaleVal
        }, _retStr); // ----------------------------

        LabComClass.setCnvScale(modelCls.vPropObj.scaledDataObj); // ----------------------------

        if (!_bool) {
          onViewUpdateCls.trigger('onGlobalUpdate', {
            type: 'onNavStageResize',
            data: {}
          });
        }
      }, 300);

      onModelUpdateCls.trigger('setVProp', {
        resizeTimeoutObj: _resizeTimeoutObj
      }, '');
    } // ===================================================================================


    function calculateScaleVal(_dataObj) {
      var _obj = {};

      try {
        _obj = JSON.parse('{"' + location.search.substring(1).replace(/&/g, '","').replace(/=/g, '":"') + '"}');
      } catch (e) {
        console.log('To switch off the scale: ?noscale=true');
      }

      if (_obj.noscale !== 'true') {
        var _shellWidth = _dataObj.w;
        var _shellHeight = _dataObj.h;

        var _newShellHeight;

        var _newShellWidth;

        var _actWid = window.innerWidth;
        var _actHgt = window.innerHeight;
        var _scale = 1;
        var _nscale = 1;

        if (_actHgt < _actWid) {
          _newShellHeight = _actHgt;
          _scale = Number(_shellHeight / _newShellHeight); // .toFixed(2);

          _newShellWidth = _shellWidth / _shellHeight * _newShellHeight;

          var _aleft = _actWid / 2 - Number(_newShellWidth) / 2;

          if (_aleft < 0) {
            _newShellWidth = _actWid;
            _scale = Number(_shellWidth / _newShellWidth); // .toFixed(2);

            _newShellHeight = _shellHeight / _shellWidth * _newShellWidth;
          }

          _nscale = 1 / _scale;

          if (_nscale < 0.1) {
            _nscale = 0.1;
          }
        } else {
          _newShellWidth = _actWid;
          _scale = Number(_shellWidth / _newShellWidth); // .toFixed(2);

          _newShellHeight = _shellHeight / _shellWidth * _newShellWidth;
          _nscale = 1 / _scale;

          if (_nscale < 0.1) {
            _nscale = 0.1;
          }
        }

        return {
          w: Math.round(_shellWidth * _nscale),
          h: Math.round(_shellHeight * _nscale),
          scale: _nscale,
          x: Math.round(window.innerWidth / 2 - Number(_newShellWidth) / 2),
          y: Math.round(window.innerHeight / 2 - Number(_newShellHeight) / 2)
        };
      }

      document.body.style.overflow = 'auto';
      return {
        w: _dataObj.w,
        h: _dataObj.h,
        scale: 1,
        x: 0,
        y: 0
      };
    } // ===================================================================================


    function calculateDevicePixelRatio(_cnvObj) {
      var _ctxObj = _cnvObj.getContext('2d');

      var devicePixelRatio = window.devicePixelRatio || 1;
      var backingStoreRatio = _ctxObj.webkitBackingStorePixelRatio || _ctxObj.mozBackingStorePixelRatio || _ctxObj.msBackingStorePixelRatio || _ctxObj.oBackingStorePixelRatio || _ctxObj.backingStorePixelRatio || 1;
      var ratio = devicePixelRatio / backingStoreRatio;
      return ratio;
    } // ===================================================================================


    function loadUIFonts(_callback) {
      // load font divs
      var _uiFonts = modelCls.cPropObj.labObj.fonts; // remmove deprecated fonts

      var fontArr = [];

      if (_uiFonts.length > 0) {
        for (var i = 0; i < _uiFonts.length; i += 1) {
          fontArr.push(_uiFonts[i]);
        }
      }

      LabComClass.fontLoader({
        timeout: 15000,
        // error callback will be executed after timeout if one/all fonts failed to load.
        fontArr: fontArr,
        callback: _callback,
        error: function error(_fontFailureArr) {
          console.log('List of fonts failed to load === ', JSON.stringify(_fontFailureArr));

          if (typeof trackJs !== 'undefined') {
            trackJs.console.error('List of fonts failed to load === ', JSON.stringify(_fontFailureArr)); // t2
          }
        }
      });
    } // ===================================================================================
    // function loadCompScript() {
    //   var _gScrObj = {};
    //   var _gScrStrArr = [];
    //   var _iInt = 0;
    //   // Loading local CJSs.
    //   var _locCjs = modelCls.cPropObj.labObj.localCJS;
    //   if (typeof (_locCjs) !== 'undefined') {
    //     for (_iInt = 0; _iInt < _locCjs.length; _iInt++) {
    //       _gScrStrArr.push(_locCjs[_iInt].path + '.js');
    //     }
    //   }
    //   // Loading global component classes.
    //   var _httpData = modelCls.cPropObj.labObj.components;
    //   for (_iInt = 0; _iInt < _httpData.length; _iInt++) {
    //     if (_httpData[_iInt].type === 'global') {
    //       _gScrStrArr.push(modelCls.cPropObj.playerPath + 'component/' + _httpData[_iInt].ref + '.js');
    //     } else {
    //       _gScrStrArr.push(modelCls.cPropObj.playerPath + 'localcomponent/' + _httpData[_iInt].ref + '.js');
    //     }
    //   }
    //   // Start
    //   onModelUpdateCls.trigger('setCProp', {
    //     totalCompCountInt: _gScrStrArr.length
    //   }, '');
    //   // Loading local script
    //   // var _localBrain = modelCls.cPropObj.labObj.brainClass;
    //   _gScrStrArr.push(modelCls.cPropObj.playerPath + 'localcomponent/' + _localBrain.ref + '.js');
    //   // Start Loading all scripts
    //   scriptLoader(_gScrObj, _gScrStrArr, function () {
    //     // loadCompAssets();
    //     loadSFXAudio();
    //   });
    // }
    // ===================================================================================


    function loadSFXAudio() {
      LabComClass.childPreloadProgress(78); // Audio SFX loading

      var _totalSfxList = [];
      var _sfxList = modelCls.cPropObj.labObj.globalSfx;
      Object.keys(_sfxList).forEach(function (i) {
        var _sfxTemList = _sfxList[i];
        _sfxList[i].source = modelCls.cPropObj.playerPath + 'assets/audio/' + _sfxTemList.source;

        _totalSfxList.push(_sfxList[i]);
      });

      if (_sfxList.length > 0) {
        var _aPlayer = modelCls.cPropObj.audioContextCls;

        _aPlayer.sfxObj.add(_totalSfxList, function () {
          onModelUpdateCls.trigger('setCProp', {}, 'onSFXLoad');
        });
      } else {
        onModelUpdateCls.trigger('setCProp', {}, 'onSFXLoad');
      }
    } // ===================================================================================


    function scriptLoader(_dataObj, _scriptArr, _callBackFn) {
      var _cnt = 0;

      for (var i = 0; i < _scriptArr.length; i++) {
        _cnt++;
        addScript(_scriptArr[i], onloaded, 0);
      } // ----------------------------


      function onloaded() {
        _cnt--;

        if (_cnt <= 0) {
          _callBackFn();
        }
      }
    } // ===================================================================================


    function addScript(src, callback, loadCnt) {
      var s = document.createElement('script');
      s.setAttribute('data-load-cnt', loadCnt);
      s.onload = callback;

      s.onerror = function (e) {
        if (loadCnt <= 2) {
          setTimeout(function () {
            addScript(src, callback, loadCnt + 1);
          }, 500);
        } else if (typeof trackJs !== 'undefined') {
          trackJs.console.error('script onload error URL : ' + src);
          window.alert('There was an error loading a critical file for this lesson. The lesson needs to close');
          onViewUpdateCls.trigger('onGlobalUpdate', {
            type: 'onClosePlayerWindow'
          });
        }
      };

      s.setAttribute('src', src);
      document.getElementsByTagName('head')[0].appendChild(s);
    } // ===================================================================================


    function createCompList() {
      var _iInt = 0;
      var _interactiveLayerArr = modelCls.cPropObj.interactiveLayerArr;
      var _compListObj = {}; // ------------------------

      var _globalData = modelCls.cPropObj.labObj.components;

      for (_iInt = 0; _iInt < _globalData.length; _iInt++) {
        var _idObj = _globalData[_iInt].initdata || {};

        _idObj.id = _globalData[_iInt].id;
        _idObj.domLayer = modelCls.vPropObj.domLayerObj;
        _idObj.canvas = modelCls.vPropObj.contCanvasObj;
        _idObj.context = modelCls.vPropObj.contContextObj;
        _idObj.deviceTypeBool = modelCls.cPropObj.deviceTypeBool;
        _idObj.devScaleRatioInt = modelCls.vPropObj.scaledDataObj.devScaleRatioInt;
        _idObj.playerConfigObj = modelCls.cPropObj.playerConfigObj;
        _idObj.LabComClass = LabComClass;

        var _func = eval(_globalData[_iInt].ref);

        _compListObj[_globalData[_iInt].id] = {};
        _compListObj[_globalData[_iInt].id].obj = new _func(_idObj);

        _interactiveLayerArr.push(_globalData[_iInt].id);
      } // ----------------------------


      onModelUpdateCls.trigger('setCProp', {
        compListObj: _compListObj,
        interactiveLayerArr: _interactiveLayerArr
      }, '');
    } // ===================================================================================


    function allCompLoaded(e) {
      var _returnStr = '';
      var _compCountInt = modelCls.cPropObj.compCountInt;
      var _totalCompCountInt = modelCls.cPropObj.labObj.components.length;
      _compCountInt++;

      if (_compCountInt === _totalCompCountInt) {
        _returnStr = 'onCompListAdd';
      }

      onModelUpdateCls.trigger('setCProp', {
        compCountInt: _compCountInt
      }, _returnStr);
    } // ===================================================================================


    function sendInstanceToAct() {
      var _compListObj = modelCls.cPropObj.compListObj;
      var _obj = {};

      if (Object.keys(_compListObj).length <= 0) {
        requestAnimationFrame(sendInstanceToAct);
      } else {
        Object.keys(_compListObj).forEach(function (j) {
          _obj[j] = _compListObj[j].obj;
        });
        var _idObj = {};
        _idObj.spineObj = _obj;
        _idObj.spineObj.LabComClass = LabComClass;

        var _brainClassObj = eval('BrainClass');

        var _brainObj = new _brainClassObj(_idObj);

        onModelUpdateCls.trigger('setCProp', {
          brainObj: _brainObj
        }, 'onActivityInited');
      }
    }

    function getTableData(toolArray, infoObj) {
      var content = '<table style = "border:1px solid black;border-collapse: collapse">\
        <tr style = "border:1px solid black">\
          <th style = "padding: 5px 10px;border:1px solid black">Werkzeug</th>\
          <th style = "padding: 5px 20px;border:1px solid black">Symbol</th>\
          <th style = "padding: 5px 50px;border:1px solid black">Funktionsweise</th>\
        </tr>';
      toolArray.forEach(function (tool) {
        tool = tool.includes('brush') ? 'color' : tool;
        var height = tool === 'point' ? '20px' : '70px';
        content += '<tr style = "border:1px solid black">\
            <td style = "padding: 5px 10px;border:1px solid black">' + infoObj.toolGerman[tool] + '</td>\
            <td style = "padding: 5px 20px;vertical-align:middle;border:1px solid black"><img src="assets/images/' + tool + '.svg" style = "height:' + height + ';width:70px;vertical-align:text-top"/></td>\
            <td style = "padding: 5px 50px;border:1px solid black">' + infoObj[tool] + '</td>\
          </tr>';
      });
      content += '</table>';
      return content;
    } // ===================================================================================


    function updatePopupContent(_ref) {
      var title = _ref.title,
          contentKey = _ref.contentKey;
      var _modelCls$vPropObj$in = modelCls.vPropObj.infoPopupObj,
          titleDiv = _modelCls$vPropObj$in.titleDiv,
          contentDiv = _modelCls$vPropObj$in.contentDiv;
      var content = LabComClass.globalLangText[title] || modelCls.cPropObj.globalTextObj[contentKey][title];
      titleDiv.innerHTML = title;

      if (title !== 'Werkzeugliste') {
        contentDiv.innerHTML = content;
      } else {
        // const toolsUsed = LabComClass.globalLangText['toolsUsed'];
        // const toolArray = toolsUsed.split(",");
        var toolArray = ['move', 'select', 'color', 'point', 'segment', 'segmentDash', 'segSize', 'ray', 'line', 'angleRay', 'angleSize', 'angle', 'perpendicularLine', 'parallelLine', 'circle', 'circleSize', 'circle_3', 'compass', 'length', 'mirrorOnLine', 'midPoint', 'mirrorOnPoint', 'perpendicularBisector', 'angleB', 'triangle', 'square', 'labelTool', 'delete'];
        contentDiv.innerHTML = getTableData(toolArray, modelCls.cPropObj.globalTextObj[contentKey][title]); // contentDiv.innerHTML = getTableData(modelCls.cPropObj.toolsUsed,modelCls.cPropObj.globalTextObj[contentKey][title]);
      }
    } // ===================================================================================
    // ----------------------
    // ----------------------


    onModelUpdateCls.on('controllerInit', init);
    onModelUpdateCls.on('onChange', onChange); // ----------------------------

    onViewUpdateCls.on('onGlobalUpdate', onGlobalUpdate);
  } // ===================================================================================
  // ===================================================================================

  /*
   * Audio player
   */


  function AudioContextClass() {
    var thisObj = this;
    var context;
    var bufferLoader;
    var support;
    var hasOProp = Object.prototype.hasOwnProperty;
    var audioObj = new AudioNativeClass();
    var audioList;
    var audioListArr;
    var previosAudio = '';
    var currentAudioCnt = 0;
    var audioContextFallbackArr = [];
    var loadCnt = 0;
    var desiredSampleRate = 44100;
    var mediaErrorCls = new MediaErrorHandlingClass({
      refObj: thisObj,
      element: null,
      type: 'audioContext'
    });

    if (isAudioContextSupported()) {
      support = true;
      context = new window.AudioContext();
    } else {
      support = false;
    }

    support = false;

    function SFXClass() {
      var audios = {};

      this.add = function (_audioListArr, _callBackFn) {
        mediaErrorCls.registerRequest({
          action: 'add',
          audioListArr: _audioListArr,
          callBackFn: _callBackFn
        });
        audioListArr = _audioListArr;

        if (support === true) {
          var finishedLoading = function finishedLoading(_list) {
            Object.keys(_list).forEach(function (i) {
              audios[_list[i].key] = {};
              audios[_list[i].key] = _list[i];
            });

            _callBackFn();
          };

          bufferLoader = new BufferLoaderClass(context, _audioListArr, finishedLoading);
          bufferLoader.load();
        } else {
          Object.keys(_audioListArr).forEach(function (k) {
            if (thisObj.mp3Support() === false) {
              _audioListArr[k].source = _audioListArr[k].source.replace('.mp3', '.ogg');
            }

            audios[_audioListArr[k].key] = new Howl({
              src: [_audioListArr[k].source]
            });

            audios[_audioListArr[k].key].once('load', loadComplete);

            audios[_audioListArr[k].key].once('loaderror', loaderror);
          });
          /* var i = 0;
           for (i = 0; i < 10; i += 1) {
           audioContextFallbackArr[i] = new AudioNativeClass();
           if (typeof _audioListArr[i] !== 'undefined') {
           audioContextFallbackArr[i].addAudio({
           src: _audioListArr[i].source
           });
           }
           } */
          // _callBackFn();
        }

        function loaderror(error) {
          console.log('loaderror', error);
          mediaErrorCls.pushError(JSON.stringify(error));
        }

        function loadComplete() {
          loadCnt += 1;

          if (_audioListArr.length === loadCnt) {
            _callBackFn();
          }
        }
      };

      this.play = function (_keyNum, _callBackFn) {
        if (support === true && audios[_keyNum]) {
          audios[_keyNum].context = context.createBufferSource();

          if (audios[_keyNum].context.context.sampleRate !== desiredSampleRate) {
            // console.log(audios[_keyNum].context.context.sampleRate, 'sampleRate');
            var buffer = context.createBuffer(1, 1, desiredSampleRate);
            audios[_keyNum].context = context.createBufferSource();
            audios[_keyNum].context.buffer = buffer;

            audios[_keyNum].context.connect(context.destination);

            audios[_keyNum].context.start(0);

            audios[_keyNum].context.disconnect();

            context.close();
            context = new window.AudioContext();
            audios[_keyNum].context = context.createBufferSource();
          }

          if (_callBackFn) {
            audios[_keyNum].context.onended = _callBackFn;
          }

          audios[_keyNum].context.buffer = audios[_keyNum].buffer;

          audios[_keyNum].context.connect(context.destination);

          audios[_keyNum].context.start(0);
        } else if (audios[_keyNum]) {
          audios[_keyNum].play(); // console.log('play sfx without audio API', _keyNum);

        }
      };

      this.setAudioList = function (_audioListArr) {
        audioList = _audioListArr;
      };
    }

    this.sfxObj = new SFXClass();

    this.mp3Support = function () {
      var audioObj = document.createElement('audio');
      var temp = !!(audioObj.canPlayType && audioObj.canPlayType('audio/mpeg;').replace(/no/, ''));
      return temp;
    }; // ----------------------------

    /*
     *  audio loading system for audio context
     */


    function BufferLoaderClass(_contextObj, _urlListArr, _callBackFn) {
      this.context = _contextObj;
      this.urlList = _urlListArr;
      this.onload = _callBackFn;
      this.bufferList = [];
      this.loadCount = 0;
    }

    BufferLoaderClass.prototype.loadBuffer = function (_urlStr, _indexNum) {
      // Load buffer asynchronously
      // console.log(thisObj.mp3Support(), 'mp3 support');
      if (thisObj.mp3Support() === false) {
        _urlStr = _urlStr.replace('.mp3', '.ogg');
      }

      var request = new XMLHttpRequest();
      request.open('GET', _urlStr, true);
      request.responseType = 'arraybuffer';
      var loader = this;

      request.onload = function () {
        // Asynchronously decode the audio file data in request.response
        loader.context.decodeAudioData(request.response, function (buffer) {
          /* if (!buffer) {
           console.log('error decoding file data: ' + _urlStr);
           return;
           } */
          // loader.bufferList[_indexNum] = buffer;
          loader.bufferList[_indexNum] = _indexNum;
          loader.urlList[_indexNum].buffer = buffer;

          if (++loader.loadCount === loader.urlList.length) {
            loader.onload(loader.urlList);
          }
        }, function (error) {
          console.log('decodeAudioData error', error);

          if (typeof trackJs !== 'undefined') {
            trackJs.console.error('Audio load error ' + JSON.stringify(error)); // t4
          }

          window.alert('There was an error loading a critical file for this lesson. The lesson needs to close');
          onViewUpdateCls.trigger('onGlobalUpdate', {
            type: 'onClosePlayerWindow'
          });
        });
      };

      request.onerror = function (error) {
        console.log('onerror', error);

        if (typeof trackJs !== 'undefined') {
          trackJs.console.error('Audio load error'); // t5
        }

        window.alert('There was an error loading a critical file for this lesson. The lesson needs to close');
        onViewUpdateCls.trigger('onGlobalUpdate', {
          type: 'onClosePlayerWindow'
        });
      };

      request.send();
    };

    BufferLoaderClass.prototype.load = function () {
      for (var i = 0; i < this.urlList.length; ++i) {
        this.loadBuffer(this.urlList[i].source, i);
      }
    };
  }

  function AudioNativeClass() {
    var audioObj = new Audio();
    var hasOProp = Object.prototype.hasOwnProperty;
    var thisObj = this;

    var ended = function ended() {};

    var onerror = function onerror() {};

    var started = function started() {};

    var stopOnLoad = false;
    var playStartedIntervalInt;
    var latestAction;
    var instantiateBool = false;
    var mediaErrorCls = new MediaErrorHandlingClass({
      refObj: thisObj,
      element: audioObj,
      type: 'audio'
    });
    audioObj.addEventListener('ended', function () {
      ended(); // ended = function () {};
    }, false);
    audioObj.addEventListener('error', function (error) {
      mediaErrorCls.pushError(error); // onerror();
      // onerror = function () {};
    }, false); // audioObj.addEventListener('canplaythrough', function () {
    // }, false);

    this.addAudio = function (_dataObj) {
      latestAction = 'add';
      mediaErrorCls.registerRequest({
        action: 'add',
        dataObj: _dataObj
      });
      audioObj.src = '';

      if (hasOProp.call(_dataObj, 'callback')) {
        ended = function ended() {
          _dataObj.callback();
        };
      } else {
        ended = function ended() {};
      }

      if (hasOProp.call(_dataObj, 'startCallback')) {
        started = function started() {
          _dataObj.startCallback();
        };
      } else {
        started = function started() {};
      }

      if (hasOProp.call(_dataObj, 'errorCallback')) {
        onerror = function onerror() {
          _dataObj.errorCallback();
        };
      } else {
        onerror = function onerror() {};
      }

      if (hasOProp.call(_dataObj, 'stopOnLoad')) {
        stopOnLoad = _dataObj.stopOnLoad;
      } else {
        stopOnLoad = false;
      }

      if (this.mp3Support() === false) {
        _dataObj.src = _dataObj.src.replace('.mp3', '.ogg');
      }

      mediaErrorCls.setFilePath(_dataObj.src);
      audioObj.src = _dataObj.src;
      audioObj.load();
      checkForPlayStart();
    };

    this.mp3Support = function () {
      var audioObj = document.createElement('audio');
      var temp = !!(audioObj.canPlayType && audioObj.canPlayType('audio/mpeg;').replace(/no/, ''));
      return temp;
    };

    this.removeAudio = function () {
      trace('remove audio...');
      latestAction = 'remove';
      audioObj.src = '';
    };

    this.callEnded = function () {
      trace('call ended...');
      /* ended();
       ended = function () {}; */
    };

    this.playAudio = function (_timeNum) {
      latestAction = 'play';
      mediaErrorCls.registerRequest({
        action: 'playAudio',
        dataObj: _timeNum
      });

      if (typeof _timeNum !== 'undefined') {
        audioObj.currentTime = _timeNum;
      }

      if (audioObj.src !== '') {
        var playPromise = audioObj.play();

        if (playPromise !== undefined) {
          playPromise.then(function () {
            // Automatic playback started!
            instantiateBool = true;
          })["catch"](function (error) {
            // Automatic playback failed.
            // Show a UI element to let the user manually start playback.
            if (audioObj.error === null) {
              if (instantiateBool === false) {
                onModelUpdateCls.trigger('setCProp', {
                  mediaPromiseErrorTypeStr: 'audio'
                });
                console.log('playPromise error audio', error);
                started();

                started = function started() {};

                onViewUpdateCls.trigger('onGlobalUpdate', {
                  type: 'navPauseBtnClick'
                });
              }
            } else {
              mediaErrorCls.pushError(error); // retry();
            }
          });
        }
      }
    };

    this.pauseAudio = function () {
      trace('pause audio...');
      latestAction = 'pause';

      if (audioObj.src !== '' && audioObj.currentTime > 0) {
        audioObj.pause();
      }
    };

    this.getCurrentTime = function () {
      trace('Get current Time ...');
      return audioObj.currentTime;
    };

    this.reload = function () {
      latestAction = 'reload';
      var _tempSrc = audioObj.src;
      audioObj.src = '';
      audioObj.src = _tempSrc;
    }; // --------


    function checkForPlayStart() {
      clearInterval(playStartedIntervalInt);

      if (audioObj.src.indexOf('blank.') === -1) {
        playStartedIntervalInt = setInterval(function () {
          if (audioObj.currentTime > 0) {
            clearInterval(playStartedIntervalInt);
            started();

            started = function started() {};

            if (stopOnLoad === true) {
              stopOnLoad = false;
              thisObj.pauseAudio();
            }

            if (latestAction === 'pause') {
              thisObj.pauseAudio();
            }
          }
        }, 5);
      }
    }
  }

  function trace(msg) {// console.log(msg);
  }

  function isAudioContextSupported() {
    // This feature is still prefixed in Safari
    window.AudioContext = window.AudioContext || window.webkitAudioContext;

    if (window.AudioContext) {
      return true;
    }

    return false;
  } // ===================================================================================
  // DETECT BROWSER TO IDENTIFY THE PLATFORM
  // ===================================================================================


  function MediaErrorHandlingClass(_obj) {
    var errorCnt = 0;
    var maxRetries = 3;
    var mediaCls = _obj.refObj;
    var mediaElement = _obj.element;
    var type = _obj.type;
    var thisObj = this;
    var previousRequestObj = {
      action: null,
      dataObj: null
    };
    var filePathStr = 'No file source';

    this.registerRequest = function (_previousRequestObj) {
      previousRequestObj = _previousRequestObj;
    };

    this.setFilePath = function (_filePathStr) {
      if (typeof _filePathStr !== 'undefined') {
        filePathStr = _filePathStr;
      }
    };

    this.pushError = function (_error, _bool) {
      errorCnt += 1; // video playback failed - show a message saying why

      var errorMsg;

      switch (type) {
        case 'audio':
        case 'video':
          switch (mediaElement.error.code) {
            case mediaElement.error.MEDIA_ERR_ABORTED:
              errorMsg = 'You aborted the audio/video playback.';
              break;

            case mediaElement.error.MEDIA_ERR_NETWORK:
              errorMsg = 'A network error caused the audio/video download to fail part-way.';
              break;

            case mediaElement.error.MEDIA_ERR_DECODE:
              errorMsg = 'The video/Audio playback was aborted due to a corruption problem or because the audio/video used features your browser did not support.';
              break;

            case mediaElement.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
              errorMsg = 'The video/Audio could not be loaded, either because the server or network failed or because the format is not supported.';
              break;

            default:
              errorMsg = 'An unknown error occurred.';
              break;
          }

          break;

        case 'audioContext':
          errorMsg = 'audio sfx missing';
          break;

        default:
          break;
      }

      if (errorCnt <= maxRetries) {
        // thisObj.playVideo();
        console.log('media error retry delay started');
        setTimeout(function () {
          console.log('media error retry delay end');

          switch (type) {
            case 'video':
              if (previousRequestObj.action === 'add') {
                mediaCls.add(previousRequestObj.dataObj);
              } else {
                mediaCls.reload();
                mediaCls.playVideo(previousRequestObj.dataObj);
              }

              break;

            case 'audio':
              if (previousRequestObj.action === 'add') {
                mediaCls.addAudio(previousRequestObj.dataObj);
              } else {
                mediaCls.reload();
                mediaCls.playAudio(previousRequestObj.dataObj);
              }

              break;

            case 'audioContext':
              if (previousRequestObj.action === 'add') {
                mediaCls.sfxObj.add(previousRequestObj.audioListArr, previousRequestObj.callBackFn);
              }

              break;

            default:
              break;
          }
        }, 500);
      } else if (errorCnt === maxRetries + 1) {
        console.log(errorMsg + 'file path = ' + filePathStr);

        if (typeof trackJs !== 'undefined') {
          if (filePathStr !== 'No file source') {
            trackJs.console.error(errorMsg + '; file path = ' + filePathStr); // t6
          } else {
            trackJs.console.error(errorMsg); // t6
          }
        }

        thisObj.backToDashboard();
      }
    };

    this.backToDashboard = function () {
      window.alert('There was an error loading a critical file for this lesson. The lesson needs to close');
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'onClosePlayerWindow'
      });
    };
  } // ===================================================================================


  function KeyHandlerClass() {
    var eventListeners = {};

    this.init = function () {
      window.addEventListener('keyup', onKeyEvent);
      window.addEventListener('keydown', onKeyEvent);
      window.addEventListener('keypress', onKeyEvent);
    };

    this.addKeyEvents = function (_ref2) {
      var id = _ref2.id,
          callback = _ref2.callback;

      if (!eventListeners[id]) {
        eventListeners[id] = [];
      }

      eventListeners[id].push(callback);
    };

    this.removeKeyEvents = function (_ref3) {
      var id = _ref3.id,
          callback = _ref3.callback;

      if (isListenerRegister(id)) {
        var index = eventListeners[id].indexOf(callback);
        eventListeners[id].splice(index, 1);

        if (eventListeners[id].length === 0) {
          delete eventListeners[id];
        }
      }
    };

    function onKeyEvent(e) {
      Object.keys(eventListeners).forEach(function (id) {
        eventListeners[id].forEach(function (callback) {
          callback({
            nativeEvent: e,
            compId: id
          });
        });
      });
    }

    function isListenerRegister(id) {
      return eventListeners[id] && eventListeners[id].length > 0;
    }
  } // ===================================================================================
  // ===================================================================================


  function MouseHandlerClass() {
    var dataObj = {};
    var scaledDataObj = {};
    var mouseRegionObj = {};
    var lastPageX = 0;
    var lastPageY = 0;
    var mouseEvents = {};
    var mousePoniterStyle = 'default';
    var activeElement = null;
    var newMouseEnterElement = null;
    var mouseContextObj;
    var hitAreaArr;
    var enableMouseEvents = true; // ============================================

    this.init = function (_obj) {
      dataObj = _obj;
      var _mousObj = {
        down: 'mousedown',
        move: 'mousemove',
        up: 'mouseup',
        click: 'click'
      };
      mouseEvents = dataObj.deviceTypeBool ? {
        down: 'touchstart',
        move: 'touchmove',
        up: 'touchend',
        click: 'click'
      } : _mousObj;
      mouseContextObj = dataObj.mouseCanvasObj.getContext('2d'); // // ----------------------------

      applyMouseEvents(true); // // ----------------------------

      onViewUpdateCls.on('onGlobalUpdate', onGlobalUpdate);
    }; // ============================================


    this.updateOnResize = function (_obj) {
      scaledDataObj = _obj;
      upadteHitAreas();
    }; // ============================================


    this.updateInteractiveLayer = function (_obj) {
      dataObj.interactiveLayerArr = _obj;
      upadteHitAreas();
    };

    this.toggleMouseEvents = function (_bool) {
      enableMouseEvents = _bool;
    }; // ============================================
    // mouseenter, mouseout, mousedown, mouseup, mouseover


    this.addMouseEvent = function (_dataObj) {
      if (!mouseRegionObj[_dataObj.id]) {
        mouseRegionObj[_dataObj.id] = [];
      } // -----


      for (var i = 0; i < _dataObj.r.length; i++) {
        var _flagBool = false;

        for (var j = 0; j < mouseRegionObj[_dataObj.id].length; j++) {
          if (mouseRegionObj[_dataObj.id][j].id === _dataObj.r[i].id) {
            _flagBool = true;
            Object.keys(_dataObj.r[i]).forEach(function (k) {
              mouseRegionObj[_dataObj.id][j][k] = _dataObj.r[i][k];
            });
          }
        }

        if (!_flagBool) {
          mouseRegionObj[_dataObj.id].push(_dataObj.r[i]);
        }
      }

      upadteHitAreas();
    };

    this.setCursor = function (_dataObj) {
      for (var j = 0; j < mouseRegionObj[_dataObj.id].length; j++) {
        if (mouseRegionObj[_dataObj.id][j].id === _dataObj.subId) {
          if (_dataObj.cursor) {
            mouseRegionObj[_dataObj.id][j].cursor = _dataObj.cursor;
          }

          if (_dataObj.downCursor) {
            mouseRegionObj[_dataObj.id][j].downCursor = _dataObj.downCursor;
          }

          break;
        }
      }
    }; // ============================================


    this.removeMouseEvent = function (_dataObj) {
      if (_dataObj.r && mouseRegionObj[_dataObj.id]) {
        for (var i = 0; i < _dataObj.r.length; i++) {
          for (var j = 0; j < mouseRegionObj[_dataObj.id].length; j++) {
            if (mouseRegionObj[_dataObj.id][j].id === _dataObj.r[i]) {
              mouseRegionObj[_dataObj.id].splice(j, 1);
            }
          }
        }
      } else if (mouseRegionObj[_dataObj.id]) {
        delete mouseRegionObj[_dataObj.id];
      }

      upadteHitAreas();
    };

    this.getCursor = function () {
      return mousePoniterStyle;
    }; // ============================================
    // PRIVATE AREA
    // ============================================


    function onGlobalUpdate(_dataObj) {
      switch (_dataObj.type) {
        case 'resumeGlobalMouseEvent':
          applyMouseEvents(true);
          break;

        case 'stopGlobalMouseEvent':
          applyMouseEvents(false);
          break;

        default:
          break;
      }
    }

    function upadteHitAreas() {
      var _intArr = dataObj.interactiveLayerArr;

      if (_intArr) {
        hitAreaArr = [];

        for (var i = _intArr.length - 1; i >= 0; i--) {
          var _elem = mouseRegionObj[_intArr[i]];

          if (typeof _elem !== 'undefined') {
            for (var _nni = _elem.length - 1; _nni >= 0; _nni--) {
              var _obj = {
                id: _intArr[i],
                subId: _elem[_nni].id,
                color: getRandomColor(),
                rect: _elem[_nni].rect,
                arc: _elem[_nni].arc,
                shape: _elem[_nni].shape
              };
              hitAreaArr.push(_obj);
            }
          }
        }

        drawNav();
      }
    } // ============================================


    function drawNav() {
      if (typeof scaledDataObj.scale !== 'undefined') {
        mouseContextObj.clearRect(0, 0, dataObj.mouseCanvasObj.width, dataObj.mouseCanvasObj.height);
        mouseContextObj.save();
        mouseContextObj.scale(scaledDataObj.scale, scaledDataObj.scale);

        for (var _ni = hitAreaArr.length - 1; _ni >= 0; _ni--) {
          var _el = hitAreaArr[_ni];
          mouseContextObj.beginPath();
          mouseContextObj.fillStyle = _el.color;

          if (typeof _el.rect !== 'undefined') {
            mouseContextObj.fillRect(_el.rect.x, _el.rect.y, _el.rect.w, _el.rect.h);
          } else if (typeof _el.arc !== 'undefined') {
            mouseContextObj.arc(_el.arc.x, _el.arc.y, _el.arc.r, 0, 2 * Math.PI);
            mouseContextObj.fill();
          } else if (typeof _el.shape !== 'undefined') {
            for (var _sh = 0; _sh < _el.shape.length; _sh++) {
              eval('mouseContextObj.' + _el.shape[_sh]);
            }

            mouseContextObj.fill();
          }

          mouseContextObj.closePath();
        }

        mouseContextObj.restore();
      }
    } // ============================================


    function mouseEventHandler(e) {
      if (!enableMouseEvents) {
        return;
      }

      var pageX, pageY;

      if (LabComClass.BrowserDetect.isDevice()) {
        if (typeof e.targetTouches[0] !== 'undefined') {
          lastPageX = e.targetTouches[0].pageX;
          lastPageY = e.targetTouches[0].pageY;
          pageX = lastPageX;
          pageY = lastPageY;
        } else {
          pageX = lastPageX;
          pageY = lastPageY;
        }
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      } // ----------------------------


      var typeStr = '';

      switch (e.type) {
        case 'touchstart':
        case 'mousedown':
          typeStr = 'mousedown';

          if (e.button && e.button === 2) {
            typeStr = 'rightmousedown';
          }

          break;

        case 'touchmove':
        case 'mousemove':
          typeStr = 'mousemove';
          break;

        case 'touchend':
        case 'mouseup':
          typeStr = 'mouseup';

          if (e.button && e.button === 2) {
            typeStr = 'rightmouseup';
          }

          break;

        case 'click':
          // typeStr = 'mouseup';
          break;

        default:
          break;
      }

      pageX -= scaledDataObj.x;
      pageY -= scaledDataObj.y;

      if (typeStr !== '') {
        isMouseInRegion({
          pageX: pageX,
          pageY: pageY,
          typeStr: typeStr
        });
      }

      if (!LabComClass.BrowserDetect.isDevice()) {
        e.preventDefault();
      }
    } // ============================================


    function isMouseInRegion(_obj) {
      var _mouseType = 'default';

      var _activeElement = checkMouseIn(_obj.pageX, _obj.pageY); // ------------------


      if (_obj.typeStr === 'mousemove') {
        if (activeElement === null) {
          if (_activeElement !== null) {
            if (newMouseEnterElement === null || newMouseEnterElement.id !== _activeElement.id || newMouseEnterElement.subIndex !== _activeElement.subIndex) {
              if (newMouseEnterElement !== null) {
                // leaves the interactive area to another interactive area.
                dispatchMouseEvent('mouseout', _obj, newMouseEnterElement);
              } // Enters the interactive area for the first time.


              dispatchMouseEvent('mouseenter', _obj, _activeElement);
              newMouseEnterElement = _activeElement;
            } else {
              // Mve dispatch once entered.
              dispatchMouseEvent('mousemove', _obj, newMouseEnterElement);
            }
          } else if (newMouseEnterElement !== null) {
            // Leaves the interactive area to the stage. called once
            dispatchMouseEvent('mouseout', _obj, newMouseEnterElement);
            newMouseEnterElement = _activeElement;
          }
        } else {
          // Move dispatch once clicked.
          dispatchMouseEvent('pressmove', _obj, activeElement);
        }
      } // ------------------


      if (_obj.typeStr === 'mousedown') {
        if (activeElement === null && _activeElement !== null) {
          activeElement = _activeElement;
          dispatchMouseEvent(_obj.typeStr, _obj, activeElement);
          dispatchStageEvent(activeElement);
        } else {
          dispatchStageEvent(activeElement);
        }
      }

      if (_obj.typeStr === 'rightmousedown') {
        if (activeElement === null && _activeElement !== null) {
          dispatchMouseEvent(_obj.typeStr, _obj, _activeElement);
        } // dispatchStageEvent(_activeElement);

      } // ------------------


      if ((_obj.typeStr === 'mouseup' || _obj.typeStr === 'rightmouseup') && activeElement !== null) {
        if (_activeElement !== null && activeElement.id === _activeElement.id && activeElement.subId === _activeElement.subId) {
          // If released on the same pressed element.
          dispatchMouseEvent(_obj.typeStr, _obj, activeElement);
        } else {
          // If released outside of the pressed element.
          dispatchMouseEvent(_obj.typeStr === 'mouseup' ? 'mouseupout' : 'rightmouseupout', _obj, activeElement);
        }

        newMouseEnterElement = null;
        activeElement = null;
      } // ------------------


      if (activeElement !== null) {
        _mouseType = typeof activeElement.cursor === 'undefined' ? 'pointer' : activeElement.cursor;

        if ((_obj.typeStr === 'mousemove' || _obj.typeStr === 'mousedown') && activeElement.downCursor) {
          _mouseType = activeElement.downCursor;
        }
      } else {
        var _overElement = checkMouseIn(_obj.pageX, _obj.pageY);

        if (_overElement !== null) {
          _mouseType = typeof _overElement.cursor === 'undefined' ? 'pointer' : _overElement.cursor;
        }
      } // ------------------


      if (mousePoniterStyle !== _mouseType) {
        // dataObj.mouseCanvasObj.style.cursor = _mouseType;
        document.body.style.cursor = _mouseType;
      }

      mousePoniterStyle = _mouseType;
    } // mouseenter, mouseout, mousedown, mouseup, mouseover
    // ============================================


    function dispatchMouseEvent(_typeStr, _obj, _elem) {
      var _actElem = mouseRegionObj[_elem.id] ? mouseRegionObj[_elem.id][_elem.subIndex] : undefined;

      if (typeof _actElem !== 'undefined' && typeof _actElem.eventListener !== 'undefined') {
        var _e = {
          id: _elem.id,
          subId: _actElem.id,
          type: _typeStr,
          pageX: _obj.pageX / scaledDataObj.scale,
          pageY: _obj.pageY / scaledDataObj.scale
        }; // _actElem.eventListener(_e);

        setTimeout(function () {
          _actElem.eventListener(_e);

          onViewUpdateCls.trigger('onGlobalUpdate', {
            type: 'rendererUpdate'
          });
        }, 0);
      } // onViewUpdateCls.trigger('onGlobalUpdate', {
      //   type: 'rendererUpdate'
      // });

    } // ============================================


    function dispatchStageEvent(_obj) {
      if (_obj === null) {
        _obj = {
          id: null,
          subId: null
        };
      }

      Object.keys(mouseRegionObj).forEach(function (_key) {
        for (var i = 0; i < mouseRegionObj[_key].length; i++) {
          var _actElem = mouseRegionObj[_key][i];

          if (typeof _actElem.eventListener !== 'undefined') {
            var _e = {
              id: _obj.id,
              subId: _obj.id,
              type: 'stageevent',
              pageX: _obj.pageX / scaledDataObj.scale,
              pageY: _obj.pageY / scaledDataObj.scale
            }; // _actElem.eventListener(_e);

            setTimeout(function () {
              _actElem.eventListener(_e);
            }, 0);
          }
        }
      });
    } // ============================================


    function checkMouseIn(_pageXNum, _pageYNum) {
      var _imgData = mouseContextObj.getImageData(_pageXNum, _pageYNum, 1, 1);

      var _colStr = LabComClass.rgba2hex(_imgData.data[0], _imgData.data[1], _imgData.data[2], _imgData.data[3]).substring(0, 6);

      if (_colStr !== '000000') {
        for (var i = 0; i < hitAreaArr.length; i++) {
          var _comStr = hitAreaArr[i].color.replace('#', '');

          if (_comStr === _colStr) {
            var _ittem = mouseRegionObj[hitAreaArr[i].id];

            for (var j = 0; j < _ittem.length; j++) {
              if (_ittem[j].id === hitAreaArr[i].subId) {
                return {
                  id: hitAreaArr[i].id,
                  subIndex: j,
                  cursor: _ittem[j].cursor,
                  downCursor: _ittem[j].downCursor
                };
              }
            }

            break;
          }
        }
      }

      return null;
    } // ============================================


    function getRandomColor() {
      // var letters = '0123456789ABCDEF'.split('');
      var letters = '0123456789'.split('');
      var color = '#';

      for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * letters.length)];
      }

      return color;
    } // ============================================


    function applyMouseEvents(_bool) {
      document.body.style.cursor = 'default';
      document.body.removeEventListener(mouseEvents.down, mouseEventHandler);
      document.body.removeEventListener(mouseEvents.move, mouseEventHandler);
      document.body.removeEventListener(mouseEvents.up, mouseEventHandler);

      if (_bool) {
        document.body.addEventListener(mouseEvents.down, mouseEventHandler, {
          passive: false
        });
        document.body.addEventListener(mouseEvents.move, mouseEventHandler, {
          passive: false
        });
        document.body.addEventListener(mouseEvents.up, mouseEventHandler, {
          passive: false
        });
      }
    }
  } // ===================================================================================


  var LabComClass = {
    // ================================================================================
    //  STATIC CONTENT SIZE CONSTANTS
    // ================================================================================
    contentAreaObj: {},
    globalLangText: '',
    snapshotCnvObj: {},
    html2CanvasQueueArr: [],
    html2CanvasQueueStarted: false,
    // ===================================================================================
    // Used to set scale of Virtual Canvas globally
    // ===================================================================================
    setCnvScale: function setCnvScale(_scale) {
      LabComClass.scale = _scale;
    },
    // ===================================================================================
    // Used to set reference of Virtual Canvas globally
    // ===================================================================================
    setVirtualCnv: function setVirtualCnv(_can) {
      LabComClass.virtualCnv = _can;
    },
    // To set a cursor on perticular event area from activity or component.
    setCursor: function setCursor(data) {
      if (modelCls.cPropObj.mouseHandleCls.getCursor() !== data.cursor) {
        document.body.style.cursor = data.cursor;
        modelCls.cPropObj.mouseHandleCls.setCursor(data);
      }
    },
    setHeader: function setHeader() {
      var _text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'header';

      modelCls.vPropObj.headerTextObj.innerHTML = _text;
    },
    // ===================================================================================
    // Used to take snapshot globally
    // ===================================================================================
    setSnapshotCnv: function setSnapshotCnv(_obj) {
      LabComClass.snapshotCnvObj = _obj;
    },
    globalSnapShot: function globalSnapShot(_obj) {
      var _bgImg = new Image();

      _bgImg.onload = function () {
        var _contImg = new Image();

        _contImg.onload = function () {
          var _cnv = LabComClass.snapshotCnvObj.snapshotCnvObj;
          _cnv.width = LabComClass.snapshotCnvObj.contCanvasObj.width;
          _cnv.height = LabComClass.snapshotCnvObj.contCanvasObj.height;
          var _x = 0;
          var _y = 0;

          if (typeof _obj.areaObj !== 'undefined') {
            _cnv.width = _obj.areaObj.width * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt;
            _cnv.height = _obj.areaObj.height * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt;
            _x = -1 * (_obj.areaObj.x * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt);
            _y = -1 * (_obj.areaObj.y * LabComClass.snapshotCnvObj.scale * LabComClass.snapshotCnvObj.devScaleRatioInt);
          }

          var _ctx = _cnv.getContext('2d');

          _ctx.drawImage(_bgImg, _x, _y);

          _ctx.drawImage(_contImg, _x, _y);

          var _ssImg = new Image();

          _ssImg.onload = function () {
            if (typeof _obj.callback !== 'undefined') {
              var _retImg = new Image();

              _retImg.src = _cnv.toDataURL('image/png');

              _obj.callback(_retImg);
            }
          };

          _ssImg.src = _cnv.toDataURL('image/png');
        };

        _contImg.src = LabComClass.snapshotCnvObj.contCanvasObj.toDataURL('image/png');
      };

      _bgImg.src = LabComClass.snapshotCnvObj.bgCanvasObj.toDataURL('image/png');
    },
    // ===================================================================================
    //  GLOBAL EVENT CLASS FOR INTER FUNCTION COMMUNICATION
    // ===================================================================================
    EventClass: function EventClass(_isLocalBool) {
      var channels = {};
      var eventNumber = 0;
      var hasOProp = Object.prototype.hasOwnProperty; //  Used to publish to subscribers that an event of their interest happened

      this.trigger = function (_eventStr, _dataObj, _typeStr) {
        Object.keys(channels).forEach(function (_topic) {
          if (_topic === _eventStr && hasOProp.call(channels, _topic)) {
            if (_isLocalBool === true) {
              callBackAll(_topic, _dataObj, _typeStr);
            } else {
              requestAnimationFrame(function () {
                callBackAll(_topic, _dataObj, _typeStr);
              });
            }
          }
        });
      }; //  Used to register for the event to listen


      this.on = function (_eventStr, _callBackFn) {
        // requestAnimationFrame(function() {
        if (typeof channels[_eventStr] === 'undefined') {
          channels[_eventStr] = [];
        }

        channels[_eventStr].push(_callBackFn); // });

      }; //  Used to unsubscribe/stop listening to the event


      this.off = function (_eventStr, _callBackFn) {
        requestAnimationFrame(function () {
          // delete channels[_eventStr]
          if (typeof channels[_eventStr] !== 'undefined') {
            for (var i = 0; i < channels[_eventStr].length; i++) {
              if (channels[_eventStr][i] === _callBackFn) {
                channels[_eventStr].splice(i, 1);
              }
            }
          }
        });
      }; // aa


      function callBackAll(_topic, _dataObj, _typeStr) {
        if (typeof channels[_topic] !== 'undefined') {
          for (var j = 0; j < channels[_topic].length; j++) {
            if (typeof channels[_topic][j] === 'function') {
              channels[_topic][j](_dataObj, _typeStr);
            }
          }
        }
      }
    },
    // ===================================================================================
    //  GLOBAL DEFINE FUNCTION
    // ===================================================================================
    defineObject: function defineObject(_obj, _key, _value) {
      Object.defineProperty(_obj, _key, {
        value: _value,
        writable: false,
        configurable: true,
        enumerable: true
      });
    },
    global_line_intersect: function global_line_intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      var ua;
      var ub;
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

      if (denom === 0) {
        return null;
      }

      ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
      ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
      return {
        x: x1 + ua * (x2 - x1),
        y: y1 + ub * (y2 - y1),
        seg1: ua >= 0 && ua <= 1,
        seg2: ub >= 0 && ub <= 1
      };
    },
    // ===================================================================================
    //  REQUEST IMAGE LOAD
    // ===================================================================================
    localImagePath: '',
    globalImagePath: '',
    requestLocalImage: function requestLocalImage(_imgArr, _callBackFn, _errorCnt) {
      var _imgObj = {};

      for (var i = 0; i < _imgArr.length; i++) {
        _imgObj[_imgArr[i]] = LabComClass.localImagePath + _imgArr[i];
      }

      LabComClass.imageLoader(_imgObj, _callBackFn, _errorCnt);
    },
    requestGlobalImage: function requestGlobalImage(_imgArr, _callBackFn, _errorCnt) {
      var _imgObj = {};

      for (var i = 0; i < _imgArr.length; i++) {
        _imgObj[_imgArr[i]] = LabComClass.globalImagePath + _imgArr[i];
      }

      LabComClass.imageLoader(_imgObj, _callBackFn, _errorCnt);
    },
    // ===================================================================================
    //  RGBA to Hexa
    // ===================================================================================
    rgba2hex: function rgba2hex(r, g, b, a) {
      if (r > 255 || g > 255 || b > 255 || a > 255) {
        throw 'Invalid color component';
      }

      return (256 + r).toString(16).substr(1) + ((1 << 24) + (g << 16) | b << 8 | a).toString(16).substr(1);
    },
    // ===================================================================================
    //  IMAGE LOADER CLASS
    // ===================================================================================
    imageLoader: function imageLoader(_imgObj, _callBackFn, _errorCnt) {
      var _dataObj = {};
      var _cnt = 0;
      var _arr = [];
      var _keys = [];
      var errorCnt = 0;

      if (typeof _errorCnt !== 'undefined') {
        errorCnt = _errorCnt;
      }

      var _maxRetries = 3;
      Object.keys(_imgObj).forEach(function (i) {
        _arr.push(_imgObj[i]);

        _keys.push(i);
      });

      function loadImage() {
        var key = _keys[_cnt];
        _dataObj[key] = new Image();
        _dataObj[key].onerror = onerror;
        _dataObj[key].onload = onloaded;
        _dataObj[key].src = _arr[_cnt];
      }

      loadImage();

      function onerror() {
        errorCnt += 1;

        if (errorCnt <= _maxRetries) {
          loadImage();
        } else {
          window.alert('There was an error loading a critical file for this lesson. The lesson needs to close'); // onViewUpdateCls.trigger('onGlobalUpdate', {
          //   type: 'onClosePlayerWindow'
          // });
        }
      } // ----------------------------


      function onloaded() {
        _cnt += 1;
        errorCnt = 0;

        if (_cnt === _arr.length) {
          _callBackFn(_dataObj);
        } else {
          loadImage();
        }
      }
    },
    // ===================================================================================
    //  GLOBAL EVENT CLASS FOR INTER FUNCTION COMMUNICATION
    // ===================================================================================
    BrowserDetect: {
      platformAndroid: function platformAndroid() {
        return !!navigator.userAgent.match(/Android/i);
      },
      platformBlackBerry: function platformBlackBerry() {
        return !!navigator.userAgent.match(/BlackBerry/i);
      },
      platformIOS: function platformIOS() {
        return navigator.userAgent.match(/iPhone|iPad|iPod|caireadymobile/i) ? true : navigator.maxTouchPoints > 0 && typeof window.orientation !== 'undefined';
      },
      platformWindows: function platformWindows() {
        return !!navigator.userAgent.match(/IEMobile/i);
      },
      isDevice: function isDevice() {
        return LabComClass.BrowserDetect.platformAndroid() || LabComClass.BrowserDetect.platformBlackBerry() || LabComClass.BrowserDetect.platformIOS() || LabComClass.BrowserDetect.platformWindows();
      },
      browserUserAgentName: function browserUserAgentName() {
        return navigator.userAgent;
      },
      ie9: function ie9() {
        return !!navigator.userAgent.match(/MSIE 9.0/i);
      },
      ie10: function ie10() {
        return !!navigator.userAgent.match(/MSIE 10.0/i);
      },
      ie: function ie() {
        return navigator.appName === 'Microsoft Internet Explorer' || !!(navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/rv:11/)) || navigator.userAgent.indexOf('MSIE') > 0 || !!navigator.userAgent.match(/Edge\/\d./i) || !!navigator.userAgent.match(/MSIE 9.0/i) || !!navigator.userAgent.match(/MSIE 10.0/i);
      }
    },
    // ================================================================================
    // GlobalAnimClass is accepts objects
    // id: Required to stop the particular animation.
    // fps (optional): Frame per second.
    // delay (optional): if delay given then fps will not work.
    // start (optional): Callback when the animation starts.
    // frame (optional): Callback when the animation is playing.
    // stop (optional): Callback when the animation stops.
    // ================================================================================
    GlobalAnimClass: function GlobalAnimClass() {
      var animObjects = {};

      var _thisObj = this;

      var animPlaying = false;
      var requestId; // ================================================================

      this.start = function (_obj) {
        if (_obj.id) {
          animObjects[_obj.id] = _obj;

          if (!_obj.immediate) {
            animObjects[_obj.id].oldDate = new Date();
          }

          animObjects[_obj.id].lastFrame = null;

          if (animObjects[_obj.id].start) {
            animObjects[_obj.id].start();
          }
        }

        if (!animPlaying) {
          animPlaying = true;
          enterFrame();
        }
      }; // ================================================================


      this.stop = function (_id) {
        if (_id) {
          if (animObjects[_id]) {
            if (animObjects[_id].stop) {
              animObjects[_id].stop();
            }

            if (animObjects[_id] !== undefined) {
              delete animObjects[_id];
            }
          }
        }

        if (objectSize(animObjects) === 0) {
          animPlaying = false;
          cancelAnimationFrame(requestId);
        }
      }; // ================================================================


      this.reset = function (_id) {
        animObjects[_id].resetVal = true;
      }; // ================================================================


      function enterFrame() {
        var _newDate = new Date(); // --------------------------


        Object.keys(animObjects).forEach(function (i) {
          if (animObjects[i].delay !== undefined) {
            if (typeof animObjects[i].oldDate === 'undefined' || _newDate - animObjects[i].oldDate >= animObjects[i].delay) {
              animObjects[i].oldDate = _newDate;

              if (animObjects[i].frame) {
                animObjects[i].frame(i);
              }
            }
          } else if (animObjects[i].fps !== undefined) {
            var _curFrame = Math.ceil((_newDate - animObjects[i].oldDate) / (1 / animObjects[i].fps * 1000));

            if (animObjects[i].lastFrame !== _curFrame) {
              if (animObjects[i].resetVal) {
                animObjects[i].oldDate = new Date();
                _curFrame = 1;
                animObjects[i].resetVal = null;
              }

              animObjects[i].lastFrame = _curFrame;

              if (animObjects[i].frame) {
                animObjects[i].frame({
                  id: i,
                  frame: _curFrame
                });
              }
            }
          }
        }); // --------------------------

        if (animPlaying) {
          requestId = requestAnimationFrame(enterFrame);
        }
      } // ================================================================


      function objectSize(obj) {
        var size = 0;
        var key;
        Object.keys(obj).forEach(function (key) {
          if (obj.hasOwnProperty(key)) {
            size++;
          }
        });
        return size;
      } // ================================================================
      // ================================================================


      (function () {
        var lastTime = 0;
        var vendors = ['webkit', 'moz'];

        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
          window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
          window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function () {
              callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
          };
        }

        if (!window.cancelAnimationFrame) {
          window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
          };
        }
      })();
    },
    // ================================================================================
    // ================================================================================
    //  STATIC MATH CONSTANTS
    // ================================================================================
    Maths: {
      // ================================================================================
      TO_DEGREES: 180 / Math.PI,
      TO_RADIANS: Math.PI / 180,
      // ================================================================================
      //  Returns a random number from a range.
      getRandomIntInclusive: function getRandomIntInclusive(min, max) {
        var minVal = Math.ceil(min);
        var maxVal = Math.floor(max);
        return Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal; // The maximum is inclusive and the minimum is inclusive
      },
      // Return random number with steps.
      getRandomNumber: function getRandomNumber(min, max, numOfDes, step) {
        var newRand = Math.random() * (max - min) + min;
        if (!step) return Number(newRand.toFixed(numOfDes));
        var temp = newRand + 0;
        newRand -= temp % step;
        return Number(newRand.toFixed(numOfDes));
      },
      // ================================================================================
      //  Returns distance between given points
      getDistance: function getDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      },
      getPointLineDistance: function getPointLineDistance(_pt, p1, p2) {
        var _dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        var _ans = 0;

        if (_dist > 0) {
          var _num = (p2.x - p1.x) * (p1.y - _pt.y) - (p2.y - p1.y) * (p1.x - _pt.x);

          _ans = _num / _dist;
        }

        return _ans;
      },
      // ================================================================================
      //  Returns angle between given points with optional parameter isRad.
      getAngle: function getAngle(_x1, _y1, _x2, _y2) {
        return Math.atan2(_y2 - _y1, _x2 - _x1);
      },
      // ================================================================================
      //  return Point Object with given angle and radius
      getPoint: function getPoint(p, angle, rad) {
        var temp = {};
        temp.x = parseFloat((p.x + rad * Math.cos(angle)).toFixed(5));
        temp.y = parseFloat((p.y + rad * Math.sin(angle)).toFixed(5));
        return temp;
      },
      getLineintersect2: function getLineintersect2(x1, y1, x2, y2, x3, y3, x4, y4) {
        var ua, ub;
        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

        if (denom === 0) {
          return null;
        }

        ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
        console.info('denom', denom);
        console.info('ua', ua);
        console.info('ub', ub);
        console.info('(x2 - x1)', x2 - x1);
        console.info('(y2 - y1)', x2 - x1);
        return {
          x: x1 + ua * (x2 - x1),
          y: y1 + ub * (y2 - y1),
          seg1: ua >= 0 && ua <= 1,
          seg2: ub >= 0 && ub <= 1
        };
      },
      getLinePointIntersection: function getLinePointIntersection(lineStart, lineEnd, point) {
        var lineAngle = LabComClass.Maths.getAngle(lineStart.x, lineStart.y, lineEnd.x, lineEnd.y);
        var perpandicularAngle = lineAngle + Math.PI / 2;
        var perpandicularPoint = LabComClass.Maths.getPoint(point, perpandicularAngle, 10);
        var intersectionPoint = LabComClass.Maths.getLineintersect(lineStart.x, lineStart.y, lineEnd.x, lineEnd.y, point.x, point.y, perpandicularPoint.x, perpandicularPoint.y);
        return intersectionPoint;
      },
      getLineintersect: function getLineintersect(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
        // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
        var denominator,
            a,
            b,
            numerator1,
            numerator2,
            result = {
          x: null,
          y: null,
          onLine1: false,
          onLine2: false
        };
        denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);

        if (denominator === 0) {
          return result;
        }

        a = line1StartY - line2StartY;
        b = line1StartX - line2StartX;
        numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
        numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
        a = numerator1 / denominator;
        b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:

        result.x = line1StartX + a * (line1EndX - line1StartX);
        result.y = line1StartY + a * (line1EndY - line1StartY);
        /*
                // it is worth noting that this should be the same as:
                x = line2StartX + (b * (line2EndX - line2StartX));
                y = line2StartX + (b * (line2EndY - line2StartY));
                */
        // if line1 is a segment and line2 is infinite, they intersect if:

        if (a > 0 && a < 1) {
          result.onLine1 = true;
        } // if line2 is a segment and line1 is infinite, they intersect if:


        if (b > 0 && b < 1) {
          result.onLine2 = true;
        } // if line1 and line2 are segments, they intersect if both of the above are true


        return result;
      },
      //
      getIntersectOfTwoCircles: function getIntersectOfTwoCircles(_x1, _y1, _r1, _x2, _y2, _r2) {
        // var rLX1,
        //   rLY1,
        //   gLX1,
        //   gLY1;
        // var radArr = [];
        // // ---------------------------
        // for (var i = 0; i <= (2 * Math.PI); i += 0.1) {
        //   var _rX1 = _x1 + (_r1 * Math.cos(i));
        //   var _rY1 = _y1 + (_r1 * Math.sin(i));
        //   for (var j = 0; j <= (2 * Math.PI); j += 0.1) {
        //     var _gX1 = _x2 + (_r2 * Math.cos(j));
        //     var _gY1 = _y2 + (_r2 * Math.sin(j));
        //     // ---------------------------
        //     if (gLX1 && gLY1 && rLX1 && rLY1) {
        //       var _inter = LabComClass.Maths.getLineintersect(_rX1, _rY1, rLX1, rLY1, _gX1, _gY1, gLX1, gLY1);
        //       if (_inter && _inter.seg1 && _inter.seg2) {
        //         radArr.push({
        //           t1: parseFloat((i * LabComClass.Maths.TO_DEGREES).toFixed(2), 10),
        //           t2: parseFloat((j * LabComClass.Maths.TO_DEGREES).toFixed(2), 10)
        //         });
        //       }
        //     }
        //     // ---------------------------
        //     gLX1 = _gX1;
        //     gLY1 = _gY1;
        //   }
        //   rLX1 = _rX1;
        //   rLY1 = _rY1;
        // }
        var _r = LabComClass.Maths.getDistance({
          x: _x1,
          y: _y1
        }, {
          x: _x2,
          y: _y2
        });

        var _cal = 0.5 * Math.sqrt(2 * (Math.pow(_r1, 2) + Math.pow(_r2, 2)) / Math.pow(_r, 2) - Math.pow(Math.pow(_r1, 2) - Math.pow(_r2, 2), 2) / Math.pow(_r, 4) - 1);

        var _p1X = 0.5 * (_x1 + _x2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_x2 - _x1) / (2 * Math.pow(_r, 2)) + _cal * (_y2 - _y1);

        var _p1Y = 0.5 * (_y1 + _y2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_y2 - _y1) / (2 * Math.pow(_r, 2)) + _cal * (_x1 - _x2);

        var _p2X = 0.5 * (_x1 + _x2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_x2 - _x1) / (2 * Math.pow(_r, 2)) - _cal * (_y2 - _y1);

        var _p2Y = 0.5 * (_y1 + _y2) + (Math.pow(_r1, 2) - Math.pow(_r2, 2)) * (_y2 - _y1) / (2 * Math.pow(_r, 2)) - _cal * (_x1 - _x2);

        return [{
          x: _p1X,
          y: _p1Y
        }, {
          x: _p2X,
          y: _p2Y
        }]; // return radArr;
      },
      findCirclesIntersect: function findCirclesIntersect(c1, c2) {
        var midPoint = {
          x: (c1.x + c2.x) / 2,
          y: (c1.y + c2.y) / 2
        };
        var distance = Math.abs(LabComClass.Maths.getDistance(c1, c2));
        var lengthHalf = distance / 2;
        var midPointAngle = LabComClass.Maths.getAngle(c1.x, c1.y, midPoint.x, midPoint.y);
        var axis = Math.sqrt(c1.r * c1.r - lengthHalf * lengthHalf);
        var point1 = LabComClass.Maths.getPoint(midPoint, Math.PI / 2 + midPointAngle, axis);
        var point2 = LabComClass.Maths.getPoint(midPoint, Math.PI / 2 + midPointAngle, -1 * axis);
        point1.type = 'point';
        point2.type = 'point';
        var intersections = [];

        if (!isNaN(point1.x)) {
          intersections.push(point1);
        }

        if (!isNaN(point2.x)) {
          intersections.push(point2);
        }

        return intersections;
      },
      pointInSegment: function pointInSegment(point, segmentStart, segmentEnd) {
        if (point) {
          var segmentDist = LabComClass.Maths.getDistance(segmentStart, segmentEnd);
          var distFromStart = LabComClass.Maths.getDistance(point, segmentStart);
          var distFromEnd = LabComClass.Maths.getDistance(point, segmentEnd);

          if (distFromStart <= segmentDist && distFromEnd <= segmentDist) {
            return true;
          }
        }

        return false;
      },
      findCircleLineIntersect: function findCircleLineIntersect(circle, lineStart, lineEnd) {
        var m = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x);
        var c1 = lineStart.y - m * lineStart.x;
        var a = Math.pow(m, 2) + 1;
        var b = -2 * circle.x + 2 * m * c1 - 2 * m * circle.y;
        var c = Math.pow(circle.x, 2) + Math.pow(c1, 2) + Math.pow(circle.y, 2) - 2 * c1 * circle.y - Math.pow(circle.r, 2);
        var x1 = (-1 * b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
        var x2 = (-1 * b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
        var p1 = {
          type: 'point',
          x: x1,
          y: m * x1 + c1
        };
        var p2 = {
          type: 'point',
          x: x2,
          y: m * x2 + c1
        };

        if (isNaN(x1)) {
          var topPoint = {
            type: 'point',
            x: circle.x,
            y: circle.y - circle.r
          };
          var bottomPoint = {
            type: 'point',
            x: circle.x,
            y: circle.y + circle.r
          };

          if (LabComClass.Maths.getPointLineDistance(topPoint, lineStart, lineEnd) === 0) {
            p1 = topPoint;
          }

          if (LabComClass.Maths.getPointLineDistance(bottomPoint, lineStart, lineEnd) === 0) {
            p2 = bottomPoint;
          }
        }

        p1 = isNaN(p1.x) ? null : p1;
        p2 = isNaN(p2.x) ? null : p2;

        function checkInSegment(point, lineS, lineE) {
          if (point) {
            var segmentDist = LabComClass.Maths.getDistance(lineS, lineE);
            var distFromStart = LabComClass.Maths.getDistance(point, lineS);
            var distFromEnd = LabComClass.Maths.getDistance(point, lineE);

            if (distFromStart <= segmentDist && distFromEnd <= segmentDist) {
              point.isInSegment = true;
            } else {
              point.isInSegment = false;
            }
          }
        }

        checkInSegment(p1, lineStart, lineEnd);
        checkInSegment(p2, lineStart, lineEnd);
        return {
          p1: p1,
          p2: p2
        };
      }
    },
    // eslint-disable-next-line object-shorthand
    Vector: function Vector(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;

      this.reset = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      };

      this.toString = function (decPlaces) {
        decPlaces = decPlaces || 3;
        var scalar = Math.pow(10, decPlaces);
        return '[' + Math.round(this.x * scalar) / scalar + ', ' + Math.round(this.y * scalar) / scalar + ', ' + Math.round(this.z * scalar) / scalar + ']';
      };

      this.clone = function () {
        return new LabComClass.Vector(this.x, this.y, this.z);
      };

      this.copyTo = function (v) {
        v.x = this.x;
        v.y = this.y;
        v.z = this.z;
      };

      this.copyFrom = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
      };

      this.magnitude = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      };

      this.normalise = function () {
        var m = this.magnitude();
        this.x = this.x / m;
        this.y = this.y / m;
        this.z = this.z / m;
        return this;
      };

      this.reverse = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      };

      this.plusEq = function (v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      };

      this.plusNew = function (v) {
        return new LabComClass.Vector(this.x + v.x, this.y + v.y, this.z + v.z);
      };

      this.minusEq = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      };

      this.getNormal = function () {
        return new LabComClass.Vector(-this.y, this.x, this.z);
      };

      this.minusNew = function (v) {
        return new LabComClass.Vector(this.x - v.x, this.y - v.y, this.z - v.z);
      };

      this.multiplyEq = function (scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      };

      this.multiplyNew = function (scalar) {
        var returnvec = this.clone();
        return returnvec.multiplyEq(scalar);
      };

      this.divideEq = function (scalar) {
        this.x /= scalar;
        this.y /= scalar;
        this.z /= scalar;
        return this;
      };

      this.divideNew = function (scalar) {
        var returnvec = this.clone();
        return returnvec.divideEq(scalar);
      };

      this.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      };

      this.angle = function (useRadians) {
        return Math.atan2(this.y, this.x) * (useRadians ? 1 : LabComClass.Maths.TO_DEGREES);
      };

      this.rotate = function (angle, useRadians) {
        var cosRY = Math.cos(angle * (useRadians ? 1 : LabComClass.Maths.TO_RADIANS));
        var sinRY = Math.sin(angle * (useRadians ? 1 : LabComClass.Maths.TO_RADIANS));
        var VectorConst = {
          clone: new LabComClass.Vector()
        };
        VectorConst.clone.copyFrom(this);
        this.x = VectorConst.clone.x * cosRY - VectorConst.clone.y * sinRY;
        this.y = VectorConst.clone.x * sinRY + VectorConst.clone.y * cosRY;
        return this;
      };

      this.equals = function (v) {
        return this.x === v.x && this.y === v.x;
      };

      this.length = function () {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));
      };

      this.angleBetween = function (v) {
        this.z = this.z === undefined ? 0 : this.z;
        v.z = v.z === undefined ? 0 : v.z;
        return Math.acos((this.x * v.x + this.y * v.y + this.z * v.z) / (Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2)) * Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2) + Math.pow(v.z, 2))));
      };

      this.crossProduct = function (v) {
        var x = this.y * v.z - this.z * v.y;
        var y = this.x * v.z - this.z * v.x;
        var z = this.x * v.y - this.y * v.x;
        return new LabComClass.Vector(x, y, z);
      };

      return this;
    },
    // eslint-disable-next-line object-shorthand
    Matrix: function Matrix(arr, m, n) {
      // Private variables
      var _thisRef = this; // Public variables


      this.elements = []; // ===================================================
      // Private Functions
      // ===================================================

      function init(arg) {
        if (arg) {
          _thisRef.setElements(arg);
        }
      } // ===================================================
      // Public Functions
      // ===================================================
      //++++++++++++++++++++++++++++++++++++++++++++++++++++


      this.setElements = function (a) {
        var i,
            elements = a.elements || a;

        if (typeof elements[0][0] !== 'undefined') {
          var b = elements.length,
              ki = b,
              nj,
              kj,
              j;
          this.elements = [];

          do {
            i = ki - b;
            nj = elements[i].length;
            kj = nj;
            this.elements[i] = [];

            do {
              j = kj - nj;
              this.elements[i][j] = elements[i][j];
            } while (--nj);
          } while (--b);

          return this;
        }

        var n = elements.length,
            k = n;
        this.elements = [];

        do {
          i = k - n;
          this.elements.push([elements[i]]);
        } while (--n);

        return this;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return element of given index


      this.elem = function (i, j) {
        if (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) {
          return null;
        }

        return this.elements[i - 1][j - 1];
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return whole row of given number


      this.row = function (i) {
        if (i > this.elements.length) {
          return null;
        }

        return this.elements[i - 1];
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return whole column of given number


      this.col = function (j) {
        if (j > this.elements[0].length) {
          return null;
        }

        var a = [],
            n = this.elements.length,
            k = n * 1,
            i;

        do {
          i = k - n;
          a.push(this.elements[i][j - 1]);
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns number of Rows and columns in array


      this.dimensions = function () {
        return {
          rows: this.elements.length,
          cols: this.elements[0].length
        };
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns number of Rows


      this.rows = function () {
        return this.elements.length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns number of Columns


      this.cols = function () {
        return this.elements[0].length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Check if given matrix is equal with current matrix


      this.eql = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === 'undefined') {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (this.elements.length !== M.length || this.elements[0].length !== M[0].length) {
          return false;
        }

        var b = this.elements.length,
            ki = b,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - b;
          nj = kj;

          do {
            j = kj - nj;

            if (Math.abs(this.elements[i][j] - M[i][j]) > 0) {
              return false;
            }
          } while (--nj);
        } while (--b);

        return true;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return duplicate matrix


      this.dup = function () {
        return new LabComClass.Matrix().setElements(this.elements);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Maps the receiver to another matrix by calling iterator on each element of the receiver in turn. iterator receives the row and column index of each element as second and third arguments. Some examples:


      this.map = function (a) {
        var b = [],
            ni = this.elements.length,
            ki = ni,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - ni;
          nj = kj;
          b[i] = [];

          do {
            j = kj - nj;
            b[i][j] = a(this.elements[i][j], i + 1, j + 1);
          } while (--nj);
        } while (--ni);

        return new LabComClass.Matrix().setElements(b);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Check if number of rows and columns are same of given matrix with respect to current matrix


      this.isSameSizeAs = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === 'undefined') {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        return this.elements.length === M.length && this.elements[0].length === M[0].length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Add Matrix


      this.add = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === 'undefined') {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (!this.isSameSizeAs(M)) {
          return null;
        }

        return this.map(function (x, i, j) {
          return x + M[i - 1][j - 1];
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Subtract Matrix


      this.subtract = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === 'undefined') {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (!this.isSameSizeAs(M)) {
          return null;
        }

        return this.map(function (x, i, j) {
          return x - M[i - 1][j - 1];
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // A.canMultiplyFromLeft(B) returns true if AB is a mathematically valid expression.
      // This is the case if A has the same number of columns as B has rows.
      // Matrix can also be a Vector, as long as it has the same number of elements as the receiver has rows.


      this.canMultiplyFromLeft = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === 'undefined') {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        return this.elements[0].length === M.length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Return Multiplication of Matrix


      this.multiply = function (a) {
        if (!a.elements) {
          return this.map(function (x) {
            return x * a;
          });
        }

        var b = !!a.modulus;
        var M = a.elements || a;

        if (typeof M[0][0] === 'undefined') {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        if (!this.canMultiplyFromLeft(M)) {
          return null;
        }

        var d = this.elements.length,
            ki = d,
            i,
            nj,
            kj = M[0].length,
            j;
        var e = this.elements[0].length,
            elements = [],
            sum,
            nc,
            c;

        do {
          i = ki - d;
          elements[i] = [];
          nj = kj;

          do {
            j = kj - nj;
            sum = 0;
            nc = e;

            do {
              c = e - nc;
              sum += this.elements[i][c] * M[c][j];
            } while (--nc);

            elements[i][j] = sum;
          } while (--nj);
        } while (--d);

        M = new LabComClass.Matrix().setElements(elements);
        return b ? M.col(1) : M;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for multiply


      this.x = function (a) {
        return this.multiply(a);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // This method returns a matrix formed from a subset of the receiver’s elements. It selects elements beginning at row i and column j of the receiver, and returns a matrix with n rows and m columns. The selection wraps to the other side of the receiver if n or m is large enough.


      this.minor = function (a, b, c, d) {
        var e = [],
            ni = c,
            i,
            nj,
            j;
        var f = this.elements.length,
            cols = this.elements[0].length;

        do {
          i = c - ni;
          e[i] = [];
          nj = d;

          do {
            j = d - nj;
            e[i][j] = this.elements[(a + i - 1) % f][(b + j - 1) % cols];
          } while (--nj);
        } while (--ni);

        return new LabComClass.Matrix().setElements(e);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the matrix transpose of the receiver.


      this.transpose = function () {
        var a = this.elements.length,
            cols = this.elements[0].length;
        var b = [],
            ni = cols,
            i,
            nj,
            j;

        do {
          i = cols - ni;
          b[i] = [];
          nj = a;

          do {
            j = a - nj;
            b[i][j] = this.elements[j][i];
          } while (--nj);
        } while (--ni);

        return new LabComClass.Matrix().setElements(b);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns true if the receiver is square.


      this.isSquare = function () {
        return this.elements.length === this.elements[0].length;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the value of the element of the receiver with the largest absolute value.


      this.max = function () {
        var m = 0,
            ni = this.elements.length,
            ki = ni,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - ni;
          nj = kj;

          do {
            j = kj - nj;

            if (Math.abs(this.elements[i][j]) > Math.abs(m)) {
              m = this.elements[i][j];
            }
          } while (--nj);
        } while (--ni);

        return m;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Reads the receiver’s elements row by row from left to right and returns an object containing the indexes of the first exact match. Returns null if no match is found.


      this.indexOf = function (x) {
        var a = null,
            ni = this.elements.length,
            ki = ni,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - ni;
          nj = kj;

          do {
            j = kj - nj;

            if (this.elements[i][j] === x) {
              return {
                i: i + 1,
                j: j + 1
              };
            }
          } while (--nj);
        } while (--ni);

        return null;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // If the receiver is square, returns its leading-diagonal elements as a Array. Otherwise, returns null.


      this.diagonal = function () {
        if (!this.isSquare) {
          return null;
        }

        var a = [],
            n = this.elements.length,
            k = n,
            i;

        do {
          i = k - n;
          a.push(this.elements[i][i]);
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a copy of the receiver converted to right triangular form. The conversion is done only by adding multiples of rows to other rows, so the determinant (if the matrix is square) is unchanged. This method can be used on non-square matrices, which lets you use it to solve sets of simultaneous equations.


      this.toRightTriangular = function () {
        var M = this.dup(),
            els;
        var n = this.elements.length,
            k = n,
            i,
            np,
            kp = this.elements[0].length,
            p;

        do {
          i = k - n;

          if (M.elements[i][i] === 0) {
            for (var j = i + 1; j < k; j++) {
              if (M.elements[j][i] !== 0) {
                els = [];
                np = kp;

                do {
                  p = kp - np;
                  els.push(M.elements[i][p] + M.elements[j][p]);
                } while (--np);

                M.elements[i] = els;
                break;
              }
            }
          }

          if (M.elements[i][i] !== 0) {
            for (j = i + 1; j < k; j++) {
              var a = M.elements[j][i] / M.elements[i][i];
              els = [];
              np = kp;

              do {
                p = kp - np;
                els.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * a);
              } while (--np);

              M.elements[j] = els;
            }
          }
        } while (--n);

        return M;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for toRightTriangular.


      this.toUpperTriangular = function () {
        return this.toRightTriangular();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // If the receiver is square, returns its determinant, otherwise returns null. Note that if the receiver is singular, this method will return exactly zero, with no rounding errors.


      this.determinant = function () {
        if (!this.isSquare()) {
          return null;
        }

        var M = this.toRightTriangular();
        var a = M.elements[0][0],
            n = M.elements.length - 1,
            k = n,
            i;

        do {
          i = k - n + 1;
          a *= M.elements[i][i];
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      //  Alias for determinant.


      this.det = function () {
        return this.determinant();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns true if the receiver is square and has zero determinant.


      this.isSingular = function () {
        return this.isSquare() && this.determinant() === 0;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the trace for square matrices, which is the sum of their leading-diagonal elements.


      this.trace = function () {
        if (!this.isSquare()) {
          return null;
        }

        var a = this.elements[0][0],
            n = this.elements.length - 1,
            k = n,
            i;

        do {
          i = k - n + 1;
          a += this.elements[i][i];
        } while (--n);

        return a;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for trace.


      this.tr = function () {
        return this.trace();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the receiver’s rank, which is the number of linearly independent rows/columns it contains.


      this.rank = function () {
        var M = this.toRightTriangular(),
            rank = 0;
        var a = this.elements.length,
            ki = a,
            i,
            nj,
            kj = this.elements[0].length,
            j;

        do {
          i = ki - a;
          nj = kj;

          do {
            j = kj - nj;

            if (Math.abs(M.elements[i][j]) > 0) {
              rank++;
              break;
            }
          } while (--nj);
        } while (--a);

        return rank;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for rank.


      this.rk = function () {
        return this.rank();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the result of augmenting the receiver with matrix, that is, appending matrix to the right hand side of the receiver. Both matrices must have the same number of rows for this to work.


      this.augment = function (a) {
        var M = a.elements || a;

        if (typeof M[0][0] === 'undefined') {
          M = new LabComClass.Matrix().setElements(M).elements;
        }

        var T = this.dup(),
            cols = T.elements[0].length;
        var b = T.elements.length,
            ki = b,
            i,
            nj,
            kj = M[0].length,
            j;

        if (b !== M.length) {
          return null;
        }

        do {
          i = ki - b;
          nj = kj;

          do {
            j = kj - nj;
            T.elements[i][cols + j] = M[i][j];
          } while (--nj);
        } while (--b);

        return T;
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns the matrix inverse of the receiver, if one exists. If the matrix is singular or not square, then null is returned. The inverse is computed using Gauss-Jordan elimination.


      this.inverse = function () {
        if (!this.isSquare() || this.isSingular()) {
          return null;
        }

        var a = this.elements.length,
            ki = a,
            i,
            j;
        var M = this.augment(LabComClass.Matrix.I(a)).toRightTriangular();
        var b,
            kp = M.elements[0].length,
            p,
            els,
            divisor;
        var c = [],
            new_element;

        do {
          i = a - 1;
          els = [];
          b = kp;
          c[i] = [];
          divisor = M.elements[i][i];

          do {
            p = kp - b;
            new_element = M.elements[i][p] / divisor;
            els.push(new_element);

            if (p >= ki) {
              c[i].push(new_element);
            }
          } while (--b);

          M.elements[i] = els;

          for (j = 0; j < i; j++) {
            els = [];
            b = kp;

            do {
              p = kp - b;
              els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);
            } while (--b);

            M.elements[j] = els;
          }
        } while (--a);

        return new LabComClass.Matrix().setElements(c);
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Alias for inverse.


      this.inv = function () {
        return this.inverse();
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a copy of the receiver with all its elements rounded to the nearest integer.


      this.round = function () {
        return this.map(function (x) {
          return Math.round(x);
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a copy of the receiver in which any elements that differ from x by less than the value of 0 are set exactly equal to x.


      this.snapTo = function (x) {
        return this.map(function (p) {
          return Math.abs(p - x) <= 0 ? x : p;
        });
      }; //++++++++++++++++++++++++++++++++++++++++++++++++++++
      // Returns a string representation of the receiver, useful for debugging.


      this.inspect = function () {
        var a = [];
        var n = this.elements.length,
            k = n,
            i;

        do {
          i = k - n;
          a.push('[' + this.elements[i].join(', ') + ']');
        } while (--n);

        return a.join('\n');
      };

      this.RotationZ = function (t) {
        var c = Math.cos(t),
            s = Math.sin(t);
        return new LabComClass.Matrix().setElements([[c, -s, 0], [s, c, 0], [0, 0, 1]]);
      }; //


      init(arr);
    },
    // ================================================================================
    //  Calculate Senetence Highlight
    // ================================================================================
    calculateSentenceHighlight: function calculateSentenceHighlight(_charArr, _lineHeightInt, _data) {
      // console.log(_charArr, _lineHeightInt, _data);
      var _tempArr = [];
      var _lineObj = {};
      var _leftArr = [];
      var rightArr = [];
      var _maxFontSize = 0;

      _charArr.forEach(function (e, i) {
        if (i >= _data.s && i <= _data.e) {
          if (typeof e.lineIndex === 'number') {
            if (!_lineObj.hasOwnProperty(e.lineIndex)) {
              if (_maxFontSize < e.maxFontSize) {
                _maxFontSize = e.maxFontSize;
              }

              _lineObj[e.lineIndex] = [];
            }

            _lineObj[e.lineIndex].push(e);
          }
        }
      });

      var _lastWordIndex;

      var _len = Object.keys(_lineObj).length - 1;

      Object.keys(_lineObj).forEach(function (i) {
        _lastWordIndex = _lineObj[i].length - 1;

        if (_lineObj[i][_lastWordIndex].value === ' ') {
          _lastWordIndex -= 1;
        }

        var tempYint = 0;

        if (_lineObj[i][0].fontSizeNum < _maxFontSize) {
          tempYint = (_maxFontSize - _lineObj[i][0].fontSizeNum) / 2;
        }

        _leftArr.push({
          xInt: _lineObj[i][0].x,
          yInt: _lineObj[i][0].y - _lineHeightInt / 2 - tempYint
        }, {
          xInt: _lineObj[i][0].x,
          // yInt: _lineObj[i][0].y + _maxFontSize + (_lineHeightInt / 2) - tempYint
          yInt: _lineObj[i][0].y + _lineObj[i][0].fontSizeNum + _lineHeightInt / 2 + tempYint
        });

        rightArr.push({
          xInt: _lineObj[i][_lastWordIndex].x + _lineObj[i][_lastWordIndex].w,
          yInt: _lineObj[i][_lastWordIndex].y - _lineHeightInt / 2 - tempYint
        }, {
          xInt: _lineObj[i][_lastWordIndex].x + _lineObj[i][_lastWordIndex].w,
          // yInt: _lineObj[i][_lastWordIndex].y + _maxFontSize + (_lineHeightInt / 2) - tempYint
          yInt: _lineObj[i][_lastWordIndex].y + _lineObj[i][_lastWordIndex].fontSizeNum + _lineHeightInt / 2 + tempYint
        });
      });

      if (_leftArr.length > 0 && rightArr.length > 0) {
        _leftArr.forEach(function (e, i) {
          rightArr.push(_leftArr[_leftArr.length - 1 - i]);
        });
      }

      return rightArr;
    },
    // ================================================================================
    //  get underline points
    // ================================================================================
    getUnderline: function getUnderline(_charArr, _data) {
      // console.log(_charArr, _data);
      var s = _data.s;
      var e = _data.e;
      var pointArr = [s];
      var breakPointArr = [];

      for (var i = 0; i < _charArr.length; i += 1) {
        if (i >= s && i <= e) {
          if (typeof _charArr[i + 1] !== 'undefined') {
            if (_charArr[i].lineIndex !== _charArr[i + 1].lineIndex) {
              pointArr.push(i);

              if (i + 1 <= e) {
                pointArr.push(i + 1);
              }
            }
          }
        }
      }

      if (pointArr.indexOf(e) === -1) {
        pointArr.push(e);
      }

      if (pointArr.length % 2 !== 0) {
        pointArr.push(e);
      }

      return pointArr;
    },
    // ================================================================================
    //  Text Wrapper New Class
    // ================================================================================
    TextImgNewClass: function TextImgNewClass(obj) {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d'); // ============================

      var devicePixelRatio = window.devicePixelRatio || 1;
      var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
      var ratio = devicePixelRatio / backingStoreRatio; // ===========================

      var modelObj = {
        textStr: '',
        style: {},
        callback: function callback() {}
      };
      Object.keys(obj).forEach(function (key) {
        modelObj[key] = obj[key];
      }); // Stylemarker modification

      modelObj.textStr = modelObj.textStr.replace(/§b/g, '<span style="font-family: OpenSans-Bold;">');
      modelObj.textStr = modelObj.textStr.replace(/§i/g, '<span style="font-family: OpenSans-Italic;">');
      modelObj.textStr = modelObj.textStr.replace(/§t/g, '<span style="font-family: OpenSans-BoldItalic;">');
      modelObj.textStr = modelObj.textStr.replace(/§l/g, '<span style="font-family: Alef-Light;">');
      modelObj.textStr = modelObj.textStr.replace(/§r/g, '</span>');

      var _div = document.createElement('div');

      _div.style.position = 'absolute';
      _div.style.left = '0px';
      _div.style.top = '0px';
      _div.style.visibility = 'hidden';
      Object.keys(modelObj.style).forEach(function (key) {
        _div.style[key] = modelObj.style[key];
      });
      _div.innerHTML = modelObj.textStr;
      document.body.appendChild(_div);
      _div.style.height = "".concat(_div.offsetHeight + 5, "px");
      LabComClass.html2CanvasQueueArr.push({
        div: _div,
        callback: modelObj.callback
      });
      LabComClass.executeHtml2canvas();
    },
    executeHtml2canvas: function executeHtml2canvas() {
      if (!LabComClass.html2CanvasQueueStarted) {
        LabComClass.html2CanvasQueueStarted = true; // console.log('executeHtml2canvas started');

        var _obj = LabComClass.html2CanvasQueueArr[0];
        html2canvas(_obj.div, {
          pixelRatio: 2,
          onrendered: function onrendered(canvas) {
            function loadOrErr() {
              LabComClass.html2CanvasQueueArr.splice(0, 1); // console.log('executeHtml2canvas completed', LabComClass.html2CanvasQueueArr.length);

              LabComClass.html2CanvasQueueStarted = false;

              if (LabComClass.html2CanvasQueueArr.length > 0) {
                LabComClass.executeHtml2canvas();
              }
            }

            var _width = _obj.div.offsetWidth;
            var _height = _obj.div.offsetHeight;
            document.body.removeChild(_obj.div);
            _obj.div = null;
            var img = new Image();

            img.onload = function () {
              _obj.callback({
                imageObj: {
                  imageObj: img,
                  widthInt: _width,
                  heightInt: _height
                }
              });

              loadOrErr();
            };

            img.onerror = function () {
              loadOrErr();
            };

            img.src = canvas.toDataURL();
          }
        });
      }
    },
    // ================================================================================
    //  Text Wrapper Class
    // ================================================================================
    TextImgClass: function TextImgClass(style, message, callback) {
      var scaleVal = 4;

      var pre = document.createElement('pre'),
          canvas = document.createElement('canvas'),
          context = canvas.getContext('2d'),
          _style = {
        fontFamilyStr: 'Polo22Klett-Regular',
        align: 'left',
        color: '#000000',
        fontSizeNum: 16,
        background: 'rgba(0, 0, 0, 0)',
        stroke: 0,
        fontFormat: 'px ',
        strokeColor: '#FFFFFF',
        lineHeight: '1.5em',
        bold: false,
        italic: false
      },
          thisObj = this,
          _str,
          _tempArr,
          preStyle = ';padding: 0; display: block; position: fixed; top: 100%; overflow: hidden;';

      message = message || style.textStr || '';
      context.save();
      style = style || {};
      Object.keys(_style).forEach(function (key) {
        if (!style[key]) {
          style[key] = _style[key];
        }
      });
      _style = 'font: ';

      if (style.italic || message.indexOf(LabComClass.italic) >= 0 || message.indexOf(LabComClass.italicbold) >= 0 || message.indexOf(LabComClass.italicDistance) >= 0) {
        _style += 'italic ';
      }

      if (style.bold || message.indexOf(LabComClass.bold) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
        _style += 'bold ';
      }

      _style += style.fontSizeNum + style.fontFormat + style.fontFamilyStr + ';';
      _style += 'line-height:' + style.lineHeight + ';';
      _style += 'text-align: ' + style.align + ';';
      _style += 'color: ' + style.color + ';';
      _style += 'background-color: ' + style.background + ';';
      _style += preStyle;
      _str = String(message);

      if (_str.indexOf(LabComClass.subscript) >= 0) {
        style.yNum += Math.round(style.fontSizeNum / 5);
      }

      pre.innerText = _str;

      if (style.maxWidthNum) {
        _style += 'max-width: ' + style.maxWidthNum + 'px; word-spacing: normal;word-break: keep-all; white-space: pre-wrap; white-space: -moz-pre-wrap;white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word';
      }

      pre.setAttribute('style', _style);
      document.body.appendChild(pre);
      var lines = [],
          _tempLine = [];
      var context_font = '';

      if (style.italic) {
        context_font += 'italic ';
      }

      if (style.bold) {
        context_font += 'bold ';
      }

      if (style.italic && style.bold) {
        message = LabComClass.italicbold + message + LabComClass.end;
      } else if (style.italic) {
        message = LabComClass.italic + message + LabComClass.end;
      } else if (style.bold) {
        message = LabComClass.bold + message + LabComClass.end;
      }

      context_font += style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = style.align;
      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;
      var width = style.maxWidthNum;

      if (style.maxWidthNum && message.indexOf('\n') === -1) {
        var result = message.split(' '); // console.log('RESULT', result);

        var _lineText = '';

        while (result.length > 0) {
          if (context.measureText(_lineText).width + context.measureText(result[0]).width >= style.maxWidthNum) {
            // _bool = false;
            lines.push(_lineText);
            _lineText = '';
          }

          if (_lineText === '') {
            _lineText = "".concat(result[0]);
          } else {
            _lineText = "".concat(_lineText, " ").concat(result[0]);
          }

          result.splice(0, 1);
        }

        lines.push(_lineText); // while (message.length) {
        //   for (var i = message.length; context.measureText(message.substr(0, i)).width > style.maxWidthNum; i--);
        //   var result = message.substr(0, i);
        //   if (i !== message.length) {
        //     for (var j = 0; result.indexOf(' ', j) !== -1; j = result.indexOf(' ', j) + 1);
        //   }
        //   lines.push(result.substr(0, j || result.length));
        //   var width = Math.max(width, context.measureText(lines[lines.length - 1]).width);
        //   message = message.substr(lines[lines.length - 1].length, message.length);
        // }
      } else {
        lines = message.split('\n');
      }

      lines.forEach(function (val, i) {
        _tempLine[i] = val;
        _tempLine[i] = _tempLine[i].replace(LabComClass.bold, '');
        _tempLine[i] = _tempLine[i].replace(LabComClass.italic, '');
        _tempLine[i] = _tempLine[i].replace(LabComClass.italicbold, '');
        _tempLine[i] = _tempLine[i].replace(LabComClass.italicDistance, '');
        _tempLine[i] = _tempLine[i].replace(LabComClass.end, '');
      });
      var x = style.stroke,
          y = pre.offsetHeight / lines.length,
          base = y * 0.25;
      canvas.width = (width + style.xNum * 2) * scaleVal;
      canvas.height = (pre.offsetHeight + style.yNum * 2) * scaleVal;
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = style.background;
      context.beginPath();
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.fill();
      context_font = ''; // add bold/italic

      if (style.italic) {
        context_font += 'italic ';
      }

      if (style.bold) {
        context_font += 'bold ';
      } // append size, font


      context_font = style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = 'left'; // style.align;

      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;

      switch (style.align) {
        case 'center':
          x = canvas.width / scaleVal / 2;
          break;

        case 'right':
          x = canvas.width / scaleVal;
          break;

        default:
          break;
      }

      var _x, width;

      context.scale(scaleVal, scaleVal);
      lines.forEach(function (line, i) {
        if (style.align === 'center') {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width / 2;
        } else if (style.align === 'right') {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width;
        } else {
          _x = x;
        } // width = context.measureText(_tempLine[i]).width;
        // switch (style.align) {
        //   case 'center':
        //     _x = x - width / 2;
        //     break;
        //   case 'right':
        //     _x = x - width;
        //     break;
        //   default:
        //     _x = x;
        //     break;
        // }
        // _x = x;


        var text;

        if (style.bold) {
          text = LabComClass.bold + _tempLine[i] + LabComClass.end;
        } else {
          text = line;
        }

        if (style.stroke) {
          context.strokeText(text, _x + style.xNum, y * (i + 1) + style.yNum);
        } // context.fillText()


        context.drawStyledText(text, _x + style.xNum, y * (i + 1) - base + style.yNum, style.fontFamilyStr, style.fontSizeNum); // context.fillText(line, x + style.xNum, y * (i + 1) - base + style.yNum);
      });
      context.restore();
      setTimeout(function () {
        document.body.removeChild(pre);
      }, 100);
      var img = new Image();

      if (callback) {
        img.onload = callback;
      }

      img.src = canvas.toDataURL();
      return {
        imageObj: {
          imageObj: img,
          widthInt: canvas.width / scaleVal,
          heightInt: canvas.height / scaleVal
        }
      };
    },
    TextImgV2Class: function TextImgV2Class(style, message, callback) {
      var scaleVal = 4;
      /* Define function for escaping user input to be treated as
      a literal string within a regular expression */

      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }
      /* Define functin to find and replace specified term with replacement string */


      function replaceAll(str, term, replacement) {
        return str.replace(new RegExp(escapeRegExp(term), 'g'), replacement);
      }

      var pre = document.createElement('pre'),
          canvas = document.createElement('canvas'),
          context = canvas.getContext('2d'),
          _style = {
        fontFamilyStr: LabComClass.AlefFontRegular,
        align: 'left',
        color: '#000000',
        fontSizeNum: 16,
        background: 'rgba(0, 0, 0, 0)',
        stroke: 0,
        fontFormat: 'px ',
        strokeColor: '#FFFFFF',
        lineHeight: '1.5em',
        bold: false,
        italic: false
      },
          thisObj = this,
          _str,
          _tempArr,
          preStyle = ';padding: 0; display: block; position: fixed; top: 100%; overflow: hidden;';

      message = message || style.textStr || '';
      style = style || {};
      Object.keys(_style).forEach(function (key) {
        if (!style[key]) {
          style[key] = _style[key];
        }
      });
      _style = 'font: '; // if (style.italic || message.indexOf(LabComClass.italic) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
      //   _style += 'italic ';
      // }
      // if (style.bold || message.indexOf(LabComClass.bold) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
      //   _style += 'bold ';
      // }

      if (style.italic || message.indexOf(LabComClass.italic) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
        _style += ' ';
      }

      if (style.bold || message.indexOf(LabComClass.bold) >= 0 || message.indexOf(LabComClass.italicbold) >= 0) {
        _style += ' ';
      }

      _style += style.fontSizeNum + style.fontFormat + style.fontFamilyStr + ';';
      _style += 'line-height:' + style.lineHeight + ';';
      _style += 'text-align: ' + style.align + ';';
      _style += 'color: ' + style.color + ';';
      _style += 'background-color: ' + style.background + ';';
      _style += preStyle;
      _str = String(message);

      if (_str.indexOf(LabComClass.subscript) >= 0) {
        style.yNum += Math.round(style.fontSizeNum / 5);
      }

      var support = function () {
        if (!window.DOMParser) return false;
        var parser = new DOMParser();

        try {
          parser.parseFromString('x', 'text/html');
        } catch (err) {
          return false;
        }

        return true;
      }();

      var textToHTML = function textToHTML(str) {
        // check for DOMParser support
        // if (support) {
        //   var parser = new DOMParser();
        //   var doc = parser.parseFromString(str, 'text/html');
        //   return doc.body.innerHTML;
        // }
        // Otherwise, create div and append HTML
        var dom = document.createElement('pre');
        dom.innerHTML = str;
        return dom;
      };

      _str = replaceAll(_str, '</d>', '');
      _str = replaceAll(_str, '<d>', '');
      _str = replaceAll(_str, '§p', '');
      _str = replaceAll(_str, '§q', '');
      _str = replaceAll(_str, '§Q', '');
      _str = replaceAll(_str, '§d', '');

      while (_str.includes('<c>')) {
        var index = _str.indexOf('<c>');

        var index2 = _str.indexOf('</c>');

        _str = _str.substring(0, index) + _str.substring(index + 9, index2) + _str.substring(index2 + 4);
      }

      pre = textToHTML(_str);
      pre.innerHTML = _str;

      if (style.maxWidthNum) {
        _style += 'max-width: ' + style.maxWidthNum + 'px; word-spacing: normal;word-break: keep-all; white-space: pre-wrap; white-space: -moz-pre-wrap;white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word';
      }

      pre.setAttribute('style', _style);
      document.body.appendChild(pre);
      var lines = [],
          _tempLine = [];
      var context_font = ''; // if (style.italic) {
      //   context_font += 'italic ';
      // }
      // if (style.bold) {
      //   context_font += 'bold ';
      // }

      if (style.italic) {
        context_font += ' ';
      }

      if (style.bold) {
        context_font += ' ';
      }
      /* Testing our replaceAll() function  */


      message = replaceAll(message, '</b>', '§r');
      message = replaceAll(message, '<b>', '§b');
      message = replaceAll(message, '</i>', '§r');
      message = replaceAll(message, '<i>', '§i');
      message = replaceAll(message, '</d>', '§r');
      message = replaceAll(message, '<d>', '§d');
      message = replaceAll(message, '</c>', '§c');
      message = replaceAll(message, '<c>', '§c');

      if (style.italic && style.bold) {
        message = LabComClass.italicbold + message + LabComClass.end;
      } else if (style.italic) {
        message = LabComClass.italic + message + LabComClass.end;
      } else if (style.bold) {
        message = LabComClass.bold + message + LabComClass.end;
      }

      context_font += style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = style.align;
      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;

      var msg = _str.split('\n');

      var text = message;
      var newlines = [];

      if (style.maxWidthNum && _str.indexOf('\n') === -1) {
        for (var k = 0; k < msg.length; k++) {
          _str = msg[k];

          while (_str.length) {
            var condition = context.measureText(_str.substr(0, i)).width > style.maxWidthNum;

            for (var i = _str.length; context.measureText(_str.substr(0, i)).width > style.maxWidthNum; i--) {
              ;
            }

            var result = _str.substr(0, i); // console.info(condition, _str);
            // console.info(result);


            if (i !== _str.length) {
              for (var j = 0; result.indexOf(' ', j) !== -1; j = result.indexOf(' ', j) + 1) {
                ;
              }
            }

            lines.push(result.substr(0, j || result.length));
            var newText = result.substr(0, j || result.length);
            var _k = 0;
            var _index = 0;

            for (var _i = 0; _i < text.length; _i++) {
              if (newText[_k] === text[_i]) {
                _k++;
              }

              if (_k === newText.length) {
                _index = _i;
                break;
              }
            }

            if (_index) {
              _index++;
            }

            newText = text.substring(0, _index);
            newlines.push(newText);
            text = text.substring(_index);
            var width = Math.max(width, context.measureText(lines[lines.length - 1]).width);
            _str = _str.substr(lines[lines.length - 1].length, _str.length);
          }
        }
      } else {
        newlines = msg;
        lines = msg;
      }

      lines = newlines;
      lines.forEach(function (val, i) {
        _tempLine[i] = val;
        _tempLine[i] = _tempLine[i].replace(LabComClass.bold, '');
        _tempLine[i] = _tempLine[i].replace(LabComClass.italic, '');
        _tempLine[i] = _tempLine[i].replace(LabComClass.italicbold, '');
        _tempLine[i] = _tempLine[i].replace(LabComClass.end, '');
      });
      var x = style.stroke,
          y = pre.offsetHeight / lines.length,
          base = y * 0.25;
      canvas.width = (pre.offsetWidth + style.xNum * 2) * scaleVal;
      canvas.height = (pre.offsetHeight + style.yNum * 2) * scaleVal;
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = style.background;
      context.beginPath();
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.fill();
      context_font = ''; // add bold/italic
      // if (style.italic) {
      //   context_font += 'italic ';
      // }
      // if (style.bold) {
      //   context_font += 'bold ';
      // }

      if (style.italic) {
        context_font += ' ';
      }

      if (style.bold) {
        context_font += ' ';
      } // append size, font


      context_font = style.fontSizeNum + style.fontFormat + style.fontFamilyStr;
      context.font = context_font;
      context.textAlign = 'left'; // style.align;

      context.lineWidth = style.stroke;
      context.strokeStyle = style.strokeColor;
      context.fillStyle = style.color;

      switch (style.align) {
        case 'center':
          x = canvas.width / scaleVal / 2;
          break;

        case 'right':
          x = canvas.width / scaleVal;
          break;

        default:
          break;
      }

      var _x;

      context.scale(scaleVal, scaleVal);
      lines.forEach(function (line, i) {
        if (style.align === 'center') {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width / 2;
        } else if (style.align === 'right') {
          width = context.measureText(_tempLine[i]).width;
          _x = x - width;
        } else {
          _x = x;
        } // width = context.measureText(_tempLine[i]).width;
        // switch (style.align) {
        //   case 'center':
        //     _x = x - width / 2;
        //     break;
        //   case 'right':
        //     _x = x - width;
        //     break;
        //   default:
        //     _x = x;
        //     break;
        // }
        // _x = x;


        if (style.stroke) {
          context.strokeText(line, _x + style.xNum, y * (i + 1) + style.yNum);
        } // context.fillText()


        context.drawStyledText(line, _x + style.xNum, y * (i + 1) - base + style.yNum, style.fontFamilyStr, style.fontSizeNum); // context.fillText(line, x + style.xNum, y * (i + 1) - base + style.yNum);
      }); // document.body.removeChild(pre);

      var img = new Image();

      if (callback) {
        img.onload = callback;
      }

      img.src = canvas.toDataURL();
      return {
        imageObj: {
          imageObj: img,
          widthInt: canvas.width / scaleVal,
          heightInt: canvas.height / scaleVal
        }
      };
    },
    // ================================================================================
    //  Text Style Class
    // ================================================================================
    drawCurveRect: function drawCurveRect(_xNum, _yNum, _wNum, _hNum, _rInt) {
      var _waNum = _xNum + _wNum;

      var _haNum = _yNum + _hNum;

      this.beginPath();
      this.moveTo(_xNum + _rInt, _yNum);
      this.lineTo(_waNum - _rInt, _yNum);
      this.arcTo(_waNum, _yNum, _waNum, _yNum + _rInt, _rInt);
      this.lineTo(_waNum, _haNum - _rInt);
      this.arcTo(_waNum, _haNum, _waNum - _rInt, _haNum, _rInt);
      this.lineTo(_xNum + _rInt, _haNum);
      this.arcTo(_xNum, _haNum, _xNum, _haNum - _rInt, _rInt);
      this.lineTo(_xNum, _yNum + _rInt);
      this.arcTo(_xNum, _yNum, _xNum + _rInt, _yNum, _rInt);
      this.lineTo(_xNum + _rInt, _yNum);
      this.fill();
      this.closePath();
    },
    // ================================================================================
    //  Text Style Class
    // ================================================================================
    TextStyleClass: {
      s1Obj: {
        fontColor: '#FFCC00'
      }
    },
    // ================================================================================
    //  Text Styling Class
    // ================================================================================
    drawStyledText: function drawStyledText(_text, x, y, font, fontSize) {
      var _styleCodeToStyle;

      var styleMarker = '§',
          styleCodeToStyle = (_styleCodeToStyle = {
        r: '',
        i: 'italic',
        b: 'bold',
        t: 'italic bold',
        l: 'lighter',
        p: 'supscript',
        q: 'subscript',
        Q: '',
        //subscript with distance bar on it.
        d: '',
        c: 'color',
        a: '',
        s: '',
        //lessthan sign <
        g: '',
        //greaterthan sign >
        h: '',
        //Hypen long
        w: ''
      }, _defineProperty(_styleCodeToStyle, "b", ''), _defineProperty(_styleCodeToStyle, "t", ''), _styleCodeToStyle); // start with regular style

      var _ctx = this;

      var _width = 0;
      var _scaleFont = 0.66;
      var _supMux = 0.25;
      var _subMux = 0.20;
      var distanceBar = 1.1;
      var fontCodeStyle = 'r';
      var fontColor = '';
      var mainFontColor = _ctx.fillStyle;

      if (typeof _text !== 'string') {
        _text = _text.toString();
      }

      var textForWidth = _text;
      var textWidth = 0;
      var originalTextAlign = _ctx.textAlign;
      calculateTextWidth(textForWidth, font, fontSize, fontCodeStyle);

      if (originalTextAlign === 'right') {
        x -= textWidth;
      }

      if (originalTextAlign === 'center') {
        x -= textWidth / 2;
      }

      _ctx.save();

      _ctx.beginPath();

      _ctx.textBaseline = 'bottom';

      do {
        // set context font
        _ctx.font = buildFont(font, fontSize, fontCodeStyle); // find longest run of text for current style

        var ind = _text.indexOf(styleMarker); // take all text if no more marker


        if (ind === -1) ind = _text.length; // fillText current run

        var run = _text.substring(0, ind);

        var _y = y;

        if (fontCodeStyle === 'p') {
          _y = y - fontSize * _supMux * 1.5; // y = y - (fontSize * _supMux);

          x -= _ctx.measureText(run).width * 0.01; // x -= _ctx.measureText(run).width * (_supMux);
        }

        if (fontCodeStyle === 'q' || fontCodeStyle === 'Q') {
          _y = y + fontSize * _subMux;
          x -= _ctx.measureText(run).width * (fontCodeStyle === 'Q' ? _subMux : 0.01); // x -= _ctx.measureText(run).width 
        }

        if (fontColor !== '' || fontColor.includes(' ')) {
          _ctx.fillStyle = fontColor;
          _ctx.strokeStyle = fontColor;
        } // if ((originalTextAlign === 'right' || originalTextAlign === 'center')) _ctx.textAlign = 'left';


        if (_ctx.textAlign === 'right') {
          x += _ctx.measureText(run).width;
        } else if (_ctx.textAlign === 'center') {
          x += _ctx.measureText(run).width / 2;
        } // _ctx.save();
        // _ctx.beginPath();
        // _ctx.lineWidth = 0.1;
        // _ctx.strokeText(run, x, _y);


        _ctx.fillText(run, x, _y); // _ctx.closePath();
        // _ctx.restore();


        if (_ctx.textAlign === 'right') {
          x -= _ctx.measureText(run).width;
        } else if (_ctx.textAlign === 'center') {
          x -= _ctx.measureText(run).width / 2;
        }

        if (fontCodeStyle === 'w') {
          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;
          _ctx.lineJoin = 'round'; // _ctx.moveTo(x, _y - (fontSize * distanceBar));
          // _ctx.lineTo(x + _ctx.measureText(run).width - 0.25, _y - (fontSize * distanceBar));

          _ctx.moveTo(x, _y - fontSize / 2 * distanceBar);

          _ctx.lineTo(x + fontSize * 0.15, _y - fontSize / 2 * distanceBar);

          _ctx.lineTo(x + fontSize * 0.25, _y);

          _ctx.lineTo(x + fontSize * 0.35, _y - fontSize * distanceBar);

          _ctx.lineTo(x + _ctx.measureText(run).width, _y - fontSize * distanceBar); // _ctx.lineTo(x + _ctx.measureText(run).width/2 ,  _y - (fontSize * distanceBar))


          _ctx.stroke();

          _ctx.closePath();
        }

        if (fontCodeStyle === 'd') {
          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;
          _ctx.lineJoin = 'round';

          _ctx.moveTo(x, _y - fontSize * distanceBar);

          _ctx.lineTo(x + _ctx.measureText(run).width - 0.25, _y - fontSize * distanceBar);

          _ctx.stroke();

          _ctx.closePath();
        }

        if (fontCodeStyle === 'Q') {
          _y = _y - fontSize * _subMux;

          _ctx.beginPath();

          _ctx.lineJoin = 'bevel';
          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x + 0.6, _y - fontSize * distanceBar);

          _ctx.lineTo(x + _ctx.measureText(run).width - 0.25, _y - fontSize * distanceBar);

          _ctx.stroke();

          _ctx.closePath();
        }

        if (fontCodeStyle === 'a') {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x, _y - fontSize / 3);

          _ctx.lineTo(x + fontSize / 2, _y - fontSize / 3);

          _ctx.stroke();

          _ctx.closePath(); //Slant Line 


          _ctx.beginPath();

          _ctx.moveTo(x, _y - fontSize / 3);

          _ctx.lineTo(x + fontSize / 2.5, _y - fontSize / 1.1);

          _ctx.stroke();

          _ctx.closePath(); //Arc of Angle


          _ctx.beginPath();

          _ctx.arc(x, _y - fontSize / 3, fontSize / 3, 30 * Math.PI / 180, -85 * Math.PI / 180, 1);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        }

        if (fontCodeStyle === 's') {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x, _y - fontSize / 1.5);

          _ctx.lineTo(x + fontSize / 2, _y - fontSize / 2.5);

          _ctx.stroke();

          _ctx.closePath(); //Slant Line 


          _ctx.beginPath();

          _ctx.moveTo(x, _y - fontSize / 1.5);

          _ctx.lineTo(x + fontSize / 2, _y - fontSize / 1.1);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        }

        if (fontCodeStyle === 'h') {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x, _y - fontSize);

          _ctx.lineTo(x + textWidth / 2 * (fontSize / 2), _y - fontSize);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        }

        if (fontCodeStyle === 'g') {
          _ctx.save();

          _ctx.lineWidth = 1; //Horizontal Line

          _ctx.beginPath();

          _ctx.strokeStyle = _ctx.fillStyle;

          _ctx.moveTo(x + fontSize / 2, _y - fontSize / 2.5);

          _ctx.lineTo(x + fontSize / 2 * 2, _y - fontSize / 1.5);

          _ctx.stroke();

          _ctx.closePath(); //Slant Line 


          _ctx.beginPath();

          _ctx.moveTo(x + fontSize / 2, _y - fontSize / 1.1);

          _ctx.lineTo(x + fontSize / 2 * 2, _y - fontSize / 1.5);

          _ctx.stroke();

          _ctx.closePath();

          _ctx.restore();
        } // return if ended


        if (ind === _text.length) break; // move forward

        x += _ctx.measureText(run).width; // update current style

        fontCodeStyle = _text[ind + 1];

        if (fontCodeStyle === 'c') {
          if (_text[ind + 2] === ' ' || _text.substring(ind + 2, ind + 8).includes(' ')) {
            fontColor = mainFontColor;
            _text = _text.substring(ind + 2);
          } else {
            fontColor = "#".concat(_text.substring(ind + 2, ind + 8));
            _text = _text.substring(ind + 8);
          } // keep only remaining part of text

        } else {
          // keep only remaining part of text
          _text = _text.substring(ind + 2);
        }
      } while (_text.length > 0);

      function calculateTextWidth(text, font, fontSize, fontCodeStyle) {
        var tempSting = '';

        do {
          _ctx.save();

          _ctx.font = buildFont(font, fontSize, fontCodeStyle); // find longest run of text for current style

          var ind = text.indexOf(styleMarker); // take all text if no more marker

          if (ind === -1) ind = text.length; // fillText current run

          var run = text.substring(0, ind);
          tempSting += run;

          if (fontCodeStyle === 'p') {
            textWidth += _ctx.measureText(run).width * _supMux;
          } else if (fontCodeStyle === 'q') {
            textWidth += _ctx.measureText(run).width * _subMux;
          } else {
            textWidth += _ctx.measureText(run).width;
          } // update current style


          fontCodeStyle = text[ind + 1]; // keep only remaining part of text

          text = text.substring(ind + 2);

          _ctx.restore();
        } while (text.length > 0); // console.log(textWidth, _ctx.measureText(tempSting).width, _text)

      }

      function buildFont(font, fontSize, fontCodeStyle) {
        var style = styleCodeToStyle[fontCodeStyle];

        if (fontCodeStyle === 'p' || fontCodeStyle === 'q' || fontCodeStyle === 'Q') {
          return ' ' + fontSize * _scaleFont + 'px ' + font;
        }

        return style + ' ' + fontSize + 'px ' + font;
      }

      _ctx.closePath();

      _ctx.restore();
    },
    // ================================================================================
    //  Tween Class
    // ================================================================================
    // _tObj.duration: End frame number till what frame the tween will get calculated.
    // _tObj.startValue: initial value from which the calculation will start.
    // _tObj.endValue: Destination values for the calculation.
    // _tObj.type: Tween type.
    TweenClass: function TweenClass(_tObj) {
      var hasOProp = Object.prototype.hasOwnProperty; // t: Current time
      // b: Begin value
      // c: Total change in the value
      // d: Total motion duration

      var tweenFunctions = {
        plain: function plain(t, b, c, d) {
          var _t = t / d;

          return b + c * _t;
        },
        back: function back(t, b, c, d) {
          var ts = (t /= d) * t;
          var tc = ts * t;
          return b + c * (1.77635683940025e-15 * tc * ts + 4 * tc + -9 * ts + 6 * t);
        },
        cubic: function cubic(t, b, c, d) {
          var ts = (t /= d) * t;
          var tc = ts * t;
          return b + c * (1.77635683940025e-15 * tc * ts + 0.999999999999998 * tc + -3 * ts + 3 * t);
        }
      }; // ------------------------------------------------------

      var _arr = [];

      if (tweenFunctions[_tObj.type]) {
        var _valueDiff = _tObj.endValue - _tObj.startValue;

        for (var i = 0; i <= _tObj.duration; i += 1000 / 24) {
          // _arr.push(Math.round(tweenFunctions[_tObj.type](i, _tObj.startValue, _valueDiff, _tObj.duration)));
          _arr.push(tweenFunctions[_tObj.type](i, _tObj.startValue, _valueDiff, _tObj.duration));
        }
      }

      return _arr;
    },
    // ================================================================================
    //  Jump to for QA
    // ================================================================================
    jumpToSlide: function jumpToSlide(_pInt) {
      onViewUpdateCls.trigger('onGlobalUpdate', {
        type: 'onJumpToSlide',
        data: {
          curSlideInt: _pInt
        }
      });
    },
    // ================================================================================
    //  RGB to Hex
    // ================================================================================
    rgbToHex: function rgbToHex(_r, _g, _b) {
      if (_r > 255 || _g > 255 || _b > 255) {
        throw 'Invalid color component';
      }

      return (_r << 16 | _g << 8 | _b).toString(16);
    },
    childPreloadProgress: function childPreloadProgress(_no) {
      var _cpNo = _no;

      if (window !== window.parent && typeof window.parent.childPreloadProgress !== 'undefined') {
        window.parent.childPreloadProgress(_cpNo);
      }
    },

    /**
     * Class to create shadow of an image using create JS
     *
     * @public
     */
    createShadow: function createShadow(_Obj) {
      var _canvas = document.createElement('canvas');

      var _context = _canvas.getContext('2d');

      _canvas.width = 800;
      _canvas.height = 600;

      var _stage;

      var _shape;

      var _glowFilter;

      _stage = new createjs.Stage(_canvas);
      _shape = new createjs.Bitmap(_Obj.imgObj[_Obj.imgNameStr]);
      _shape.x = _Obj.xInt;
      _shape.y = _Obj.yInt;
      _shape.scaleX = _Obj.widthInt / _Obj.imgObj[_Obj.imgNameStr].naturalWidth;
      _shape.scaleY = _Obj.heightInt / _Obj.imgObj[_Obj.imgNameStr].naturalHeight;
      var color = _Obj.hasOwnProperty('colorStr') ? _Obj.colorStr.replace('#', '0x') : '0xffff00';
      var alpha = _Obj.hasOwnProperty('alphaInt') ? _Obj.alphaInt : 1;
      var blurX = _Obj.hasOwnProperty('blurXInt') ? _Obj.blurXInt : 20;
      var blurY = _Obj.hasOwnProperty('blurYInt') ? _Obj.blurYInt : 20;
      var strength = _Obj.hasOwnProperty('strengthInt') ? _Obj.strengthInt : 3;
      var quality = _Obj.hasOwnProperty('qualityInt') ? _Obj.qualityInt : 1;
      var inner = _Obj.hasOwnProperty('innerBool') ? _Obj.innerBool : false;
      var knockout = _Obj.hasOwnProperty('knockoutBool') ? _Obj.knockoutBool : false;
      _glowFilter = new createjs.GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout);
      _shape.filters = [_glowFilter];

      _shape.cache(0, 0, 800, 600);

      _stage.addChild(_shape);

      _stage.update();

      var dataURL = _canvas.toDataURL();

      var _tempImg = new Image();

      _tempImg.src = dataURL;
      return _tempImg;
    },

    /**
     * Returns the hostname.
     * @private
     * @param {!object} [windowObject=window] - browser window object by default, or a
     *                                          custom window object to use for testing purposes.
     * @returns {!string} hostname
     */
    getHostName: function getHostName() {
      var windowObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var inIframe;
      var hostname;

      try {
        inIframe = windowObject.self !== windowObject.top;

        if (inIframe) {
          hostname = windowObject.parent.location.hostname; // Host name, no port e.g. mack.i-ready.com
        } else {
          hostname = windowObject.location.hostname;
        }
      } catch (e) {
        hostname = 'defaultHostName';
      }

      return hostname;
    },

    /*
     * preload fonts
     */
    fontLoader: function fontLoader() {
      var _Obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _fontArr = _Obj.fontArr;
      var _fontElementArr = [];
      var _bodyElement = document.getElementsByTagName('body')[0];
      var _loadedCnt = 0;
      var _fontFailureArr = [];
      var _exitBool = false;

      var _callback = function _callback() {
        if (typeof _Obj.callback !== 'undefined') {
          _Obj.callback();
        }
      };

      if (_fontArr.length > 0) {
        for (var i = 0; i < _fontArr.length; i += 1) {
          _fontElementArr[i] = document.createElement('span');
          _fontElementArr[i].innerHTML = 'preloadFont';
          _fontElementArr[i].style.color = 'rgba(0,0,0,0)';
          _fontElementArr[i].style.fontSize = '24px';

          _bodyElement.appendChild(_fontElementArr[i]);

          _fontElementArr[i].setAttribute('data-fontsizebefore', _fontElementArr[i].offsetWidth);

          _fontElementArr[i].setAttribute('data-fontloaded', 'false');

          _fontElementArr[i].style.fontFamily = _fontArr[i];
        }
      }

      function isFontLoader() {
        _fontFailureArr = [];

        if (_loadedCnt < _fontElementArr.length) {
          for (var i = 0; i < _fontElementArr.length; i += 1) {
            if (_fontElementArr[i].getAttribute('data-fontloaded') === 'false' && Number(_fontElementArr[i].offsetWidth) !== Number(_fontElementArr[i].getAttribute('data-fontsizebefore'))) {
              _fontElementArr[i].setAttribute('data-fontsizeafter', _fontElementArr[i].offsetWidth);

              _fontElementArr[i].setAttribute('data-fontloaded', 'true'); // console.log('font familty ' + _fontArr[i] + ' loaded.');


              _loadedCnt += 1;
            } else if (_fontElementArr[i].getAttribute('data-fontloaded') === 'false') {
              // to update refresh font request
              _fontElementArr[i].innerHTML = 'preloadFont';
              _fontElementArr[i].style.color = 'rgba(0,0,0,0)';
              _fontElementArr[i].style.fontSize = '24px';

              _fontFailureArr.push(_fontArr[i]);
            }
          }

          if (_exitBool === false) {
            requestAnimationFrame(isFontLoader);
          }
        } else {
          console.log('total ' + _loadedCnt + ' fonts loaded out of ' + _fontArr.length); // remove elements from document

          for (var k = 0; k < _fontElementArr.length; k += 1) {
            document.body.removeChild(_fontElementArr[k]);
          }

          _callback();

          _callback = function _callback() {}; // reset callback after execution

        }
      }

      isFontLoader();
      setTimeout(function () {
        if (_loadedCnt < _fontArr.length) {
          _exitBool = true; // remove elements from document

          for (var k = 0; k < _fontElementArr.length; k += 1) {
            document.body.removeChild(_fontElementArr[k]);
          }

          if (typeof _Obj.error !== 'undefined') {
            _Obj.error(_fontFailureArr);
          }

          _callback();

          _callback = function _callback() {}; // reset callback after execution

        }
      }, _Obj.timeout ? _Obj.timeout : 30000);
    },

    /*
     * preload fonts
     */
    tracer: function tracer() {
      var _obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // eval('console.log(arguments)');
      eval('console.log(_obj)');
    }
  }; // ===================================================================================
  //  Global event class

  window.onViewUpdateCls = new LabComClass.EventClass(true); //  LOCAL event class

  var onModelUpdateCls = new LabComClass.EventClass(true); // ===================================================================================

  var controllerCls = new ControllerClass();
  var viewCls = new ViewClass();
  var modelCls = new ModelClass();
  onModelUpdateCls.trigger('controllerInit'); // ===================================================================================
}
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// ////////////////////////////////////////////////////////////////////////////////////
// Developed By: Mitr Learning & Media
// Name: BrainClass
// Description: The Brain Class act as an intermediate where all the class update data.
// And the updated data is passed to all other classes requiring it
// Date Modified: 26/08/2021
// Version: 1.0
// ////////////////////////////////////////////////////////////////////////////////////
function BrainClass(_obj) {
  // This is a model object which stores public data and is updated by labstructure.json or components
  var modelObj = {
    showSteps: false,
    taskData: [],
    solved: false,
    solvedWithHelp: false,
    solvedWithAuto: false,
    mathData: [],
    taskNumber: 0,
    totalCorrectShapes: 0,
    totalShapesByHelp: 0,
    totalShapesByAuto: 0,
    isLastQuestion: false,
    lastStepCompleted: false,
    blackColor: 'rgba(0,0,0,1)',
    disableColor: 'rgba(207,207,205,1)',
    greenColor: 'rgba(70, 170, 57, 1)',
    blueColor: 'rgba(10, 190, 220,1)',
    pinkColor: 'rgba(222,108,225,1)',
    greyColor: '#CFCFCF',
    lengthCount: 0,
    totalSteps: 6,
    pointU: null,
    currentStep: 0,
    currentQuestion: {},
    segmentData: {},
    circleData: {},
    labelData: {},
    labelInput: '',
    segInput: null,
    angleSizeData: null,
    radioSolvedAuto: false,
    defaultDiff: {
      x: 6,
      y: -9
    },
    segLabel: {
      'AB': 'a',
      'BC': 'b',
      'CD': 'c',
      'AD': 'd'
    },
    angleOver: {
      'A': 'BAD',
      'B': 'CBA',
      'C': 'DCB',
      'D': 'ADC',
      'E': 'BEC'
    },
    angleLabelDiff: {
      'A': {
        x: 1,
        y: -4
      },
      'B': {
        x: -11,
        y: -6.2
      },
      'C': {
        x: -4,
        y: 3
      }
    },
    // angleLabelDiff:{'A':{x:1,y:-4},'B':{x:-27,y:-27},'C':{x:-4,y:3}},
    pointLabelDiff: {
      'A': {
        x: -22,
        y: 9
      },
      'B': {
        x: 7,
        y: 9
      },
      'C': {
        x: 12,
        y: -9
      },
      'D': {
        x: -22,
        y: -9
      }
    },
    labelDiffSegment: {
      'a': {
        x: 0,
        y: 10,
        label: 'a'
      },
      'b': {
        x: 10,
        y: 0,
        label: 'b'
      },
      'c': {
        x: 0,
        y: -15,
        label: 'c'
      },
      'd': {
        x: -15,
        y: 0,
        label: 'd'
      },
      'e': {
        x: -31,
        y: 5,
        label: 'e'
      },
      'f': {
        x: -6,
        y: -17,
        label: 'f'
      }
    },
    positionArr: [{
      x: -2,
      y: 3,
      zoom: {
        value: 0
      }
    }, {
      x: 0,
      y: 2,
      zoom: {
        value: 2
      }
    }, {
      x: -3,
      y: 5,
      zoom: {
        value: 0
      }
    }, {
      x: 2,
      y: 3,
      zoom: {
        value: 1
      }
    }, {
      x: 0,
      y: 3,
      zoom: {
        value: 1
      }
    }],
    planPositionArr: {
      x: 1,
      y: 2,
      zoom: {
        value: 1
      }
    }
  };
  var spineObj = {};
  Object.keys(_obj).forEach(function (i) {
    modelObj[i] = _obj[i];
  });
  spineObj = modelObj.spineObj;
  window.spineObj = spineObj;
  var graphRighEdge = 1073;
  var graphBottomEdge = 383;
  spineObj.graphComp.addEventListener("scaleUpdate", onChange);
  spineObj.planComp.addEventListener("scaleUpdate", onChange);
  spineObj.logicObj.addEventListener('onUpdateIndex', onChange);
  spineObj.logicObj.addEventListener("setStep", onChange);
  spineObj.logicObj.init(modelObj);
  spineObj.zoomControls.addEventListener("click", onActUpdate);
  spineObj.zoomControls.reset();
  spineObj.zoomPlanControls.addEventListener("click", onActUpdate);
  spineObj.zoomPlanControls.reset();
  spineObj.geoDrawHelpObj.snapToGrid(false); //Draggable

  spineObj.draggable.addEventListener("change", onActUpdate);
  spineObj.angleDraggable.addEventListener("change", onActUpdate);
  spineObj.circleDraggable.addEventListener("change", onActUpdate);
  spineObj.labelDraggable.addEventListener("change", onActUpdate); //Events to be added on input Box

  var eventsToListen = ["focusOut", "keyup"];
  var inputBoxes = ["angleInput", "segInput", "radInput", "labelInput"];
  inputBoxes.forEach(function (inputBox) {
    spineObj[inputBox].on(eventsToListen[0], onActUpdate);
    spineObj[inputBox].on(eventsToListen[1], onKeyUp);
    spineObj[inputBox].enable(); //Submit Btn and Radio is selected bydefault
  });
  spineObj.labelInput.on('focusIn', onActUpdate);
  spineObj.segSubmitBtn.disable();
  spineObj.angleSubmitBtn.disable();
  spineObj.circleSubmitBtn.disable(); // spineObj.labelSubmitBtn.disable();

  spineObj.angleArc_Btn.disable();
  spineObj.radio.setValue(0);
  var drawEvents = ['geoInteraction', 'move', 'moveGraph', "rightClick", 'select', 'segSize', 'angleSize', 'circleSize', 'labelTool'];

  for (var i = 0; i < drawEvents.length; i++) {
    spineObj.geoDrawHelpObj.addEventListener(drawEvents[i], onActUpdate);
  }

  spineObj.rightClickOptions.addEventListener('click', onActUpdate);
  var buttonsForClickEvents = ['timeLine', 'editAgainBtn', 'geoTools', 'segSubmitBtn', 'angleSubmitBtn', 'circleSubmitBtn', 'labelSubmitBtn', 'undoBtn', 'redoBtn', 'alpha_Btn', 'beta_Btn', 'gama_Btn', 'delta_Btn', 'epsilon_Btn', 'lambda_Btn', 'rho_Btn', 'psi_Btn', 'fi_Btn', 'omega_Btn', 'angleArc_Btn'];
  spineObj.numPad.registerEntryBox(spineObj.angleInput, spineObj.radInput, spineObj.labelInput, spineObj.segInput);
  buttonsForClickEvents.forEach(function (btn) {
    spineObj[btn].addEventListener('click', onActUpdate);
  });
  spineObj.logicObj.setMathObj(spineObj.mathObj, spineObj.LabComClass.Maths);
  spineObj.mathObj.setMathObj(spineObj.LabComClass.Maths);
  spineObj.mathObj.populateDefaultQuestions();
  updateGridOptions();
  newTask();
  updateAnglePos();
  updateRender();
  updateAnglePos();
  onViewUpdateCls.trigger("onGlobalUpdate", {
    type: "componentLoaded",
    data: {
      id: modelObj.id
    }
  }); // spineObj.geoDrawHelpObj.addShape({
  //   type:'angle',
  //   x:0,
  //   y:0,
  //   strokeColor:"rgba(10,190,220,1)",
  //   fillColor:"rgba(10,190,220,1)",
  //   label:'',
  //   startAngle:1,
  //   endAngle:2,
  // });

  window.showGraph = function (_bool) {
    spineObj.graphComp.graphLines({
      axis: _bool,
      grid: _bool
    });
  };

  window.showGraph(true); // ===========================================================================
  // PRIVATE SECTION
  // ===========================================================================

  /*
   * This function is a change event listener to update data from activity class
   * @param _obj is of type object. It has 2 properties type and data.
   * @param _bool is of type boolean. It is used to indicate weather the lab should be updated or not
   */

  function onChange(_obj, _bool) {
    switch (_obj.type) {
      case "scaleUpdate":
        spineObj.geoDrawHelpObj.setScreenData(spineObj.graphComp.getScreenData());
        spineObj.logicObj.setSnappingDiff(spineObj.graphComp.getPointUnitByPixelUnit(10)); // snap if required pos is in 10 pixel

        break;

      case "setStep":
        updateTaskStep(_obj.data.step);
        break;
      // case "onUpdateIndex":
      //   if ( _obj.data.type === "remove") {
      //     removeShapeHandler(_obj);
      //   } else {
      //     addShapeHandler(_obj);
      //   }        
      //   break;

      default:
        console.info("Brain No event Added for " + _obj.type);
        break;
    }

    if (!_bool) {
      updateRender();
    }
  } // ===========================================================================

  /*
   * This function is a change event listener to update data from components
   * @param e is of type object. It usually has 2 properties id and value.
   */


  function onActUpdate(e) {
    var _e$data;

    var restrictRender = false;

    switch (e.id) {
      case "rightClickOptions":
        updateGridOptions(e);
        break;

      case "wrongAlertBox":
        break;

      case 'editAgainBtn':
        resetLab(true);
        spineObj.undoBtn.enable();
        spineObj.redoBtn.enable(); // addData();
        // setGraphSize();

        break;

      case 'undoBtn':
        spineObj.geoDrawHelpObj.undo();
        break;

      case 'alpha_Btn':
      case 'beta_Btn':
      case 'gama_Btn':
      case 'delta_Btn':
      case 'epsilon_Btn':
      case 'lambda_Btn':
      case 'rho_Btn':
      case 'psi_Btn':
      case 'fi_Btn':
      case 'omega_Btn':
      case 'angleArc_Btn':
        var varName = e.id.split('_')[0];
        spineObj.labelInput.focusIn();
        var text = e.id !== 'angleArc_Btn' ? spineObj.LabComClass.globalLangText[varName] : spineObj.LabComClass.globalLangText.angleLogo; // const text = spineObj.LabComClass.globalLangText[varName];

        console.log('Text', text);

        if (modelObj.labelInput === '') {
          spineObj.labelInput.setValue(text);
          spineObj.labelSubmitBtn.enable();
        } else {
          modelObj.labelInput = modelObj.labelInput + text;
          spineObj.labelInput.setValue(modelObj.labelInput);
        }

        break;

      case 'redoBtn':
        spineObj.geoDrawHelpObj.redo();
        break;

      case "stepsTable":
        spineObj.logicObj.resetLogicFlag(false);
        spineObj.logicObj.setGivenValues(modelObj.currentQuestion.given);

        switch (e.type) {
          case "help":
            spineObj.geoDrawHelpObj.setStep(Number(e.value) - 1);
            spineObj.geoDrawHelpObj.setStep(Number(e.value));
            autoCompleteStep(Number(e.value));
            modelObj.totalShapesByAuto++;
            modelObj.solvedWithAuto = true;
            modelObj.currentStep++;
            spineObj.geoDrawHelpObj.setStep(Number(e.value) + 1);

            if (modelObj.currentStep === modelObj.totalSteps) {
              spineObj.stepsEndAlertBox.show();
              disableAllTools();
            }

            break;

          case "reset":
            spineObj.geoDrawHelpObj.setStep(Number(e.value) - 1);
            spineObj.geoDrawHelpObj.setStep(Number(e.value));
            modelObj.currentStep = Number(e.value);
            spineObj.logicObj.setSegmentOrder(spineObj.mathObj.getOrder(modelObj.currentQuestion));

            if (Number(e.value) === 0) {
              colorPlan(modelObj.currentQuestion, 'blueColor');
            }

            var _spineObj$geoDrawHelp = spineObj.geoDrawHelpObj.getData(),
                _visible = _spineObj$geoDrawHelp.visible;

            colorLinesReset(_visible, modelObj.currentStep);

            if (Number(e.value) <= 1) {
              var oQ = modelObj.originalQuestion;
              modelObj.currentQuestion = spineObj.mathObj.alterCurrentQuestion(modelObj.currentQuestion.pointA, oQ.pointB, modelObj.originalQuestion);
              reDrawSolution();
            } //   modelObj.totalShapesByHelp=Number(e.value);
            // }
            // enableAllToolss();


            break;

          default:
        }

        break;

      case "geoDrawHelpObj":
        var _spineObj$geoDrawHelp2 = spineObj.geoDrawHelpObj.getData(),
            visible = _spineObj$geoDrawHelp2.visible;

        switch (e.type) {
          case "geoInteraction":
            visible.forEach(function (el) {
              el.isDraggable = true;
            });
            spineObj.geoDrawHelpObj.setData({
              visible: visible
            });
            spineObj.geoDrawHelpObj.updateShape(e.data.uniqueId, {
              isDraggable: true
            });
            break;

          case "moveGraph":
            spineObj.graphComp.setPanValues(e.data);
            restrictRender = true;
            break;

          case "rightClick":
            spineObj.rightClickOptions.setPos(e.x > graphRighEdge ? graphRighEdge : e.x, e.y > graphBottomEdge ? graphBottomEdge : e.y);
            updateMenuOptions();
            break;

          case 'segSize':
            renderSegmentPanel(e.visible); //PAnel is shown.

            if (e.visible) {
              spineObj.segInput.focusIn();
              modelObj.segmentData = e.data; //Data is stored in variable

              updatePos(); //To set Pos of all comps in patch i.e, input Box,label,radio and Submit Btn
            }

            break;

          case "angleSize":
            //Angle Size Event called from Geodraw
            renderAnglePanel(e.visible); //PAnel is shown.

            if (e.visible) {
              spineObj.angleInput.focusIn();
              modelObj.angleSizeData = e.data; //Data is stored in variable

              updateAnglePos(); //To set Pos of all comps in patch i.e, input Box,label,radio and Submit Btn
              //If Manual Setting
              // e.data.degree=45;
              // e.data.clockwise=true;
            }

            break;

          case 'circleSize':
            renderCirclePanel(e.visible); //PAnel is shown.

            if (e.visible) {
              spineObj.radInput.focusIn();
              modelObj.circleData = e.data; //Data is stored in variable

              updateCirclePos(); //To set Pos of all comps in patch i.e, input Box,label,radio and Submit Btn
            }

            break;

          case 'labelTool':
            // console.log('Event',e.visible);
            // console.log(e.data);
            if ((_e$data = e.data) === null || _e$data === void 0 ? void 0 : _e$data.label
            /*&& !e.data.type === ('angle') && !e.data.type.includes('segment')*/
            ) {
                if (e.data.label.includes(' = ')) {
                  modelObj.labelInput = e.data.label.split(' = ')[0];
                  spineObj.labelInput.setValue(modelObj.labelInput);
                } else if (e.data.type === 'angle' || e.data.type === 'angleSize') {
                  modelObj.labelInput = '';
                  spineObj.labelInput.setValue(modelObj.labelInput);
                } else if (e.data.type === 'segment' && e.data.onlyLength) {
                  spineObj.labelInput.setValue(''); // modelObj.labelInput = ;
                } else {
                  modelObj.labelInput = e.data.label;
                  spineObj.labelInput.setValue(modelObj.labelInput);
                }

                if (e.data.type.includes('angle')) {
                  if (modelObj.labelInput.includes(spineObj.LabComClass.globalLangText.angleArc)) {
                    // console.log('here');
                    modelObj.labelInput = modelObj.labelInput.replace(spineObj.LabComClass.globalLangText.angleArc, spineObj.LabComClass.globalLangText.angleLogo);
                  }

                  spineObj.labelInput.setValue(modelObj.labelInput);
                }
              }

            if (e.visible && e.data.type.includes('angle')) {
              // console.log('Angle hai');
              spineObj.angleArc_Btn.enable();
            }

            renderLabelPanel(e.visible);

            if (e.visible) {
              spineObj.labelInput.focusIn();
              modelObj.labelData = e.data;
              updateLabelPos();
            }

            break;

          default:
            break;
        }

        break;

      case 'circleSubmitBtn':
        renderCirclePanel(false); //Panel is hidden

        modelObj.circleData.distance = +modelObj.radInput; //Degree is provided

        spineObj.geoDrawHelpObj.setCircleSize(modelObj.circleData); //Calling setAngle Size Function with data

        spineObj.circleSubmitBtn.disable();
        break;

      case 'labelSubmitBtn':
        renderLabelPanel(false);
        modelObj.labelData.newLabel = modelObj.labelInput;
        spineObj.geoDrawHelpObj.setLabel(modelObj.labelData); // spineObj.labelSubmitBtn.disable();

        break;

      case 'segSubmitBtn':
        renderSegmentPanel(false); //Panel is hidden

        modelObj.segmentData.distance = +modelObj.segInput; //Degree is provided

        spineObj.geoDrawHelpObj.setSegSize(modelObj.segmentData); //Calling setAngle Size Function with data

        break;

      case 'angleSubmitBtn':
        var angleSizeData = modelObj.angleSizeData;
        angleSizeData.degree = +spineObj.angleInput.getValue();
        angleSizeData.clockwise = !Boolean(spineObj.radio.getValue());
        angleSizeData.fillColor = modelObj.blueColor;
        angleSizeData.strokeColor = modelObj.blueColor;
        var data = spineObj.geoDrawHelpObj.setAngleSize(angleSizeData);
        renderAnglePanel(false); //Panel is hidden

        break;

      case "zoomControls":
        if (e.value.includes("zoom")) {
          updateValues(e);
        } else {
          spineObj.graphComp.setPanValues(e.data);
        }

        break;

      case "zoomPlanControls":
        if (e.value.includes("zoom")) {
          spineObj.planComp.setZoom(e);
        } else {
          spineObj.planComp.setPanValues(e.data);
        }

        break;

      case "geoTools":
        break;

      case 'draggable':
        //If Moved
        updatePos();
        spineObj.segInput.focusIn();
        restrictRender = true;
        break;

      case 'circleDraggable':
        //If Moved
        updateCirclePos();
        spineObj.radInput.focusIn();
        restrictRender = true;
        break;

      case 'angleDraggable':
        updateAnglePos();
        spineObj.angleInput.focusIn();
        restrictRender = true;
        break;

      case 'labelDraggable':
        // If moved
        updateLabelPos();
        spineObj.labelInput.focusIn();
        restrictRender = true;
        break;

      default:
        if (inputBoxes.includes(e.id)) {
          onKeyUp(e); //Keyup to store the data of Input Box

          restrictRender = true;
          break;
        } else {
          console.info("No event Added for " + e.id, e);
          break;
        }

    }

    if (!restrictRender) {
      updateRender();
    }
  }

  function updateAnglePos() {
    //Setting Positions
    var oPos = spineObj.angleDraggable.getPos();
    spineObj.angleLabel.setPos(oPos.x + 100, oPos.bodyY + 20);
    spineObj.angleInput.setPos(oPos.x + 100, oPos.bodyY + 50);
    spineObj.angleDegree.setPos(oPos.x + 143, oPos.bodyY + 50);
    spineObj.radio.setPos(oPos.x + 100, oPos.bodyY + 90);
    spineObj.angleSubmitBtn.setPos({
      x: oPos.x + 100,
      y: oPos.bodyY + 170
    });
  }

  function colorLinesReset(data, step) {
    data.forEach(function (el) {
      if (el.type === 'point' && el.label !== '') {
        spineObj.geoDrawHelpObj.setStyle(el.uniqueId, {
          strokeColor: modelObj.blueColor,
          fillColor: modelObj.blueColor
        });
      }

      if (step === 3 && el.type === 'ray') {
        spineObj.geoDrawHelpObj.setStyle(el.uniqueId, {
          strokeColor: modelObj.blueColor,
          fillColor: modelObj.blueColor
        });
      }

      if (el.type === 'segment' && el.label !== 'e' && el.label !== 'f') {
        spineObj.geoDrawHelpObj.setStyle(el.uniqueId, {
          strokeColor: modelObj.blueColor,
          fillColor: modelObj.blueColor
        });
      }
    });
  }

  function renderAnglePanel(_bool) {
    if (_bool) {
      spineObj.angleDraggable.show();
      spineObj.angleInput.show();
      spineObj.angleSubmitBtn.show();
      spineObj.angleLabel.show();
      spineObj.angleDegree.show();
      spineObj.radio.show();
    } else {
      spineObj.angleDraggable.hide();
      spineObj.angleInput.hide();
      spineObj.angleSubmitBtn.hide();
      spineObj.angleLabel.hide();
      spineObj.radio.hide();
      spineObj.angleDegree.hide();
      spineObj.angleInput.setValue('');
      spineObj.angleSubmitBtn.disable();
    }
  }

  function onKeyUp(e) {
    //Storing the Value of Input Box
    var submitBtn, inputBox;

    switch (e.id) {
      case 'angleInput':
        submitBtn = spineObj.angleSubmitBtn;
        inputBox = 'angleInput';
        break;

      case 'segInput':
        submitBtn = spineObj.segSubmitBtn;
        inputBox = 'segInput';
        break;

      case 'radInput':
        submitBtn = spineObj.circleSubmitBtn;
        inputBox = 'radInput';
        break;

      case 'angleInput':
        submitBtn = spineObj.angleSubmitBtn;
        inputBox = 'angleInput';

      case 'labelInput':
        submitBtn = spineObj.labelSubmitBtn;
        inputBox = 'labelInput';
    }

    if (e.id !== 'labelInput') {
      modelObj[inputBox] = spineObj[inputBox].getValue();
    } else {
      if (modelObj.labelInput === '') {
        modelObj[inputBox] = spineObj[inputBox].getValue();
      } else {
        modelObj[inputBox] = spineObj[inputBox].getValue();
      }
    }

    if (modelObj[inputBox] !== '') {
      submitBtn.enable();
    } else {
      submitBtn.disable();
    }

    spineObj.labelSubmitBtn.enable();

    if (e.id === 'radInput' && spineObj[e.id].getValue() != '' && spineObj[e.id].getValue !== 0 && e.enterPressed) {
      renderCirclePanel(false); //Panel is hidden

      modelObj.circleData.distance = +modelObj.radInput; //Degree is provided

      spineObj.geoDrawHelpObj.setCircleSize(modelObj.circleData); //Calling setAngle Size Function with data

      spineObj.circleSubmitBtn.disable();
    }

    if (e.id === 'segInput' && spineObj[e.id].getValue() != '' && spineObj[e.id].getValue !== 0 && e.enterPressed) {
      renderSegmentPanel(false); //Panel is hidden

      modelObj.segmentData.distance = +modelObj.segInput; //Degree is provided

      spineObj.geoDrawHelpObj.setSegSize(modelObj.segmentData); //Calling setAngle Size Function with data

      spineObj.segSubmitBtn.disable();
    }

    if (e.id === 'angleInput' && spineObj[e.id].getValue() != '' && spineObj[e.id].getValue !== 0 && e.enterPressed) {
      renderAnglePanel(false);
      modelObj.angleSizeData.degree = +modelObj.angleInput;
      modelObj.angleSizeData.clockwise = !Boolean(spineObj.radio.getValue());
      modelObj.angleSizeData.fillColor = modelObj.blueColor;
      modelObj.angleSizeData.strokeColor = modelObj.blueColor;
      var data = spineObj.geoDrawHelpObj.setAngleSize(modelObj.angleSizeData);
    }

    if (e.id === 'labelInput'
    /*&& spineObj[e.id].getValue() != ''*/
    && spineObj[e.id].getValue !== 0 && e.enterPressed) {
      renderLabelPanel(false); //Panel is hidden

      modelObj.labelData.newLabel = modelObj.labelInput; //Label is provided

      spineObj.geoDrawHelpObj.setLabel(modelObj.labelData); //Calling setAngle Size Function with data
      // spineObj.labelSubmitBtn.disable();
    }
  } //To show and hide the Angle Panel


  function renderSegmentPanel(_bool) {
    if (_bool) {
      spineObj.draggable.show();
      spineObj.segInput.show();
      spineObj.segSubmitBtn.show();
      spineObj.segmentLabel.show();
    } else {
      spineObj.draggable.hide();
      spineObj.segInput.hide();
      spineObj.segSubmitBtn.hide();
      spineObj.segmentLabel.hide();
      spineObj.segInput.setValue('');
      spineObj.segSubmitBtn.disable();
    }
  }

  function updatePos() {
    //Setting Positions
    var oPos = spineObj.draggable.getPos();
    spineObj.segmentLabel.setPos(oPos.x + 105, oPos.bodyY + 25);
    spineObj.segInput.setPos(oPos.x + 132, oPos.bodyY + 50);
    spineObj.segSubmitBtn.setPos({
      x: oPos.x + 105,
      y: oPos.bodyY + 92.5
    });
  }

  function renderCirclePanel(_bool) {
    if (_bool) {
      spineObj.circleDraggable.show();
      spineObj.radInput.show();
      spineObj.circleSubmitBtn.show();
      spineObj.radiusLabel.show();
    } else {
      spineObj.circleDraggable.hide();
      spineObj.radInput.hide();
      spineObj.circleSubmitBtn.hide();
      spineObj.radiusLabel.hide();
      spineObj.radInput.setValue('');
      spineObj.circleSubmitBtn.disable();
    }
  }

  function renderLabelPanel(_bool) {
    if (_bool) {
      modelObj.labelInput = ''; // spineObj.labelInput.focusIn();

      spineObj.labelDraggable.show();
      spineObj.labelInput.show();
      spineObj.labelSubmitBtn.show();
      spineObj.labelQuestion.show();
      spineObj.alpha_Btn.show();
      spineObj.beta_Btn.show();
      spineObj.gama_Btn.show();
      spineObj.delta_Btn.show();
      spineObj.epsilon_Btn.show();
      spineObj.lambda_Btn.show();
      spineObj.rho_Btn.show();
      spineObj.psi_Btn.show();
      spineObj.fi_Btn.show();
      spineObj.omega_Btn.show();
      spineObj.angleArc_Btn.show();
    } else {
      // modelObj.labelInput = '';
      // spineObj.labelInput.setValue('');
      spineObj.labelDraggable.hide();
      spineObj.labelInput.hide();
      spineObj.labelSubmitBtn.hide();
      spineObj.labelQuestion.hide();
      spineObj.labelInput.setValue('');
      spineObj.alpha_Btn.hide();
      spineObj.beta_Btn.hide();
      spineObj.gama_Btn.hide();
      spineObj.delta_Btn.hide();
      spineObj.epsilon_Btn.hide();
      spineObj.lambda_Btn.hide();
      spineObj.rho_Btn.hide();
      spineObj.psi_Btn.hide();
      spineObj.fi_Btn.hide();
      spineObj.omega_Btn.hide();
      spineObj.angleArc_Btn.hide();
      spineObj.angleArc_Btn.disable();
    }
  }

  function updateCirclePos() {
    //Setting Positions
    var oPos = spineObj.circleDraggable.getPos();
    spineObj.radiusLabel.setPos(oPos.x + 105, oPos.bodyY + 25);
    spineObj.radInput.setPos(oPos.x + 132, oPos.bodyY + 50);
    spineObj.circleSubmitBtn.setPos({
      x: oPos.x + 105,
      y: oPos.bodyY + 92.5
    });
  }

  function updateLabelPos() {
    //Setting Positions
    var oPos = spineObj.labelDraggable.getPos();
    spineObj.labelQuestion.setPos(oPos.x + 80, oPos.bodyY + 25);
    spineObj.labelInput.setPos(oPos.x + 92, oPos.bodyY + 50);
    spineObj.labelSubmitBtn.setPos({
      x: oPos.x + 105,
      y: oPos.bodyY + 170
    });
    spineObj.alpha_Btn.setPos({
      x: oPos.x + 50,
      y: oPos.y + 90
    });
    spineObj.beta_Btn.setPos({
      x: oPos.x + 90,
      y: oPos.y + 90
    });
    spineObj.gama_Btn.setPos({
      x: oPos.x + 130,
      y: oPos.y + 90
    });
    spineObj.delta_Btn.setPos({
      x: oPos.x + 170,
      y: oPos.y + 90
    });
    spineObj.epsilon_Btn.setPos({
      x: oPos.x + 210,
      y: oPos.y + 90
    });
    spineObj.lambda_Btn.setPos({
      x: oPos.x + 50,
      y: oPos.y + 130
    });
    spineObj.rho_Btn.setPos({
      x: oPos.x + 90,
      y: oPos.y + 130
    });
    spineObj.psi_Btn.setPos({
      x: oPos.x + 130,
      y: oPos.y + 130
    });
    spineObj.fi_Btn.setPos({
      x: oPos.x + 170,
      y: oPos.y + 130
    });
    spineObj.omega_Btn.setPos({
      x: oPos.x + 210,
      y: oPos.y + 130
    });
    spineObj.angleArc_Btn.setPos({
      x: oPos.x + 250,
      y: oPos.y + 110
    });
  } // To update menu as per current properties.


  function updateMenuOptions() {
    var menuData = spineObj.rightClickOptions.getData();
    var drawData = spineObj.geoDrawHelpObj.getData().visible;

    if (drawData.length === 0) {
      menuData.selectAll.visible = false;
      menuData.deselectSelected.visible = false;
      menuData.deleteSelected.visible = false;
    } else {
      menuData.selectAll.visible = true;
      var selected = 0;
      var nonSelected = 0;

      for (var _i = 0; _i < drawData.length; _i++) {
        if (drawData[_i].isSelected) {
          selected++;
        } else {
          nonSelected++;
        }
      }

      if (selected === drawData.length) {
        menuData.selectAll.selected = true;
      } else {
        menuData.selectAll.selected = false;
      }

      if (selected > 0) {
        menuData.deselectSelected.visible = true;
        menuData.deleteSelected.visible = true;
      } else {
        menuData.deselectSelected.visible = false;
        menuData.deleteSelected.visible = false;
      }
    }

    menuData.selectAll.selected = false;
    menuData.deleteSelected.selected = false;
    menuData.deselectSelected.selected = false;
    spineObj.rightClickOptions.setData(menuData);
    spineObj.rightClickOptions.show();
  }

  function disableAllTools() {
    var _flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    // eslint-disable-next-line no-case-declarations
    spineObj.geoTools.disable();
  }

  function enableAllToolss() {
    spineObj.geoTools.enable();
  }

  function newTask() {
    resetLab();
    modelObj.solvedWithAuto = false;
    spineObj.logicObj.resetLogicFlag(false); // modelObj.mathData = spineObj.mathObj.generateQuestionS(
    //   modelObj.taskData.length
    // );
    // modelObj.currentStep = 0;

    modelObj.planData = spineObj.mathObj.generatePlanData(modelObj.taskData.length); // spineObj.mathObj.populateDefaultQuestions();

    modelObj.currentQuestion = spineObj.mathObj.getQuestion(modelObj.taskData.length);
    modelObj.originalQuestion = _objectSpread({}, modelObj.currentQuestion); // console.log(modelObj.currentQuestion);

    modelObj.totalSteps = 7;
    spineObj.logicObj.updateRender(modelObj);
    spineObj.zoomControls.reset();
    var point = modelObj.positionArr[modelObj.currentQuestion.variant - 1];

    if (point && !point.zoom) {
      spineObj.graphComp.setPointToScreenCenter(point.x, point.y);
    } else if (point && point.zoom) {
      spineObj.zoomControls.setValue(spineObj.zoomControls.getValue().resetVal + point.zoom.value);
      spineObj.graphComp.setPointToScreenCenter(point.x, point.y);
    }

    var _spineObj$logicObj$ge = spineObj.logicObj.getStepsText(),
        steps = _spineObj$logicObj$ge.steps; // for (let i = 0; i < modelObj.totalSteps; i++) {
    //   spineObj.stepsTable.addData({
    //     text: spineObj.LabComClass.globalLangText[steps[i]],
    //   });
    // }


    spineObj.logicObj.setSegmentOrder(spineObj.mathObj.getOrder(modelObj.currentQuestion));
    spineObj.logicObj.setGivenValues(modelObj.currentQuestion.given);
  }

  function setTaskDefaults() {
    // const data = modelObj.mathData;
    var data = modelObj.currentQuestion.pointA;
  }

  function addDefaultData(target, type) {
    target.clearAll();
  }

  function updateTaskStep(stepCompletedNumber) {
    var stepNumber = 0;
    var data = {
      '0': 1,
      '1': 2,
      '2': 3,
      '3': 4,
      '4': 5,
      '5': 6,
      '6': 7,
      '7': 8
    };
    Object.keys(data).forEach(function (i) {
      if (stepCompletedNumber === Number(i)) {
        stepNumber = data[stepCompletedNumber];
      }
    });
    modelObj.taskNumber = stepNumber;
    spineObj.geoDrawHelpObj.setStep(stepCompletedNumber + 1);
  }

  function storeData() {
    var data = {
      visited: true,
      solved: modelObj.solved,
      solvedWithHelp: modelObj.solvedWithHelp,
      totalCorrectShapes: modelObj.totalCorrectShapes,
      totalShapesByHelp: modelObj.totalShapesByHelp
    };
    modelObj.totalCorrectShapes = 0;
    modelObj.totalShapesByHelp = 0;
    modelObj.totalShapesByAuto = 0;
    modelObj.taskData.push(data);
    var taskStatus = [];

    for (var _i2 = 0; _i2 < modelObj.taskData.length; _i2++) {
      taskStatus.push(JSON.parse(JSON.stringify(modelObj.taskData[_i2])));
    }

    spineObj.timeLine.setTaskStatus(taskStatus);
  }

  function updateGridOptions(e) {
    spineObj.rightClickOptions.hide();
    var data = spineObj.rightClickOptions.getData();
    spineObj.graphComp.graphLines({
      axis: !!data.showAxis.selected,
      grid: !!data.showGrid.selected
    });

    if (!e || e.value === 'selectAll') {
      spineObj.geoDrawHelpObj.selectAll(!!data.selectAll.selected);
    }

    if (!e || e.value === 'snapToGrid') {
      spineObj.geoDrawHelpObj.snapToGrid(!!data.snapToGrid.selected);
    }

    if (e && e.value === 'deselectSelected') {
      spineObj.geoDrawHelpObj.selectAll(false);
    }

    if (e && e.value === 'deleteSelected') {
      spineObj.geoDrawHelpObj.deleteSelected();
    }
  }

  function updateValues(e) {
    spineObj.graphComp.setZoom(e);

    if (modelObj.currentQuestion && e.value === 'zoomReset') {
      var point = modelObj.positionArr[modelObj.currentQuestion.variant - 1];

      if (point && !point.zoom) {
        spineObj.graphComp.setPointToScreenCenter(point.x, point.y);
      } else if (point && point.zoom) {
        spineObj.zoomControls.setValue(spineObj.zoomControls.getValue().resetVal + point.zoom.value);
        spineObj.graphComp.setPointToScreenCenter(point.x, point.y);
      }
    }
  } // ===========================================================================

  /*
   * This function is a lab updater function.It is used to update the lab with the updated Data.
   */


  function updateRender() {
    console.log('XX', spineObj.geoDrawHelpObj.getData().visible, modelObj.currentStep); // // /console.log('XXST',spineObj.geoDrawHelpObj.getStep(),'CS',modelObj.currentStep);
    // // /console.log(modelObj.totalShapesByHelp,modelObj.totalSteps,!modelObj.solvedWithAuto,!modelObj.solved,modelObj.radioBtnHelpSolved);

    if (modelObj.totalShapesByHelp >= modelObj.totalSteps && !modelObj.solvedWithAuto && !modelObj.solved) {
      modelObj.solved = true;
    }

    var data = spineObj.geoDrawHelpObj.getData(); // console.log('Wait',spineObj.geoDrawHelpObj.getWaiting());

    if (data.visible.length) {
      spineObj.editAgainBtn.enable(); // if(!spineObj.geoDrawHelpObj.getWaiting()){
      // spineObj.undoBtn.enable();
      // }
      // else {
      //   spineObj.undoBtn.disable();    
      // }
    } else {
      spineObj.editAgainBtn.disable(); // spineObj.undoBtn.disable();
    }

    if (spineObj.geoDrawHelpObj.undoPossible()) {
      spineObj.undoBtn.enable();
    } else {
      spineObj.undoBtn.disable();
    }

    if (spineObj.geoDrawHelpObj.redoPossible()
    /*&& !spineObj.geoDrawHelpObj.getWaiting()*/
    ) {
        spineObj.redoBtn.enable();
      } else {
      spineObj.redoBtn.disable();
    } // // /console.log(modelObj.solved);
    // // /console.log(!modelObj.totalShapesByAuto , !modelObj.solvedWithAuto , modelObj.radioBtnHelpSolved, !modelObj.solved );
    // if (!modelObj.totalShapesByAuto && !modelObj.solvedWithAuto && modelObj.radioBtnHelpSolved && !modelObj.solved ) {
    //   modelObj.solved = true;
    // }
    // else {
    //   modelObj.solved = false;
    // }
    // // /console.log('SLoved',modelObj.solved);


    spineObj.geoDrawHelpObj.show();
    spineObj.logicObj.updateRender(modelObj);

    if (modelObj.taskData.length >= spineObj.mathObj.getNumberOfVariants() - 1) {
      modelObj.isLastQuestion = true;
    }

    if (modelObj.taskData.length >= spineObj.mathObj.getNumberOfVariants()) {
      spineObj.geoTools.disable();
    }

    if (spineObj.submitBox.isVisible()) {
      spineObj.wrongAlertBox.hide();
      spineObj.stepsEndAlertBox.hide();
    } //modelobj.selectedTool=move activity reloaded
    //Retreive store data update selected tool to circle
    //Check Current Data with stored Data
    // if(modelObj.selectedTool!==spineObj.geoTools.getSelected()){
    //   spineObj.geoTools.setSelected(modelObj.selectedTool)
    // }
    //Now Geo Tools are updated to circle


    var selectedGeoTool = spineObj.geoTools.getSelected();

    if (!spineObj.geoTools.getEnabled()) {
      selectedGeoTool = 'moveGraph';
    }

    spineObj.geoDrawHelpObj.setInteractionType(selectedGeoTool);
    onViewUpdateCls.trigger("onGlobalUpdate", {
      type: "rendererUpdate"
    });
  }

  function resetHelpMode() {
    spineObj.logicObj.resetAll();
    spineObj.stepsEndAlertBox.hide();
    modelObj.helpModeData = [];
    spineObj.geoDrawHelpObj.clearAll();
    modelObj.lastStepCompleted = false;
    modelObj.taskNumber = 0;
    modelObj.totalShapesByAuto = 0;
  }

  function resetLab() {
    spineObj.logicObj.resetAll();
    modelObj.helpModeData = [];
    spineObj.logicObj.resetAll(true);
    modelObj.lastStepCompleted = false;
    spineObj.geoDrawHelpObj.clearAll(); // addDefaultData(spineObj.geoDrawHelpObj, "tutorial");

    modelObj.solved = false;
    modelObj.solvedWithHelp = false;
    spineObj.geoTools.reset();
    spineObj.logicObj.updateRender(modelObj);
    modelObj.lengthCount = 0;
    modelObj.currentStep = 0; // spineObj.zoomControls.setValue(spineObj.zoomControls.getValue().resetVal - 1);
  }
}